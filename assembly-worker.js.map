{"version":3,"sources":["webpack://assembly-worker/webpack/universalModuleDefinition","webpack://assembly-worker/webpack/bootstrap","webpack://assembly-worker/./kotlin-dce/wrapper.js","webpack://assembly-worker/./kotlin-dce/misc.js","webpack://assembly-worker/./kotlin-dce/polyfills.js","webpack://assembly-worker/./kotlin-dce/core.js","webpack://assembly-worker/./kotlin-dce/markerFunctions.js","webpack://assembly-worker/./kotlin-dce/arrayUtils.js","webpack://assembly-worker/./kotlin-dce/callableReferenceUtils.js","webpack://assembly-worker/./kotlin-dce/conversions.js","webpack://assembly-worker/./kotlin-dce/long.js","webpack://assembly-worker/./kotlin-dce/rtti.js","webpack://assembly-worker/./kotlin-dce/runtime/arrayUtils.kt","webpack://assembly-worker/./kotlin-dce/runtime/Enum.kt","webpack://assembly-worker/primitiveCompanionObjects.kt","webpack://assembly-worker/./kotlin-dce/generated/_Arrays.kt","webpack://assembly-worker/./kotlin-dce/generated/_Ranges.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UByte.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UInt.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UShort.kt","webpack://assembly-worker/./kotlin-dce/Ranges.kt","webpack://assembly-worker/./kotlin-dce/collections/Collections.kt","webpack://assembly-worker/./kotlin-dce/collections/Maps.kt","webpack://assembly-worker/./kotlin-dce/collections/Sets.kt","webpack://assembly-worker/./kotlin-dce/text/StringNumberConversions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UnsignedUtils.kt","webpack://assembly-worker/./kotlin-dce/collections/Sequences.kt","webpack://assembly-worker/./kotlin-dce/generated/_Collections.kt","webpack://assembly-worker/./kotlin-dce/collections/Iterables.kt","webpack://assembly-worker/./kotlin-dce/generated/_Sequences.kt","webpack://assembly-worker/./kotlin-dce/util/Preconditions.kt","webpack://assembly-worker/./kotlin-dce/generated/_Strings.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/string.kt","webpack://assembly-worker/./kotlin-dce/Iterators.kt","webpack://assembly-worker/./kotlin-dce/ProgressionIterators.kt","webpack://assembly-worker/./kotlin-dce/Progressions.kt","webpack://assembly-worker/./kotlin-dce/Collections.kt","webpack://assembly-worker/./kotlin-dce/Range.kt","webpack://assembly-worker/./kotlin-dce/Unit.kt","webpack://assembly-worker/./kotlin-dce/internal/progressionUtil.kt","webpack://assembly-worker/./kotlin-dce/kotlin/builtins.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/CoroutineImpl.kt","webpack://assembly-worker/./kotlin-dce/util/Standard.kt","webpack://assembly-worker/./kotlin-dce/util/Result.kt","webpack://assembly-worker/./kotlin-dce/coroutines/Continuation.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/exceptions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/kotlin.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/numberConversions_js-v1.kt","webpack://assembly-worker/./kotlin-dce/generated/_ArraysJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableCollection.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableList.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableSet.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/ArrayList.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/ArraySorting.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/EqualityComparator.kt","webpack://assembly-worker/./kotlin-dce/kotlin/Comparator.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/HashMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/HashSet.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/InternalHashCodeMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/InternalStringMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/LinkedHashMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/LinkedHashSet.kt","webpack://assembly-worker/./kotlin-dce/kotlin/console.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/SafeContinuationJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/exceptionUtils.kt","webpack://assembly-worker/./kotlin-dce/kotlin/json.kt","webpack://assembly-worker/./kotlin-dce/kotlin/math.kt","webpack://assembly-worker/./kotlin-dce/kotlin/numbers_js-v1.kt","webpack://assembly-worker/./kotlin-dce/kotlin/numbers.kt","webpack://assembly-worker/./kotlin-dce/kotlin/random/PlatformRandom.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/KClassImpl.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/InternalMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/jsOperators.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/KTypeImpl.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/primitives.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/reflection.kt","webpack://assembly-worker/./kotlin-dce/kotlin/regexp.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/StringBuilderJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/char.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/numberConversions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/regex.kt","webpack://assembly-worker/./kotlin-dce/text/Strings.kt","webpack://assembly-worker/./kotlin-dce/generated/_ComparisonsJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/stringsCode.kt","webpack://assembly-worker/./kotlin-dce/kotlin/time/DurationUnit.kt","webpack://assembly-worker/./kotlin-dce/kotlin/time/MonoTimeSource.kt","webpack://assembly-worker/./kotlin-dce/kotlin/time/formatToDecimals.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractCollection.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractList.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractMap.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractSet.kt","webpack://assembly-worker/./kotlin-dce/collections/IndexedValue.kt","webpack://assembly-worker/./kotlin-dce/collections/Iterators.kt","webpack://assembly-worker/./kotlin-dce/collections/MapWithDefault.kt","webpack://assembly-worker/./kotlin-dce/collections/MutableCollections.kt","webpack://assembly-worker/./kotlin-dce/collections/SequenceBuilder.kt","webpack://assembly-worker/./kotlin-dce/coroutines/ContinuationInterceptor.kt","webpack://assembly-worker/./kotlin-dce/coroutines/CoroutineContext.kt","webpack://assembly-worker/./kotlin-dce/coroutines/CoroutineContextImpl.kt","webpack://assembly-worker/./kotlin-dce/coroutines/intrinsics/Intrinsics.kt","webpack://assembly-worker/./kotlin-dce/random/Random.kt","webpack://assembly-worker/./kotlin-dce/random/XorWowRandom.kt","webpack://assembly-worker/./kotlin-dce/ranges/Ranges.kt","webpack://assembly-worker/./kotlin-dce/reflect/KTypeProjection.kt","webpack://assembly-worker/./kotlin-dce/reflect/KVariance.kt","webpack://assembly-worker/./kotlin-dce/text/Appendable.kt","webpack://assembly-worker/./kotlin-dce/text/Char.kt","webpack://assembly-worker/./kotlin-dce/text/Indent.kt","webpack://assembly-worker/./kotlin-dce/text/regex/MatchResult.kt","webpack://assembly-worker/./kotlin-dce/time/Duration.kt","webpack://assembly-worker/./kotlin-dce/time/DurationUnit.kt","webpack://assembly-worker/./kotlin-dce/time/TimeSource.kt","webpack://assembly-worker/./kotlin-dce/text/StringBuilder.kt","webpack://assembly-worker/./kotlin-dce/time/TimeSources.kt","webpack://assembly-worker/./kotlin-dce/time/measureTime.kt","webpack://assembly-worker/./kotlin-dce/util/Lazy.kt","webpack://assembly-worker/./kotlin-dce/util/Tuples.kt","webpack://assembly-worker/./kotlin-dce/kotlin/ULong.kt","webpack://assembly-worker/./kotlin-dce/experimental/bitwiseOperations.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UIntRange.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UIterators.kt","webpack://assembly-worker/./kotlin-dce/kotlin/ULongRange.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UProgressionUtil.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UStrings.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflection_js-v1.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/JsClass.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/KTypeHelpers.kt","webpack://assembly-worker/./kotlin-dce/comparisons/Comparisons.kt","webpack://assembly-worker/./kotlin-dce/kotlin/MathH.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/utf8Encoding.kt","webpack://assembly-worker/./kotlin-dce/util/DeepRecursive.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/commonMain/kotlin/world/phantasmal/core/PwResult.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/JsExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/commonMain/kotlin/world/phantasmal/core/math/Math.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/ConsoleOutputAppender.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/DefaultMessageFormatter.kt","webpack://assembly-worker/../../../../../src/commonMain/kotlin/mu/internal/MessageInvoker.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/KotlinLogging.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/KotlinLoggingConfiguration.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/KotlinLoggingLevel.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/internal/ErrorMessageProducer.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/internal/KLoggerJS.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/AssociatedObjects.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/PolymorphicSerializer.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/SealedSerializer.kt","webpack://assembly-worker/./kotlin-dce/collections/Grouping.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/SerializationException.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/Serializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/builtins/BuiltinSerializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptor.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialKinds.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/PluginGeneratedSerialDescriptor.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/AbstractDecoder.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/AbstractEncoder.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/AbstractPolymorphicSerializer.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/CollectionDescriptors.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/CollectionSerializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Enums.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/InlineClassDescriptor.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/InlineClasses.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/NoOpEncoder.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/NullableSerializer.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/ObjectSerializer.kt","webpack://assembly-worker/./kotlin-dce/util/HashCode.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/PrimitiveArraysSerializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/PluginHelperInterfaces.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Primitives.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Tagged.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Tuples.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/modules/SerializersModule.kt","webpack://assembly-worker/../../../../../core/jsMain/src/kotlinx/serialization/Serializers.kt","webpack://assembly-worker/../../../../../core/jsMain/src/kotlinx/serialization/internal/Platform.kt","webpack://assembly-worker/./kotlin-dce/generated/_Maps.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/JsonInternalDependencies.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/build/js/node_modules/process/browser.js","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/GetRegisterValue.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/ValueSet.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/Endianness.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/Episode.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/AsmTokenization.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/Assembly.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/BytecodeIr.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/Opcode.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/PrimitiveExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/StandardExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/Strings.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/ControlFlowGraph.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/GetMapDesignations.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/GetStackValue.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Areas.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/EntityProp.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/NpcType.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/jsMain/kotlin/world/phantasmal/lib/buffer/Buffer.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/build/generated-src/commonMain/kotlin/world/phantasmal/lib/asm/Opcodes.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/Disassembly.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/compression/prs/PrsDecompress.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/Afs.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/AreaRenderGeometry.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/Iff.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Angle.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Nj.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Texture.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Xj.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Bin.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Bytecode.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Dat.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/NpcTypeExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Qst.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Quest.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/vm/VirtualMachine.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/AsmAnalyser.kt","webpack://assembly-worker/./kotlin/kotlin/collections.kt","webpack://assembly-worker/./kotlin/collections/Collections.kt","webpack://assembly-worker/./kotlin/generated/_Collections.kt","webpack://assembly-worker/./kotlin/text/Strings.kt","webpack://assembly-worker/./kotlin/kotlin/math.kt","webpack://assembly-worker/./kotlin/generated/_Sequences.kt","webpack://assembly-worker/./kotlin/comparisons/Comparisons.kt","webpack://assembly-worker/./kotlin/time/measureTime.kt","webpack://assembly-worker/./kotlin/kotlin/text/string.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/Js.kt","webpack://assembly-worker/./kotlin/util/Standard.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/AsmServer.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/Main.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/SerialFormat.kt","webpack://assembly-worker/../../../../../common/src/Delay.kt","webpack://assembly-worker/../../../../../common/src/EventLoop.common.kt","webpack://assembly-worker/../../../../../common/src/flow/SharedFlow.kt","webpack://assembly-worker/../../../../../common/src/internal/LockFreeTaskQueue.kt","webpack://assembly-worker/../../../../../js/src/JSDispatcher.kt","webpack://assembly-worker/../../../../../common/src/AbstractCoroutine.kt","webpack://assembly-worker/../../../../../common/src/Builders.common.kt","webpack://assembly-worker/../../../../../common/src/CancellableContinuation.kt","webpack://assembly-worker/../../../../../common/src/CancellableContinuationImpl.kt","webpack://assembly-worker/../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://assembly-worker/../../../../../common/src/CompletionState.kt","webpack://assembly-worker/../../../../../common/src/CoroutineDispatcher.kt","webpack://assembly-worker/../../../../../common/src/CoroutineExceptionHandler.kt","webpack://assembly-worker/../../../../../common/src/CompletableDeferred.kt","webpack://assembly-worker/../../../../../common/src/CoroutineName.kt","webpack://assembly-worker/../../../../../common/src/CoroutineScope.kt","webpack://assembly-worker/../../../../../common/src/CoroutineStart.kt","webpack://assembly-worker/../../../../../common/src/Job.kt","webpack://assembly-worker/../../../../../common/src/JobSupport.kt","webpack://assembly-worker/../../../../../js/src/internal/LinkedList.kt","webpack://assembly-worker/../../../../../common/src/MainCoroutineDispatcher.kt","webpack://assembly-worker/../../../../../common/src/NonCancellable.kt","webpack://assembly-worker/../../../../../common/src/Supervisor.kt","webpack://assembly-worker/../../../../../common/src/Timeout.kt","webpack://assembly-worker/../../../../../common/src/channels/AbstractChannel.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Reduce.kt","webpack://assembly-worker/../../../../../common/src/internal/ThreadSafeHeap.kt","webpack://assembly-worker/../../../../../common/src/selects/Select.kt","webpack://assembly-worker/../../../../../common/src/flow/operators/Zip.kt","webpack://assembly-worker/../../../../../common/src/flow/internal/SafeCollector.common.kt","webpack://assembly-worker/../../../../../common/src/internal/ConcurrentLinkedList.kt","webpack://assembly-worker/../../../../../atomicfu/src/jsMain/kotlin/kotlinx/atomicfu/AtomicFU.kt","webpack://assembly-worker/../../../../../common/src/internal/DispatchedContinuation.kt","webpack://assembly-worker/../../../../../common/src/internal/InlineList.kt","webpack://assembly-worker/../../../../../common/src/internal/Scopes.kt","webpack://assembly-worker/../../../../../common/src/intrinsics/Undispatched.kt","webpack://assembly-worker/../../../../../js/src/Runnable.kt","webpack://assembly-worker/../../../../../common/src/sync/Semaphore.kt","webpack://assembly-worker/../../../../../common/src/channels/Channels.common.kt","webpack://assembly-worker/../../../../../common/src/flow/operators/Limit.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Collection.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Collect.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Count.kt","webpack://assembly-worker/../../../../../common/src/internal/ArrayQueue.kt","webpack://assembly-worker/../../../../../common/src/internal/Atomic.kt","webpack://assembly-worker/../../../../../js/src/internal/Synchronized.kt","webpack://assembly-worker/../../../../../common/src/intrinsics/Cancellable.kt","webpack://assembly-worker/../../../../../common/src/sync/Mutex.kt","webpack://assembly-worker/../../../../../js/src/CompletionHandler.kt","webpack://assembly-worker/../../../../../js/src/CoroutineContext.kt","webpack://assembly-worker/./kotlin-dce/kotlin/jsTypeOf.kt","webpack://assembly-worker/../../../../../js/src/CoroutineExceptionHandlerImpl.kt","webpack://assembly-worker/../../../../../js/src/Debug.kt","webpack://assembly-worker/../../../../../js/src/Dispatchers.kt","webpack://assembly-worker/../../../../../js/src/EventLoop.kt","webpack://assembly-worker/../../../../../js/src/Promise.kt","webpack://assembly-worker/../../../../../js/src/Window.kt","webpack://assembly-worker/../../../../../js/src/internal/CopyOnWriteList.kt","webpack://assembly-worker/../../../../../js/src/Exceptions.kt","webpack://assembly-worker/../../../../../js/src/flow/internal/FlowExceptions.kt","webpack://assembly-worker/../../../../../js/src/flow/internal/SafeCollector.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/commonMain/kotlin/world/phantasmal/web/shared/JsonFormat.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/commonMain/kotlin/world/phantasmal/web/shared/messages/Messages.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/Throttle.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/LogAppender.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/LogFormatter.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/MessageWithThrowable.kt","webpack://assembly-worker/../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicDecoders.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/Json.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElement.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementSerializers.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonConf.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonExceptions.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonParser.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonReader.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/Polymorphic.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonEncoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/PolymorphismValidator.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonDecoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonEncoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StringOps.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonDecoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/WriteMode.kt"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Kotlin","buf","bufFloat64","bufFloat32","bufInt32","lowIndex","highIndex","_","getObjectHashCode","obj","hash","Math","random","throwMarkerError","Error","imul","a","b","isBooleanArray","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","toString","String","fromCharCode","map","e","join","arrayEquals","length","equals","arrayHashCode","arr","result","hashCode","getCallableRef","f","callableName","toShort","toByte","toChar","numberToInt","Long","toInt","doubleToInt","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","objType","numberHashCode","Number","str","code","charCodeAt","getStringHashCode","identityHashCode","low_","low","high_","high","$metadata$","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","pow","size","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","setCoroutineResult","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","floatToRawBits","floatFromBits","ensureNotNull","x","throwNPE","startsWith","searchString","position","lastIndexOf","endsWith","subjectString","undefined","lastIndex","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","y","exp","y1","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","fill","TypeError","O","len","start","relativeStart","k","end","relativeEnd","finalValue","normalizeOffset","offset","typedArraySlice","begin","constructor","subarray","arrays","TypedArray","slice","Function","self","array","callback","totalOrderComparator","sort","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","getPrototypeOf","isType","proto","kind","OBJECT","klassMetadata","INTERFACE","isInheritanceFromInterface","ctor","iface","metadata","interfaces","superPrototype","superConstructor","isNumber","isChar","isComparable","type","Comparable","isCharSequence","CharSequence","ordinal","initValue","fillArrayVal","init","element","index","IntRange","destination","item","asCollection","emptySet","setOf","toCollection","emptySequence","iterator","hasNext","NoSuchElementException","last","next","isEmpty","single","j","emptyList","listOf","optimizeReadOnlyList","optimizeReadOnlySet","separator","prefix","postfix","limit","truncated","transform","buffer","count","to","first","step","EMPTY","minimumValue","maximumValue","FilteringSequence","predicate","it","TakeSequence","TransformingSequence","CharIterator","IntIterator","LongIterator","getProgressionLastElement","endInclusive","sortedList","NotImplementedError","nextByte","nextChar","nextShort","nextInt","nextLong","nextFloat","nextDouble","nextBoolean","CharProgressionIterator","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","context","current","v","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","cause","message","Exception","RuntimeException","src","dst","srcLen","dstLen","source","newSize","defaultValue","checkRadix","ArrayList","fromIndex","toIndex","toArray","copyToArrayImpl","collection","push","pair","list","copyToArray","comparator","collectionsSort","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","initialCapacity","elements","_stableSortingIsSupported","comparison","getStableSortingIsSupported","median","left","leftIndex","rightIndex","right","leftValue","rightValue","target","mergeSort","checkIsMutable","remove","modified","_index","changed","times","hasPrevious","newValue","oldValue","entries","clear","from","iter","entry","modCount","splice","concat","pop","value1","value2","internalMap","equality","InternalHashCodeMap","loadFactor","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","ClassCastException","pairs","NEGATIVE_INFINITY","toRawBits","bits","POSITIVE_INFINITY","isInfinite","hi26","INV_2_26","low27","INV_2_53","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","old","newEntry","build","println","outputStream","write","messageString","flush","console","cur","simpleName","jsClass","PrimitiveKClassImpl","classifier","isMarkedNullable","kClass","variance","prefixString","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","content","matches","toUpperCase","uppercase","MIN_HIGH_SURROGATE","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","MAX_LOW_SURROGATE","toLowerCase","char","pattern","options","collectionSizeOrDefault","RegExp","match","IndexOutOfBoundsException","startIndex","endIndex","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","destinationOffset","dstIndex","stringCsq","reset","exec","input","test","findNext","Regex","replace","replacement","lastStart","sb","foundMatch","range","nonGlobalOptions","subSequence","literal","AbstractList","ignoreCase","n1","n2","s1","s2","regex","regionMatchesImpl","thisOffset","otherOffset","sourceUnit","targetUnit","sourceCompareTarget","isNode","HrTimeSource","MatchGroup","markNow","TimeMark","process","hrtime","AbstractDoubleTimeSource","startedAt","seconds","nanos","performance","now","decimals","round","toFixed","toLocaleString","json","toExponential","previous","nextIndex","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","ArithmeticException","values","contains","isVarargs","IndexingIterator","IndexedValue","checkIndexOverflow","putAll","emptyMap","filterInPlace","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","block","SequenceScope","asSequence","sequence","throwOnFailure","FlatteningSequence","GeneratorSequence","seedFunction","nextFunction","nextItem","nextState","itemIterator","nextItemIterator","SubSequence","safe","getOrThrow","acc","removed","interceptor","CombinedContext","baseKey","operation","initial","newLeft","Random","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","rnd","doubleFromParts","r1","nextDown","steps","remainder","vr","seed","boundsErrorMessage","seed1","seed2","KTypeProjection","v0","takeUpperBits","star","uppercaseChar","newIndent","lines","isBlank","line","isWhitespace","int","firstChar","limitBeforeMul","digitOf","digit","limitForMaxRadix","NumberFormatException","padChar","padStart","indices","regionMatches","currentStartIndex","strings","findAnyOf","currentIndex","second","DelimitedRangesSequence","asList","delimiters","splitToSequence","lineSequence","Duration","nextSearchIndex","groupValues","convertDurationUnit","unit","scale","action","inDays","hoursComponent","minutesComponent","secondsComponent","nanosecondsComponent","inHours","inMinutes","inSeconds","inNanoseconds","absoluteValue","scientific","maxDecimals","absNs","formatScientific","formatUpToDecimals","formatToExactDecimals","shortName","number","hours","nanoseconds","minutes","hasSeconds","hasHours","hasMinutes","nss","AdjustedTimeMark","duration","elapsedNow","mark","adjustment","read","initializer","isInitialized","InitializedLazyImpl","Pair","that","UByte","third","UInt","uintCompare","data","ulongCompare","uintDivide","ulongDivide","uintRemainder","ulongRemainder","UIntProgression","UIntRange","uintToDouble","UIntProgressionIterator","UIntIterator","ULong","nextUInt","nextULong","ULongProgression","ulongToDouble","ulongToString","ULongProgressionIterator","ULongIterator","ac","bc","UShort","uradix","beforeAdding","v1","v2","divisor","dividend","quotient","base","toMutableList","IndexingIterable","resultSize","throwCountOverflow","sequenceOf","fillFrom","arrayCopyResize","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","captureStackTrace","instance","stack","UnsafeLazyImpl","rangeSize","set","subrange","original","delegate","NullPointerException","KTypeImpl","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","toByteOrNull","numberFormatError","toShortOrNull","toIntOrNull","toLongOrNull","getOrImplicitDefault","mapOf","optimizeReadOnlyMap","toSet","replaceIndent","startFound","padEnd","delimiter","currentOffset","isLimited","toUByteOrNull","toUShortOrNull","toUIntOrNull","toULongOrNull","NodeJsOutput","BufferedOutputToConsoleLog","Comparator","severity","uiMessage","joinToString","problems","PwResultBuilder","logger","PwResult","problem","Problem","Success","Failure","close","PI","sourceIterator","mapCapacity","findAssociatedObject","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","args","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","episode","LineTokenizer","srcLoc","SegmentSrcLoc","Segment","labels","Arg","AnyType","isLabel","HEX_INT_REGEX","hexStr","drop","FLOAT_REGEX","floatStr","toDoubleOrNull","isRegister","prevWasBackSpace","terminated","replaceAll","ident","nextToken","hasLabel","BytecodeIr","InstructionSegment","seg","instructions","Instruction","opcode","valid","InstructionSrcLoc","mnemonicSrcLoc","argSrcLocs","trailingArgSeparator","DataSegment","bytes","oldSize","StringSegment","AssemblyProblem","col","intValue","label","segment","mutableListOf","section","mnemonicToOpcode","strValue","prevToken","prevCol","prevLen","argCount","shouldBeArg","paramI","token","getOrNull","params","param","nextCol","nextLen","coarseCol","varargs","typeMatch","paramType","FloatArg","IntArg","StringArg","UnknownArg","ArgSrcLoc","SrcLoc","coarseLen","immediateArgs","arg","srcLocs","typeStr","OP_ARG_PUSHB","OP_ARG_PUSHR","OP_ARG_PUSHW","OP_ARG_PUSHL","OP_ARG_PUSHS","paramCount","errorLength","bitSize","minValue","maxValue","toByteArray","segments","copy","sum","dcGcFormat","paramToArgs","listOfNotNull","pArgs","paramIndex","ValueType","LabelType","RegRefType","getOpcode","OPCODES","OPCODES_F8","OPCODES_F9","mnemonic","UNKNOWN_OPCODE_MNEMONIC_REGEX","codeStr","codeToOpcode","opcodes","Opcode","instruction","bytecodeIr","instructionSegments","ControlFlowGraphBuilder","createBasicBlocks","cfg","blocks","branchType","nextBlock","branchLabels","labelsToBlock","callers","caller","ret","linkReturningBlocks","linkBlocks","firstBlock","inst","OP_RET","OP_JMP","OP_JMP_ON","OP_JMP_OFF","OP_JMP_E","OP_JMPI_E","OP_JMP_NE","OP_JMPI_NE","OP_UJMP_G","OP_UJMPI_G","OP_JMP_G","OP_JMPI_G","OP_UJMP_L","OP_UJMPI_L","OP_JMP_L","OP_JMPI_L","OP_UJMP_GE","OP_UJMPI_GE","OP_JMP_GE","OP_JMPI_GE","OP_UJMP_LE","OP_UJMPI_LE","OP_JMP_LE","OP_JMPI_LE","OP_SWITCH_JMP","OP_CALL","OP_VA_CALL","OP_SWITCH_CALL","BasicBlockImpl","instructionsToBlock","labelBlocks","linkReturningBlocksRecurse","encountered","toBlock","register","RegisterValueFinder","minOrNull","ControlFlowGraph","all","OP_SYNC","path","isNotEmpty","OP_LET","OP_LETI","OP_LETB","OP_LETW","OP_SYNC_LETI","OP_SET","OP_CLEAR","OP_REV","prevVals","OP_ADDI","OP_SUBI","OP_MULI","OP_DIVI","OP_IF_ZONE_CLEAR","OP_GET_DIFFLVL","OP_GET_SLOTNUMBER","OP_GET_RANDOM","maxOrNull","OP_STACK_PUSHM","OP_STACK_POPM","minReg","maxReg","argLen","registers","regRef","empty","vaStartIdx","vaCallIdx","OP_VA_START","OP_ARG_PUSHA","OP_ARG_PUSHO","pos","getRegisterValue","multipleInstructions","fromValues","fromInstruction","idx","firstOrNull","lastOrNull","Interval","scalar","addI","oldStart","oldEnd","newEnd","newStart","ValueSet","Area","id","order","avs","variants","AreaVariant","avId","area","uniqueName","rareType","lazy","FRIENDLY_NPC_PROPERTIES","EntityProp","arrayBuffer","DataView","endianness","byteLength","getUint8","getUint16","getUint32","getInt8","getInt16","getInt32","getFloat32","maxByteLength","nullTerminated","codePoint","setUint8","setUint16","setUint32","setInt8","setInt16","setInt32","setFloat32","btoa","Buffer","minNewSize","capacity","Uint8Array","newBuffer","initialSize","toTypedArray","atob","inlineStackArgs","Assembler","assemble","time","checkCountOverflow","inMilliseconds","warnings","errors","func0Segment","OP_MAP_DESIGNATE","OP_MAP_DESIGNATE_EX","createCfg","areaId","variantIdRegister","variantId","mapDesignations","OP_BB_MAP_DESIGNATE","StackValueFinder","Param","RegType","KotlinLogging","repeat","createArea","ep1","ep2","ep4","VALUES","npcType","ultimateName","compareValues","selector","argSrcLoc","precise","pushInst","pushArg","labelArg","CompletionItem","sortedWith","filterNotNull","sig","documentation","asm","changes","change","startLineNo","startCol","endLineNo","endCol","split","newAsm","linesChanged","newLines","lineNo","newLineParts","lineStart","lineEnd","newLinePart","startLine","endLine","startLineStart","endLineEnd","toList","assemblyResult","notifications","getMapDesignations","designations","trim","text","filter","suggestions","startingWith","containing","requestId","signature","activeParam","paramIdx","SignatureHelp","parameters","activeParameter","labelStart","labelEnd","contents","doc","Hover","coarse","addAll","flatMap","Label","results","ir","instLineNo","lastCol","argIdx","definitions","references","labelIdx","AsmRange","processParam","processImmediateArg","processStackArgSrcLoc","getStackValue","processStackArg","StringBuilder","Parameter","Signature","ByteType","ShortType","IntType","FloatType","ILabelType","DLabelType","SLabelType","ILabelVarType","StringType","RegVarType","PointerType","Throttle","asmChanges","otherMessages","messages","processAsm","responses","response","JSON_FORMAT","postMessage","KotlinLoggingConfiguration","LogFormatter","LogAppender","location","hostname","AsmServer","AsmAnalyser","onmessage","ignoreUnknownKeys","classDiscriminator","ClientMessage","ClientNotification","Request","ServerMessage","ServerNotification","Response","throwable","info","warn","error","level","loggerName","msg","MessageWithThrowable","Date","date","getHours","getMinutes","getSeconds","getMilliseconds","Json","defaultConfig","prettyPrint","toDouble"],"mappings":"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b,EAC3B,eAAmCmB,EAAA,WAAO,EJvCyBmZ,GIuCtBpZ,EJvCwCmZ,KIuC/Bra,EJvC2Cqa,OIuCpD,EJvCsBC,GIuCHpZ,EJvCqBmZ,KIuCZra,EJvCwBqa,OIuCjC,EAChE,YJwNsC,IAAAW,GIxNnB7Z,GACnB,YAAuB,eAASD,EAAW,oBCtG/C,mBAEI,M3GyHoDuZ,G2GzH3CttB,EAAI3C,GACb,E3GwHoDiwB,G2GxH3CrtB,EAAI5C,GACb,O3GiDkE4vB,G2GjDvDoB,E3GiDwEnB,K2GjDlEoB,E3GiD8EpB,O2GjDpF,E3GgF2C,IAAAF,G2GhFjCqB,E3GgF2CnB,K2GhFtCoB,E3GgFuDpB,KAAZ,GAbhB,IAAAF,GAAU,IAaTA,G2GhFpBqB,E3GgF8BnB,K2GhFzBoB,E3GgF0CpB,KAAZ,GAbNA,K2GnEnB7vB,E3GmEmC6vB,KAAX,G2GhExE,mBACI,MLsHsDK,GKtH7CvtB,EAAI3C,GACb,ELqHsDkwB,GKrH7CttB,EAAI5C,GACb,OLmDmE8vB,GKnDxDkB,ELmD0EnB,KKnDpEoB,ELmDgFpB,OKnDtF,EL6E6C,IAAAW,GK7EnCQ,EL6E8CnB,KAAK,SK7E9CoB,EL6E0DpB,OAb7B,IAAAW,GAAW,IAaVA,GK7EtBQ,EL6EiCnB,KAAK,SK7EjCoB,EL6E6CpB,OAblBA,KAAK,IKhE3B7vB,ELgEsC6vB,OK7DtF,mBAmBI,GAAAlZ,EAAO,EADuE,O3GsBZiZ,G2GrBlDve,E3GqBmEwe,K2GrB1Dre,E3GqBsEqe,O2GrB/E,EAAcre,E3GoDwB,IAAAme,G2GpDfne,E3GoDyBqe,K2GpDnB,GAAiBre,EAAKH,E3G8QhC,IAAAse,G2G9QuChZ,I3GoDOkZ,KAAZ,G2GnDrE,GAAAlZ,EAAO,EAFuE,O3GsBZiZ,G2GpBlDve,E3GoBmEwe,K2GpB1Dre,E3GoBsEqe,O2GpB/E,EAAcre,E3GsCuB,IAAAme,G2GtCdne,E3GsCwBqe,K2GtClB,GAAiBxe,EAAOG,E3G6QlC,IAAAme,G2G7QwC,GAAChZ,I3GsCGkZ,KAAX,G2GrC5D,MAAa,GAAyB,iBAGlD,mBAmBI,GAAAlZ,EAAA,WAAO,EAD2E,OLMfmZ,GKLnDze,ELKqEwe,KKL5Dre,ELKwEqe,OKLjF,EAAcre,EL+B0B,IAAAgf,GK/BjBhf,EL+B4Bqe,KAAK,SK/B3B,GAAiBre,EAAKH,ELqQ7B,IAAAmf,GKrQoC7Z,IL+BUkZ,OK9BpF,GAAAlZ,EAAA,WAAO,EAF2E,OLMfmZ,GKJnDze,ELIqEwe,KKJ5Dre,ELIwEqe,OKJjF,EAAcre,ELiByB,IAAAgf,GKjBhBhf,ELiB2Bqe,KAAK,IKjB1B,GAAiBxe,EAAOG,ELoQ/B,IAAAgf,GKpQsC7Z,EAAD,eLiBOkZ,OKhB1E,MAAa,GAAyB,iB1GpDvB,eAEvB,KAF0D,YAE1D,sBACI,eAGqC,IAAAqB,GAAO,GAE5C,eAGqC,IAAAA,IAAO,GAE5C,gBAGmC,EAEnC,eAGkC,G,0FyG6EtC,WAAkC,uB,uBAElC,WACI,MAAY,YACZ,GAAI,MAAAtwB,KAAA,OAAS,qB,CACT,IAAK,eAAS,MAAa,KAC3B,gBAAU,OAEV,YJtC+C,IAAA4vB,GIsC/C,YJtC0DX,KAAK,IIsCvD,YJtCkEA,OIwC9E,OAAOjvB,G,qJzG1GX,0C2G2GJ,eAM4C,YAAsB,IAElE,iBASmB,MAAL,UAAK,KAAL,EAAkB8G,IAAU,OAAO,KAA7C,MAAU,EACV,O5GhFkEkoB,G4GgF9DnE,E5GhF+EoE,KAAY,IDkK5DF,GAAsB,I6GlF/C,KAAMxoB,U7GkF6B,MClKkD0oB,M4GgF3F,EAA8B,K7GmJG,IAAAJ,GAAWtqB,E6GlJzCsmB,E5GwF8BoE,O4GrFzC,eAM8C,YAAuB,IAErE,iBASmB,MAAL,UAAK,KAAL,EAAkBnoB,IAAU,OAAO,KAA7C,MAAU,EACV,O5GtGkEkoB,G4GsG9DnE,E5GtG+EoE,KAAY,ICmK5DF,GAAsB,M2G7D/C,KAAOxoB,U3G6D4B,MDnKkD0oB,M4GsG3F,EAA+B,K3G8HI,IAAAqB,GAAYhsB,E2G7H5CumB,E5G4EgCoE,O4GzE3C,eAM0C,YAAqB,IAE/D,iBASI/U,GAAWpT,GAEX,MAAa,EAAKjD,OAClB,GAAc,IAAVA,EAAa,OAAO,KAExB,IACA,EADA,EAAkB,KAAK0C,UAGvB,EAAgB,aAAK,GACrB,GAAIukB,EAAY,G,CACZ,GAAc,IAAVjnB,GAA4B,KAAbinB,EAAkB,OAAO,KAC5Cra,EAAQ,OAERA,EAAQ,EAQZ,IALA,MAAuB,kBAEnBsa,EAAiBG,EACrB,E5G2GmC,IAAA6D,G4G3GtBjoB,GACT7C,EAAS,UACb,EAAUwM,EAAV,EAAsB5M,EAAtB,I,CACI,MAAYmnB,GAAQ,aAAKjsB,GAAI+H,GAE7B,GAAImkB,EAAQ,EAAG,OAAO,KACtB,G5GpJ8D+D,G4GoJ1D/qB,E5GpJ2EgrB,K4GoJlElE,E5GpJ8EkE,M4GoJvF,E,CACA,GAAI,MAAAlE,MAAA,OAAkBG,GAOlB,OAAO,KAJP,GAFAH,E5G7FwCoE,G4G6FvB3Z,EAAQ+a,G5GtJ6BvB,G4GwJlD/qB,E5GxJmEgrB,K4GwJ1DlE,E5GxJsEkE,M4GwJ/E,EACA,OAAO,KASnB,MAFAhrB,E5GpHkD,IAAA8qB,GAAe,O4GoHjE9qB,E5GpH4DgrB,K4GoHlDsB,E5GpHmEtB,O4GwH7E,G5GpK8DD,I4GmK9D/qB,E5GjJiD,IAAA8qB,G4GiJjD9qB,E5GjJ2DgrB,KAAgB,IAuO5CF,G4GtFrB9D,G5GjJiEgE,KAAX,IAlBeA,K4GoKlEuB,E5GpK8EvB,M4GoKvF,EAAuB,OAAO,KAGtC,OAAOhrB,EAGX,eAM4C,YAAsB,IAElE,iBASIiW,GAAWpT,GAEX,MAAa,EAAKjD,OAClB,GAAc,IAAVA,EAAa,OAAO,KAExB,IACA,EADA,EAAmB,KAAM0C,UAGzB,EAAgB,aAAK,GACrB,GAAIukB,EAAY,G,CACZ,GAAc,IAAVjnB,GAA4B,KAAbinB,EAAkB,OAAO,KAC5Cra,EAAQ,OAERA,EAAQ,EASZ,IALA,MAAuB,wCAEnBsa,EAAiBG,EACrB,EN8CqC,IAAA0E,GAAW,eM9CnC9oB,IACT7C,EAAS,oBACb,EAAUwM,EAAV,EAAsB5M,EAAtB,I,CACI,MAAYmnB,GAAQ,aAAKjsB,GAAI+H,GAE7B,GAAImkB,EAAQ,EAAG,OAAO,KACtB,GN7M+DiE,GM6M3DjrB,EN7M6EgrB,KM6MpElE,EN7MgFkE,MM6MzF,E,CACA,GAAI,MAAAlE,MAAA,OAAkBG,GAOlB,OAAO,KAJP,GAFAH,EN3J0CqE,GM2JzB5Z,EAAQ+a,GN/M8BrB,GMiNnDjrB,ENjNqEgrB,KMiN5DlE,ENjNwEkE,MMiNjF,EACA,OAAO,KASnB,MAFAhrB,ENlLoD,IAAA2rB,GMkLpD3rB,ENlL+DgrB,KAAK,SMkL1DsB,ENlLsEtB,OMsLhF,GN7N+DC,IM4N/DjrB,EN/MmD,IAAA2rB,GM+MnD3rB,EN/M8DgrB,KAAK,IAAW,ItG2K7CW,GAAW,eAAL,IAyDRb,G4GrBrB9D,G5GpC6BgE,MAAA,QsG3KuCA,QAbGA,KM6NpEuB,EN7NgFvB,MM6NzF,EAAuB,OAAO,KAGtC,OAAOhrB,ErG7RX,iBACkD,OAAuB,sBAAf,WAAPwsB,GAAuC,WAAPC,GACnF,iBACqD,OAACD,EAAA,OAAuB,gBAAUC,EAAA,QAEvF,iBACoD,OPoTZ,IAAA3B,GAvGI,eO7MS0B,EP6MdxB,MAAA,OO7Mc,IP6MT,eO7MuByB,EP6M5BzB,MAAA,QAuGWtqB,SOnTlD,iBACuD,OPkTf,IAAAoqB,GAvGI,eO3MY0B,EP2MjBxB,MAAA,OO3MiB,OP2MZ,eO3M0ByB,EP2M/BzB,MAAA,QAuGWtqB,SO7SlD,iBAEI,MAAe8rB,E+FqMoBxB,K/FpMnC,EAAcyB,E+FoMqBzB,K/FnMnC,GAAI0B,EAAA,WAAU,EACV,O+F2C+DzB,G/F3CpDuB,E+F2CsExB,K/F3CjEyB,E+F2C6EzB,M/F3ClF,EAAS,IAAAW,GAAA,GAAc,IAAAA,GAAA,GAItC,GAAIgB,EAAA,YAAY,EACZ,OAAO,IAAAhB,GAAMgB,EAAAnoB,IAAWkoB,IAI5B,MAAiBC,EAAA,mBAAc,GAAf,IAAoBD,GAArB,UAAkC,GACjD,EAAUC,EAAA,SAAWC,EAAA,SAAWF,IAChC,OAAO,IAAAf,GAAMiB,EAAA,mB+FgCsD3B,GAAkB,I/FhCzDU,GAAMlnB,G+FgCmDumB,KAAY,I/FhCvDW,GAAMe,G+FgCiD1B,O/FhCrE,EAA8B,EAAO,KAIrE,iBAKe,IAHX,EAAewB,E+FiLoBxB,K/FhLnC,EAAcyB,E+FgLqBzB,K/F/KnC,GAAI0B,EAAA,WAAU,EACV,O+FuB+DzB,G/FvBpDuB,E+FuBsExB,K/FvBjEyB,E+FuB6EzB,M/FvBlF,EACPwB,E+FgDgD,IAAAb,G/F9ChDa,E+F8C2DxB,KAAK,S/F9C3DyB,E+F8CuEzB,O/FzCpF,GAAI2B,EAAA,YAAY,EACZ,OAAO,IAAAhB,GAAMgB,EAAA,OAAWD,IAI5B,MAAiBC,EAAA,mBAAc,GAAf,IAAoBD,GAArB,UAAkC,GACjD,EAAUC,EAAA,SAAWC,EAAA,SAAWF,IAChC,OAAO,IAAAf,GAAMlnB,EAAA,S+FQsDwmB,GAAkB,I/FR9DU,GAAMlnB,G+FQwDumB,KAAY,I/FR5DW,GAAMe,G+FQsD1B,O/FR1E,EAA8B0B,EAAlC,IA+BvB,eAA8C,UAAclY,EAAG,IAE/D,iBACI,GAAIA,EAAA,YAAK,EAAG,OAAS,GAAFA,EAAWqY,GAE9B,IAAID,EAAapY,EAAA,mBAAO,GAAR,mBAAaqY,IAAd,UAAwB,GACnCpoB,EAAM+P,EAAA,SAAIoY,EAAA,wBAAWC,KAKzB,OAJIpoB,EAAA,YAAOooB,IACPpoB,IAAA,wBAAOooB,IACPD,IAAA,mBAAY,KAEA,GAATA,EAAkBC,GAAY,GAAJpoB,EAAaooB,G,2ENjE9C,YAM0D,OAAa,qBAkJrB,MAAZ,UFDY,IEjJ+B1nB,EFiJ3C,S,uEE/ItC,YAOoE,OAAa,qBAyI/B,MAAZ,UAAY,MAzIyCA,EAyIrD,S,0EAvItC,cAgKA,oBDjKA,+BCCA,mBAMyD,ODAS4lB,EAAiB,ICmKhD,EAAsB,MAAZ,WDnKsCC,KCAF7lB,EDAc6lB,W,0ECE/F,cAkKA,MAS6D,sBAT7D,iBqGnKA,gCrGCA,mBAM0D,OqGASC,EAAkB,IrGqKhD,EAAW,eAAL,KAAAD,MAAA,QqGrK0CA,KrGAF7lB,EqGAc6lB,W,gErGEjG,cAgJA,oBAhJA,mBAEsD,ODMD,MAAU,ICiJ5B,EAAsB,MAAZ,WDjJkBA,KAAgB,IDgJ5C,EAAsB,IEtJgB7lB,EFsJ5B,MChJkC6lB,KAAX,Q,gECLpE,cA6IA,oBA7IA,mBAEuD,ODGF,MAAU,ICiJ5B,EAAsB,MAAZ,WDjJkBA,KAAgB,ICiJ5C,EAAsB,MApJiB7lB,EAoJ7B,MDjJkC6lB,KAAX,Q,gECFpE,cA0IA,oBA1IA,mBAEqD,ODAA,MAAU,ICiJ5B,EAAsB,MAAZ,WDjJkBA,KCAS7lB,EDAO6lB,KAAX,Q,gECCpE,cAiJA,MAS6D,sBAT7D,iBAjJA,mBAEuD,OqGAA,MAAW,IrGwJ7B,EAAW,eAAL,KAAAA,MAAA,QqGxJuBA,KAAK,IrGAI7lB,EqGAO6lB,Y,kErGElF,cAmIA,oBAnIA,mBAEuD,ODMD,MAAU,ICoI7B,EAAsB,MAAZ,WDpImBA,KAAiB,IDmI9C,EAAsB,IEzIkB7lB,EFyI9B,MCnIoC6lB,KAAZ,Q,kECLrE,cAgIA,oBAhIA,mBAEwD,ODGF,MAAU,ICoI7B,EAAsB,MAAZ,WDpImBA,KAAiB,ICoI9C,EAAsB,MAvImB7lB,EAuI/B,MDpIoC6lB,KAAZ,Q,kECFrE,cA6HA,oBA7HA,mBAEsD,ODAA,MAAU,ICoI7B,EAAsB,MAAZ,WDpImBA,KCAU7lB,EDAO6lB,KAAZ,Q,kECCrE,cAoIA,MAS6D,sBAT7D,iBApIA,mBAEwD,OqGAA,MAAW,IrG2I9B,EAAW,eAAL,KAAAA,MAAA,QqG3IwBA,KAAK,SrGAK7lB,EqGAO6lB,Y,kErGEpF,cAsHA,oBAtHA,mBAEuD,ODMD,MAAe,OAAL,ICuH7B,EAAsB,MAAZ,WDvHmBA,KAAiB,IDsH9C,EAAsB,IE5HkB7lB,EF4H9B,MCtHoC6lB,Y,kECLjF,cAmHA,oBAnHA,mBAEwD,ODGF,MAAe,OAAL,ICuH7B,EAAsB,MAAZ,WDvHmBA,KAAiB,ICuH9C,EAAsB,MA1HmB7lB,EA0H/B,MDvHoC6lB,Y,kECFjF,cAgHA,oBAhHA,mBAEsD,ODAA,MAAe,OAAL,ICuH7B,EAAsB,MAAZ,WDvHmBA,KCAU7lB,EDAO6lB,Y,kECCjF,cAuHA,MAS6D,sBAT7D,iBAvHA,mBAEwD,OqGAA,MAAW,IrG8H9B,EAAW,eAAL,KAAAA,MAAA,QqG9HwBA,KAAK,SrGAK7lB,EqGAO6lB,Y,8DrGEpF,cAyGA,oBDnGA,8BCNA,mBAEqD,ODMDE,EC0GjB,MAAsB,MAAZ,WFDV,MAAsB,IE/Gc/lB,EF+G1B,Y,8DE9G7C,cAsGA,oBDnGA,8BCHA,mBAEsD,ODGF+lB,EC0GjB,MAAsB,MAAZ,WAAV,MAAsB,MA7Ge/lB,EA6G3B,Y,8DA5G7C,cAmGA,oBDnGA,8BCAA,mBAEoD,ODAA+lB,EC0GjB,MAAsB,MAAZ,WA1GyB/lB,Q,8DACtE,cA0GA,MAS6D,sBAT7D,iBqG1GA,+BrGAA,mBAEsD,OqGAAgmB,ErGiHjB,MAAW,eAAL,KAAAH,MAAA,QAjH8B7lB,Q,8DAEzE,cA4FA,oBDtFA,iCCNA,mBAEqD,ODMDimB,EC6FjB,MAAsB,MAAZ,WFDV,MAAsB,IElGcjmB,EFkG1B,Y,8DEjG7C,cAyFA,oBDtFA,iCCHA,mBAEsD,ODGFimB,EC6FjB,MAAsB,MAAZ,WAAV,MAAsB,MAhGejmB,EAgG3B,Y,8DA/F7C,cAsFA,oBDtFA,iCCAA,mBAEoD,ODAAimB,EC6FjB,MAAsB,MAAZ,WA7FyBjmB,Q,8DACtE,cA6FA,MAS6D,sBAT7D,iBqG7FA,kCrGAA,mBAEsD,OqGAAkmB,ErGoGjB,MAAW,eAAL,KAAAL,MAAA,QApG8B7lB,Q,8CAEzE,kEAE2C,aAAY,EAAL,KAAA6lB,KAAK,S,8CACvD,kEAE2C,aAAY,EAAL,KAAAA,KAAK,S,sEAEvD,8CAwEA,gBAxEA,mBAE+D,aA+E5B,MAAsB,MAAZ,WAAV,MAAsB,MA/E+B7lB,EA+E3C,Y,8DA7E7C,oCsGvHJ,YtGuHI,mBAEqD,asGtHiC9E,EtGsH1B3F,KAAKswB,KAAS7lB,EAAM6lB,Y,4DAChF,oCsGrHJ,YtGqHI,mBAEoD,asGpHgC3qB,EtGoHzB3F,KAAKswB,KAAQ7lB,EAAM6lB,Y,8DAC9E,oCsGnHJ,YtGmHI,mBAEqD,asGlHiC3qB,EtGkH1B3F,KAAKswB,KAAS7lB,EAAM6lB,Y,8CAChF,oCsGjHJ,YtGiHI,kBAEkC,asGhHsB3qB,GtGgHf,KAAA2qB,Y,oDAEzC,+CAUmC,OAAK1qB,EAAL,KAAA0qB,W,uDACnC,WASqC,YAAAA,Q,mDACrC,WASiC,OAAiB,MAAZ,a,oDACtC,oBASqD,sBATrD,kBASmC,OAAK,eAAL,KAAAA,MAAA,Y,sDAEnC,cF+DJ,gCE/DI,kBASqC,OFiEE,MAAW1qB,EEjEb,KAAA0qB,Y,yDACrC,WAEuC,OAAAtwB,Q,oDACvC,oDASmC,aAAsB,MAAZ,gB,sDAC7C,oBAS6D,sBAT7D,mCASqC,aAAW,eAAL,KAAAswB,MAAA,a,uDAE3C,WAMqC,OApDa,MAAZ,a,yDAqDtC,WAMuC,OA3DW,MAAZ,a,sBA6DtC,WAAyC,OA7DS,MAAZ,WA6DW3rB,Y,gIAhPrD,0BAG8D,gC,oBAH9D,mHAG8D,4B,0TJsqP1D,YAAQ,WAAA2Q,GAAS,EAAG,O,wLA2/DxB,YAIiB,IAAN,SAAM,U,KACT,EAAK,EAAAgB,KAAL,M,KACA,EAAK,EAAAC,GAAO,EAAK,IAAjB,M,QACa,EAAA6b,GAAL,GAHZ,OAAO,G,6MkFrkTX,cAIU,IAIe,EAHjB,YADExV,EACF,IAAiB,OAAO,iBAAOA,GAE3B,IAAItX,GAAkB,EACtB,IAAa,EAAAsX,EAAA,wB,CAAA,eACL,YAAIpH,KAAOlQ,GAAS,GAC5B,OAAOA,G,kGlF60WnB,YAKI,OAAO,IAAA+sB,IAAiB,eAAE,6BAAF,O,uB6Ct7WxB,oDAGoB,WAZxB,WAaQ,cAAM,KAJV,G,uH7Cq2rBJ,cAoGI,IAFA,MsE1srBO,EAAK1pB,ItE0srBK,SA3FN8B,EA2FkB,QAC7B,EAAW,GAAa/B,GACxB,EAAU,EAAV,EAAkBA,EAAlB,IACIsT,EAAK,UA9FqB,GA8FP,EAAK5b,GA9FjBqK,EA8F2BrK,KA9FtC,OAgGO4b,G,gHYrtrBX,cAMI,OAAW3G,GAAS,GAAKA,GAAS,MAAW,cAAIA,GAAY,M,iBApEjE,YAKI,GAAI,EAAAc,UACA,MAAM,IAAAH,GAAuB,kBACjC,OAAO,cAAK,I,uBAgChB,YAII,OAAW,EAAAG,UAAW,KAAU,cAAK,I,6FA8NzC,YAMI,OAAW,EAAAA,UAAW,KAAU,cAAK,EAAAzN,KAAO,EAAP,I,0DAqKzC,cAoBsC,MAGT,EAUZ,EAvBb,EGxmBA,KHsmBQ7G,GAAK,GGpmBT,MAAM,IHomBQ,oDGpmByB8C,YHqmB3C,GAAS,IAAL9C,EAAQ,OAAO,MAEnB,GAAI,e,CACA,MAAiB,EAAA6G,KAAO7G,EAAP,EACjB,GAAIywB,GAAc,EACd,OAAOhc,KACX,GAAkB,IAAdgc,EACA,OAAO/b,GAAO,OAElB,GADAyF,EAAO,GAAasW,GAChB,e,CACA,GAAI,e,CACsB,IAAA5pB,KAAtB,IAAK,IAAL,EAAc7G,EAAd,QACIma,EAAK,UAAI,cAAK3G,SAElB,IAAa,yBAAaxT,GAAb,a,CAAA,eACTma,EAAK,UAAIxG,GAEjB,OAAOwG,QAIXA,EAAO,KAEX,IAAI/E,EAAQ,EACZ,IAAa,4B,CAAA,eACLA,GAASpV,EAAGma,EAAK,UAAI,GAAW,QAExC,OAAYxF,GAALwF,I,4FAkXX,YAMoB,MACL,EAHX,EAAa,eAAa,EAAAtT,MACtB2M,EAAQ,EACZ,IAAgB,4B,CAAA,eACZ/P,GAAO,EAAA+P,IAAA,MAAP,IAAkBD,EACtB,OAAO9P,G,sBAGX,YAMoB,MACL,EAHX,EAAa,cAAU,EAAAoD,MACnB2M,EAAQ,EACZ,IAAgB,4B,CAAA,eACZ/P,GAAO,EAAA+P,IAAA,MAAP,IAAkBD,EACtB,OAAO9P,G,gDA0MX,YAII,OAAO,KAAa,GAAuB+d,GAAwB,S,2HuBnhCvE,YAKI,OAHIpM,EAAQ,GACRsb,KAEGtb,G,qBvBg0DX,YAKI,MAAe,EAAAnB,WACf,IAAKA,EAASC,UAAW,OAAO,KAEhC,IADA,IAAI5J,EAAM2J,EAASI,OACZJ,EAASC,W,CACZ,MAAQD,EAASI,OACb,YAAA/J,EAAMpH,GAAN,IAASoH,EAAMpH,GAEvB,OAAOoH,G,gOXl+BX,gBAQI,GAAImL,EAAA,gBAAeC,GAAf,EAA6B,MAAM,GAAyB,kDAAiDA,EAAjD,oCAAoFD,EAApF,gBAChE,OAAI,kBAAOA,GAAP,EAA4BA,EAC5B,kBAAOC,GAAP,EAA4BA,EACzB,G,yDa5tBX,cAQI,OAAO,IAAAC,GAAkB,GAAM,EAAMC,I,gEAoEzC,YASW,MAAP,OAAO,gBAAU,IAAV,Y,yCAwHX,cAQI,OAAO,IAAP,S,+FAmMJ,cAYI,OAAO,IAAAwR,GAAmB,EAAMlS,EAAzB,cAAoC,Y,2DAysD/C,cASI,OAAkC,GAA3Byb,GAAW,GAAM5V,M,sGuDtrE5B,YAG4D,kB,4CrD7F5D,YAIiB,IAAN,SAAM,EAAA1X,Q,KACT,EAAK,MAAM,IAAA8Q,GAAuB,2B,KAClC,EAAK,eAAK,GAAV,M,QACQ,MAAM,GAAyB,4CAH3C,OAAO,G,4DAiSX,cD3eI,KCmfQnU,GAAK,GDjfT,MAAM,ICifQ,sDDjfyB8C,YCkf3C,OCzT4F,EAAA2D,UDyT3E,EAAK,GAAFzG,EAAe,EAAAqD,U,kEkBorBvC,cnBxqCI,KmBkrCQmW,GAAW,GnBhrCf,MAAM,ImBgrCc,kCnBhrCmB1W,YmBirC3C,OAAO8tB,GAAS,EAAM,eAASpX,K,kBAGnC,cnBtrCI,KmBgsCQA,GAAW,GnB9rCf,MAAM,ImB8rCc,kCnB9rCmB1W,YmB+rCpC,MAAsB+tB,GAAgB,EAAMrX,EAAtB,GAA7B,OThhCAtI,EAAM,OSghCU,YT/gCTA,G,iBS09BX,cnB5oCI,KmBspCQsI,GAAW,GnBppCf,MAAM,ImBopCc,kCnBppCmB1W,YmBqpC3C,OAAO8tB,GAAS,EAAM,cAAUpX,K,kBAGpC,cnB1pCI,KmBoqCQA,GAAW,GnBlqCf,MAAM,ImBkqCc,kCnBlqCmB1W,YmBmqC3C,OAAO8tB,GAAS,EAAM,eAAWpX,K,mtCTnsCrC,cAEI,SAD8DzG,EAAN,cAE1B7B,GAF0B,OAAM6B,G,IAS9D,eATwD,OAStC+d,GAAqB5f,G,IACvC,YAVwD,OAUzC6f,GAAkB7f,G,IACjC,aAXwD,OAWxC8f,GAAmB9f,G,IACnC,YAZwD,OAYzC+f,GAAkB/f,G,IACjC,WAbwD,OAa1CggB,GAAiBhgB,G,IAC/B,YAdwD,OAczCigB,GAAkBjgB,G,IACjC,aAfwD,OAexCkgB,GAAmBlgB,G,IACnC,cAhBwD,OAgBvCmgB,GAAoBngB,G,QAC7B,MAAM,GAAsB,kDAA+C6B,M,oNA8DvF,WAC8C,MAAM,M,cAEpD,gBAEI,MAAI,iBAAAnU,EACOA,ERmIiF6H,UQnIrEmb,EAAYC,GAEtB,EAAY,oBAAsBD,EAAYC,I,eAI/D,cAEQ,MAAYyP,kBAGZ,MAAYA,kBAAkBC,GAErB,EAAT,OAA+C,IAAnD,OAAmDC,O,6BAmGvD,WAC6B,MAAS,YAAT,EAAsB,IAA/C,YAAY,GAAE,MAAM,KAAM,YAAD,OAQzBtgB,EAAM,OAAW6B,EACV7B,G,yMK/JX,cA0BI,OAA+B,GAAtB,EAAY7N,OAEZ,EAAYoV,GAAY,GAFjC,QAImD,mBAC3C,OAAK,EAAY,KA2DK,WA5DSA,EA4DT,kBA5DqB,K,kEAyCvD,YAWK,QAAD,yBAAC,2BAAD,wBAA2C,G,iJC/F3C,oDAAuB,UAAK,KAAM,MAAlC,G,shBCAJ,YAG4D,WAAAgZ,GAAezD,I,oFgFrC3E,cAGI,OAAO,M,yD7EyKX,oBAII,KAAa,0BAAkBpM,EAAYC,EAAUtI,EAAO,QAC5D,MAAgBsI,EAAWD,EAAX,EAGhB,GAFA,KAAa,0BAAkBS,EAAmBA,EAAoBqP,EAApB,EAA+Bhe,EAAY,QAEzF,YAAkB9Q,OAAO8Q,IAAgB,YAAkB9Q,OAAO2W,G,CAClE,MAAsB,EAAY3I,SAASgR,EAAYC,GAC3C,EAAY8P,IAAIC,EAAUvP,QAEtC,GAAI9I,IAAW7F,GAAe2O,GAAqBT,EAC/C,IAAK,IAAL,EAAc,EAAd,EAAsB8P,EAAtB,IACIhe,EAAY2O,EAAoB7O,EAApB,GAA6B+F,EAAOqI,EAAapO,EAAb,QAGpD,IAAK,IAAL,EAAcke,EAAY,EAAZ,EAAd,GAAmC,EAAnC,IACIhe,EAAY2O,EAAoB,EAApB,GAA6B9I,EAAOqI,EAAa,EAAb,I,kBDkiChE,cnBpsCI,KmB8sCQpI,GAAW,GnB5sCf,MAAM,ImB4sCc,kCnB5sCmB1W,YmB6sC3C,OAAO8tB,GAAS,EAAM,iBAAWpX,K,kBAGrC,cnBltCI,KmB4tCQA,GAAW,GnB1tCf,MAAM,ImB0tCc,kCnB1tCmB1W,YmB2tC3C,OAAO8tB,GAAS,EAAM,iBAAYpX,K,kBAGtC,cnBhuCI,KmB0uCQA,GAAW,GnBxuCf,MAAM,ImBwuCc,kCnBxuCmB1W,YmByuCpC,MAAyB+tB,GAAgB,EAAMrX,GAAS,GAA/D,OT1jCAtI,EAAM,OS0jCU,eTzjCTA,G,kBS4jCX,cnB9uCI,KmBwvCQsI,GAAW,GnBtvCf,MAAM,ImBsvCc,kCnBtvCmB1W,YmBuvCpC,MAAsB8tB,GAAS,EAAM,YAAUpX,IAAtD,OTxkCAtI,EAAM,OSwkCU,YTvkCTA,G,kDSo4DX,YAII,MAAO,GAASH,MAAMrS,KAAK,I,mNCz9D/B,YAMuD,KAAQ,O,sFGhHvD,sDAAsC,UAAK+d,EAAM3c,IAAK2c,EAAMjd,OAA5D,G,8WMuDJ,qBAG8C,GAH9C,kCAII,EAAK,eAAOqyB,GAJhB,G,sCCtDA,sDAG2C,WAnB/C,WAoBQ,cAAM,GAAgB9W,EAASlU,MAC/B,iBAAOkU,GALX,G,kOGwKA,qBAG2C,GAH3C,kCAtLJ,WA0LQ,gBAAM,KACN,EAAK,eAAO8W,GALhB,G,kDC1KA,sDAG8C,GAAM,KAAN,GAjBlD,WAkBQ,iBAAO9W,GAJX,G,4NERA,sDACyD,UAAK+W,EAAU,MADxE,G,kCCVJ,YAEI,MAAM,IAAAC,GAAqB/Y,I,wCAa/B,YAEI,MAAM,GAAqC,qBAAqBrH,EAArB,8B,+LIU/C,YAG8C,OAAC,QAAiB,O,uHyDZ5D,YAAS,MAAD,OAAC,yBAAuB0M,Q,qXCZpC,gBAMI,WAAA2T,GAAUjS,EAAsBuL,GAAV,GAAoBtL,I,iCA+B9C,YAEI,YAAgB,kBAAUjN,I,0JnD1B9B,YAEU,IAAN,gBAAe7P,G,IACX,SAA6B,EAAjB,KAAiBwd,YAA7B,M,IACA,SAAY,GAAmB,EAAHxd,KAAsBA,EAAG,KAAiB+uB,SAAc,KAAiBC,YAArG,M,IACA,UAA8B,EAAjB,KAAiBC,aAA9B,M,IACA,WAA+B,EAAjB,KAAiBC,cAAgB,EAAY/uB,QAA3D,M,QAGQ,oBAAAH,GAAsC,EAAjB,KAAiBmvB,uBACtC,iBAAAnvB,GAAmC,EAAjB,KAAiBovB,oBACnC,iBAAApvB,GAAmC,EAAjB,KAAiBqvB,oBACnC,kBAAArvB,GAAoC,EAAjB,KAAiBsvB,qBACpC,gBAAAtvB,GAAkC,EAAjB,KAAiBuvB,mBAClC,iBAAAvvB,GAAmC,EAAjB,KAAiBwvB,oBACnC,kBAAAxvB,GAAoC,EAAjB,KAAiByvB,qBACpC,mBAAAzvB,GAAqC,EAAjB,KAAiB0vB,sBACrC,YAAA1vB,EAAA,I,cACA,aAAAA,GAAkC,EAAjB,KAAiB2vB,e,CAE9B,MAAkB,OAAa/gB,eAAe5O,GAAGyN,YAEI,EAAjDA,IAAgB,OAAgB,KAAiBmiB,SACjDniB,IAAgB,MAAe,KAAiBoiB,eAG5CxS,GAD0B5P,IAvBlD,U,8OILJ,YAI0C,sBAAAqiB,GAAA,MAAkBC,GAAkB,I,mBAU9E,YAI4C,sBAAAC,GAAA,MAAmBD,GAAkB,I,iBASjF,YAIwC,sBAAAE,GAAA,MAAiBF,GAAkB,I,iBAE3E,cAKkD,2BAAY3sB,IAAZ,EAAsB2sB,GAAkB,I,kBAE1F,YAI0C,sBAAAG,GAAA,MAAkBH,GAAkB,I,oBAS9E,YAIyF,OAAnC,EAAR,OACnC,GxCgBD,KwChBkB,OAAiB,IxCgBnC,GwChB+C/I,GAAQ,KACzD+I,GAAkB,GxCgBf,G,0BwCNX,YAIgG,OAAnC,EAAR,OAC5C,GxC4BgB,KwC5BC,OAAiB,IxC4BlB,GwC5B8B/I,GAAQ,GxC4BrB,KAAV,G,oBwCAhC,cAMqD,SAAYpnB,SAAS4W,GAAWpT,K,4PIpHrF,gBAKI,YADgD,IAAAkd,OAAsB,GACjEA,EAGMuH,GAAc,IAAGjW,EAAQ,EAAGA,EAAOzR,OAAQmgB,GtD8LmC,EAAAlW,WsDhM7DwH,EAAQ,I,6DAmCxC,gBAGI,cAD6C,IAAA0O,OAAsB,GAC/D,QAAJ,EACa,MAAT5a,M,CACC,SAAK4a,E,CAGN,YAAA5a,EAAA,IAAiB,MtD4IyCwY,csD5IrBxY,EtD4IqBwY,gBsD/IzD,WACD,IAAQxY,GAHZ,c,kDAaJ,YAUI,OFqNmD,EAAAvF,OAAS,EpDzEgC,EAAAoD,UsD5IzD,EAAG,GtD0F0Bqa,cA+Ca,EAAAra,UsDzIV,GAAQ,G,kBAa/E,cAMiB,IAAN,ExDlEP,KwDiEQzG,GAAK,GxD/DT,MAAM,IwD+DQ,kDxD/DyB8C,YwDgEpC,OAAM9C,G,KACT,EAAK,KAAL,M,KACA,EAAU,EAAL,EAAK8C,WAAV,M,QAEI,IAAIW,EAAS,GACb,GFqLkD,IAAV,EAAAJ,OElLpC,IAFA,IAAI/C,EAAI,EAAKwC,WACTsS,EAAQpV,EAEa,IAAN,EAAVoV,KACD3R,GAAUnD,GAGD,IADb8U,KAAmB,IAInB9U,GAAKA,EAGb,OAAOmD,EAnBf,OAAO,G,mBAwBX,kBAEI,YADiE,IAAA+f,OAAsB,GtD4GU,EAAAV,QsD3GnF,IAAArB,OAAO,KAAM,eAAOrF,GAAeoH,EAAY,KAAU,KAAM,KAAM,0BAAkBrH,K,qgCjEvDzG,YAIqD,OAAIpB,EAAS,OAAO,EAAYuQ,GAATvQ,GAAuBtG,M,yBAyBnG,YAKI,OAAqB,IAAjBsG,EAAS,OAAW,KAAiB,GAAU,IAAA+K,GAAkB/K,GAAsB,K,mDAS/F,YAI2D,OAAe,MAAXxH,EAAiBmB,GAAOnB,GAAckB,M,sF6GrDrG,cAWY,MALR,OAAIlT,IAAMC,EAAU,EACX,MAALD,GAAmB,EACd,MAALC,EAAkB,EAGQ,EAAAiL,UAAtB,iBAAAlL,GAAA,OAAgCC,I,8L5GpC5C,YAaI,OAAIkc,EAAM,OAAO,EAAS,GAANA,EAAY,GAA0BA,EAAM,SAAa6I,M,4CAuRjF,cAUkD,OAAA8M,GAAA,EAAqBvzB,I,2DAiMvE,YAQqB,IAAN,EADX,GAAI,e,CACO,OAAM,EAAA+G,M,KACT,EAAK,EAAA0f,KAAL,M,KACA,EAAK,EAAA+M,GAAU,eAAc,cAAK,GAAQ,EAAArf,WAAWI,QAArD,M,QACQ,OAAM,GAAgC,EAAAxN,OAHlD,OAAO,EAMX,OAAoC0sB,GAA7B,KAAM,Q,8I4EvhBjB,YASqG,eAAS,eAAE,UAAS,MAAX,O,iX3Ea9G,YAMmD,OAAIxY,EAAS,OAAO,EAAYyY,GAATzY,GAAsBlH,M,msCuFIhG,YAeyC,OAAA4f,GAAA,EAAc,K,iV1BsGvD,YA1FI,IAJA,IAAI7R,EAAa,EACbC,EAAW,EAAAxe,OAAS,EAAT,EACXqwB,GAAa,EAEV9R,GAAcC,G,CACjB,MAAiB6R,EAA4B7R,EAAhBD,EAC7B,OAAsB,eAAKpO,MAE3B,GAAKkgB,E,CAMD,IAAKhS,EACD,MAEAG,IAAY,EAAZ,OARCH,EAGDE,IAAc,EAAd,EAFA8R,GAAa,EAuFkB,OA5EpC,EAAArQ,YAAA,EAAYzB,EAAYC,EAAW,EAAX,I,qFAoKnC,gBAUK,MAAD,YADkC,IAAA+I,MAAgB,IAC3B+I,GAAtB,6BAA6BtwB,EAAQunB,GAAS9nB,Y,4KAk2BnD,gBAOI,YAD2D,IAAA0gB,OAAsB,GAC7E,iBAAA5a,EACA,KAAQA,OAAR,EAA4B4a,IAAe,EAE3C,KAAQ5a,EAAO,EAAG,EAAAvF,OAAQmgB,IAAe,G,6CA2IjD,kBAYI,QADqD,IAAAA,OAAsB,QAAO,IAAAxO,MAAa,GACxE,IAAnBuW,EAAW,O,CACX,MAAgBA,EAAW,GAC3B,GA/+BsD,IA++BjDqI,EA/+BuCvwB,OAg/BxC,OAgCZ,kBtD5wCI,KsDqxCQ2R,GAAS,GtDnxCb,MAAM,IsDmxCY,8CtDnxCqBlS,YsDqxC3C,IAAI+wB,EAAgB,EAChBrO,EAAY,KAAQoO,EAAWC,EAAerQ,GAClD,IAAkB,IAAdgC,GAA4B,IAATxQ,EACnB,OAAON,GAAO,EAAK5R,YAGvB,MAAgBkS,EAAQ,EACxB,EAAa,GAAsB8e,EAAiB,GAAN9e,EAAmB,IAAS,I,GAKtE,GAHAvR,EAAO,UA16B6E,EAAA4f,YAAA,EA06B/DwQ,EAAerO,GA16BkF1iB,YA26BtH+wB,EAAgBrO,EAAYoO,EAAUvwB,OAAtB,EAEZywB,GAAarwB,EAAOoD,QAAQmO,EAAQ,EAAR,GAAW,MAC3CwQ,EAAY,KAAQoO,EAAWC,EAAerQ,UAC3B,IAAdgC,GAGT,OADA/hB,EAAO,UAj7BiF,EAAA4f,YAAA,EAi7BnEwQ,EAAe,EAAAxwB,QAj7BsFP,YAk7BnHW,EA5DQ,GAAMmwB,EAAWpQ,EAAYxO,GAI8C,IzDgS7E,EyDhS6E,EAAb,GAAtE,KAAkBuW,OAAlB,EAA2C/H,EAAoBxO,IzDyN/D,EAAM,GAAawM,GAAwB,OAuElD,IAAa,4B,CAAA,eACT9N,EAAY,UyDjSgF,KzDiSlEC,IyDjS9B,OzDkSOD,G,+TuF3hDP,0C,gnBzF2DJ,YAC4C,OAAO,WAANuE,GAAkE,GAA/BA,IAAO,IAAO,K,qUAE9F,YAC8C,OAAyB,KAAxBA,EAAA,mBAAO,IAAI,WAAqBA,EAAA,OAAjC,Y,wRqGvC9C,YAMqC,sBAAA8b,GAAA,MAAmBd,GAAkB,I,oBAY1E,YAMuC,sBAAAe,GAAA,MAAoBf,GAAkB,I,kBAW7E,YAMmC,sBAAAgB,GAAA,MAAkBhB,GAAkB,I,mBAWvE,YAMqC,sBAAAiB,GAAA,MAAmBjB,GAAkB,I,4lDK3F5C,kB,G3EsBoB,US8C/B,IAAZ,GAA2B,EAAO,UAAe,EAAO,SAAS,KACxD,IAAAkB,GAAhB,EAA6B,QAA2B,IAAAC,G,OmE1EJ,MAAuB,YzFiKhE,MyF/JX,OzF8JIjN,GyF/JA1jB,GzFgKO,SyFhKPA,EzFgKOjE,QAAA,mByF/JX,M,G/DyYsD,EAAWoH,IG1YlC,GAAS,I,GH0Yc,EAAWA,IGzYlC,GAAS,I,GKoEV,WAA8B,EAA9B,M7C6Lc,IAAAytB,IAAmB,cAAU,OAAE5nB,GAAFlL,EAAYC,GAAgB,MqGxHlD,eAAiBuC,EAAL,KAAoBA,EAAL,KAAoBA,EAAL,O1F5DjF,IAAA2U,G2FmCkC,M,KpI5HhC,iC,gO4BuBd,+C,iJA+GA,4C,ETnDA,2C,4PEjCA,+C4F4VA,iC,eoB5Y4B,cAWxB,IAXyB,gBAQ2B,cAAE,UAAI7C,EAAGye,SAAP,KAAoBze,EAAG0e,UAG7E,oB,iVAVA,WACI,gBADwBp2B,KACxB,GAAc,KAAAqB,MACd,SAFwBrB,KAExB,GAAc,KAFI,yB,mBAKtB,WACI,YADoBA,KACpB,GADc,OACA,KAAAqB,MACd,YAFoBrB,KAEpB,GzGkIyC,MAAM,EyGlIlBq2B,EAAT,KAAAC,SAAsB,UAAb,uBAAmB,GzGkI6B3xB,YyGpI/D,gC,0BAMd,YACI,WAAA4xB,EAAgBC,I,gFAFxB,sCAMY,qBAAe,IAAAF,MAA0BhgB,KAAemgB,EAAA,UAAYH,GAAnE,aAEJ,cAA4BG,EAAA,UAAkBH,GAEzC,yBAMd,UAGuB,WACvB,UAAwB,MATxB,gBACA,iBAIA,eAIA,aAGJ,sFACI,mBACA,mBACA,kBACA,qBACA,mBAJA,0BACA,0BACA,0BACA,0BACA,0BAMoB,cAAC,gBACrB,gBlHyCoD,I,2SkHrDxD,wC,kBAAA,sB,IAAA,mB,IAAA,mB,IAAA,kB,IAAA,qB,IAAA,mB,QAAA,0D,+BAcI,YAMI,OAAMI,EAAQP,SAAd,M,IACI,QAAkB,cAAO,cAAMO,EAAQ9b,OAAO,eAAU,MAAR,cAAQ,EAAR,EAAQC,SAAR,EAAmB,EAAQub,aAA3E,M,IACA,QAAkB,cAAO,cAAMM,EAAQ9b,MAAO,8BAAU,MAAR,cAAQ,EAAR,EAAQC,SAAR,EAAmB,EAAQub,WAA7B,KAA9C,M,IACA,OAAiB,cAAO,aAAKM,EAAQ9b,MAAO,8BAAU,MAAR,cAAQ,EAAR,EAAQC,SAAR,EAAmB,EAAQub,WAA7B,KAA5C,M,IACA,UAAoB,cAAO,aAAKM,EAAQ9b,MAAO,8BAAU,MAAR,cAAQ,EAAR,EAAQC,SAAR,EAAmB,EAAQub,WAA7B,KAA/C,M,IACA,QAAkB,cAAO,cAAMM,EAAQ9b,MAAO,8BAAU,MAAR,cAAQ,EAAR,EAAQC,SAAR,EAAmB,EAAQub,WAA7B,KAJA,MAQlD,OADA,gBAAS,UAAIM,GACN12B,M,+BAGX,kBASI,YAHA,IAAA6a,MAAmB,WACnB,IAAAD,MAAoB,MAEpB,wBAAW,IAAA+b,EAAQR,EAAUC,EAAWvb,EAASD,K,8BAErD,YAKI,OADA,gBAAS,eAAOtV,EAAOgxB,UAChBt2B,M,0BAGX,YACI,WAAA42B,EAAQv1B,EAAO,kB,oBAEnB,WACI,WAAAw1B,EAAQ,kB,6HCxFhB,8H,IAEQ,OAAOjO,EAAM,G,QAEL,gBAAR,EAAAkO,QAAQ,8B,ucCLiB,EAAAC,GACN,EAAAA,G,yXCH3B,oB,qJACI,YAAiD,QAAQ,IAAI,I,0BAC7D,YAAiD,QAAQ,IAAI,I,yBAC7D,YAAgD,QAAQ,KAAK,I,yBAC7D,YAAgD,QAAQ,KAAK,I,0BAC7D,YAAiD,QAAQ,MAAM,I,mFALnE,sCCEA,oB,kCACI,gB,ICDO,E,EDEA,EAAM,K,MAAS,E,SCDT,IDCuB,K,SCAlC,kBAFK,QAGkB,EAArB,uBAAqB,oBAAY,GDDjC,Y,kCAEJ,kB,ICJO,E,EDKA,EAAM,K,MAAS,E,SCJT,IDIuB,K,SCHlC,kBAFK,QAGkB,EAArB,uBAAqB,oBAAY,GDEjC,WAAuD,yBAAF,I,kCAEzD,kB,ICPO,E,EDQA,EAAM,K,MAAS,E,OAAc,0B,QCPvB,IDO4C,K,SCNvD,kBAFK,QAGkB,EAArB,uBAAqB,oBAAY,GDKjC,Y,kCAEJ,oB,ICVO,E,EDiBA,EAAM,K,MAAS,E,OAAc,0B,QChBvB,IDgB4C,K,SCfvD,kBAFK,QAGkB,EAArB,uBAAqB,oBAAY,GDcjC,WAA4E,yBAAF,I,gCAE9E,YACI,GAAI,QACA,MAAO,GAIX,IAFA,MAAU,GACV,EAAc,EACP,UAAmB,IAAQ,MAAS,IACvC,GAAO,mBAAiB,EAAQ,SAAzB,IACP,EAAU,EAAQ,MAEtB,OAAO,G,qFA7Bf,sC,4BECA,oB,+IACI,YAMsD,aAAsB,4BAAZ,IAAe,O,2BAE/E,YAAkD,aAAU,I,0ECZhE,oBACI,mBACA,cAAgC,IAChC,eAAkC,I,iGAHtC,sCCEA,sFACI,mBACA,mBACA,kBACA,kBACA,mBAJA,0BACA,0BACA,0BACA,0BACA,0BAGJ,cAA4D,SAAK,SAAW,cAAU,QCVtF,oB,8EDEA,wC,kBAAA,sB,IAAA,mB,IAAA,mB,IAAA,kB,IAAA,kB,IAAA,mB,QAAA,iD,gCCDI,YAAsD,wCAAiC,G,iFCWnE,cACpB,oBAkFuB,aAAE,e,0BA/EzB,YAA4C,oBAAN,IAAmB,EAAb,UAAkB,c,6BAAlB,UAAkB,iB,0BAE9D,YAA4C,oBAAN,IAAmB,EAAb,UAAkB,c,6BAAlB,UAAkB,iB,yBAE9D,YAA0C,oBAAL,IAAkB,EAAb,SAAkB,c,4BAAlB,UAAkB,iB,yBAE5D,YAA0C,oBAAL,IAAkB,EAAb,SAAkB,c,4BAAlB,UAAkB,iB,0BAE5D,YAA4C,oBAAN,IAAmB,EAAb,UAAkB,c,6BAAlB,UAAkB,iB,0BAE9D,cAA2D,oBAAN,IAAmB,EAAK,EAAlB,UAAqB,c,6BAArB,UAAqB,iB,0BAEhF,cAA2D,oBAAN,IAAmB,EAAK,EAAlB,UAAqB,c,6BAArB,UAAqB,iB,yBAEhF,cAAyD,oBAAL,IAAkB,EAAK,EAAlB,SAAqB,c,4BAArB,UAAqB,iB,yBAE9E,cAAyD,oBAAL,IAAkB,EAAK,EAAlB,SAAqB,c,4BAArB,UAAqB,iB,0BAE9E,cAA2D,oBAAN,IAAmB,EAAK,EAAlB,UAAqB,c,6BAArB,UAAqB,iB,0BAEhF,cAA6D,oBAAN,IAAmB,EAAQ,EAArB,UAA0B,c,6BAA1B,UAA0B,iB,0BAEvF,cAA6D,oBAAN,IAAmB,EAAQ,EAArB,UAA0B,c,6BAA1B,UAA0B,iB,yBAEvF,cAA2D,oBAAL,IAAkB,EAAQ,EAArB,SAA0B,c,4BAA1B,UAA0B,iB,yBAErF,cAA2D,oBAAL,IAAkB,EAAQ,EAArB,SAA0B,c,4BAA1B,UAA0B,iB,0BAErF,cAA6D,oBAAN,IAAmB,EAAQ,EAArB,UAA0B,c,6BAA1B,UAA0B,iB,0BAEvF,gBACU,oBAAN,IAAmB,EAAQ,EAAK,EAA1B,UAA6B,c,6BAA7B,UAA6B,iB,0BAEvC,gBACU,oBAAN,IAAmB,EAAQ,EAAK,EAA1B,UAA6B,c,6BAA7B,UAA6B,iB,yBAEvC,gBACS,oBAAL,IAAkB,EAAQ,EAAK,EAA1B,SAA6B,c,4BAA7B,UAA6B,iB,yBAEtC,gBACS,oBAAL,IAAkB,EAAQ,EAAK,EAA1B,SAA6B,c,4BAA7B,UAA6B,iB,0BAEtC,gBACU,oBAAN,IAAmB,EAAQ,EAAK,EAA1B,UAA6B,c,6BAA7B,UAA6B,iB,2BAEvC,gBACQ,MACA,EAAY,cAAU,sBAAc,EAAM,kBAAY,K,2BAI9D,kBACQ,MACA,EAAY,cAAU,sBAAc,EAAM,kBAAY,EAAG,K,2BAIjE,kBACQ,MACA,EAAY,cAAU,sBAAc,EAAM,kBAAY,EAAQ,K,2BAItE,oBAMQ,MACA,EAAY,cAAU,sBAAc,EAAM,kBAAY,EAAQ,EAAG,K,0BAIzE,YACuB,MAAb,oBAAN,KAAmB,eAAE,eAAQ,EAAR,MAAf,UAAqC,c,6BAArC,UAAqC,iB,iBAG/C,WACU,oBAAN,IAAmB,EAAb,UAA2B,c,6BAA3B,UAA2B,iB,yBAGrC,YACuB,MACnB,OADM,oBAAN,KAAmB,eAAE,cAAO,EAAP,MAAf,UAAkC,c,6BAAlC,UAAkC,gBACjC,G,6BAGX,YACuB,MACnB,OADM,oBAAN,KAAmB,eAAE,kBAAW,IAAc,EAAxC,UAAmD,c,6BAAnD,UAAmD,gBAClD,G,6BAGX,YACuB,MAAb,oBAAN,KAAmB,eAAE,kBAAW,IAAc,EAAxC,UAAmD,c,6BAAnD,UAAmD,iB,+TJ1GjE,uC,iXGHA,uC,karHq9CA,8B,ELt5CA,gD,EQuEA,4C,ERkSA,yC,EAAA,+C,EA/LA,yB,EAAA,W,2lBK0vCA,qD,EAAA,4C,EuBv9CA,iC,sItBLA,8B,4YwDoSA,8B,2c7DhOA,+C,0GXhEA,M,wKM+RA,e,GsGeA,e,GvG7DA,e,GEaA,gB,moE+H3OA,+B,6CCmDA,mBAKI,gEAAgC,EAAS,IAAzC,EAAuD,GAA0B,EAAW,aAEhG,mBAKI,gEAAgC,EAAS,IAAzC,EAAmD,6BAA0B,GAAc,axHw3C/F,iBAQW,kDyHx5CgC,qBAO+D,QAiBlG,GAnBJ,cAHA,2BAKA,0BAA4C,GAAsB,EAAtB,SAA0D,uBAClG,kBAAQ,OAAe,KAAa,YACpC,MACI,GAAsB,kCAAgC,YAAU,YAA1C,IAAtB,QAAsG,+BAC9E,IrI+mahB,EqI/magB,EAApB,ErI+maZ,IAAK,EAAL,MAAgB,EAAhB,W,CAAgB,IqI9maA,ErI8maA,EAAhB,GqI9ma2B,WACX,kBAAQ,EAAE,WAAY,GAE9B,UALsG,KAQ9G,OAFI,kBAAQ,QAAS,GAErB,KAEA,6BACA,kCAGQ,EAAW,SAAQ,EAAoB,OACvC,MAAM,EAAyB,oCAAkC,eAAU,YAA5C,mCAGnC,wBAAuD,EAAzB,EAAX,EAAe,IAE7B,ICtBC,EDsBD,EzH03CT,OyH33C4B,wBAAiB,QAAmB,IChDzD,E/HqBiD,I+HMxD,IAAU,EAAK,EAAAC,iBAAL,a,CAAA,eACN,EAAU,cAAMjyB,GAChB,EAAkBwQ,EAAA,UAAY5T,G,EAC9B4T,E,YDqBQ,GCrByD,MAAf+U,GAAwB/U,EAAY,kBAAY5T,GDqBtF,MCrBsB2oB,EvH4DO,MAAM,GsHrC/B,kCAAiC,eAAjC,gCCvBa3oB,EvH4DgD,OuH5D3C2oB,EDwBO,IAAjB,OCxBuBvlB,EDwBY,IAAnC,KtHoCqDJ,YRyGjF,O+HrKI4Q,EAAY5T,EAAmCoD,G/HiW5C,IKkwBS,ELlwBT,EAAY,EAAoBkyB,E+H/VhC1hB,E/H+V4C7M,OKkwBnD,IAAgB,E0HjmCT6M,E/H6SA2I,QKozBS,wB,CAAA,eLpzBa,EKqzBb,YAAgB9I,ELrzBezT,IKqzBUyT,EyHxkChC,MAAM,OAV3B,6B9H6RyB,E8H7RmC,eAAE,SAAG,MAAM,WAAW,W,+EExDtF,yDAGuC,EAAM,EAAN,GAzC3C,WAsCI,EAKA,2DAG0D,SAAM,EAAS,GA9C7E,WA2CI,EAiBJ,iB,GAAmF,EAAS,E,wCAc5F,e,GAAgE,E,wCC9BhE,iBAQI,2BAAsB,GAAuC,IAA7D,EACK,GADsE,GAAL,IAG1E,iBAQI,OAAO,KAAsB,GAAuC,GAGxE,mBAU6C,MADT,E5Hk+CnB,E4Ht+Cb,EAAqB,GAAL,GAChB,EAAiB,EAAK,iBAEjB,EADe,EAAK,U5H65ClB,EAAM,EAAaiO,EAAwB,OAuElD,IAAa,4B,CAAA,I4Hn+CF,E5Hm+CE,W,EACT9N,E,U4Hp+CO,E5Ho+CmBC,E4Hp+CD,KzHhB7B,GAAa,MAATnU,EAEA,MAAM,GyHc2B,kEzHdMsD,YAEvC,EAAOtD,EHg/CK,OAAZkU,EAAY,G4Hr+ChB,IAEgC,ECF4B,EDA5D,E5Hs+COA,E4Hh+CP,OAAO,OAJyB,SACD,EAA3B,EAAc,UAAa,OAAU,KAAV,MAAgC,wBAAc,GAMjF,kBAMsB,MAoB6C,EAdxD,EANW,GAAI,E,CACJ,I5Ho9CL,E4Hp9CK,iBAAI,c,gBAAJ,c5H64CX,EAAM,EAAa8N,E4H74CtB,E5H64C8C,KAuElD,IAAa,E4Hp9CT,E5Ho9CS,wB,CAAA,eACT9N,EAAY,UAxEwCwB,EAwE1BvB,I4Hr9CZ,E5Hs9CXD,M,CAzEA,IAuEM,EAvEN,EAAM,EAAa8N,E4H34CtB,E5H24C8C,KAuElD,IAAa,E4Hl9CT,E5Hk9CS,wB,CAAA,I4Hl9CW,E5Hk9CX,W,EACT,E,U4Hn9CoB,iB5Hm9CM,I4Hn9CkB,OAAO,K5Hm9CvC,OAAZ,E4Hn9CoB,GAAN,E5Ho9CX,E4Hv9CP,QAOI,KADS,EACT,SADS,EACT,SADS,EACT,SADS,EACT,MAAwE,SAAoB,cAAY,SACxG,KAFS,EAET,MAAkB,SAAkB,cAAY,SAChD,KAHS,EAGT,SAHS,EAGT,SAHS,EAGT,MAAuD,SAAwB,cAAY,SAC3F,KAJS,EAIT,MAAkB,SAAkB,cAAY,GAAI,cAAY,SAChE,KALS,EAKT,SALS,EAKT,SALS,EAKT,MAAuD,SACnD,cAAY,GACZ,cAAY,SAEhB,KATS,EAST,MAAoB,KAAmB,cAAY,GAAI,cAAY,SACnE,KAVS,EAUT,MAAe,KAAe,cAAY,GAAI,cAAY,SAC1D,KAXS,EAWT,MAAiB,KAAiB,cAAY,GAAI,cAAY,GAAI,cAAY,Q,CChCtB,MDkCpD,GAAI,GAAiB,GACjB,OCnCgD,WDmCzC,GAA2B,SAAiB,EAAjB,cAAc,GAAG,WAAjB,SAA4C,cAAY,ICnC1C,UDqC1C,KAAV,ErGrG0DpH,EqGqGX,GAArC,SAhBlB,SAjBY,GAAkB,EAAe,EAAW,ICJI,uBDE5B,MA0FpC,cAEW,MADP,OAAI,EAAyB,MACtB,uBAxFA,CAJP,EAIwB,GAAjB,KA+DX,eAqBI,+BAA4B,MExJ5B,eAEuC,MAAnC,OAAW,aAAW,WAAa,uBAA8B,OAAmB,GAG5F,iBAO6B,OAA+B,OAAe,EAAe,GAE1F,iBASkC,OAA+B,OAAmB,EAAe,GAEnG,mBAQkC,OAA+B,OAAiB,EAAa,EAAa,GAE5G,eAG4D,YAE5D,cAK2D,YAE3D,eAG4D,YAE5D,cAI2D,YAE3D,eAG8D,YAE9D,cAI6D,YAE7D,eAG0D,YAE1D,cAIyD,YAEzD,eAG4D,YAE5D,cAI2D,YAE3D,eAG8D,YAE9D,cAI6D,YAE7D,eAGgE,YAEhE,cAI+D,YAE/D,eAGkE,YAElE,cAIiE,YAEjE,eAIkD,YAElD,eAGgE,YAWhE,iBAQ2B,cAA+B,EAAQ,G7HhKlE,eAMuF,wB,e8HuQ/E,8CACI,oBAA2B,gBAFnC,eAAQ,O9HtQ2E,Q8HsQlE,eACb,oBADa,MChOwC,eAAC,SA1C9D,mB7HwBI,Q6HkBA,UAAyD,IvE8PL8P,GuE5P5C,G7HlBJ,MAAM,E6HkByB,oC7HlBQpnB,Y6HmB3C,MAAgB,OAA6B,GAE7C,OADU,EAAV,GACO,OACH,EADG,KAGH,EAAU,qBAAa,KACR,EAAf,GACA,GAwC+C,eAAC,SAbxD,qB7HvDI,Q6HoEA,UAAmD,IvE4MConB,GuE1M5C,G7HpEJ,MAAM,E6HoEyB,oC7HpEQpnB,YAF3C,G6HuEQ,U7HrEJ,MAAM,E6HqE6B,0E7HrEIA,Y6HsE3C,MAAgB,OAA6B,GAE7C,OADU,EAAV,GACO,OAAqB,EAAY,EAAM,EAAU,qBAAa,KAAqB,EAAf,GAAyB,GAuF9D,eACtC,kBAGA,iBAMiC,EAEjC,iBAI2C,IAE3C,0BAAiD,IACjD,mBAA8C,IAC9C,gCAAiE,IACjE,gCAAiE,IACjE,gCAAwD,IAgDzB,uBAC/B,4BACA,sBACA,+BAKA,2BAA6C,EAAQ,YACrD,2BAA6D,EAArB,EAAQ,sBAEhD,oBzGtQkEsX,EyGsQxB,EAAQ,sBAClD,0BAAqF,GAA3B,EAAQ,4BAClE,0BzGxQkEA,EyGwQR,EAAQ,4BAClE,0BAA0E,EAA3B,EAAQ,4BACa,IhI0xCvD,EgIxxCsB,EAFiC,EAAZ,EAAb,qBhImtCpC,EAAM,EAAaoH,EAAwB,OAuElD,IAAa,4B,CAAA,eACT9N,EAAY,UgI3xC0D,EhI2xC5CC,EgI3xC+C,MhI2xC/CA,EgI3xC2D,QAAzF,kBAAiG,EhI4xC1FD,GgI3xCP,iCAAgF,GAAf,GACjE,yBAA8B,IAAK,kBAAE,YAAa,kCCjRtD,eAoBI,sBAUqB,c,+8IjI+6CzB,4BASQ,WAA6C,OAAAvV,KAAA,gBAAgB8V,YATrE,yBAUQ,YAAoC,gCAAYV,IAVxD,sC,oDyH94CI,8C,qEAKA,+C,qDAmCA,cACW,M9H8HkB,E8H9HlB,+BAAP,OAAO,U9H8HkB,uBAAmB,U8H9Hf,IAAtB,EAA0C,+DAAgC,EAAS,I,qDAG9F,cACY,QInCoE,EJmC5E,OAAO,OAAC,uEAAiB,KAAjB,EAAwC,+DAAgC,EAAS,IInCb,uBJmCrE,M,waxH7Gf,sBAOI,WAAuC,gCAP3C,sC,qE8HwJmC,WAAQ,Y,mEAMV,WAAQ,Y,sEAsBI,WAAQ,c,wFA2FzC,WAAkC,2BAAe,G,kBAEjD,WACiD,QAAjB,EAA5B,OAA4B,6CAAiB,oDAAtC,0DAAqB,Q,mEC/DxC,kB7HzLA,Q6H8MI,UAAgC,UAChC,WAAsB,IAEd,mBAAY,UAAI,G7H/MxB,MAAM,G6H+MkC,mD7H/MDzQ,Y6HgNvC,0B1DlMC,U0DkMe,GAChB,gC1DnMC,U0DmMqB,GACtB,gC1DpMC,U0DoMqB,GACtB,gC1DrMC,U0DqMqB,I,oIAmB1B,+C,+CACA,yC,wDACA,kD,sEAKA,gD,sEACA,gD,sEAQA,W,OrChPwF,yBAAAtD,S,oCqCkPxF,YAAkD,OAAa,GAAb,oBAAwB,I,qCAC1E,YAAkD,kDAAW,IAAX,GAAoB,G,2CACtE,YAAmE,OAAmB,GAAnB,0BAA8B,I,0CACjG,YAAkE,OAAmB,GAAnB,0BAA8B,I,uCAChG,YAAsD,OAAmB,GAAnB,0BAA8B,I,oBAEpF,YACI,M,KEnLkB,MALtB,GAAI,OFwLW,E,CExLK,GAAO,EAAP,QACpB,IAAI,SFuLW,EEvLX,I,CAAc,GAAO,EAAP,QAClB,IAAI,kBFsLW,EEtLS,Y,CAAY,GAAO,EAAP,QACpC,IFsLkC,EAA1B,iCADO,EAEa,6B,CEvLI,GAAO,EAAP,QAChC,GAAS,qBFoLM,EEpLiB,c,CAAe,GAAO,EAAP,QACzB,qBAAtB,UAAc,EAAd,Q,CACI,IAAI,oCAAqB,GAAO,WFkLrB,EElLyC,6BAAqB,GAAO,Y,CAAY,GAAO,EAAP,QAC5F,IAAI,oCAAqB,GAAO,KFiLrB,EEjLmC,6BAAqB,GAAO,M,CAAM,GAAO,EAAP,SAEpF,GAAO,Q,GF+KH,U,sBAMJ,WAA+B,yB,sBAE/B,WACI,OAA+B,EAAvB,IAAQ,oBAA4B,KAAiB,gBAAF,IAA0B,SAAtD,UAA2D,mBACtF,gCAAe,GAAM,KAAO,+BAAqB,GAAI,cADiC,O,iJC/Q9F,0CAYA,sBAW2B,c,2EAX3B,0CAsBJ,cAuBoC,cAChC,sBAKwB,c,sBAtCxB,WAEI,OAAO,GAAY,0BAAZ,MAAY,a,sBAGvB,WAC+B,OAAW,EAAX,kB,qIA2B/B,0CAOA,sBAKqB,c,qEALrB,0CAOA,sBAKqB,c,qEALrB,0CAOA,sBAKsB,c,sEALtB,0CAOA,sBAKoB,c,oEALpB,0CAOA,sBAKqB,c,qEALrB,0CAOA,sBAKsB,c,sEALtB,0CAOA,sBAKuB,c,uEALvB,0CAOA,sBAKuB,c,uEALvB,0CAQJ,cAsCoC,cAEhC,sBAKsB,c,wIALtB,0CAOA,sBAWqB,c,qEAXrB,0CAaA,sBAQoB,c,oEARpB,0CAUA,sBAQuB,c,uEARvB,0CAWJ,cAQsC,cAClC,sBAIuB,c,yIAJvB,0CAMA,sBAWqB,c,qEE1PzB,eCEA,e,6BCwRI,2BAII,kBAIoC,EAEpC,mBAIqC,E,6FF/RzC,WAGqC,MAAM,GAAuB,0BAAG,MAAH,8C,+BAElE,WAA4C,U,wBAC5C,WAAsC,a,2BACtC,WAAwC,2D,wBACxC,WAAkC,0D,yBAClC,WAAoC,0D,uBACpC,WAAgC,0D,wBAChC,WAAkC,0D,yBAClC,WAAoC,0D,0BACpC,WAAsC,0D,wBACtC,WAAkC,mD,0BAClC,WAAsC,0D,gCACtC,YAAiE,0D,kCAEjE,YAAyE,a,qDAEzE,cAIO,4CAAwB,I,6CAAxB,gB,YADH,UAAoB,MAHxB,4D,oCAMA,YAA8E,a,kCAE9E,c,0CAGA,cAA6F,6B,uCAC7F,cAAuF,0B,wCACvF,cAAyF,2B,sCACzF,cAAqF,yB,uCACrF,cAAuF,0B,wCACvF,cAAyF,2B,yCACzF,cAA2F,4B,uCAC3F,cAAuF,0B,yCACvF,cAA2F,4B,yCAE3F,cAGa,iCAAa,EAAW,6BAAqB,K,uDAE1D,kBAKO,4CAAwB,EAAc,I,+DAE7C,kBAOI,OAD6B,EAAa,WAAW,YAChB,yBAAqB,qCAAwB,EAAc,GAAoB,mB,2GC1DxH,YAA8E,a,kCAE9E,c,mCAEA,cAMmF,U,iCAEnF,YAII,MAAM,GAAuB,8CAAoB,GAApB,kDAAwD,MAAxD,a,wBAEjC,WACI,MAAM,GAAuB,uC,mCAGjC,YAAmD,yBAAY,I,gCAC/D,YAA6C,yBAAY,I,iCACzD,YAA+C,yBAAY,I,+BAC3D,YAA2C,yBAAY,I,gCACvD,YAA6C,yBAAY,I,iCACzD,YAA+C,yBAAY,I,kCAC3D,YAAiD,yBAAY,I,gCAC7D,YAA6C,yBAAY,Q,kCACzD,YAAiD,yBAAY,I,gCAC7D,cAA8E,yBAAY,I,kCAE1F,YAAyE,a,0CAEzE,gBACwG,2BAAc,EAAY,IAAQ,2BAAc,I,uCACxJ,gBAAkG,2BAAc,EAAY,IAAQ,wBAAW,I,wCAC/I,gBAAoG,2BAAc,EAAY,IAAQ,yBAAY,I,sCAClJ,gBAAgG,2BAAc,EAAY,IAAQ,uBAAU,I,uCAC5I,gBAAkG,2BAAc,EAAY,IAAQ,wBAAW,I,wCAC/I,gBAAoG,2BAAc,EAAY,IAAQ,yBAAY,I,yCAClJ,gBAAsG,2BAAc,EAAY,IAAQ,0BAAa,I,uCACrJ,gBAAkG,2BAAc,EAAY,IAAQ,wBAAW,I,yCAC/I,gBAAsG,2BAAc,EAAY,IAAQ,0BAAa,I,yCAErJ,cAII,OAAI,2BAAc,EAAY,GAAQ,0BAAa,EAAW,6BAAqB,IAAa,M,+CAEpG,kBAMQ,2BAAc,EAAY,IAC1B,qCAAwB,EAAY,I,uDAG5C,kBAMQ,2BAAc,EAAY,IAC1B,6CAAgC,EAAY,I,oHCiKpD,YAMI,SAAa,oBAAY,O,qDAE7B,YAMI,OAD6B,EAAa,WAAW,YAChB,yBAAqB,qCAAwB,GAAmB,mB,oJA2BzG,0C,8BC5QyD,eA2E7D,iBAEI,MAAY,sBAAoB,EAAU,YAA9B,IACZ,MAAM,GACE,QACA,0FAAyF,EAEzF,YAAS,GAAT,qDAAwE,EAAxE,6EAKZ,iBAEuC,MAAnC,UAA0B,OAAS,EAAT,EAAS,YAAT,EAAyB,EAAF,WAAa,G,eCrG1B,eAAC,yBAErC,6BAAkC,EAmCC,mBACnC,4BACA,qBACA,uBAGA,6BAAkC,EAwDE,eAEpC,aAAmB,GACnB,0BAAqC,EAAU,WAAb,QAGT,eAAkC,aAAmB,GAIjD,eAAkC,aAAmB,GAIjD,eAAkC,aAAmB,GAI3D,eAAkC,aAAmB,GAI/C,iBACjC,aAAkB,GAAsB,EAAS,GAEtB,iBAC3B,aAAkB,GAAe,EAAS,GC5H9C,eA4CsE,eAElE,cADA,2BA2B2F,iBAG3F,cAFA,qBACA,uBA2CiD,eAcrB,eAE5B,aAA4C,GAC5C,0BAAkD,OAAyB,EAAoB,YAqCf,iBAGhF,aAAgE,GAFhE,gBAGA,0BAA4C,OAAe,EAAY,YAmBtC,eAA4B,aAA6C,GAC1G,0BAA4C,OAAmB,EAAQ,YAYlC,eAErC,aAAgD,GAEhD,0BAA4C,OAAuB,EAAY,YAYhD,eAE/B,aAA0C,GAE1C,0BAA4C,OAAiB,EAAY,YAYjC,iBAExC,aAAwD,EAAa,GAErE,0BAA4C,OAAuB,EAAY,WAAY,EAAY,YAYrE,iBAElC,aAAkD,EAAa,GAE/D,0BAA4C,OAAiB,EAAY,WAAY,EAAY,YCzN3D,iBAKyD,QAH/F,gBAGA,0BAA4C,GAAsB,EAAtB,SAAmD,uBACpF,IrJqoaK,EqJroaL,EAAP,WrJqoaJ,IAAK,EAAL,MAAgB,EAAhB,W,CAAgB,QAAhB,GqJnoaQ,EAA2B,GADjB,MrJooaW+T,EqJpoaO,KACD,SAC3B,kBrJkoaqBA,EqJloaV,KAAM,GAEzB,YCpDgC,iBAGhC,aAAgC,EAAM,EAAqB,GAE3D,yBAAiC,EAWL,kDADhC,iBACI,cAAsB,EAAtB,WClBJ,sBAII,0BAA4C,GAA0B,cAAmB,M,gCNkTzF,WAqC2C,U,0CAuD3C,YAMqE,U,+CAoGrE,oB,YAgBI,UAAoB,MAhBxB,sE,uDAmBA,oB,YAcI,UAAoB,MAdxB,8E,kGOtaA,a,qCAsJA,cAOsB,mCAAe,I,6CAErC,cAMI,EAAW,kBAAU,KAAM,I,qDAG/B,cASuC,MAFnC,GAD6B,EAAW,WAAW,WAG/C,OAAO,qCAAwB,uBAAyC,GAIxE,QACA,mBAEA,yBACA,qCAAwB,EAAY,K,0GAsC5C,cAa2F,U,kGNlU3F,cACI,MAAuB,QAA0B,EAAS,GAClD,EAAgB,gBM0b5B,EN1bI,EM0bY,uBAAe,GAC/B,EAAqB,K,IfxY2D,Me0Y5E,EN5bI,4BAAoB,gBAAY,EAAoB,aAAW,YM4bnE,EN3bI,kCAA0B,gBAAY,ETiDkC,uBSjDxE,G,SM4bN,sBACE,EAAK,EACC,GAJV,E,QAOQ,SAAY,EAAU,qBAAa,K,iCN7b3C,YAAqE,QAAgB,gBD6gBrF,EC7gB6D,ED6gB7C,uBAAe,GAC/B,EAAqB,K,ICxfI,QArBrB,KAAyB,MACzB,EAAkB,KAClB,GD6gBO,EC7gBH,qBACA,OAAO,kCD4gBJ,G,ECzgBG,O,CACA,MDwgBH,ECxgBe,2BAAmB,iBAArC,U,KACI,EACI,Q,KAEJ,EACI,IDmgBL,ECngBiB,4BAAoB,gBAAY,GADhD,M,KAGA,EACgB,QAAe,InIU3C,GAAI,QAEA,MAAM,EmIZ8C,sDnIYbzQ,YAEvC,EAAO,EmIdK,MACA,MAAiB,QD+ftB,EC/fsD,KACjD,ED8fL,EC9fa,kCAA0B,gBAAY,EAAO,GAHzD,M,QAKQ,MAAM,GACV,oDACS,gBAAa,iBACd,kDAAiD,IAKrE,QAAe,EnIFnB,GAAI,Q,CACA,MmICwB,mDAAgD,KnIAxE,MAAM,EAAyB,EAAQA,YAEvC,EAAO,EkIkfP,ECpfA,uB,SDqfF,sBACE,EAAK,EACC,GAJV,E,QAOQ,SAAY,EAAU,qBAAa,GCthBkB,U,0CA+B7D,YACI,MAAgB,EAAiB,4BAAoB,gBAAY,GACjE,EAAiB,QAA0B,EAAkB,GAC7D,OAAO,EAAiB,kCAA0B,gBAAY,EAAG,I,qDAGrE,cAQqC,SAAQ,kBAAkB,uBAAe,eAAW,I,qDAGzF,cASI,SAAQ,kBAAkB,uBAAe,eAAW,I,+MCnF1B,WAAQ,e,wEACtC,kD,oCAEA,YAAkD,SAAM,Y,qCACxD,YACS,MAAL,UAAK,KAAL,IAAsB,MAAM,EAA2B,EAAF,8BAArD,U,uCAEJ,YpIgBA,KoIfY,GAAS,G,CpIgBjB,MoIhBsB,wBAAwB,gBAAxB,qCpIiBtB,MAAM,EAAyBkW,EAAQlW,YoIhBvC,OAAO,G,2CAGX,YpIWA,KoIVY,GAAS,G,CpIWjB,MoIXsB,wBAAwB,gBAAxB,qCpIYtB,MAAM,EAAyBkW,EAAQlW,YoIXvC,OAAO,K,0CAGX,YpIMA,KoILY,GAAS,G,CpIMjB,MoINsB,wBAAwB,gBAAxB,qCpIOtB,MAAM,EAAyBkW,EAAQlW,YoINvC,OAAO,wB,oBAGX,YACI,OAAI,OAAS,KACT,mBACA,yBAAqB,EAAM,qBAAqB,kBAAc,EAAM,c,sBAI5E,WACI,OAAsC,GAAb,EAAlB,2BAA+C,EAAX,iBAApC,G,sBAGX,WAAkC,OAAE,gBAAF,IAAc,uBAAd,K,4HAIlC,+C,+DAI8B,WAAQ,e,wEACtC,kD,oCACA,YAAkD,SAAM,Y,qCACxD,YACS,MAAL,UAAK,KAAL,IAAsB,MAAM,EAA2B,EAAF,6BAArD,U,uCAEJ,YpIxBA,KoIyBY,GAAS,G,CpIxBjB,MoIwBsB,wBAAwB,gBAAxB,qCpIvBtB,MAAM,EAAyBkW,EAAQlW,YoIwBvC,OAAO,G,2CAGX,YpI7BA,KoI8BY,GAAS,G,CpI7BjB,MoI6BsB,wBAAwB,gBAAxB,qCpI5BtB,MAAM,EAAyBkW,EAAQlW,YoI6BvC,OAAO,K,0CAGX,YAEiB,IAAN,EpIpCX,KoImCY,GAAS,G,CpIlCjB,MoIkCsB,wBAAwB,gBAAxB,qCpIjCtB,MAAM,EAAyBkW,EAAQlW,YoIkChC,OAAM,EAAQ,G,KACjB,EAAK,qBAAL,M,KACA,EAAK,uBAAL,M,QpIqEqC,MAAM,EoIpE7B,YpIoE2DA,YoIvE7E,U,oBAOJ,YACI,OAAI,OAAS,KACT,kBACA,kBAAc,EAAM,eACpB,qBAAiB,EAAM,kBACvB,uBAAmB,EAAM,kB,sBAIjC,WACI,MAAwB,EAAX,iBAGb,OADA,GAAS,IADT,GAAS,GAAK,EAAL,GAA4B,EAAd,oBAAd,GACA,GAA8B,EAAhB,sBAAd,G,sBAIb,WAAkC,OAAE,gBAAF,IAAc,mBAAd,KAA8B,qBAA9B,K,2IAmBlC,+C,kJAIgC,WAAQ,a,wIAIR,WAAQ,a,4IAIR,WAAQ,a,gJAIR,WAAQ,a,gPCzGxC,cAEkB,MAAd,EAAc,iDAAyB,eACvC,EAAyB,uBAAR,GACjB,EAAuB,EAAQ,uBAAe,iBAC9C,GAAI,EAAiB,qBACjB,qBAAQ,EAAkB,EAAS,EAAY,wBAAS,EAAkB,SAE1E,O,CACI,MAAY,EAAiB,2BAAmB,iBAChD,IAAa,IAAT,EAAuC,MAC3C,yBAAY,EAAkB,EAAa,EAAb,EAAoB,GAI1D,OADA,EAAiB,qBAAa,iBACf,oBAAR,I,iCAGX,YAAyD,0BAAM,EAAS,O,gCAExE,cACI,MAAW,EAAQ,6BAAqB,iBAExC,OADQ,2BAAR,EAAsB,GACf,G,iCAGX,yBAA4F,WAAsB,GAAlH,wD,gHAaA,cAII,IAHA,MAAiB,0BAAN,GACX,EAAgB,EAAQ,wBAAgB,gBAAY,GACpD,EAAqB,8BAAN,GACf,EAAc,EAAd,EAAsB,EAAtB,IACI,EAAU,kCAA0B,gBAAY,EAAO,yBAAmB,EAAS,QACvF,EAAU,qBAAa,kB,6BAG3B,kBrIrCA,KqIsCY,GAAQ,GrIpChB,MAAM,EqIoCe,oDrIpCkBA,YqIqCvC,UAAc,EAAd,EAAsB,EAAtB,IACI,yBAAY,EAAS,EAAa,EAAb,EAAoB,GAAsB,I,yCAGvE,kBACY,mBAAR,EAAe,EAAO,EAAQ,kCAA0B,gBAAY,EAAO,4B,oGAa/E,kBAE0B,MrI3D1B,KqI0DY,GAAQ,GrIxDhB,MAAM,EqIwDe,oDrIxDkBA,YqIyDjB,EAAO,EAAP,IAAtB,UAAc,EAAd,OAAoC,EAChC,yBAAY,EAAS,EAAa,EAAb,EAAoB,GAAsB,I,yCAGvE,kBAEiB,MADb,EAAe,EAAQ,kCAA0B,gBAAY,EAAO,oBACvD,GAAI,E,CAC0B,MAAvC,EAAQ,2BAAmB,iBrIlEnC,GY8DM,KyHKoB,EAAQ,EAAR,GrIjEtB,MAAM,GqIiE6B,mFzHLjC,GZ5DqCA,YqIgEI,EzHHxC,OyHOC,IAAQ,EAAR,EALJ,QAOA,EAAuB,EAAQ,kBAAY,KAAQ,8BAAgB,WAAW,KAA3B,IAC/C,EAAQ,kCAA0B,gBAAY,EAAQ,qBAAyB,GAAR,EAAiB,IAExF,EAAQ,kCAA0B,gBAAY,EAAQ,sBAE1D,E7IuIJ,Y6IvIY,EAAO,I,+BAGnB,cpEpFA,IoEqFI,MAAiB,0BAAN,GACX,EAAgB,EAAQ,wBAAgB,gBAAY,GACpD,EAAqB,8BAAN,GACf,KAAY,GACZ,EpEzFY,W,CAAA,IoE0F4B,IpE1F5B,EoEyFZ,EpEzFY,OoEyFQ,EpEzFQyQ,EzEsQgCzT,I6I7KrC,EpEzFKyT,EzEmRgC/T,M6IzL9C,oCAA0B,iBAAY,gBAAtC,GAA+C,mBAAe,GAC9D,oCAA0B,iBAAY,gBAAtC,GAA+C,qBAAiB,GAE9E,EAAU,qBAAa,kB,0GAO3B,mBAAqC,UAAwB,cAAW,EAAX,GAA7D,+C,6IAeA,+C,+BAEA,YAAgD,mB,4BAChD,YAA+C,kB,mCAC/C,cAA4D,yBAAe,I,sCAE3E,YrIV6C,MAAM,EqIWzC,6ErIXuEsD,a,2BqIajF,gBrIb6C,MAAM,EqIczC,8ErIduEA,a,qBqIgBjF,WAAwC,OAAQ,qBAAR,e,+BAaxC,cACI,MAAiB,0BAAN,GACX,EAAgB,EAAQ,wBAAgB,gBAAY,GACpD,yBAAa,EAAW,EAAO,GAC/B,EAAU,qBAAa,kB,iCAG3B,YAA0D,0BAAM,EAAS,O,kJASzE,+C,kCAEA,YAAoD,iB,sCACpD,YAAsE,2B,qBACtE,WAA6C,O9I5FG,K,+B8I6FhD,YAAqD,e,4BAErD,YAC6D,YAAyC,gB,6BAEtG,YAA8D,UAAe,GAAL,K,mCACxE,cAAiE,yBAAe,I,2BAChF,gBACI,cAAI,EAAO,I,kJAOf,+C,kCACA,YAA6C,e,sCAC7C,YAAyD,qB,qBACzD,WAAuC,O9I/GS,K,+B8IgHhD,YAA+C,e,4BAC/C,YAAgD,U,6BAChD,YAAiD,kDAAyB,GAAU,I,mCACpF,cAA2D,yBAAe,I,2BAC1E,gBAA2D,cAAI,EAAO,I,6IAQtE,+C,kCACA,YAA4C,e,sCAC5C,YAAwD,qB,qBACxD,WAA2C,O5I/IS,M,+B4IgJpD,YAAmD,e,4BACnD,YAAmD,U,6BACnD,YAAoD,kDAA6B,GAAc,I,mCAC/F,gB,2BACA,gBAA+D,YAAI,I,iJAQnE,+C,kCACA,YAA4C,e,sCAC5C,YAAwD,qB,qBACxD,WAAqC,Y,+BACrC,YAA6C,e,4BAC7C,YAA6C,U,6BAC7C,YAA8C,kDAAuB,GAAQ,I,mCAC7E,gB,2BACA,gBAAyD,YAAI,I,2IAQ7D,+C,kCACA,YAA+C,e,sCAC/C,YAAyE,O7IiHW,EAAAuZ,QAAQpI,Y,qB6IhH5F,WAA8C,Y,+BAC9C,YAAsD,e,4BACtD,YAAyD,U,6BACzD,YAA0D,kDAAgC,GAAc,I,mCACxG,gB,wCACA,kB7IhBA,c6IgB8F,EAAK,I,iJAQnG,+C,kCACA,YAA+C,e,sCAC/C,YAAyE,O7IiGW,EAAAoI,QAAQpI,Y,qB6IhG5F,WAAwC,a,+BACxC,YAAgD,e,4BAChD,YAAmD,U,6BACnD,YAAoD,kDAA0B,GAAQ,I,mCACtF,gB,wCACA,kB7IhCA,c6IgCwF,EAAK,I,2IC5N7F,+C,+BAQA,cACI,MAAmB,GAAP,cAAe,GAC3B,IAAa,IAAT,EACA,MAAM,GACA,EAAF,mCAA8B,gBAAW,WAAvC,oBAC+B,GAAP,gBAGlC,EAAQ,mBAAW,gBAAY,I,iCAGnC,YACI,MAAY,EAAQ,mBAAW,iBAC/B,IAAqB,GAAP,eAAV,oBACA,MAAM,GACA,EAAF,kCAA6B,gBAAW,WAAtC,gCACwB,cAAO,QAGzC,OAAO,cAAO,I,sBAGlB,WAAkC,uDAAiD,gBAAW,WAA5D,K,sICvElC,6C,sBAEA,WAA+B,OAAmB,GAAb,iCAAN,G,oBAE/B,YAA4C,M,KR2FtB,MALtB,GAAI,OQtFmD,E,CRsFnC,GAAO,EAAP,QACpB,IAAI,SQvFmD,ERuFnD,I,CAAc,GAAO,EAAP,QAClB,IAAI,kBQxFmD,ERwF/B,Y,CAAY,GAAO,EAAP,QACpC,IQzFuD,EACnC,WACiB,EAAzB,sCAF2C,EAEY,kC,CRuFnC,GAAO,EAAP,QAChC,GAAS,qBQ1F8C,ER0FvB,c,CAAe,GAAO,EAAP,QACzB,qBAAtB,UAAc,EAAd,Q,CACI,IAAI,oCAAqB,GAAO,WQ5FmB,ER4FC,6BAAqB,GAAO,Y,CAAY,GAAO,EAAP,QAC5F,IAAI,oCAAqB,GAAO,KQ7FmB,ER6FL,6BAAqB,GAAO,M,CAAM,GAAO,EAAP,SAEpF,GAAO,Q,GQ/FqC,U,wGAQxC,WACyD,OAAQ,mC,qEAEvB,WvI6GD,MAAM,EuI7GS,cvI6GqBnR,e,+BuI3G7E,cvI2GyC,MAAM,EuI1GrC,cvI0GmEA,a,iCuIvG7E,YvIuGyC,MAAM,EuItGrC,cvIsGmEA,a,4GwI/HjF,+C,+BAEA,cACY,MAAR,OAAQ,EAAR,EAAQ,qBAAa,mB,oBAAuB,EpJ+Lf2rB,O,iCoJ5LjC,YACI,OpJgS+B,OoJhSxB,EAAQ,qBAAa,iBAAY,c,+EAXhD,0CAeA,sBAII,0BAA4C,GAA0B,eAAqB,M,qEAA3F,+C,+BAEA,cACY,MAAR,OAAQ,EAAR,EAAQ,qBAAa,mB,qBAAwB,E9C2LdA,O,iC8CxLnC,YACI,O9CgSkC,O8ChS3B,EAAQ,qBAAa,iBAAY,e,gFAXhD,0CAeA,sBAII,0BAA4C,GAA0B,eAAqB,M,qEAA3F,+C,+BAEA,cACY,MAAR,OAAQ,EAAR,EAAQ,qBAAa,mB,qBAAwB,ErJyHdA,O,iCqJtHnC,YACI,OrJoNkC,OqJpN3B,EAAQ,qBAAa,iBAAY,e,gFAXhD,0CAeA,sBAII,0BAA4C,GAA0B,gBAAuB,M,qEAA7F,+C,+BAEA,cACY,MAAR,OAAQ,EAAR,EAAQ,qBAAa,mB,sBAAyB,EnJqHbA,O,iCmJlHrC,YACI,OnJkNqC,OmJlN9B,EAAQ,qBAAa,iBAAY,gB,iFAXhD,0CE7CA,sBAI8B,cAC1B,iCAAoD,G,4EAApD,sD,iCAEA,c,wBAEA,a,mCAEA,c,gCACA,c,iCACA,c,+BACA,c,gCACA,c,iCACA,c,kCACA,c,gCACA,c,kCACA,c,gCACA,gB,kFApBJ,0CCK0C,eAAC,oBACvC,0BAA4C,OAA4B,kBAAW,YA6B7C,eACtC,wBAGA,0BAAkC,sBAAS,WAAa,IACxD,2BAAiD,GAAT,uBCjCJ,iBAAqB,wBACzD,0BAA4C,GAAsB,EAAtB,SlBsChD,eAIsB,MAFlB,GAAI,eAAqB,OAAO,cAChC,MAAa,GAAgB,iBACX,kBAAlB,UAAU,EAAV,Q,CACI,MAAU,yBAAe,GAAzB,EvDXC,UAAIlb,GuDaT,OAAO,EAMX,eAKI,iCnIqKO,SAAqB,EAAAe,UqBrGW,KAAhC,GQ5H2D8F,EAAY,GsG4D9E,QAAqD,GAuBzD,eAC8B,QAAM,EAAQ,aACxC,kB1H0C6C,MAAM,G0HzCrC,8CAA2C,I1HyCwBtX,Y0H3CvD,OACV,IADU,sBKnFqB,wBAE/C,UAA2D,MAD3D,4BACA,6BACA,+BAKA,cAAoB,EjJVmC,IAI1C,EiJgBiC,EjJpBS,EAAa,GiJW1C,oBjJPb,EAAAoO,EAAM,OAAO,EAAb,EAAb,IAAK,IAAL,EAAU,EAAV,SACIA,EAAM3S,GiJMiC,kBAA3C,ajJJO2S,EiJKP,6BAAoC,WAAuC,mBAAvC,MAEpC,wBACyD,KACzD,2BAAkC,eAAa,oBAG/C,uBACyC,IAAK,kBAAE,6BAChD,gCACgC,GAAK,8BAAE,uF9GxBI,I8GwBN,QAErC,gDACkE,GAAK,8BACnE,4F,C9Iy/VG,IA+UM,EA/UN,EAAM,EAAa,UA+U1B,IAAK,EAAL,mB,CAAa,MAAb,KACIwC,EAAY,UAAcC,E8Iz0WiC,YAA3D,E9I00WGD,O8I10WH,cAAwE,OADL,QAIvE,yBAC8B,GAAK,8BAAE,YAAa,qCAAf,QA4EvC,iBAEI,MAAwB,EAAX,cACb,GAAS,GAAK,EAAL,GAAyB,GAAX,GAAd,EACT,IlI6lDgB,EkI7lDhB,EAAyB,MlI4lDrB+U,E6H5kDQ,E7H6kDZ,IAAgB,EkI5lDA,ElI4lDA,wB,CAAA,IgJxsDqB,EnB2HH,K7H6kDYA,E6H7kDZ,EAA8B,E7H6kDhD,SkI5lD2C,WlI4lDrCA,E6H7kDY,GmB3HG,8BAAoB,GnB2HvB,EKflC,IlI4lDgB,EkI5lDhB,ElI6lDOA,EAFH,E6H5kDQ,E7H6kDZ,IAAgB,EkI3lDD,ElI2lDC,wB,CAAA,IgJxsDqB,EnB2HH,K7H6kDY,E6H7kDZ,EAA8B,E7H6kDhD,SkI3lD0C,KlI2lDpC,E6H7kDY,GmB3HG,8BAAoB,GnB2HvB,EKXlC,OADA,GAAS,IADT,GAAS,GAAK,EAAL,GAAc,EAAd,GACA,GlI0lDF,EkI1lDE,E,8BepHb,sBAQI,aAAiE,M,qEHHjE,+C,+BAEA,cACQ,SACA,EAAQ,oBACR,EAAQ,gCAAwB,kBAAY,IAE5C,EAAQ,c,iCAIhB,YACI,OAAW,EAAQ,oBAAqB,EAAQ,gCAAwB,mBAAiB,EAAQ,c,oBAGrG,Y,MACI,OAAI,OAAS,KACT,SAAiB,+EAAe,OACpC,sBACI,oBAAc,EAAM,gB,sBAI5B,WACI,OAAkB,EAAX,oB,4IASX,+C,sEACA,gD,qEAEI,WAAQ,Y,oBAEZ,YACI,OAAI,OAAS,KACT,kBACA,wBAAY,EAAM,mB,sBAI1B,WACI,OAAS,sBAAF,gB,sBAGX,WACI,OAA6B,GAAb,EAAT,0B,sEAnBX,uD,wEAAA,yD,mEAAA,oD,+DAAA,gD,2CAAA,2E,0CAAA,0E,qCAAA,qE,oCAAA,oE,uCAAA,uE,wJC7BA,+C,+BAEA,cACI,EAAQ,uBAAe,iBAAY,qBAAa,kB,iCAGpD,YAEI,OADA,EAAQ,uBAAe,iBAAY,qBAAa,iBACzC,uB,0HbVX,+C,wDAEA,kD,+DAE8B,WAAQ,e,sEACK,WAAQ,iDAAoB,O,sEAS1B,WAAQ,sBAAQ,Q,oEAE7D,W,OvCUwF,uBAAAjpB,S,6EuCRxF,W,OvCQwF,gCAAAA,S,2FuCLxF,W,OvCKwF,gDAAAA,S,sEuCAxF,W,OvCAwF,yBAAAA,S,gCuCGxF,mBAAoC,WAAsB,GACtD,cAAM,6CAAW,EACjB,2BAAoB,cAAS,EAC7B,6BAAsB,cAAS,M,oCAGnC,YnH2DO,QmH1DQ,6BAAsB,cAC7B,GAAI,Q,CACA,MAAa,EAAsB,GACnC,6BAAsB,cAAS,EAFnC,EAGI,OAHJ,EAKI,EANR,EASK,UAAI,I,yCAGb,YACQ,gCACA,wBAAmB,EAAU,IAEjC,4BAAmB,UAAI,I,0CAG3B,YACI,OAAwB,GAAjB,wBAA4B,GAAO,Y,uCAG9C,YAAsD,OAAoB,GAApB,2BAA+B,I,2CACrF,YAC0B,MAAtB,cAAsB,KAAtB,6BAAiC,IAAjC,EAA2C,K,oCAC/C,YAAkD,OAAM,GAAN,aAAiB,I,qCACnE,YAAkD,+CAAQ,IAAR,GAAiB,G,4BAEnE,WAEc,MADV,EAAc,KACJ,eAAV,6B,CACI,MAAQ,aAAM,GAAd,EvIkKR,YAAIM,EuIlKwB,GAExB,OAAO,G,oBAGX,YAA4C,M,KAuBtB,MALtB,GAAI,OAlBmD,E,CAkBnC,GAAO,EAAP,QACpB,IAAI,SAnBmD,EAmBnD,I,CAAc,GAAO,EAAP,QAClB,IAAI,kBApBmD,EAoB/B,Y,CAAY,GAAO,EAAP,QACpC,IApB6B,EAAzB,sCADmD,EACI,kC,CAoB3B,GAAO,EAAP,QAChC,GAAS,qBAtB8C,EAsBvB,c,CAAe,GAAO,EAAP,QACzB,qBAAtB,UAAc,EAAd,Q,CACI,IAAI,oCAAqB,GAAO,WAxBmB,EAwBC,6BAAqB,GAAO,Y,CAAY,GAAO,EAAP,QAC5F,IAAI,oCAAqB,GAAO,KAzBmB,EAyBL,6BAAqB,GAAO,M,CAAM,GAAO,EAAP,SAEpF,GAAO,Q,GA3BqC,U,sBAI5C,WAA+B,yB,sBAE/B,WACI,OAAuB,EAAhB,eAAQ,QAAqB,KAAQ,gBAAF,IAAgB,SAAnC,UAAwC,mBAC3D,SAAG,IAAM,KAAO,+BAAqB,EAAG,OAAO,cADY,O,8HgB3EnE,WAAgE,W,8KDAhE,YAA+C,iB,6BAC/C,YAAuD,cAAiB,I,mBACxE,WAAkC,qBAAU,I,yCAE5C,kBACI,EAAQ,eAAO,EAAQ,0BAAkB,gBAAY,K,iCAGzD,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,0BAAkB,gBAAY,EAAG,EAAQ,K,uFApB7D,0CAyBgC,eAE5B,cAEA,cAAgC,EAChC,wBAA6B,EAAe,OAIxC,4BAAe,IAiBvB,sBAQI,aAAqE,M,mEA7BrE,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,uGAcrC,YAAgD,iB,6BAChD,YAAyD,cAAkB,I,mBAC3E,WAAmC,sBAAW,I,yCAE9C,kBACI,EAAQ,eAAO,EAAQ,2BAAmB,gBAAY,K,iCAG1D,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,2BAAmB,gBAAY,EAAG,EAAQ,K,wFApB9D,0CAyBiC,eAE7B,cAEA,cAAiC,EACjC,wBAA6B,EAAe,OAIxC,4BAAe,IAgBvB,sBAQI,aAA6D,M,mEA5B7D,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,wGAarC,YAA8C,iB,6BAC9C,YAAqD,cAAgB,I,mBACrE,WAAiC,sBAAS,I,yCAE1C,kBACI,EAAQ,eAAO,EAAQ,yBAAiB,gBAAY,K,iCAGxD,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,yBAAiB,gBAAY,EAAG,EAAQ,K,sFApB5D,0CAyB+B,eAE3B,cAEA,cAA+B,EAC/B,wBAA6B,EAAe,OAIxC,4BAAe,IAgBvB,sBAQI,aAAiE,M,mEA5BjE,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,sGAarC,YAA+C,iB,6BAC/C,YAAuD,cAAiB,I,mBACxE,WAAkC,mBAAU,I,yCAE5C,kBACI,EAAQ,eAAO,EAAQ,0BAAkB,gBAAY,K,iCAGzD,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,0BAAkB,gBAAY,EAAG,EAAQ,K,uFApB7D,0CAyBgC,eAE5B,cAEA,cAAgC,EAChC,wBAA6B,EAAe,OAIxC,4BAAe,IAgBvB,sBAQI,aAAqE,M,mEA5BrE,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,uGAarC,YAAgD,iB,6BAChD,YAAyD,cAAkB,I,mBAC3E,WAAmC,wBAAW,I,yCAE9C,kBACI,EAAQ,eAAO,EAAQ,2BAAmB,gBAAY,K,iCAG1D,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,2BAAmB,gBAAY,EAAG,EAAQ,K,wFApB9D,0CAyBiC,eAE7B,cAEA,cAAiC,EACjC,wBAA6B,EAAe,OAIxC,4BAAe,IAgBvB,sBAQI,aAAyE,M,mEA5BzE,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,wGAarC,YAAiD,iB,6BACjD,YAA2D,cAAmB,I,mBAC9E,WAAoC,wBAAY,I,yCAEhD,kBACI,EAAQ,eAAO,EAAQ,4BAAoB,gBAAY,K,iCAG3D,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,4BAAoB,gBAAY,EAAG,EAAQ,K,yFApB/D,0CAyBkC,eAE9B,cAEA,cAAkC,EAClC,wBAA6B,EAAe,OAIxC,4BAAe,IAgBvB,sBAQI,aAAiE,M,mEA5BjE,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,yGAarC,YAA+C,iB,6BAC/C,YAAuD,cAAiB,I,mBACxE,WAAkC,mBAAU,I,yCAE5C,kBACI,EAAQ,eAAe,GAAR,EAAQ,0BAAkB,gBAAY,M,iCAGzD,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,0BAAkB,gBAAY,EAAG,EAAQ,K,uFApB7D,0CAyBgC,eAE5B,cAEA,cAAgC,EAChC,wBAA6B,EAAe,OAIxC,4BAAe,IAgBvB,sBAMI,aAA6E,M,mEA1B7E,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,uGAWrC,YAAkD,iB,6BAClD,YAA6D,cAAoB,I,mBACjF,WAAqC,sBAAa,I,yCAElD,kBACI,EAAQ,eAAO,EAAQ,6BAAqB,gBAAY,K,iCAG5D,gBACI,UAAU,EAAV,EAAkB,EAAlB,IACI,EAAQ,6BAAqB,gBAAY,EAAG,EAAQ,K,6FAlBhE,0CAuBmC,eAE/B,cAEA,cAAmC,EACnC,wBAA6B,EAAe,OAIxC,4BAAe,IErWiB,iBACpC,4BACA,sBAYJ,iBAEI,OAGJ,YAEsB,MADlB,EAAW,GAAoB,KAC/B,IAAkB,4B,CAAA,eACd,EAAwC,GAAvB,KAAU,aAE3B,GAAe,GAAX,EADgB,UAAS,GACqB,IAAoB,GAAX,EAAkB,GAAyB,GAClG,MAAM,EAIF,GAJ2B,oIAEV,EAFU,wBAEkC,GAAX,GAFvB,2HAVvC,CAAU,GACH,OAA0B,EAAY,GAkBjD,eAEI,mCAAoB,KAApB,qBAEJ,sBACiC,yBAAqB,OAAiB,cAAe,G,mEF0TlF,2C,IAAA,yC,4CAOA,YACQ,cAAO,OAAO,IACd,cAAgB,GAAP,cAA+B,GAAjB,EAA6C,EAAd,cAAO,OAAP,M,4BAG9D,YAEW,MADP,8BACA,eAAO,oCAAP,IAAqB,G,mBAGzB,WAAuB,OAAO,GAAP,cAAc,gB,6HEjXrC,+C,+CACA,yC,wEAEgC,WAAQ,Y,oCACxC,YAAkD,uB,qCAClD,YAAkD,uB,uCAClD,YAAsD,uB,0CACtD,YAAkE,uB,2CAClE,YAAmE,uB,sBACnE,WAAkC,6BAAsB,gBAAtB,K,qBAClC,WAA+B,MAAM,EAAsB,gD,mJA4B9B,yD,iCAAA,oE,+BAAA,sE,+EADjC,0CAGA,sBAEI,0BAA4C,OAA0B,iBAA1B,M,qEAA5C,+C,+BACA,cAAiE,EAAQ,sBAAc,I,iCACvF,YAAsD,SAAQ,iB,kFAJlE,0CAOA,sBAEI,0BAA4C,OAA0B,cAA1B,M,qEAA5C,+C,+BACA,cAA8D,EAAQ,mBAAW,I,iCACjF,YAAmD,SAAQ,c,+EAJ/D,0CAOA,sBAEI,0BAA4C,OAA0B,eAA1B,M,qEAA5C,+C,+BACA,cAA+D,EAAQ,oBAAY,I,iCACnF,YAAoD,SAAQ,e,gFAJhE,0CAOA,sBAEI,0BAA4C,OAA0B,aAA1B,M,qEAA5C,+C,+BACA,cAA6D,EAAQ,kBAAU,I,iCAC/E,YAAkD,SAAQ,a,8EAJ9D,0CAOA,sBAEI,0BAA4C,OAA0B,cAA1B,M,qEAA5C,+C,+BACA,cAA8D,EAAQ,mBAAW,I,iCACjF,YAAmD,SAAQ,c,+EAJ/D,0CAOA,sBAEI,0BAA4C,OAA0B,eAA1B,M,qEAA5C,+C,+BACA,cAA+D,EAAQ,oBAAY,I,iCACnF,YAAoD,SAAQ,e,gFAJhE,0CAOA,sBAEI,0BAA4C,OAA0B,gBAA1B,M,qEAA5C,+C,+BACA,cAAgE,EAAQ,qBAAa,I,iCACrF,YAAqD,SAAQ,gB,iFAJjE,0CAOA,sBAEI,0BAA4C,OAA0B,cAA1B,M,qEAA5C,+C,+BACA,cAA8D,EAAQ,mBAAW,I,iCACjF,YAAmD,SAAQ,c,+EAJ/D,0CAOA,sBAEI,0BAA4C,OAA0B,gBAA1B,M,qEAA5C,+C,+BACA,cAAgE,EAAQ,qBAAa,I,iCACrF,YAAqD,SAAQ,gB,uFAJjE,0CC3HA,cAyII,uB1JlDgD,I0JmEpD,cAE0C,cAQ1C,cA+HI,wB1J5MgD,I0J0NhD,qBAAmB,EASvB,cAE0C,cCrTO,iBAC7C,uBACA,yBA+CmC,iBASkF,QANrH,aAA0C,EAAe,GAGzD,0BAG4C,GAAsB,+BAAtB,SAAyE,oBAGrH,OAFI,kBAAQ,MAAO,EAAc,YAC7B,kBAAQ,QAAS,EAAgB,YACrC,KARiC,iBAAC,qBAAqB,uBAgBxB,iBAIuD,QADtF,aAAqC,EAAe,GACpD,0BAA4C,GAA2B,cAA3B,IAA0C,oBAGtF,OAFI,kBAAQ,QAAS,EAAc,YAC/B,kBAAQ,SAAU,EAAgB,YACtC,KASoC,mBAMoD,MALxF,qBACA,qBACA,qBAGA,0BAA4C,GAA2B,gBAA3B,IAA4C,mBAIxF,OAHI,kBAAQ,QAAS,gBAAY,YAC7B,kBAAQ,SAAU,gBAAY,YAC9B,kBAAQ,QAAS,gBAAY,YACjC,KCtGJ,eA+F+B,qBAK3B,cAJA,0BACA,4BACA,mCACA,kC,eClGsC,eAAC,kBCJ3C,iBACI,IAAc,MAAV,oBAAmB,MAAM,OAA0B,SAAQ,EAAR,kBAA6B,OACpF,OAAO,EAAI,GAGf,iBACI,IAAc,MAAV,oBAAmB,MAAM,OAA0B,SAAQ,EAAR,kBAA6B,OACpF,OAAO,EAAI,GAEf,eAEsE,MAApB,EAAzC,EAAL,cAAK,KAAL,EAAK,KAAL,EAA8C,kBAAoB,EAAZ,GAAR,GAAoB,WAApB,+BAElD,iBAAoG,OjIP9Bsa,EAAY,GiISlF,iBAAmE,SAAO,mBAAW,GAErF,eACI,MAAM,GACF,2BAAyB,cAAzB,gNAMR,iBAKiC,MACe,EAHrC,E,IACG,MjCELib,GAAqB,EAArB,OiCDwB,EAArB,eAAqB,uBACrB,eAAwB,SAAY,EAAZ,EAAY,mBAAY,EAAZ,SAAZ,UAChB,K,SAGZ,OAPJ,SAWJ,eAAwE,iC,4EJtBhE,WAAQ,a,uCAEZ,cAEI,MAAM,GAAuB,8CAAoB,GAApB,kDAAwD,MAAxD,a,oCAEjC,YAAsD,MAAM,GAAuB,0B,qCACnF,cAAiE,+BAAkB,EAAK,I,sCACxF,cAAmE,+BAAkB,EAAK,I,uCAC1F,cAAqE,+BAAkB,EAAK,I,sCAC5F,cAAmE,+BAAkB,EAAK,I,uCAC1F,cAAqE,+BAAkB,EAAK,I,wCAC5F,cAAuE,+BAAkB,EAAK,I,yCAC9F,cAAyE,+BAAkB,EAAK,I,sCAChG,cAAmE,+BAAkB,EAAK,Q,wCAC1F,cAAuE,+BAAkB,EAAK,I,sCAE9F,gBAIU,+BAAkB,EAAK,I,wCAEjC,cACI,YAAa,iBAAb,M,kCAEJ,YACI,uCAAmB,cAAU,I,qCAIjC,cACI,MAAe,oBAAL,EAAY,GAEtB,OADA,mBAAQ,IACD,G,+BAGX,a,wBACA,WAAuC,4BAAiB,gB,mCACxD,YAAyD,iCAAoB,cAAU,I,gCACvF,YAAmD,8BAAiB,cAAU,I,iCAC9E,YAAqD,+BAAkB,cAAU,I,+BACjF,YAAiD,6BAAgB,cAAU,I,gCAC3E,YAAmD,8BAAiB,cAAU,I,iCAC9E,YAAqD,+BAAkB,cAAU,I,kCACjF,YAAuD,gCAAmB,cAAU,I,gCACpF,YAAmD,8BAAiB,cAAU,I,kCAC9E,YAAuD,gCAAmB,cAAU,I,gCAEpF,cAGU,8BAAiB,cAAU,EAAgB,I,oCAErD,YAA8E,a,kCAE9E,YACQ,uB1JgJiD/gB,W0J/IjD,cAEJ,uBAAU,I,+BAGd,c,0CAKA,gBACI,iCAA+B,oBAAX,EAAkB,GAAQ,I,uCAElD,gBACI,8BAA4B,oBAAX,EAAkB,GAAQ,I,wCAE/C,gBACI,+BAA6B,oBAAX,EAAkB,GAAQ,I,sCAEhD,gBACI,6BAA2B,oBAAX,EAAkB,GAAQ,I,uCAE9C,gBACI,8BAA4B,oBAAX,EAAkB,GAAQ,I,wCAE/C,gBACI,+BAA6B,oBAAX,EAAkB,GAAQ,I,yCAEhD,gBACI,gCAA8B,oBAAX,EAAkB,GAAQ,I,uCAEjD,gBACI,8BAA4B,oBAAX,EAAkB,GAAQ,I,yCAE/C,gBACI,gCAA8B,oBAAX,EAAkB,GAAQ,I,yCAEjD,cAII,OAAO,gCAA8B,oBAAX,EAAkB,GAAQ,EAAW,6BAAqB,K,+CAGxF,kBAMQ,6BAAc,EAAY,IAC1B,qCAAwB,EAAY,I,uDAG5C,kBAOQ,6BAAc,EAAY,IAC1B,6CAAgC,EAAY,I,qEAKhD,WAAQ,OAAS,GAAT,2B,2EAER,WAAQ,OAAS,GAAT,2B,2BAEZ,YACI,uBAAS,UAAI,I,oBAGjB,WACI,GAAI,uB1JmEiDA,U0JhEjD,MAAM,GAAuB,yCAHjC,OACI,uBAAS,iBAAkB,GAAT,0B,iGAQ1B,cAAiE,2BAAO,yBAAY,EAAM,K,4BAC1F,YAA+D,MAAZ,gCAAY,kCAAoB,GAAI,I,iCACvF,cAAmF,SAAW,uBAAe,I,iCAC7G,cACI,O3FkHsD,I2FlHlD,E3FkHwCjR,O2FlHlB,EAAiB,EAAF,IAAc,G,kJAMvD,WAAQ,a,qCAIZ,YAEI,MAAM,GAAuB,0BAAG,MAAH,8C,2CAEjC,YAAgE,U,oCAChE,YAA0D,a,uCAE1D,YAA4D,6DAAkB,IAAlB,O,oCAC5D,YAAsD,4DAAkB,IAAlB,O,qCACtD,YAAwD,4DAAkB,IAAlB,O,mCACxD,YAAoD,4DAAkB,IAAlB,O,oCACpD,YAAsD,qDAAkB,GAAlB,e,qCACtD,YAAwD,4DAAkB,IAAlB,O,sCACxD,YAA0D,4DAAkB,IAAlB,O,oCAC1D,YAAsD,qDAAkB,IAAlB,O,sCACtD,YAA0D,4DAAkB,IAAlB,O,sCAC1D,cACI,4DAAkB,IAAlB,O,wCAEJ,cAA+F,YAAa,iBAAb,M,6CAE/F,cACI,4CAAwB,I,kCAK5B,YACI,uCAAmB,cAAU,I,+BAEjC,WAGqB,yCAAoB,OAAO,EAA5C,MAAiB,EACjB,OAAO,mCAAwB,I,wBAGnC,WAA4C,a,2BAE5C,WAA8C,sCAAoB,gB,wBAClE,WAAwC,mCAAiB,gB,yBACzD,WAA0C,oCAAkB,gB,uBAC5D,WAAsC,kCAAgB,gB,wBACtD,WAAwC,mCAAiB,gB,yBACzD,WAA0C,oCAAkB,gB,0BAC5D,WAA4C,qCAAmB,gB,wBAC/D,WAAwC,mCAAiB,gB,0BACzD,WAA4C,qCAAmB,gB,gCAE/D,YAAuE,qCAAiB,cAAU,I,oCAElG,YAA8E,a,kCAE9E,c,0CAIA,cACI,sCAA+B,oBAAX,EAAkB,K,uCAE1C,cACI,mCAA4B,oBAAX,EAAkB,K,wCAEvC,cACI,oCAA6B,oBAAX,EAAkB,K,sCAExC,cACI,kCAA2B,oBAAX,EAAkB,K,uCAEtC,cACI,mCAA4B,oBAAX,EAAkB,K,wCAEvC,cACI,oCAA6B,oBAAX,EAAkB,K,yCAExC,cACI,qCAA8B,oBAAX,EAAkB,K,uCAEzC,cACI,mCAA4B,oBAAX,EAAkB,K,yCAEvC,cACI,qCAA8B,oBAAX,EAAkB,K,yCAEzC,cAGa,uCAA8B,oBAAX,EAAkB,GAAQ,EAAW,6BAAqB,K,uDAE1F,kBAMI,+BAAoB,oBAAX,EAAkB,IAAQ,0BAAE,yCAAwB,EAAc,MAAxC,W,+DAEvC,kBAMI,+BAAoB,oBAAX,EAAkB,IAAQ,0BAC/B,OAAI,sBAAqB,kCACrB,EACA,GACG,kBAJwB,W,gCAOvC,cACI,mBAAQ,GACR,MAAQ,IAKR,OAJK,qBACD,cAEJ,qBAAO,EACA,G,qEAKP,WAAQ,OAAS,GAAT,4B,2EAER,WAAQ,OAAS,GAAT,4B,2BAEZ,YACI,wBAAS,UAAI,I,gCAGjB,YACI,EAAM,mBAAS,eAAO,0B,oBAK1B,WACI,MAAQ,wBAAS,iBAAkB,GAAT,0BAE1B,OADA,qBAAO,EACA,G,iGAOX,cAAiE,2BAAO,yBAAY,EAAM,K,4BAE1F,YAA+D,MAAZ,gCAAY,kCAAoB,GAAI,I,iCACvF,cAA6E,SAAK,uBAAe,I,iCACjG,cACI,O3F/CsD,I2F+ClD,E3F/CwCA,O2F+ClB,EAAiB,EAAF,IAAc,G,qGClT3D,cACI,MAAwB,EAAQ,uBAAe,iBAC/C,EAAkB,kCAA0B,gBAAY,EAAG,qBAAqB,mBAAN,IAC1E,EAAkB,kCAA0B,gBAAY,EAAG,uBAAuB,qBAAN,IAC5E,EAAkB,qBAAa,kB,iCAGnC,YA4BoB,MAAU,EA3B1B,EAAgB,EAAQ,uBAAe,iBACvC,GAAI,EAAU,qB,CACV,MAAU,EAAU,kCAA0B,gBAAY,EAAG,sBAC7D,EAAY,EAAU,kCAA0B,gBAAY,EAAG,wBAC/D,OAAO,sBAAS,EAAK,GAGzB,MAAgB,GAChB,EAAkB,G,EACR,O,CACA,MAAU,EAAU,2BAAmB,iBAA7C,U,KACI,EACI,Q,KAEJ,EACI,EAAM,EAAU,kCAA0B,gBAAY,EAAG,sBAD7D,M,KAGA,EACI,EAAQ,EAAU,kCAA0B,gBAAY,EAAG,wBAD/D,M,QAGQ,MAAM,GAAuB,kBAAiB,IAI9D,GADA,EAAU,qBAAa,iBACnB,IAAQ,GAAM,MAAM,GAAuB,4BAC/C,GAAI,IAAU,GAAM,MAAM,GAAuB,8BAEjD,OAAO,sBAAS,kCAAU,oC,qHASI,wC,gDAAqB,0C,oFAAvD,WAAkC,iB,wBAAlC,WAAuD,mB,0BAAvD,iCAAkC,sBAAqB,qB,sBAAvD,iBAAkC,qCAAqB,kCAAvD,K,sBAAA,0BAAuD,MAArB,+BAAqB,0B,oBAAvD,mHAAkC,0BAAqB,8B,qEAEvD,+C,2BAQoC,YAAQ,SAAK,K,6BACX,YAAQ,SAAK,O,8BACnD,cAA2D,cAAS,EAAK,I,4IAQzE,+C,2BAI+B,YAAQ,SAAK,O,6BACX,YAAQ,SAAK,Q,8BAE9C,cAAsD,WAAO,I,wIAW7D,+C,+BAMA,cACI,MAAwB,EAAQ,uBAAe,iBAC/C,EAAkB,kCAA0B,gBAAY,EAAG,mBAAa,EAAM,OAC9E,EAAkB,kCAA0B,gBAAY,EAAG,mBAAa,EAAM,QAC9E,EAAkB,kCAA0B,gBAAY,EAAG,mBAAa,EAAM,OAC9E,EAAkB,qBAAa,kB,iCAGnC,YACI,MAAgB,EAAQ,uBAAe,iBACvC,OAAI,EAAU,qBACH,0BAAmB,GAEvB,uBAAgB,I,kCAG3B,YACI,MAAQ,EAAU,kCAA0B,gBAAY,EAAG,oBAC3D,EAAQ,EAAU,kCAA0B,gBAAY,EAAG,oBAC3D,EAAQ,EAAU,kCAA0B,gBAAY,EAAG,oBAE3D,OADA,EAAU,qBAAa,iBAChB,MAAO,EAAG,EAAG,I,+BAGxB,YA0BkB,MAAQ,EAAQ,EAzB9B,EAAc,GACd,EAAc,GACd,EAAc,G,EACJ,O,CACA,MAAY,EAAU,2BAAmB,iBAA/C,U,KACI,EACI,Q,KAEJ,EACI,EAAI,EAAU,kCAA0B,gBAAY,EAAG,oBAD3D,M,KAGA,EACI,EAAI,EAAU,kCAA0B,gBAAY,EAAG,oBAD3D,M,KAGA,EACI,EAAI,EAAU,kCAA0B,gBAAY,EAAG,oBAD3D,M,QAGQ,MAAM,GAAuB,oBAAmB,IAIhE,GADA,EAAU,qBAAa,iBACnB,IAAM,GAAM,MAAM,GAAuB,8BAC7C,GAAI,IAAM,GAAM,MAAM,GAAuB,+BAC7C,GAAI,IAAM,GAAM,MAAM,GAAuB,8BAE7C,OAAO,MAAO,kCAAQ,kCAAQ,oC,6KCpDlC,cAEW,QADP,OAAW,GAAN,EAAmB,IACjB,wDAAqB,IAArB,sCAAqC,IAArC,WADoC,M,oCAI/C,cAEqB,QAGT,IAHS,E3JuHQ,E2JvHR,sDAA0B,K3JuHlB,uBAAmB,U2JvHe,GAA1C,KAAjB,MAAiB,wBACjB,OAAI,QAA2B,EAExB,OAAC,iEAAyB,IAAzB,QAAD,EAAyE,GAAzE,M,mCAGX,YACI,0DAAiB,GAAjB,Y,4BAEJ,YGkDgB,UAAhB,IAAgB,EHjDZ,wB3J+OgFgZ,QAAQpI,W8J9L5E,a,CAAA,IH/CJ,EzBtDgD,E4BqG5C,WHjDgB,EGiDHV,E9JiHmCzT,I2JlKxB,EGiDXyT,E9J8HmC/T,M2J9K9C,qBACN,sBzBtDgD,WyBuDhD,EzBvDgD,W4BqG5D,IAAgB,EH1CZ,0B3JwOgF6c,QAAQpI,W8J9L5E,a,CAAA,iBH1CoB,EG0CP,E9JiHmCnU,I8JjHhE,IAAgB,EAAa,E9J8HmCN,MAgEoB6c,QAAQpI,W8J9L5E,a,CAAA,IHvCA,IzB9D4C,E4BqG5C,WHzCY,EGyCC,E9JiHmCnU,I2J1JvB,EGyCZ,E9J8HmCN,M2JtK1C,sBACN,sBACA,sBzB/D4C,WyBgE5C,EzBhE4C,Y4BqG5D,IAAgB,EHhCZ,gC3J8NgF6c,QAAQpI,W8J9L5E,a,CAAA,IH/BqB,IG+BrB,WHhCwB,EGgCX,E9JiHmCnU,I2JjJb,EGgCtB,E9J8HmCN,M2J7J9C,6BAAmB,sBAA0B,iC,upB3BlF/D,sDACiC,UAAK,UAAS,EAAT,oCAAsD,MAD5F,G,8ECjCJ,YAMwD,OAAuB,GAAvB,GAAkC,I,iyBEmI1F,YAII,cAAoB,I,yBAQxB,cAO4B,cAAwB,EAAe,I,sBAEnE,YAK4D,a,sBAE5D,YAK8D,a,sBAE9D,YAK8D,a,sBAE9D,YAKgE,a,qLEvJhE,c7HhCI,GsDgRoD0qB,GuE7N5C,G7HjDJ,MAAM,E6HiDyB,oC7HjDQpnB,Y6HkD3C,OAAO,GAAwB,EAAY,I,i3BCiK3C,0C,8sCyB7OJ,YAEmE,c,2hLnBoFnC,e,GACK,+B,GACK,mC,GACP,6B,GACO,mC,GACP,6B,GVlC2B,G,GqBxDD,G,GCK3B,IAC9B,KAAwB,MACxB,QAAoB,MACpB,KAAoB,MACpB,KAAwB,MACxB,KAAsB,MACtB,KAAsB,MACtB,KAAqB,MACrB,QAAoB,MACpB,KAAoB,MACpB,KAAkB,MAClB,KAAmB,MACnB,KAAsB,MACtB,KAAqB,MACrB,KAAoB,MACpB,KAAoB,MACpB,KAA0B,MAC1B,KAAuB,MACvB,gDAAoB,Q,GErBL,O,GC2CoC,OAAiB,KAAY,KAAY,KAAY,M,kDKxD5G,IAOIwyB,EACAC,EARA9Q,EAAUzmB,EAAOD,QAAU,GAU/B,SAASy3B,IACL,MAAM,IAAIn0B,MAAM,mCAEpB,SAASo0B,IACL,MAAM,IAAIp0B,MAAM,qCAsBpB,SAASq0B,EAAWzpB,GAChB,GAAIqpB,IAAqBK,WAErB,OAAOA,WAAW1pB,EAAK,GAG3B,IAAKqpB,IAAqBE,IAAqBF,IAAqBK,WAEhE,OADAL,EAAmBK,WACZA,WAAW1pB,EAAK,GAE3B,IAEI,OAAOqpB,EAAiBrpB,EAAK,GAC/B,MAAM/I,GACJ,IAEI,OAAOoyB,EAAiB52B,KAAK,KAAMuN,EAAK,GAC1C,MAAM/I,GAEJ,OAAOoyB,EAAiB52B,KAAKP,KAAM8N,EAAK,MAvCnD,WACG,IAEQqpB,EADsB,mBAAfK,WACYA,WAEAH,EAEzB,MAAOtyB,GACLoyB,EAAmBE,EAEvB,IAEQD,EADwB,mBAAjBK,aACcA,aAEAH,EAE3B,MAAOvyB,GACLqyB,EAAqBE,GAjB7B,GAwEA,IAEII,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAaxyB,OACbyyB,EAAQD,EAAajZ,OAAOkZ,GAE5BE,GAAc,EAEdF,EAAMzyB,QACN6yB,KAIR,SAASA,IACL,IAAIH,EAAJ,CAGA,IAAII,EAAUT,EAAWO,GACzBF,GAAW,EAGX,IADA,IAAI/lB,EAAM8lB,EAAMzyB,OACV2M,GAAK,CAGP,IAFA6lB,EAAeC,EACfA,EAAQ,KACCE,EAAahmB,GACd6lB,GACAA,EAAaG,GAAYI,MAGjCJ,GAAc,EACdhmB,EAAM8lB,EAAMzyB,OAEhBwyB,EAAe,KACfE,GAAW,EAnEf,SAAyBM,GACrB,GAAId,IAAuBK,aAEvB,OAAOA,aAAaS,GAGxB,IAAKd,IAAuBE,IAAwBF,IAAuBK,aAEvE,OADAL,EAAqBK,aACdA,aAAaS,GAExB,IAEWd,EAAmBc,GAC5B,MAAOnzB,GACL,IAEI,OAAOqyB,EAAmB72B,KAAK,KAAM23B,GACvC,MAAOnzB,GAGL,OAAOqyB,EAAmB72B,KAAKP,KAAMk4B,KAgD7CC,CAAgBH,IAiBpB,SAASI,EAAKtqB,EAAKiF,GACf/S,KAAK8N,IAAMA,EACX9N,KAAK+S,MAAQA,EAYjB,SAASslB,KA5BT/R,EAAQgS,SAAW,SAAUxqB,GACzB,IAAIyqB,EAAO,IAAIh1B,MAAM0K,UAAU/I,OAAS,GACxC,GAAI+I,UAAU/I,OAAS,EACnB,IAAK,IAAI9E,EAAI,EAAGA,EAAI6N,UAAU/I,OAAQ9E,IAClCm4B,EAAKn4B,EAAI,GAAK6N,UAAU7N,GAGhCu3B,EAAM7b,KAAK,IAAIsc,EAAKtqB,EAAKyqB,IACJ,IAAjBZ,EAAMzyB,QAAiB0yB,GACvBL,EAAWQ,IASnBK,EAAKp2B,UAAUi2B,IAAM,WACjBj4B,KAAK8N,IAAIE,MAAM,KAAMhO,KAAK+S,QAE9BuT,EAAQkS,MAAQ,UAChBlS,EAAQmS,SAAU,EAClBnS,EAAQoS,IAAM,GACdpS,EAAQqS,KAAO,GACfrS,EAAQsS,QAAU,GAClBtS,EAAQuS,SAAW,GAInBvS,EAAQwS,GAAKT,EACb/R,EAAQyS,YAAcV,EACtB/R,EAAQ0S,KAAOX,EACf/R,EAAQ2S,IAAMZ,EACd/R,EAAQ4S,eAAiBb,EACzB/R,EAAQ6S,mBAAqBd,EAC7B/R,EAAQ8S,KAAOf,EACf/R,EAAQ+S,gBAAkBhB,EAC1B/R,EAAQgT,oBAAsBjB,EAE9B/R,EAAQiT,UAAY,SAAU54B,GAAQ,MAAO,IAE7C2lB,EAAQkT,QAAU,SAAU74B,GACxB,MAAM,IAAIuC,MAAM,qCAGpBojB,EAAQmT,IAAM,WAAc,MAAO,KACnCnT,EAAQoT,MAAQ,SAAUC,GACtB,MAAM,IAAIz2B,MAAM,mCAEpBojB,EAAQsT,MAAQ,WAAa,OAAO,I,wb1K1KpC,M,mEkB2HA,4C,4LA/GA,+C,GoD2EA,qC,6ZvDimDA,gC,GAAA,gD,G0FjpDA,yB,GAgBA,yB,GhGiBA,2C,GEjCA,+C,mPIi7CA,qD,G0CrsCA,K,uL1C6/CA,gD,0JL5tDA,gD,sDiK0BoD,W,0DCjFrB,Y,uPrEsY/B,kC,mGhG1HA,gB,IDdI,8B,sWSk8BJ,8HuG5mCA,e5G4JA,yB,mCAlMA,sC,8D8DiHA,2B1CzJA,6B,iD+IdA,0FACI,sBACA,mBADA,6BACA,6BCFJ,0FACI,iBACA,kBACA,kBAQA,KAVA,6BACA,6BACA,6BAQA,sB,+yEDXJ,8B,mBAAA,sB,IAAA,qB,IAAA,kB,QAAA,4D,mBCKI,WAAmB,OAAK55B,KAAL,M,IACf,IADe,OACV,E,IACL,KAFe,OAET,E,IACN,KAHe,OAGT,E,QAHS,iC,6BAOf,YAA4B,OAAM65B,G,KAC9B,EADwB,OACnB,K,KACL,EAFwB,OAEnB,K,KACL,EAHwB,OAGnB,K,Q5J6HgC,MAAM,I4J5H3BA,EAAF,2B5J4H2Dl1B,c,2I4JjIjF,+CCHJ,0FACI,qBACA,uBACA,6BACA,wBACA,qBACA,2BACA,2BACA,0BACA,8BACA,mBACA,gCACA,sBACA,6BACA,6BAbA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BAGJ,cACI,YAAmB,GACnB,aAAoB,EACpB,kBAAyB,EAEzB,qBAAkB,KAGlB,oBAAmB,KCxBF,gCAGjB,IAAAkW,MAAmB,WACnB,IAAAD,MAAoB,MAIpB+b,GAAA,UAAQR,EAAUC,EAAWvb,EAASD,GAHtC,cACA,WACA,WAyBmB,iBAAC,aAA+B,yBACnD,cAAqB,EACrB,iBAAwB,IAAAkf,GACxB,UvK6CoD,KuK3CpD,eAGgC,KAEhC,crKOkD,KqKHlD,oBACA,2BAAiC,EACjC,yBAA+B,EAE/B,cAAqBrD,GAAS,wBAAkBD,IAukBP,mCACT,cAAO,WAAP,oCAAsB,GAAtB,qBC5nBpB,eACZ,gBASJ,0FACI,4BACA,oBACA,sBAFA,6BACA,6BACA,6BAQgB,mBAChB,YACA,cACA,cAMoB,wBAGpB,IAAAuD,MAAwB,IAAAC,GxKiD4B,OwKhDpDC,GAAA,eAAkCC,EAAQH,GAF1C,oBAca,wBAGb,IAAAA,MAAwB,IAAAC,GxKiC4B,OwKhCpDC,GAAA,eAA0BC,EAAQH,GAFlC,YAUe,0BAQf,IAAAA,MAAwB,IAAAC,GxKgB4B,OwKfpDC,GAAA,eAA4BC,EAAQH,GANpC,sBAOA,qBAAoB14B,EAsBP,qBACb,cACA,YAIA,aACA,cAEA,mBAI4C,KAqGhD,eAWiB,eAA4B84B,GAAA,WAA3B,uBAMC,eAA8BA,GAAA,WAA7B,uBAMA,eAA+BA,GAAA,WAA9B,uBAMA,eAA6BA,GAAA,WAA5B,uBASV,mBACR,cACA,WACA,WAMmB,wBAEnB,UAG4B7jB,MAJ5B,gBACA,YAIA,4BAUW,iBACX,eAIA,cAUe,oBAAC,UxKxMoC,MwKwMpC,cC/RpB,c,OxEuC4F,GAAAjV,MwE5B5F,eAII,sBAAkB+4B,GAAA,W,uEJjBtB,mC,mBAAA,sB,IAAA,gB,IAAA,iB,IAAA,iB,QAAA,yD,qECQA,0F,mBAAA,sB,IAAA,oB,IAAA,sB,IAAA,4B,IAAA,uB,IAAA,oB,IAAA,0B,IAAA,0B,IAAA,yB,IAAA,6B,IAAA,kB,IAAA,8B,IAAA,oB,IAAA,2B,IAAA,2B,QAAA,2D,gEAsBI,wC,IAAA,sC,+DAGA,uC,IAAA,qC,8DAGa,WAAQ,yBAAa,EAAb,K,8DACR,WAAQ,oBAAQ,kBAAR,K,8BAErB,YACIp6B,KAAK,OAAOgsB,EACZ,aAAQ,EACR,kBAAa,G,mEAIb,WAEW,M7Jff,G6JcgB,KAAApX,OAAA,MAAwB,KAAAA,OAAA,MAA2B,KAAAA,OAAA,K7JZ/D,MAAM,GAfO,sBAe0BjQ,Y6JanC,MAAO,wBAAAtD,OAAA,U,qEAIX,WAEW,M7JrBf,G6JoBgB,KAAAuT,OAAA,K7JlBZ,MAAM,GAfO,sBAe0BjQ,Y6JmBnC,MAAO,wBAAAtD,OAAA,U,mEAIX,WAOW,M7JhCf,G6J2BY,KAAAuT,OAAA,MACQ,KAAAA,OAAA,MACA,KAAAA,OAAA,MACA,KAAAA,OAAA,K7J5BhB,MAAM,GAfO,sBAe0BjQ,Y6J8BnC,MAAO,wBAAAtD,OAAA,U,uBAGf,WA0CW,MAtCP,IAHA,KAAAuT,KAAO,KACP,KAAAvT,MAAQ,KAED,kB,CACH,kBAAa,aACb,MAAW,cAEX,GAAY,KAAR6hB,E,CAGA,GAFA,cAEc,KAAV,cAEA,MAEA,cAIR,KIrFO,IJqFHA,MIrF2B,GJqF3BA,GIrFkD,IJqFtD,CAKI,MAAQ,KAARA,EAAA,IAAoB,EAALA,GItFZ,IJsFYA,GItFW,IJsF1B,EACA,+BACe,KAARA,GACP,KAAAtO,KAAA,KACA,eACe,KAARsO,EACP,yBACe,KAARA,EACP,wBACe,MAARA,EACP,iCAEA,uBAGJ,MAnBI,cAsBR,OAAmB,MAAR,KAAAtO,MACP,kBAAa,YAAK1P,OAClB,aAAQ,YAAKA,OACb,MAEA,KALG,G,uBASX,WAAiC,oBAAQ,YAAKA,Q,oBAE9C,WAAgC,MAAL,+BAAK,kCAAL,K,oBAE3B,WAA2B,8BAAK,e,oBAEhC,WACI,+B,oBAGJ,WACI,+B,qBAGJ,mBAAkB,IAAAkZ,MAAY,QAAG,IAAAlH,MAAU,GAClC,MAAL,YAAK,EAAU,kBAAakH,EAAb,EAAV,EAA6B,aAAQlH,EAAR,EAAlC,O3JsF4E,EAAY5O,UAAUmb,EAAYC,I,8B2JpFlH,WACI,KAAO,kB,CACH,MAAW,cAEP,EAAQ,KAARR,EAAJ,GAAI,IAAoB,EI1IjB,IJ0IYA,MI1IY,GJ0IZA,GI1ImC,IJ0IlD,E,CACA,cACA,S,qCAKZ,WAII,IAyBO,MA5BP,EAAgB,cACZmX,GAAU,EAEP,kB,CACH,MAAW,cAEX,GAAY,KAARnX,GAAuB,MAARA,EAEf,YADA,uBAEG,GAAiB,KAAbiJ,IAA6B,MAARjJ,GAAuB,KAARA,GAE3C,YADA,2BAEG,GAAY,KAARA,E,CACPmX,GAAU,EACV,MACO,MAAQ,KAARnX,EAAJ,GAAI,IAAoB,EIjKxB,IJiKmBA,MIjKK,GJiKLA,GIjK4B,IJiK3C,EACP,MAEA,cAIR,KAAA7hB,MAAgB2zB,GAAR,gBAEJqF,GACA,c,EAIA,WAAAh5B,M,KACAg5B,E,UAFJ,KAAAzlB,KAAA,G,iCAOJ,WACI,wBACA,MAAa,eAET0lB,GAAc,gBAAQC,KACtB,KAAAl5B,MAAuB,GAARm5B,GAAPD,EAAY,GAAe,IAE/B,WAAAl5B,OACA,KAAAuT,KAAA,KAKR,KAAAA,KAAA,M,6BAGJ,WACI,wBACA,MAAe,eAEX6lB,GAAY,gBAAQC,KACpB,KAAAr5B,MzGrG8Cs5B,GyGqGtCD,GAEJ,WAAAr5B,OACA,KAAAuT,KAAA,KAKR,KAAAA,KAAA,M,uCAGJ,WACI,cAGA,IAFA,IAAIgmB,GAAa,EAEV,kB,CACH,MAAW,cAEX,KAAI1X,GIxNG,IJwNHA,GIxN0B,IJ4N1B,MAHA0X,GAAa,EACb,cAMJA,GACA,KAAAv5B,MAAwB2E,GAAhB,aAAa,IACrB,KAAA4O,KAAA,OAEA,cACA,yB,+BAIR,WACI,IAQa,IAAN,EARA,kB,CACQ,MAAP,cAAJ,GI/OO,IAAf,GAAwB,GAAe,GAAQ,GAAe,GJgPlD,MAEA,cAID,OAAM,gB,IACT,Q,OAAA,M,IACA,Q,OAAA,M,IACA,U,OAAA,M,eAHJ,KAAAA,KAAA,G,8BAQJ,WAOc,IAyBH,EA/BP,cACA,IAAIimB,GAAmB,EACnBC,GAAa,E,EAGjB,KAAO,kB,CACH,OAAM,e,KACF,GACID,GAAmB,EADvB,M,KAGA,GACI,IAAKA,E,CACD,cACAC,GAAa,EACb,QAGJD,GAAmB,EAPvB,M,QAUIA,GAAmB,EAI3B,cAGJ,KAAAx5B,MAAQ,aAAa,EAAYy5B,EAAY,EAAO,GK1R5CC,WL2RS,MAAQ,KK3RjBA,WL4RS,MAAO,M,EAEbD,E,UAAX,KAAAlmB,KAAA,G,6BAOJ,WACI,IAoBU,MAKc,EACR,EA1BT,kB,CACH,MAAW,cAEP,EAAQ,KAARsO,EAAJ,GAAI,IAAoB,EIzSjB,IJySYA,MIzSY,GJySZA,GIzSmC,IJySlD,EACA,MACG,GAAY,KAARA,GAGP,GAFA,cAEc,KAAV,c,CACA,cACA,YAGJ,cAIR,MAAY,eAGZ,GAFA,KAAA7hB,MAAQ25B,EAEwB,KAAtB,EAANA,EM1TIp0B,WN0TiB,KAArB,GAA2C,IAA/C,CAKwB,EAANo0B,EAAM91B,OAAxB,IAAK,IAAL,EAAU,EAAV,QAEQ,KADQ,EAAN81B,EMhUFp0B,WNgUuBxG,IACpB,IAAH,EAAkB,MAAlB,EACG,IADH,EACkB,MAClB,KAFA,GAGA,KAHA,GAIA,KAJA,GAKA,KALA,GAMA,KANA,EAYI,YADA,KAAAwU,KAAA,MAMZ,KAAAA,KAAA,UAvBI,KAAAA,KAAA,M,4JChQR,WAEiB,MASW,EATxB,IAAa,qC,CAAA,eAIT,GAHA,iBAAU,iBAASoX,GACnB,iBAAUiP,YAEY,MAAlB,iBAAUrmB,K,CACV,IAAIsmB,GAAW,EAIC,EAAV,iBAAUtmB,KACZ,WACQ,sBACA,0BAEA,iCAGR,YACI,oBACAsmB,GAAW,GAEf,WACI,0BAEJ,WACI,0BAEJ,WACI,yBAEJ,WACQ,sBACA,oBAEA,iCAGR,WACQ,sBACA,qBAEA,iCAGR,WACI,gBAAS,yBAEb,WACI,gBAAS,uBAGT,iCAIR,wBAAmBA,EAGvB,gCAGJ,OAAO,cAAO,cAAQ,IAAAC,GAAW,a,8BAGrC,sBAQU,IA4Be,EA5Bf,EAAU,eACZ,SAEI,eAAU,IAAAC,GvKjD8B,UuKoD3B,IAAApB,IAGb,UAAG,UAAI,qBAGX,eACIqB,EAAIC,aAAa,UACb,IAAAC,GACIC,EACAjD,EACAkD,EACA,IAAAC,GACeC,EACJC,EACPC,KAOZrF,GAAO,eAAM,kBAAE,cAAO,WAAP,uC,wBAK3B,YAegB,MAQS,EAtBf,EAAU,eACZ,WAEI,eAAU,IAAAsF,GvKnF8B,KuKqF7B,KAAO,sBAAcC,GACnB,IAAA/B,IAGb,UAAG,UAAI,yBAGX,kB,CACI,MAAcqB,EAAI/K,KAAK5nB,MACnB,EAAJ2yB,EAAI/K,MAAJ,KAAS,EAAA5nB,KAAQqzB,EAAM,OAAvB,EAEA,IAAK,IAAL,QAAUA,EAAV,WACIV,EAAI/K,KAAK,gBAAQlwB,EAAI47B,EAAJ,EAAaD,EAAM37B,SAKxCo2B,GAAO,eAAM,kBAAE,cAAO,WAAP,+B,yBAK3B,YACU,IAkBe,EAlBf,EAAU,eACZ,SAEI,eAAU,IAAAyF,GvK/G8B,KuKiH5Bv1B,EACO,KACN,IAAAszB,IAGb,UAAG,UAAI,qBAGX,eACIqB,EAAIh6B,MAAJg6B,EAAIh6B,MAASqF,EAIb8vB,GAAO,eAAM,kBAAE,cAAO,WAAP,iC,wBAK3B,uBAA4D,IAAA3b,MAAmB,MAC3E,cAAO,mBACH,IAAAqhB,GAAA,SAEI9F,EACA,MAAAvb,IAAaub,EAAF,OAAgB,cAAhB,IAAwB+F,EAAxB,SAHf,EAIa,cACHA,EACAtqB,K,wBAKlB,mBAAwC,IAAAgJ,MAAmB,MACvD,gBAAS,iBAAUshB,IAAK,iBAAUtqB,IAAKukB,EAAWvb,I,uCAGtD,WAGgC,MAF5B,gBACI,oBACA,iBAAc,OAAU,EAAV,iBAAUjG,MAAV,aAAd,OAAwC,cAAxC,IAAiD,iBAAUunB,IAA3D,M,0BAIR,YACI,cAAO,mBACH,IAAAD,GAAA,WAEI9F,OAFJ,SAGa,cACH,iBAAU+F,IACV,iBAAUtqB,O,0BAK5B,WACI,MAAY,iBAAUuqB,SAEjB,cAAO,UAAIC,IACZ,gBAAS,oBAGb,MAAa,6BAEb,GAAI,wB,CACA,MAAiBpmB,GAAH,WACdqmB,EAAQpC,OAAO,UAAImC,GACnBC,EAAQvC,OAAOG,OAAO,UAAIH,GAK9B,OAFA,iBAAUkB,YAEJ,eAAN,M,IACI,eACS,0BACD,eAAU,IAAAG,GACGmB,GAAc,CAAAF,IvK5LS,KuK8LvB,IAAArC,GAAuBuC,GAAc,CAAAxC,MAGlD,UAAG,UAAI,qBAGP,iBAAUnlB,OAAV,KACA,0BACyB,MAAlB,iBAAUA,MACjB,gBAAS,6BAdjB,M,IAkBA,OACS,0BACD,eAAU,IAAAknB,GACGS,GAAc,CAAAF,IAChB,KAAO,qBAAa,GAClB,IAAArC,GAAuBuC,GAAc,CAAAxC,MAElD,UAAG,UAAI,qBAGP,iBAAUnlB,OAAV,KACA,oBACyB,MAAlB,iBAAUA,MACjB,gBAAS,mBAbjB,M,IAiBA,SACS,0BACD,eAAU,IAAAqnB,GACGM,GAAc,CAAAF,IACf,GACO,KACN,IAAArC,GAAuBuC,GAAc,CAAAxC,MAElD,UAAG,UAAI,qBAGP,iBAAUnlB,OAAV,KACA,qBACyB,MAAlB,iBAAUA,MACjB,gBAAS,wB,gCAMzB,WACI,2B,gCAGJ,WACI,2B,+BAGJ,WACI,2B,4BAGJ,YACQ5U,KAAK,YAAWw8B,GAAY,2BAC5B,kBAAW,+BAGfx8B,KAAK,UAAUw8B,EACf,2BAAqB,EAEjB,iBAAUvB,aACV,kC,gCAIR,WACI,MAAawB,GAAiB,iBAAUC,UACxC,EAAqB,6BAEP,MAAVlB,EACA,gBAAS,mBAELA,EAAOnI,QAAP,KAEA,iBACImI,EACAG,GACQ,GAIZ,iBACIH,EACAG,GACQ,I,yBAMxB,gBA2C8B,IA2DD,EAmBC,EAnDH,EA4EmB,EAiGC,EA5OvCgB,EACAC,EACAC,EARJ,EvKnSgD,KuKoShD,EvKpSgD,KuKqS5CC,EAAW,EACXrB,GAAQ,EACRsB,GAAc,EACdC,EAAS,EAITC,EAAQ,iBAAUroB,KAClBunB,EAAM,iBAAUA,IAChBtqB,EAAM,iBAAUA,IAIpB,IAFA,iBAAUopB,c,CAIN0B,EAAYM,EACZL,EAAUT,EACVU,EAAUhrB,EAGVorB,EAAQ,iBAAUroB,KAClBunB,EAAM,iBAAUA,IAChBtqB,EAAM,iBAAUA,IAChB,MAAY,iBAAUxQ,MAEtB,GAAa,MAAT47B,EACA,MAIJ,iBAAUhC,YACV,MAAgB,iBAAUrmB,KAC1B,EAAc,iBAAUunB,IACxB,EAAc,iBAAUtqB,IAExB,EAA0BqrB,GAAd1B,EAAO2B,OAAiBH,GACpC,EAAgB,MAAAI,IAAA,UAGhB,EAAgBR,EAAUC,EAAV,EAChB,EACI,GADkB5B,EAClB,MAAsBoC,EAAUC,EAAUC,EAApB,EACtB,MAFkBtC,EAEVoC,EAAUE,EAAY,EAAtB,EACAF,EAAUE,EAAV,EAGZ,GAAIN,IAAU,KACNF,EACA,gBAAS,yBACO,MAATK,GAAkBA,EAAMI,UAC/BR,IAAA,KAGJD,GAAc,M,CAWd,IAAIU,EAGW,OAZVV,GACD,gBAASQ,EAAWpB,EAAMoB,EAAN,EAAiB,qBAGzCR,GAAc,EAEdD,IAAA,IAMqBG,EAAN,M,IACX,QACI,iBAAA57B,GAAA,KAGI,GADEq8B,EACF,OACID,GAAY,EACZ,uBAActB,EAAKtqB,EAAKxQ,EAAO,IAEnC,GALEq8B,EAKF,OACA,SANEA,EAMF,KAEID,GAAY,EACZ,uBAActB,EAAKtqB,EAAKxQ,EAAO,IAEnC,GAXEq8B,EAWF,OACID,GAAY,EACZ,uBAActB,EAAKtqB,EAAKxQ,EAAO,IAEnC,GAfEq8B,EAeF,OACID,GAAY,EACZ,MAAAE,GAAe,KAGfF,GAAY,EACZ,MAAAG,GAAOv8B,IAxBnB,M,IA6BA,UACIo8B,EAAYC,IAAc,KAC1B,MAAAC,GAAS,mBAAAt8B,GAAA,QAFb,M,IAKA,WACIo8B,EAAYpK,GACJqK,IAAc,MACd,SAAAA,EAAA,IAER,iBAAAr8B,GAAA,KAEIA,EAAQ,KACR,gBAAS86B,EAAKtqB,EAAK,iDAGvB,MAAA+rB,GAAOv8B,GAXX,M,IAcA,MACIo8B,EAAYC,IAAc,KAC1B,MAAAG,GAAU,mBAAAx8B,GAAA,QAFd,M,QAMIo8B,GAAY,EACZ,MAAAK,GAAWz8B,GAxDnB,QA4DA,EAAa,IAAA08B,GACC,IAAAC,GAAO,cAAQ7B,EAAKtqB,GACrB,IAAAmsB,GAAO,cAAQT,EAAWU,IASvC,GANK5K,GACD6K,EAAc,UAAIC,GAGtBC,EAAQ,UAAIrE,IAEP0D,IACDhC,GAAQ,EAGK,MAAT2B,G,CAC0B,EAANA,EAAMxoB,KAA1B,MACI,WAAY,mBACZ,WAAa,mBACb,WAAW,mBACX,WAAa,UAEb,iBACA,MACG,uBAEH,WAAc,eACd,WAAc,iBAEd,eAAgB,UAEhB,WAAc,WAEd,YACA,eACG,uBAEH,WAAe,YAEf,WAAoB,c,wBAGxB,gBAASunB,EAAKtqB,EAAK,YAAYwsB,EAAZ,KAMvBhL,GAAsB,MAAbqK,IAELT,IAAU,KACN,SAAAS,EAAA,IACA,sBACIY,EACA/nB,GAAO4nB,GACU,MACT,EACR5nB,GAAOwjB,IACgB,GAG3B,sBACIwE,EACAhoB,GAAO4nB,GACU,MACT,EACR5nB,GAAOwjB,IACgB,GAK3B,GADE2D,EACF,OACA,SAFEA,EAEF,IAEI,sBACIY,EACA/nB,GAAO4nB,GACU,MACT,EACR5nB,GAAOwjB,IACgB,GAI/B,GAdE2D,EAcF,OACA,SAfEA,EAeF,IAEI,sBACIc,EACAjoB,GAAO4nB,GACU,MACT,EACR5nB,GAAOwjB,IACgB,GAI/B,GA3BE2D,EA2BF,MACI,sBACIe,EACAloB,GAAO4nB,GACU,MACT,EACR5nB,GAAOwjB,IACgB,GAK/B,GAvCE2D,EAuCF,MACI,sBACIe,EACAloB,GAAO,IAAAqnB,GAA+Bne,IAAvB,WAAA0e,EAAA,YAAiB98B,SACf,MACT,EACRkV,GAAOwjB,IACgB,GAI/B,GAlDE2D,EAkDF,MACI,sBACIgB,GACAnoB,GAAO4nB,GACU,MACT,EACR5nB,GAAOwjB,IACgB,GAK3BvD,GAAO,cAAM,cAUrC,MACS,wBAAmBgF,EAAOnI,QAAP,KACnBmI,EAAO2B,OAAOz0B,KAD4C,EAGnE,EAA2Bi0B,IAAc,KAGzC,EAAkBC,EAAUC,EAAUlB,EAAeQ,IAAnC,EAEdX,EAAOgC,QAGHV,EAAW6B,IACXlD,GAAQ,EACR,gBACIE,EAAeQ,IACfyC,EACA,qBAAoBD,EAApB,aACsB,IAAdA,EAAiB,GAAQ,KADjC,SAEQ7B,EAFR,MAOJA,IAAY6B,IACZlD,GAAQ,EACR,gBACIE,EAAeQ,IACfyC,EACA,YAAWD,EAAX,aACsB,IAAdA,EAAiB,GAAQ,KADjC,SAEQ7B,EAFR,MAQRjB,GACA,gBAASe,EAASC,EAAS,qBAG/B,sBAAerB,EAAQ0C,EAAevC,EAAgBF,EAAO2C,EAASvC,I,6BAG1E,kBAGI,GAAY,IAARnzB,E,CACA,MAAc,EAAIA,EAAJ,EAEd,EAAe,IAAE,GAAOm2B,EAAU,GAElC,GAAgB,GAAOA,GAAY,EAApB,EAGXx9B,EAAQy9B,EACJ,gBAAS3C,EAAKtqB,EAAQgtB,EAAH,8CAA6CC,EAA7C,KAEvBz9B,EAAQ09B,GACJ,gBAAS5C,EAAKtqB,EAAQgtB,EAAH,iDAAgDE,EAAhD,KAK/B,OAAO,IAAAnB,GAAOv8B,I,0BAGlB,WAGI,IAFA,MvKvnBgD,KuKynBzC,iBAAUuT,OAAV,M,CACH,MAAY,iBAAUwnB,SAElB/6B,EAAQ,EACR,gBAAS,gDACFA,EAAQ,KACf,gBAAS,qDAGb06B,EAAM,UAAUn2B,GAANvE,IAEV,iBAAU45B,YAGQ,MAAlB,iBAAUrmB,MACV,gBAAS,uCAGb,gBAAeoqB,GAANjD,K,2BAGb,WACI,iBAA6BpX,GAAnB,iBAAU+X,SAAiB,KAAM,SAEvC,iBAAUzB,aACV,kC,mCAIR,WAA4C,WAAA+C,GAAO,cAAQ,iBAAU7B,IAAK,iBAAUtqB,M,8FCruBpF,WACa,IlK2vBG,EkK3vBH,EAAT,KAAAotB,SlKkvBG,EAAmB,KAS1B,IAAgB,4B,CAAA,eAAU,SAAA7pB,EAAA,KAAcG,EAAY,UAAIH,GkK3vBpD,OlK4vBGG,G,kBkK1vBP,WACwB,IlKmiDX,EkKniDW,EAAT,KAAA0pB,SlK49CR,EAAM,GAAa5b,GAAwB,OAuElD,IAAa,4B,CAAA,eACT9N,EAAY,UAAcC,EkKpiDG0pB,QAA7B,WAAA/D,GlKqiDG5lB,I,yIkKliDX,mC,mBAAA,sB,IAAA,2B,IAAA,mB,IAAA,qB,QAAA,iE,qFAyBI,YlKssFgB,MADZ4pB,EAAW,EACf,IAAgB,EkKrsFZ,KAAA7D,alKqsFY,wBACZ6D,IADY,SkKrsFY,mBlKssFxB,EkKtsFA,OlKwsFGA,G,kBkKtsFP,WAEQ,IlKkgDK,EkKlgDL,KAAU,KAAAjF,QACG,EAAb,KAAAoB,aAAa,EAAM,GAAU,KAAAA,aAAa5yB,MlKigDlD,IAAa,4B,CAAA,eACT6M,EAAY,UAAcC,EkKlgDgC0pB,QAF1D,WAAA9D,GAAA,ElKqgDG7lB,EkKlgDC,KAAAwkB,OAAOmF,S,kGASf,YACI,YAAA5O,KAAK5nB,M,kBAET,WACI,WAAAozB,GAAY,GAAU,KAAA5B,QAAS,KAAA5J,KAAK4O,OAAQ,KAAAnF,OAAOmF,S,iIAavD,wC,IACI,YACI,oBAAe,KACf,qBAAQ79B,K,0BAGhB,YAGW,MADP,mC,CACO,GAAI+9B,E,CACC,OAAM,KAAA/9B,MAAM6D,OAAS,EAAf,GAAoB,EAA9B,IAAmC,GxHmNA,GAAWoH,KAAK2C,IwHnNnD,M,CAEI,OAAM,KAAA5N,MAAM6D,OAAS,EAAf,GAAoB,EAA9B,IAAmC,GxHiNA,GAAWoH,KAAK,IwHjNnD,EAJR,E,EAAA,U,kBAOJ,WACI,WAAA2vB,GAAc,GAAU,KAAA/B,QAAS,KAAA74B,MAAO,oBAAc,KAAA04B,OAAOmF,S,gGAqBjE,YAS6B,MALzB,GAAI,yB,CACA,MxK5B4C,KwK+B5C,GAFAl/B,KAAK,cAAcq/B,EAEf,KAAA7D,OAAOnI,QAAP,K,CACiB,EAAP,KAAAmI,OAAO2B,OAAjB,IAAK,IAAL,mB,CAKgB,SAJA,KAAA3B,OAAO2B,OAAP,YAAc/8B,GAIJo9B,Q,C/JjCtC,G+JkC0Bp9B,IAAmB,GAAd,KAAAo7B,OAAO2B,Q/JhClC,MAAM,GAfK,gBAeyBx4B,Y+JiCf,KAAL,KAAA4zB,KAAUn4B,QAEV,EAAAk/B,GAAmBpC,GAAL,KAAA3E,KAAen4B,IAJjC,QAOAi/B,EAAY,UAAIE,KAK5B,OAA2B,mBAApB,YAAiCC,I,mCAG5C,YAKqB,kCAAAzF,QAAA,aACV,OAAOzjB,KADd,MAAiB,EAGjB,OAAW,KAAAklB,OAAO2B,OAAP,YAAcqC,GAAYhC,QAGtB,GAAX5B,EAAgB4D,GAEhBF,GAAyBpC,GAAXtB,EAAqB4D,K,6BAI3C,YASqB,MAJb92B,EAAO,KAAA8yB,OAAO9yB,KAElB,GAAI,KAAA8yB,OAAOnI,QAAP,KAAuC,OAAO3qB,EAEjC,EAAP,KAAA8yB,OAAO2B,OAAjB,IAAK,IAAL,mB,CACI,IAGA,EAea,EAEI,EAjBT,EAHR,EAAW,KAAA3B,OAAO2B,OAAP,YAAc/8B,GAAGwU,KAC5B,EAAW,qBAAQxU,GAGf,GADJ,EAAAsI,EACI,GADUkM,EACV,MAAY,SAIZ,MALUA,EAKV,MAAiB,KAAI,EAAI2jB,EAAK7vB,KAAT,GAAJ,OAEjB,MAPUkM,EAOV,MAAa,SAEb,MATUA,EASV,UATUA,EAUV,MACG,SAEH,MAbUA,EAaV,MAEQ,EADAwqB,GACC,WAAA7G,EAAA,YAAK,GAAL,YAAsBl3B,MAAM6D,OAAS,EAAtC,EAE0C,GAA1C,GAAK,WAAAqzB,EAAA,YAAK,GAAL,YAAsBl3B,MAAM6D,OAAjC,UAIR,MArBU0P,EAqBV,MAAc,IAAI2jB,EAAK7vB,KAAT,OAId,YAzBUkM,EAyBV,IAAc,QAEd,cA3BUA,EA2BV,I/J1DiC,MAAM,I+J4DzB,4CAAkBA,GAAlB,qB/J5DuDjQ,Y+J0DrD,IA3BpB+D,EAAA,MAiCJ,OAAOA,G,kBAGX,WAC6C,MAAzC,IAAA6yB,GAAY,KAAAC,OAAQ,KAAAjD,KAAM,KAAAkD,MAAO,KAAA1B,QAAjC,OnJjHE,EmJiH8C,cAAiB,mBnJhH9D,G,sKmJ8HO,0C,uBACd,WAAgC,YAAA14B,O,yBAChC,WAA0C,MAAS,KAAAA,MAAf,OvHtK2C,EAAA0N,cAAc2Q,I,0BuHuK7F,WAAsC,YAAAre,MAAMsD,Y,oFAHhD,WAAkB,mB,0BAAlB,+BAAkB,qB,sBAAlB,iBAAkB,uCAAlB,K,sBAAA,0BAAkB,iC,oBAAlB,mHAAkB,8B,gDAME,0C,uBAChB,WAAgC,OAAM8a,GAAN,KAAApe,Q,yBAChC,WAAoC,YAAAA,O,0BACpC,WAAsC,YAAAA,MAAMsD,Y,sFAHhD,WAAoB,mB,0BAApB,+BAAoB,qB,sBAApB,iBAAoB,yCAApB,K,sBAAA,0BAAoB,iC,oBAApB,mHAAoB,8B,gDAMC,0C,uBACjB,WAAgC,U,yBAChC,WAAoC,U,0BACpC,WAAsC,YAAAtD,O,uFAH1C,WAAqB,mB,0BAArB,+BAAqB,qB,sBAArB,iBAAqB,0CAArB,K,sBAAA,0BAAqB,iC,oBAArB,mHAAqB,8B,gDAMC,0C,uBAClB,WAAgC,U,yBAChC,WAAoC,U,0BACpC,WAAsC,U,wFAH1C,WAAsB,mB,0BAAtB,+BAAsB,qB,sBAAtB,iBAAsB,2CAAtB,K,sBAAA,0BAAsB,iC,oBAAtB,mHAAsB,8B,8MAkDlB,WACI,WAAA24B,GAAc,GAAU,KAAAE,U,2IClR5B,0CAGJ,cAGyBE,GAAA,WAEzB,sBAGkBqF,GAAA,W,oMAHlB,0CAKA,sBAGmBA,GAAA,W,2EAHnB,0CAKA,sBAGiBA,GAAA,W,yEAHjB,0CAKA,sBAGmBA,GAAA,W,2EAHnB,0CAKA,cAGyBA,GAAA,WACrB,sBAAkBC,GAAA,W,0EAAlB,0CAGJ,sBAGoBA,GAAA,W,2IAHpB,0CAKA,sBAGoBA,GAAA,W,4EAHpB,0CAKA,sBAGoBA,GAAA,W,4EAHpB,0CAKA,sBAGuBA,GAAA,W,+EAHvB,0CAKA,sBAGoBD,GAAA,W,4EAHpB,0CAKA,cAG0BrF,GAAA,WAOb,eAAgCuF,GAAA,WAA/B,iBAEd,sBAGoBA,GAAA,W,yMAHpB,0CAKA,sBAGqBvF,GAAA,W,kGAHrB,0CAKW,uBACP,YACA,YACA,WAIA,YAKA,aAMA,aAGuB,KAAAxlB,OAAS,MAAiB,KAAAA,OAAS,KAG9D,0FACI,oBACA,mBADA,6BACA,6BAOS,2BACT,YAIA,gBAIA,WAIA,cAIA,aAIA,eAIA,aAKA,UAGoB,KAAAjO,KAAO,IAAM,EAAO,EAS5C,eAEQ,OAAAA,GAAQ,IAAQi5B,GAAUj5B,EAAMA,EAAMk5B,GACpBD,GAAUj5B,EAAe,IAATA,EAAlCA,GAAQ,MAAyCm5B,EACVC,GAG/C,eAIsC,MAA9B,EAHAvE,EAAS,CAAb1hB,EAAa,KAAoB7Y,IAAI++B,IAErC,GAAc,MAAVxE,EAAA,GACA,gBAA8B,EAA9ByE,GAA8B,oBAAYD,IAA1C,qB,CAAyE,IAACE,E/E1FvB,EAAA3c,MAAMkK,YAAN,YAAkB,G+E2FjE,EAAmB,GAARyS,EAAc,IACzB1E,EAAA,EAAS2E,GAAax5B,GACtB,KAAoB6sB,IAAA,EAAc,GAAAgI,EAAA,IAI1C,OAAOA,EAAA,EAGX,mBACI,IAAIA,EAAS4E,EAAQ/qB,GAerB,OAbc,MAAVmmB,IACAA,EAAS,IAAA6E,GACL15B,EACW,WAAgB,GAALA,EAAc,IAC9B,KACG2P,KACD,MACE,GACF,GAEZ8pB,EAAQ/qB,GAASmmB,GAGdA,EI/MX,0FACI,oBAKA,sBAKA,oBAKA,+BAKA,oBApBA,6BAKA,6BAKA,6BAKA,6BAKA,6B,eAqDmB,iBAUnB,KATA,cACA,4BAQA,sB,yIJmCJ,8B,mBAAA,sB,IAAA,mB,IAAA,kB,QAAA,sE,oBA4CI,YAA4C,OAAAx7B,OAASyK,G,sBAErD,WAA+B,YAAA9D,M,sBAE/B,WAAkC,YAAAq5B,U,oIIvKtC,6C,mBAAA,sB,IAAA,mB,IAAA,qB,IAAA,mB,IAAA,8B,IAAA,mB,QAAA,iF,0GA8EI,YACI,MAAY,oCAAmBM,GpKrBnC,GAAI,MoKsBe1X,EpKpBf,MAAM,GoKoBkB,qDpKpBejkB,YoKqBvC,OAAOikB,G,4BAIP,YACI,2BAAO2X,EAAWC,wB,4BAEtB,YAIoB,MAHhB,EAAU,IAAAC,GAGV,IAAgB,EAAAxB,EAAA,wBACZyB,GAAkBC,EADN,UAKhB,OAsJZ,YAII,IAAuB,IA0BD,EA5BtB,E7KpKoD,K6KsKpD,MAAmBA,EAAIC,OAAvB,2B,CAAA,IAmBkB,EACV,EApBR,WACI,EAA2B1D,GAAXyD,EAAIC,OAAiBxgC,EAAI,EAAJ,GAErC,OAAMwoB,EAAMiY,WAAZ,M,IACI,SACI,S,IAEJ,OACI,MAAAC,GAAyB,YAAI,GAAAlY,EAAA,IADjC,M,IAGA,O,IAAA,kBAEG,MAAAkY,GxJ9JJ,YwJ8JmB,c,+BxJ9JnB,UwJ8JmBlY,GxJ9JnB,CwJ8JIkY,GAFH,M,IAIA,a,gCAKJ,IAAc,EAAAlY,EAAMmY,aAAN,wB,CAAA,eACV,SAAAJ,EAAIK,cAAJ,UAAkB3E,KACR,qBAKlB,IAAsB,EAAA4E,EAAA,wB,CAAA,eAAhBC,EAAA,eAAQC,EAAA,eACVC,GAAoBT,EAAIK,cAAeG,EAAKD,IAtLxCG,CAAWV,GACJA,EAAI1f,S,kFAbnB,0CAkBJ,cACI,Y7KlBoD,K6KmBpD,yB5KrCwD,K4KsCxD,mB5KtCwD,K4K4ChC,uBACxB,yBACA,uBACA,qBACA,4BACA,8BAEA,oB7KjCoD,K6KkCpD,kB7KlCoD,K6KyDxD,iBAKI,IAAkB,IAMI,EAUoB,IAQA,IAwBA,IAYA,IAsBtB,EAAkB,EAOhB,EA7FtB,EAAUqb,EAAQhB,aAAa5yB,KAC3BoJ,EAAQ,EACRwvB,GAAa,EAEjB,EAAU,EAAV,EAAkBzvB,EAAlB,I,CACI,IAEIgvB,EACAE,EAHJ,EAAWzE,EAAQhB,aAAR,YAAqBl7B,GAO5B,IAFc,EAAZmhC,EAAK/F,OAAO70B,QAEd66B,EAAO76B,KACHk6B,EAAa,KACbE,EAAezqB,UAInB,OAAAmrB,EAAO96B,KACHk6B,EAAa,KACbE,EAAezB,GAAc,OAAC,aAAAiC,EAAKhJ,KAAL,YAAU,GAAV,YAAD,mBAIjC,OAAAmJ,EAAU/6B,MAAV,IACAg7B,EAAWh7B,KAEPk6B,EAAa,KACbE,EAAezB,GAAc,OAAC,aAAAiC,EAAKhJ,KAAL,YAAU,GAAV,YAAD,mBAEjC,OAAAqJ,EAASj7B,MAAT,IACAk7B,EAAUl7B,MADV,IAEAm7B,EAAUn7B,MAFV,IAGAo7B,EAAWp7B,MAHX,IAIAq7B,EAAUr7B,MAJV,IAKAs7B,EAAWt7B,MALX,IAMAu7B,EAASv7B,MANT,IAOAw7B,EAAUx7B,MAPV,IAQAy7B,EAAUz7B,MARV,IASA07B,EAAW17B,MATX,IAUA27B,EAAS37B,MAVT,IAWA47B,EAAU57B,MAXV,IAYA67B,EAAW77B,MAZX,IAaA87B,EAAY97B,MAbZ,IAcA+7B,EAAU/7B,MAdV,IAeAg8B,EAAWh8B,MAfX,IAgBAi8B,EAAWj8B,MAhBX,IAiBAk8B,EAAYl8B,MAjBZ,IAkBAm8B,EAAUn8B,MAlBV,IAmBAo8B,EAAWp8B,KAEPk6B,EAAa,KACbE,EAAezB,GAAc,OAAC,aAAAiC,EAAKhJ,KAAL,YAAU,GAAV,YAAD,mBAEjC,OAAAyK,EAAcr8B,K,CACVk6B,EAAa,KACoB,IvK6kD7B,EuK7kD6B,EAAR,GAAVU,EAAKhJ,KAAU,GvKq1CnC,EAAa,KAwPpB,IAAgB,4B,CAAA,IAhPK,EuK71CsC,MvK6kD3C,YAhPK,SuK71CqC,OAAC,evK6kD9BnjB,GuK7kD8B,aAAD,gBvK61CC,euK71C/C2rB,EvK81CLxrB,OuK11CC,OAAA0tB,EAAQt8B,MAAR,IACAu8B,EAAWv8B,KAEPk6B,EAAa,KACbE,EAAezB,GAAc,OAAC,aAAAiC,EAAKhJ,KAAL,YAAU,GAAV,YAAD,mBAEjC,OAAA4K,EAAex8B,K,CACXk6B,EAAa,KACoB,IvKikD7B,GuKjkD6B,GAAR,GAAVU,EAAKhJ,KAAU,GvKy0CnC,GAAa,KAwPpB,IAAgB,+B,CAAA,IAhPK,GuKj1CsC,MvKikD3C,aAhPK,UuKj1CqC,OAAC,evKikD9B,GuKjkD8B,aAAD,gBvKi1CC,iBuKj1C/CwI,EvKk1CL,O,CuK70CK,GAAI3gC,KAAKyR,EAAM,EAAN,GAML,SAJAgvB,EAAa,KACbE,EAAezqB,KAQ3B,OAAY,IAAA8sB,GAAe9G,EAASxqB,EAAO1R,EAAI,EAAJ,EAAOygC,EAAYE,GAE9C,EAANnY,GAAM9W,MAAkB,EAAN8W,GAAM3W,IAAlC,IAAK,IAAL,e,CACI,OAAA0uB,EAAI0C,oBAAJ,GAAwBza,GAAM0T,QAAQhB,aAAd,YAA2BjlB,I5KW3D,eAAI1U,G4KX6DinB,IAK7D,GAFA+X,EAAIC,OAAO,UAAIhY,IAEX0Y,E,CACA,IAAc,EAAAhF,EAAQpC,OAAR,wB,CAAA,gBACVyG,EAAIK,c5KIhB,Y4KJ8B3E,GAASzT,IAG/B0Y,GAAa,EAGjBxvB,EAAQ1R,EAAI,EAAJ,GAuChB,mBAYkB,MACV,EADJ,IAAc,EAAA8gC,EAAOH,aAAP,wB,CAAA,eACV,SAAAuC,EAAA,UAAYjH,MACG,EAAAwE,aAAP,KACO,oBAEP0C,G3KrPsC,K2KqPtC,OAMhB,mBAgBoB,MANhB,IAAaC,EAAT,eAAA5a,GAMJ,IAHI4a,EAAY,UAAI5a,GAGJ,EAAAA,EAAM1R,GAAN,wB,CAAA,eACRusB,EAAQ5C,aAAR,KACA4C,EAAQ,eAAOtC,GAEfoC,GAA2BC,EAAarC,EAAKsC,ICjTzB,iCACR,wCAAkC,EAAKjI,OAAOwE,SAA9C,iBAUQ,iCACR,gDAA0C,EAAKxE,OAAOwE,SAAtD,iBZ7BxB,mBzJ0BI,KyJtBoB,GAAZ0D,MAAe,KzJwBnB,MAAM,IyJvBN,kEzJuBuC/+B,YyJpB3C,MAAYg8B,EAAI,+BAAuBL,GAEvC,OAA6B,IAAtBqD,IAAsB,ahKyCqB,KgKvC9C/a,EACAA,EAAM,2BAAmB0X,GACzBoD,GAIR,cACI,kBAAyB,EAUL,cAAE,6BaV1B,cACI,kBAAyB,EAUL,cAAE,6BZ/BX,eA2OX,KA3O+B,mBAgN3B,oCACI,cAAqB,EACrB,iBAA8B,EAAAE,YAyBtC,sB,uFUlIA,WACI,WAAAC,GAAiB,KAAAjD,OAAQ,KAAAyC,sB,6HAI7B,4C,gDACA,0C,8CACA,wC,qDACA,+C,uDACA,iD,+DAEA,yC,6DACA,uC,wCAEA,YAGc,MAAY,EAFlBhuB,GAAS,EAEH,OAAAvD,MAAY,OAAAG,IAAtB,IAAK,IAAL,YACI,GAAI,GAAAquB,EAAe,KAAAhE,QAAQhB,aAAR,YAAqBl7B,I,CACpCiV,EAAQjV,EACR,MAIR,OAAOiV,G,4BAGX,YACkB,KAAA6B,GAAV,eAAAzM,KACA,KAAAyM,GAAG,UAAIzM,GACPA,EAAM2T,KAAK,UAAIpe,Q,8FXjHvB,kBAYmC,MAIF,EAe+B,EAUxB,EAuFf,EAQI,EAYC,EACA,EAA4B,EAgBpB,EAgBrB,EA9Kb,GAAI,0DAAe,IAEf,OADA,GAAO,aAAK,IACL,KAAS8jC,MAGW,EAANlb,EAAM9W,MAA/B,IAAK,IAAL,EAAUG,EAAM,EAAN,EAAV,S,CACI,MAAkB2W,EAAM0T,QAAQhB,aAAd,YAA2Bl7B,GAC7C,EAAWkgC,EAAY/H,KAGnB,IADqB,EAAnB+H,EAAY9E,OAAO70B,QACrBo9B,EAAQp9B,KAIJ,OAAO,KAASm9B,MAGpB,OAAAZ,EAAWv8B,K,CACP,MAAY,cAAOq9B,EAAMpb,EAAOxoB,EAAGsjC,GACnC,GAAIriC,EAAM4iC,aAAc,OAAO5iC,OAGnC,OAAA6iC,EAAOv9B,MACH,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,kBAAK,GAAcM,GAAOpb,EAAOxoB,GAAI,WAAAm4B,EAAA,YAAK,GAAL,YAAmBl3B,YAIvE,OAAA8iC,EAAQx9B,MAAR,IACAy9B,EAAQz9B,MADR,IAEA09B,EAAQ19B,MAFR,IAGA29B,GAAa39B,MAET,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,KAAS,YAAI,WAAAnL,EAAA,YAAK,GAAL,YAAmBl3B,YAI/C,OAAAkjC,EAAO59B,MACH,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,KAAS,WAAG,QAI3B,OAAAc,EAAS79B,MACL,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,KAAS,WAAG,QAI3B,OAAAe,EAAO99B,MACH,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,G,CACjB,MAAe,kBAAK,GAAcM,GAAOpb,EAAOxoB,EAAGsjC,GAEnD,OAAW,GAAAgB,EAASh8B,KAAT,KAAsC,IAAfg8B,EAAA,YAAS,GACvC,KAAS,WAAG,GACAA,EAAL,oBACP,KAAS,mBAAW,EAAG,GAEvB,KAAS,WAAG,SAKxB,OAAAC,EAAQh+B,MACJ,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,G,CACjB,IACa,EADb,EAAe,kBAAK,GAAcM,GAAOpb,EAAOxoB,EAAGsjC,GAEnD,OADA,sBAAa,WAAAnL,EAAA,YAAK,GAAL,YAAmBl3B,OACzB,QAIf,OAAAujC,EAAQj+B,MACJ,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,G,CACjB,IACa,EADb,EAAe,kBAAK,GAAcM,GAAOpb,EAAOxoB,EAAGsjC,GAEnD,OADA,uBAAa,WAAAnL,EAAA,YAAK,GAAL,YAAmBl3B,OACzB,QAIf,OAAAwjC,EAAQl+B,MACJ,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,G,CACjB,IACa,EADb,EAAe,kBAAK,GAAcM,GAAOpb,EAAOxoB,EAAGsjC,GAEnD,OADA,uBAAa,WAAAnL,EAAA,YAAK,GAAL,YAAmBl3B,OACzB,QAIf,OAAAyjC,EAAQn+B,MACJ,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,G,CACjB,IACa,EADb,EAAe,kBAAK,GAAcM,GAAOpb,EAAOxoB,EAAGsjC,GAEnD,OADA,qBAAa,WAAAnL,EAAA,YAAK,GAAL,YAAmBl3B,OACzB,QAIf,OAAA0jC,GAAiBp+B,MACb,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,KAAS,mBAAW,EAAG,QAItC,OAAAsB,GAAer+B,MACX,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,KAAS,mBAAW,EAAG,QAItC,OAAAuB,GAAkBt+B,MACd,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,GACjB,OAAO,KAAS,mBAAW,EAAG,QAItC,OAAAwB,GAAcv+B,MACV,GAAI,GAAA4xB,EAAA,YAAK,GAAGl3B,MAASqiC,G,CAEjB,MAAU,qBACN,GAAcM,GACdpb,EACAxoB,GACC,WAAAm4B,EAAA,YAAK,GAAL,YAAmBl3B,OACtBuiC,aAEQ,EACN,qBACI,GAAcI,GACdpb,EACAxoB,GACC,WAAAm4B,EAAA,YAAK,GAAL,YAAmBl3B,MAAQ,EAA5B,GACF8jC,aANI,EAONx8B,EAAM,EAAN,EAPJ,ElHq2B4B,GAAWwD,IAAI/I,EAAGC,GkH31B9C,OAAO,KAAS,mBAAWsF,EAAKwD,EAAM,EAAN,SAIxC,OAAAi5B,EAAez+B,MAAf,IACA0+B,EAAc1+B,K,CAEV,OAAc,WAAA4xB,EAAA,YAAK,GAAL,YAAmBl3B,MACjC,GAAc,WAAAk3B,EAAA,YAAK,GAAL,YAAmBl3B,OAAS,WAAAk3B,EAAA,YAAK,GAAL,YAAmBl3B,MAAhD,EAEb,GAAgBikC,GAAZ5B,KAAyB6B,EACzB,OAAO,KAASzB,WASpB,IAHA,MAAaxD,EAAY9E,OAAO2B,OACnB,EAAI5E,EAAK7vB,KAAT,EAAey0B,EAAOz0B,KAAnC,ElHk0BgC,GAAWC,IAAI,EAAG,GkHh0BlD,GAAU,EAAV,GAAkB68B,EAAlB,K,CACI,OAAYrI,EAAA,YAAO9mB,IAEnB,GAAI,SAAA+mB,GAAMxoB,KAAN,KAAyB,MAAAwoB,GAAMxoB,KAAK6wB,UAGpC,IAFA,QAAc,WAAAlN,EAAA,YAAKliB,IAAL,YAAmBhV,MAEjC,QAAsB+7B,GAAMxoB,KAAK6wB,UAAjC,6BACI,GADJ,UACiBrkB,QAASskB,GAAS1zB,GAAT,KAAc0xB,EAChC,OAAO,KAASI,OAS5C,OAAa,KAAS6B,QAGtB,IAFA3B,EAAK,UAAIpb,GAEI,EAAAA,EAAMxK,KAAN,wB,CAAA,gBAET,GAAY4lB,EAAR,eAAA5lB,IACA,OAAO,KAAS0lB,MAGpBjc,GAAO,cAAM,kBAAK,GAAcmc,GAAO5lB,GAAMA,GAAKnM,IAAKyxB,IAM3D,OAAI7b,GAAO1R,UACA,KAAS2tB,MAGbjc,I,sBAGX,kBA0BoB,IAOK,EAaW,EAIH,EAE6B,EAKlC,EAXjB,EAzBP,KAAiB,GAAb6b,MAAgB,GAAG,OAAO,KAASiC,QAKvC,IAHA,IAAIC,GAAc,EAClB,ElKnKgD,KkKqKhD,EAAUhd,EAAM9W,MAAhB,EAA4B+zB,EAA5B,I,CACI,MAAkBjd,EAAM0T,QAAQhB,aAAd,YAA2Bl7B,GAC7C,EAAakgC,EAAY9E,OAErBA,EAAO70B,OAAQm/B,EAAYn/B,KAC3Bi/B,EAAaxlC,GACS,IAAfwlC,KACM,EAAPpK,EAAO70B,QACT43B,EAAa53B,MAAb,IACA83B,EAAa93B,MADb,IAEA23B,EAAa33B,MAFb,IAGA63B,EAAa73B,MAHb,IAIAo/B,GAAap/B,MAJb,IAKAq/B,GAAar/B,MALb,IAMA+3B,GAAa/3B,MACV0sB,EAAM,UAAIiN,IAKlB,GAAyB,EAANjN,EAAM3qB,KAAT,GAAZg7B,MAAA,E,CACP,MAAkBrQ,EAAA,YAAMqQ,EAAW,EAAX,GACxB,EAA2BvsB,GAAjB,EAAYohB,MAId,GAFiB,EAAnB,EAAYiD,OAAO70B,QACrB43B,EAAa53B,KACT,kBAAK,GAAcq9B,GAAOpb,EAAOgd,GAAa,WAAAzH,EAAA,YAAe98B,OAEjE,IAAAo9B,EAAa93B,MAAb,IACA23B,EAAa33B,MADb,IAEA63B,EAAa73B,KACV,KAAS,YAAI,WAAAw3B,EAAA,YAAe98B,OAGvB,KAASyiC,WAGZ,EAAT,KAAS,WAAG,GAjBhB,OAAO,G,iGarPX,oBAcmC,MAUF,EAkDhB,EAnEb,GAAI,0DAAe,IAEf,OADA,GAAO,aAAK,IACL,IAAA9T,GAAK,KAAS8T,MAAO,MAGhC,IAAImC,EAAM52B,EAEqB,EAANuZ,EAAM9W,MAA/B,IAAK,IAAL,EAAUG,EAAM,EAAN,EAAV,S,CACI,MAAkB2W,EAAM0T,QAAQhB,aAAd,YAA2Bl7B,GAE7C,GAAI,GAAAkgC,EAAY9E,OAAOnI,MAAnB,MACA4S,IAAO3F,EAAY9E,OAAO2B,OAAOz0B,KAAjC,MADJ,CAKA,MAAW43B,EAAY/H,KAGnB,IADqB,EAAnB+H,EAAY9E,OAAO70B,QACrB43B,EAAa53B,KACT,IAAW,IAAPs/B,E,CACA,MAAU1N,EAAA,YAAK,GAEf,OAAW,SAAA4F,EAAA,IACP,IAAAnO,GAAKkW,GAAiBvF,EAAKL,EAAanC,EAAI98B,OAAQi/B,GAEpD,IAAAtQ,GAAK,KAAS8T,MAAOxD,GAGzB2F,IAAA,SAIR,OAAAxH,EAAa93B,MAAb,IACA23B,EAAa33B,MADb,IAEA63B,EAAa73B,KAET,IAAW,IAAPs/B,E,CACA,MAAU1N,EAAA,YAAK,GAEf,OAAW,eACP,IAAAvI,GAAK,KAAS,WAAG,EAAI3uB,OAAQi/B,GAE7B,IAAAtQ,GAAK,KAAS8T,MAAOxD,GAGzB2F,IAAA,SAIR,OAAAF,GAAap/B,MAAb,IACAq/B,GAAar/B,MADb,IAEA+3B,GAAa/3B,KAET,IAAW,IAAPs/B,EACA,OAAO,IAAAjW,GAAK,KAAS8T,MAAOxD,GAE5B2F,IAAA,MAMhB,MAAa,KAASN,QAClB,EAA4B,KAC5BQ,GAAuB,EAG3B,IAFAnC,EAAK,UAAIpb,GAEI,EAAAA,EAAMxK,KAAN,wB,CAAA,eAET,GAAY4lB,EAAR,eAAA5lB,GACA,OAAO,IAAA4R,GAAK,KAAS8T,MAAO,M,MAGI,kBAAK,GAAcE,GAAOrD,EAAKviB,EAAMA,EAAKnM,IAAKg0B,GAA9EG,EAAA,eAAYC,EAAA,eACjBxe,EAAO,cAAMue,GAERD,IACG,QACA,EAAcE,EACP,KAAeA,KACtB,EAAc,KACdF,GAAuB,IAKnC,OAAO,IAAAnW,GAAKnI,EAAQ,I,mIZlHpB,WAAkB,I7J+sDN,E6J/sDM,EAAV,iB7J8sDRyC,EAAc,GAClB,IAAgB,4B,CAAA,eAAMA,EAAwBA,E6J/sDH,mB7J+sDgBlV,E6J/sDRnD,MAAR,wB7J+sDgBmD,E6J/sDAtD,QAAhB,QAA/B,O7JgtDLwY,K,yB6J9sDP,YAGyB,MAFjBgc,EAAMlmC,EAEV,IAAqB,2C,CAAA,eAAf0R,EAAA,eACF,EADS,eACQA,EAAQ,EAAd,EAEX,GAAIw0B,EAAM59B,EACN,OAAOoJ,EAAQw0B,EAAR,EAEPA,IAAO59B,EAAP,EAIR,OAAO,M,qBAGX,WACI,wBAAUyN,W,wBAEd,WACI,wBnKmMqDA,W,uBmKjMzD,WACc,MAAV,cAAU,EAAAowB,GAAV,iC,uBAEJ,WACc,MAAV,cAAU,EAAAC,GAAV,+B,8BAEJ,YACgB,MAAZ,IAAY,2CACR,GADQ,SACJ,iBAAAnlC,GACA,OAAO,EAIf,OAAO,G,8BAGX,YAMI,OAFA,iBAAU8c,QACV,iBAAU,UAAI,IAAAsoB,GAASplC,EAAOA,IACvBrB,M,iCAGX,c1JxBA,K0J+BYiS,GAAOH,G1J7Bf,MAAM,I0J8BF,4F1J9BmCnN,Y0JmCvC,OAFA,iBAAUwZ,QACV,iBAAU,UAAI,IAAAsoB,GAAS30B,EAAOG,IACvBjS,M,gCAGX,YAkB8B,MAgCiB,EA9C3C,GAAI0mC,GAAU,EAIV,IAHA,IAAItmC,EAAI,EACJumC,EAAO,EAEJvmC,EAAI,iBAAUsI,M,CACjB,MAAU,6BAAUtI,GACpB,EAAe8rB,EAAIpa,MACnB,EAAaoa,EAAIja,IAIjB,GAHAia,EAAIpa,MAAJoa,EAAIpa,MAAS40B,EAAb,EACAxa,EAAIja,IAAJia,EAAIja,IAAOy0B,EAAX,EAEIxa,EAAIpa,MAAQ80B,EAEZ,iBAAU,iBAASxmC,GACnB,iBAAU,aAAIumC,GAAA,EAAAA,GAAA,IAAJ,GAAYza,QACnB,GAAIA,EAAIja,IAAM40B,E,CAEjB,MAAa3a,EAAIja,IACjBia,EAAIja,IAAM,YAEN60B,EAAS,EAAT,KAAwB3vB,GAAV,kBAAkBrF,MACtBqF,GAAV,yBAA0B,YAE1B,iBAAU,YAAI,EAAG,IAAAsvB,IAAS,WAAeK,IACzCH,IAAA,IAEAvmC,IAAA,KAIRA,IAAA,SAMJ,IAHA,IAAI,EAAc,GAAV,kBACJ,EAAO,EAEJ,GAAK,G,CACR,MAAU,6BAAU,GACpB,EAAe,EAAI0R,MACnB,EAAa,EAAIG,IAIjB,GAHA,UAAIH,MAAS40B,EAAb,EACA,QAAIz0B,IAAOy0B,EAAX,EAEI,EAAIz0B,IAAM,EAEV,iBAAU,iBAAS,GACnB,iBAAU,YAAI,iBAAUvJ,MAAO,YAAjB,KAAyB,QACpC,GAAI,EAAIoJ,MAAQ,E,CAEnB,MAAe,EAAIA,MACnB,SAAY,YAERi1B,EAAW,EAAX,KAA0B9wB,GAAV,kBAAiBhE,IACvBgE,GAAV,sBAAuB,YAEvB,iBAAU,UAAI,IAAAwwB,GAASM,EAAU,aACjC,SAIR,U,iCAKZ,YAII,wBAAW,GAACL,I,iCAGhB,YAIgB,MAAZ,IAAY,2C,CAAA,IAAAxa,EAAA,SACRA,EAAIpa,MAAJ,OAAAoa,EAAIpa,MAAS3P,GACb+pB,EAAIja,IAAJ,OAAAia,EAAIja,IAAO9P,K,+BAInB,YAIgB,MAAZ,IAAY,2C,CAAA,IAAA+pB,EAAA,SACRA,EAAIpa,MAAJoa,EAAIpa,MAAS3P,EAAb,EACA+pB,EAAIja,IAAJia,EAAIja,IAAO9P,EAAX,I,2BAIR,YAGqB,MAFb/B,EAAI,EAES,EAAAqK,EAAM,YAAN,W,EAAV,KAAU,a,CACb,IADa,eACNrK,EAAI,iBAAUsI,M,CACjB,MAAQ,6BAAUtI,GAElB,GAAIiD,EAAE4O,IAAM,eAAA7O,EAAE0O,OAAF,aAAR,W,CAEA,iBAAU,YAAI1R,EAAGiD,EAAE,gBACnBjD,IAAA,IACA,WACG,GAAIiD,EAAEyO,OAAS,eAAA1O,EAAE6O,KAAF,QAAX,W,CAEG,MAAI7O,EAAE0O,MAAN,EAAazO,EAAEyO,MAAzB1O,EAAE0O,MnHs0B8B,GAAWnJ,IAAI,EAAG,GmHj0BlD,IAFA,MAAQvI,EAAI,EAAJ,EAEDiW,EAAI,iBAAU3N,MACbrF,EAAE4O,KAAO,4CAAUoE,GAAGvE,OAAb,aAAT,YACA1O,EAAE6O,IAAM,6BAAUoE,GAAGpE,IACrB,iBAAU,iBAASoE,GAMnB,MAAIjT,EAAE6O,IAAN,EAAW5O,EAAE4O,IAArB7O,EAAE6O,InH+zB8B,GAAW9F,IAAI,EAAG,GmH9zBlD/L,IAAA,IACA,WAGAA,IAAA,IAKR,iBAAU,UAAIiD,EAAE,gBAGpB,OAAOrD,M,qBAQH,WACI,+B,kBAEJ,WACY,MAGJ,EAHI,8BAAa,MAAM,KAA3B,IAAA8Z,EAAQ,EAeR,OAZQA,EAAI,2CAAU,eAAQ7H,IACtB,EAAA6H,EAAI,EAAJ,GAEA,gCAGsB,EADlB,cAAS,+BAAUpR,KACnB,2CAAU,eAAQoJ,MAElB,MATZ,mBAaOgI,G,8DAxBnB,WACI,qB,mBA4BA,WAGwB,WAAAktB,GnK5JwB,O,iBmK8JhD,WAGsB,gCAAW,WAAe,a,wBAEhD,YAG+B,WAAAA,GAASzK,GAAc,KAAAkK,GAASplC,EAAOA,O,gCAEtE,cAII,WAAA2lC,GAASzK,GAAc,KAAAkK,GAAS30B,EAAOG,O,+fApB/C,0CA2BuB,iBAAC,aAAgB,Wa1QlC,qBACN,UACA,YACA,aACA,oBAGa,iBACb,UACA,YA+EJ,qBAII,IAHA,MhLFoD,KgLGpD,EAAW,IAAAg1B,GAAKC,EAAIvmC,EAAMwmC,EAAOC,GAEjC,EAAa,EAAb,EAAqBC,EAArB,IACID,EAAI,UAAI,IAAAE,GAAYC,EAAMC,IAG9B,OAAOA,EC/FK,mBACZ,YACA,cACA,YAGJ,0FACI,mBACA,mBAEA,qBAHA,6BACA,6BAEA,6B,eCHc,uCA47CiB,WA17C/B,UAAkCC,QAClC,UAA2BhmB,QAC3B,UAAwB,WACxB,WAAqB,QACrB,IAAAimB,MAA6B,WAK7B,UAGmB,WACnB,UAGiB,WACjB,UAKwB,WACxB,UAG4CpxB,MA5BhD,cACI,4BACA,4BACA,oBACA,eACA,aAEA,eAIA,cAIA,YAIA,eAMA,4BAzBJ,6BAy7CI,wBAG0BqxB,IAAK,eAAE,2BA57CrC,8BAkCI,sBACiB,eADjB,8BlLqCsCrxB,MkL5BtC,wBACiB,kBADjB,8BAEcC,GAAO,GACR,EACF,GACG,EACGqxB,IAEjB,0BACiB,oBADjB,8BAEcrxB,GAAO,GACR,EACF,GACG,EACGqxB,IAEjB,yBACiB,mBADjB,8BAEcrxB,GAAO,GACR,EACF,GACG,EACGqxB,IAEjB,wBACiB,kBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,sBACiB,gBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,wBACiB,kBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,sBACiB,gBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,0BACiB,oBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,yBACiB,mBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,yBACiB,iBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,sBACiB,cADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,yBACiB,kBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,yBACiB,iBADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,qBACiB,aADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,qBACiB,aADjB,8BAEcrxB,GAAO,GACR,GACF,GACG,EACGqxB,IAEjB,wBACiB,iBADjB,8BAEcrxB,GAAO,GACR,IACF,GACG,EACGqxB,IAEjB,sBACiB,iBACA,aAFjB,qBAIcrxB,GAAO,GACR,IACF,GACG,EACGqxB,IASjB,yBACiB,iBADjB,EAEmB,UAFnB,MAIY,EACG,GACD,IAAO,EAAG,IACX,GACF,GACG,GAEd,yBACiB,iBADjB,EAEmB,YAFnB,MAIY,OAJZ,EAKc,IAAO,EAAG,IACX,GACF,GACG,GAEd,wBACiB,iBADjB,EAEmB,WAFnB,MAIY,EACG,GACD,IAAO,EAAG,IACX,GACF,GACG,GAEd,uBACiB,gBADjB,EAEmB,YAFnB,MAIY,OAJZ,EAKc,IAAO,EAAG,IACX,GACF,GACG,GAEd,sBACiB,cADjB,EAEmB,WAFnB,MAIY,OAJZ,EAKc,IAAO,EAAG,IACX,GACF,GACG,EACG,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M,EACI,qD,6BAEA,K,UALR,E,yIAQA,K,0IA/rDF,K,uKA8uDE,U,uGACY,wBAAS,yBACjB,kBAAQ,uB,OACR,K,UACI,S,EACA,KALR,gD,iEAQA,iB,kFApuDU,mF,MAAV,c,8HAiyDA,cAAI,YAjyDmB,sB,+CAiyDJ,U,4HAqBL,qF,oEAAA,U,wJAEE,kB,6BAAT,EAAS,mC,UAAA,uB,4EAAhB,gB,uKAyBc,S,uIAAd,K,YAEqB,a,GACrB,iD,8FAAgB,E,EAAT,SAAS,kE,wBAAA,gC,wBAAhB,e,gJAMR,8B,8FA11DQ,gD,iDAAU,S,IAAA,Y,eAAA,e,0UAAA,gDAAV,kB,wCAAU,W,0BAAA,I,EAAA,E,aAAV,O,oWAAU,a,0GAAA,oB,+DAu6DN,O,2DAGO,U,yQCjhEP,E,qdAER,E,yCAPyB,qB,UAAA,a,EAAA,kE,yBAAA,E,gBAFuD,uB,KAAA,mD,cAAA,e,+NAEpE,gB,WAqDR,+B,wJACF,a,qRADE,kB,0OAEE,yBAAe,OAAf,qC,qgBXqIuC,sB,OAAA,qC,OAAA,0B,oYAAc,K,iBAAhB,qC,UAAA,oB,OAAA,e,yCAAA,+B,iBADzB,qD,OAAA,+GAKuC,E,0FAD7D,0DACsD,4CAEtD,sC,OAAA,0BCnLA,c,MAAA,E,WAAA,M,yGAQsB,yBAAV,GAAU,iC,kBAAA,c,0UDwLE,a,WAAA,K,WAAA,kB,2BAAA,kD,sBAAsB,qB,yPAAf,kD,YAAA,I,2FAAL,qB,8GAAF,c,2FAJR,6D,kBAAA,c,KAAA,kF,KAAA,E,2WAAA,iC,0CAAA,kC,oGAThB,SAQI,S,KACA,E,4DAQJ,uE,YnNzRA,iB,MmNqSmC,qC,gMYtRnC,oCARA,gB,EAAA,a,kGC+BA,sE,iCCnCY,mB,OFYZ,E,mCCuBA,iC,mBAAA,E,WAoB8C,KCvDlC,a,MAAA,a,6mBALZ,kB,QAAA,QAUA,OAVA,uC,EAAA,E,EAAA,E,sBAKY,e,WAER,oBAPJ,wBAUA,SjB6DA,O,4UAD0C,0B,wFcuDlC,sH,2KACF,gB,IACI,EAAe,gB,gFAHrB,kB,6BdtDA,cAAW,+C,kKAjBf,UAkBA,E,2BAlBA,E,qDAkBA,G,iBAQiB,E,WAAA,e,WAAA,I,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","file":"assembly-worker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assembly-worker\"] = factory();\n\telse\n\t\troot[\"assembly-worker\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}",null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\n@file:OptIn(ExperimentalUnsignedTypes::class)\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = @OptIn(ExperimentalStdlibApi::class) buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence from the second time.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n/** Returns true when it's safe to convert this collection to a set without changing contains method behavior. */\nprivate fun <T> Collection<T>.safeToConvertToSet() = size > 2 && this is ArrayList\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperationWith(source: Iterable<T>): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection ->\n            when {\n                source is Collection && source.size < 2 -> this\n                else -> if (this.safeToConvertToSet()) toHashSet() else this\n            }\n        else -> toHashSet()\n    }\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperation(): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection -> if (this.safeToConvertToSet()) toHashSet() else this\n        else -> toHashSet()\n    }\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement = last.toInt()\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first.toInt() else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toInt()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start.toLong(), endInclusive.toLong(), step).toLong()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\npublic inline class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @JsName(\"toJSON\")\n    open fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    // TODO: should we implement them this way? Currently it's unspecified in JVM\n                    override fun equals(other: Any?): Boolean {\n                        if (this === other) return true\n                        if (other !is Collection<*>) return false\n                        return AbstractList.orderedEquals(this, other)\n                    }\n\n                    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual constructor(initialCapacity: Int = 0) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n    override fun toArray(): Array<Any?> = js(\"[]\").slice.call(array)\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    protected open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * An interface for indexing access to a collection of key-value pairs, where type of key is [String] and type of value is [Any?][Any].\n */\npublic external interface Json {\n    /**\n     * Calls to the function will be translated to indexing operation (square brackets) on the receiver with [propertyName] as the argument.\n     *\n     * E.g. for next code:\n     * ```kotlin\n     * fun test(j: Json, p: String) = j[\"prop\"] + j.get(p)\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p) {\n     *     return j[\"prop\"] + j[p];\n     * }\n     * ```\n     */\n    operator fun get(propertyName: String): Any?\n\n    /**\n     * Calls of the function will be translated to an assignment of [value] to the receiver indexed (with square brackets/index operation) with [propertyName].\n     *\n     * E.g. for the following code:\n     * ```kotlin\n     * fun test(j: Json, p: String, newValue: Any) {\n     *     j[\"prop\"] = 1\n     *     j.set(p, newValue)\n     * }\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p, newValue) {\n     *     j[\"prop\"] = 1;\n     *     j[p] = newValue;\n     * }\n     * }\n     * ```\n     */\n    operator fun set(propertyName: String, value: Any?): Unit\n}\n\n/**\n * Returns a simple JavaScript object (as [Json]) using provided key-value pairs as names and values of its properties.\n */\npublic fun json(vararg pairs: Pair<String, Any?>): Json {\n    val res: dynamic = js(\"({})\")\n    for ((name, value) in pairs) {\n        res[name] = value\n    }\n    return res\n}\n\n/**\n * Adds key-value pairs from [other] to [this].\n * Returns the original receiver.\n */\npublic fun Json.add(other: Json): Json {\n    val keys: Array<String> = js(\"Object\").keys(other)\n    for (key in keys) {\n        if (other.asDynamic().hasOwnProperty(key)) {\n            this[key] = other[key];\n        }\n    }\n    return this\n}\n\n/**\n * Exposes the JavaScript [JSON object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external object JSON {\n    public fun stringify(o: Any?): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: Int): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: String): String\n    public fun stringify(o: Any?, replacer: Array<String>): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: Int): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: String): String\n\n    public fun <T> parse(text: String): T\n    public fun <T> parse(text: String, reviver: ((key: String, value: Any?) -> Any?)): T\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"DEPRECATION_ERROR\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = kotlin.js.Math.clz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal class KTypeImpl(\n    override val classifier: KClassifier,\n    override val arguments: List<KTypeProjection>,\n    override val isMarkedNullable: Boolean\n) : KType {\n    override fun equals(other: Any?): Boolean =\n        other is KTypeImpl &&\n                classifier == other.classifier && arguments == other.arguments && isMarkedNullable == other.isMarkedNullable\n\n    override fun hashCode(): Int =\n        (classifier.hashCode() * 31 + arguments.hashCode()) * 31 + isMarkedNullable.hashCode()\n\n    override fun toString(): String {\n        val kClass = (classifier as? KClass<*>)\n        val classifierName = when {\n            kClass == null -> classifier.toString()\n            kClass.simpleName != null -> kClass.simpleName\n            else -> \"(non-denotable type)\"\n        }\n\n        val args =\n            if (arguments.isEmpty()) \"\"\n            else arguments.joinToString(\", \", \"<\", \">\") { it.asString() }\n        val nullable = if (isMarkedNullable) \"?\" else \"\"\n\n        return classifierName + args + nullable\n    }\n\n    // TODO: this should be the implementation of KTypeProjection.toString, see KT-30071\n    private fun KTypeProjection.asString(): String {\n        if (variance == null) return \"*\"\n        return variance.prefixString() + type.toString()\n    }\n}\n\ninternal object DynamicKType : KType {\n    override val classifier: KClassifier? = null\n    override val arguments: List<KTypeProjection> = emptyList()\n    override val isMarkedNullable: Boolean = false\n    override fun toString(): String = \"dynamic\"\n}\n\ninternal fun KVariance.prefixString() =\n    when (this) {\n        KVariance.INVARIANT -> \"\"\n        KVariance.IN -> \"in \"\n        KVariance.OUT -> \"out \"\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [RegExp object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external class RegExp(pattern: String, flags: String? = definedExternally) {\n\n    public fun test(str: String): Boolean\n\n    public fun exec(str: String): RegExpMatch?\n\n    public override fun toString(): String\n\n    /**\n     * The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.\n     */\n    public var lastIndex: Int\n\n    public val global: Boolean\n    public val ignoreCase: Boolean\n    public val multiline: Boolean\n}\n\n/**\n * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the beginning of the input string.\n */\npublic fun RegExp.reset() {\n    lastIndex = 0\n}\n\n// TODO: Inherit from array or introduce asArray() extension\n/**\n * Represents the return value of [RegExp.exec].\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external interface RegExpMatch {\n    public val index: Int\n    public val input: String\n    public val length: Int\n}\n\n/**\n * Returns the entire text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis\n * at the given index.\n */\npublic inline operator fun RegExpMatch.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Converts the result of [RegExp.exec] to an array where the first element contains the entire matched text and each subsequent\n * element is the text matched by each capturing parenthesis.\n */\npublic inline fun RegExpMatch.asArray(): Array<out String?> = unsafeCast<Array<out String?>>()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n// actually \\s is enough to match all whitespace, but \\xA0 added because of different regexp behavior of Rhino used in Selenium tests\npublic actual fun Char.isWhitespace(): Boolean = toString().matches(\"[\\\\s\\\\xA0]\")\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = toString().asDynamic().toLowerCase().charCodeAt(0).unsafeCast<Int>().toChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase() as String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase() as String\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Provides enumeration values to use to set regular expression options.\n */\npublic actual enum class RegexOption(val value: String) {\n    /** Enables case-insensitive matching. */\n    IGNORE_CASE(\"i\"),\n    /** Enables multiline mode.\n     *\n     * In multiline mode the expressions `^` and `$` match just after or just before,\n     * respectively, a line terminator or the end of the input sequence. */\n    MULTILINE(\"m\")\n}\n\n\n/**\n * Represents the results from a single capturing group within a [MatchResult] of [Regex].\n *\n * @param value The value of captured group.\n */\npublic actual data class MatchGroup(actual val value: String)\n\n\n/**\n * Represents a compiled regular expression.\n * Provides functions to match strings in text with a pattern, replace the found occurrences and split text around matches.\n *\n * For pattern syntax reference see [MDN RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions)\n * and [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](https://www.w3schools.com/jsref/jsref_obj_regexp.asp).\n *\n * @constructor Creates a regular expression from the specified [pattern] string and the specified set of [options].\n */\npublic actual class Regex actual constructor(pattern: String, options: Set<RegexOption>) {\n\n    /** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n    public actual constructor(pattern: String, option: RegexOption) : this(pattern, setOf(option))\n\n    /** Creates a regular expression from the specified [pattern] string and the default options.  */\n    public actual constructor(pattern: String) : this(pattern, emptySet())\n\n\n    /** The pattern string of this regular expression. */\n    public actual val pattern: String = pattern\n    /** The set of options that were used to create this regular expression. */\n    public actual val options: Set<RegexOption> = options.toSet()\n    private val nativePattern: RegExp = RegExp(pattern, options.map { it.value }.joinToString(separator = \"\") + \"g\")\n\n    /** Indicates whether the regular expression matches the entire [input]. */\n    public actual infix fun matches(input: CharSequence): Boolean {\n        nativePattern.reset()\n        val match = nativePattern.exec(input.toString())\n        return match != null && match.index == 0 && nativePattern.lastIndex == input.length\n    }\n\n    /** Indicates whether the regular expression can find at least one match in the specified [input]. */\n    public actual fun containsMatchIn(input: CharSequence): Boolean {\n        nativePattern.reset()\n        return nativePattern.test(input.toString())\n    }\n\n    /** Returns the first match of a regular expression in the [input], beginning at the specified [startIndex].\n     *\n     * @param startIndex An index to start search with, by default 0. Must be not less than zero and not greater than `input.length()`\n     * @return An instance of [MatchResult] if match was found or `null` otherwise.\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun find(input: CharSequence, startIndex: Int = 0): MatchResult? {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return nativePattern.findNext(input.toString(), startIndex)\n    }\n\n    /**\n     * Returns a sequence of all occurrences of a regular expression within the [input] string, beginning at the specified [startIndex].\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     *\n     * @sample samples.text.Regexps.findAll\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence<MatchResult> {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return generateSequence({ find(input, startIndex) }, { match -> match.next() })\n    }\n\n    /**\n     * Attempts to match the entire [input] CharSequence against the pattern.\n     *\n     * @return An instance of [MatchResult] if the entire input matches or `null` otherwise.\n     */\n    public actual fun matchEntire(input: CharSequence): MatchResult? {\n        if (pattern.startsWith('^') && pattern.endsWith('$'))\n            return find(input)\n        else\n            return Regex(\"^${pattern.trimStart('^').trimEnd('$')}$\", options).find(input)\n    }\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replace(input: CharSequence, replacement: String): String = input.toString().nativeReplace(nativePattern, replacement)\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with the result of\n     * the given function [transform] that takes [MatchResult] and returns a string to be used as a\n     * replacement for that match.\n     */\n    public actual inline fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String {\n        var match = find(input)\n        if (match == null) return input.toString()\n\n        var lastStart = 0\n        val length = input.length\n        val sb = StringBuilder(length)\n        do {\n            val foundMatch = match!!\n            sb.append(input, lastStart, foundMatch.range.start)\n            sb.append(transform(foundMatch))\n            lastStart = foundMatch.range.endInclusive + 1\n            match = foundMatch.next()\n        } while (lastStart < length && match != null)\n\n        if (lastStart < length) {\n            sb.append(input, lastStart, length)\n        }\n\n        return sb.toString()\n    }\n\n    /**\n     * Replaces the first occurrence of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replaceFirst(input: CharSequence, replacement: String): String {\n        val nonGlobalOptions = options.map { it.value }.joinToString(separator = \"\")\n        return input.toString().nativeReplace(RegExp(pattern, nonGlobalOptions), replacement)\n    }\n\n    /**\n     * Splits the [input] CharSequence around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun split(input: CharSequence, limit: Int = 0): List<String> {\n        require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n        val matches = findAll(input).let { if (limit == 0) it else it.take(limit - 1) }\n        val result = mutableListOf<String>()\n        var lastStart = 0\n\n        for (match in matches) {\n            result.add(input.subSequence(lastStart, match.range.start).toString())\n            lastStart = match.range.endInclusive + 1\n        }\n        result.add(input.subSequence(lastStart, input.length).toString())\n        return result\n    }\n\n\n    /**\n     * Returns the string representation of this regular expression, namely the [pattern] of this regular expression.\n     *\n     * Note that another regular expression constructed from the same pattern string may have different [options]\n     * and may match strings differently.\n     */\n    public override fun toString(): String = nativePattern.toString()\n\n    actual companion object {\n        /**\n         * Returns a regular expression that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun fromLiteral(literal: String): Regex = Regex(escape(literal))\n\n        /**\n         * Returns a regular expression pattern string that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun escape(literal: String): String = literal.nativeReplace(patternEscape, \"\\\\$&\")\n\n        /**\n         * Returns a literal replacement expression for the specified [literal] string.\n         * No characters of that string will have special meaning when it is used as a replacement string in [Regex.replace] function.\n         */\n        public actual fun escapeReplacement(literal: String): String = literal.nativeReplace(replacementEscape, \"$$$$\")\n\n        private val patternEscape = RegExp(\"\"\"[-\\\\^$*+?.()|[\\]{}]\"\"\", \"g\")\n        private val replacementEscape = RegExp(\"\"\"\\$\"\"\", \"g\")\n    }\n}\n\n/** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_sb3q2\\$\")\npublic fun Regex_0(pattern: String, option: RegexOption): Regex = Regex(pattern, setOf(option))\n\n/** Creates a regular expression from the specified [pattern] string and the default options.  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_61zpoe\\$\")\npublic fun Regex_1(pattern: String): Regex = Regex(pattern, emptySet())\n\n\n\n\nprivate fun RegExp.findNext(input: String, from: Int): MatchResult? {\n    this.lastIndex = from\n    val match = exec(input)\n    if (match == null) return null\n    val range = match.index..lastIndex - 1\n\n    return object : MatchResult {\n        override val range: IntRange = range\n        override val value: String\n            get() = match[0]!!\n\n        override val groups: MatchGroupCollection = object : MatchGroupCollection, AbstractCollection<MatchGroup?>() {\n            override val size: Int get() = match.length\n            override fun iterator(): Iterator<MatchGroup?> = indices.asSequence().map { this[it] }.iterator()\n            override fun get(index: Int): MatchGroup? = match[index]?.let { MatchGroup(it) }\n        }\n\n\n        private var groupValues_: List<String>? = null\n\n        override val groupValues: List<String>\n            get() {\n                if (groupValues_ == null) {\n                    groupValues_ = object : AbstractList<String>() {\n                        override val size: Int get() = match.length\n                        override fun get(index: Int): String = match[index] ?: \"\"\n                    }\n                }\n                return groupValues_!!\n            }\n\n        override fun next(): MatchResult? = this@findNext.findNext(input, if (range.isEmpty()) range.start + 1 else range.endInclusive + 1)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\npublic fun String.matches(regex: String): Boolean {\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || (if (this is String) this else this.toString()).matches(\"^[\\\\s\\\\xA0]+$\")\n\n@OptIn(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean =\n    if (this == null)\n        other == null\n    else if (!ignoreCase)\n        this == other\n    else\n        other != null && this.lowercase() == other.lowercase()\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toUpperCase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toLowerCase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gi\" else \"g\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gi\" else \"g\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"i\" else \"\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"i\" else \"\"), newChar.toString())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic actual enum class DurationUnit(internal val scale: Double) {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS(1e0),\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS(1e3),\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS(1e6),\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS(1e9),\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES(60e9),\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS(3600e9),\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS(86400e9);\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal actual fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> value * (sourceUnit.scale / targetUnit.scale)\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale)\n        else -> value\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport org.w3c.performance.GlobalPerformance\nimport org.w3c.performance.Performance\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal actual object MonotonicTimeSource : TimeSource {\n\n    private val actualSource: TimeSource = run {\n        val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n\n        if (isNode)\n            HrTimeSource(js(\"process\").unsafeCast<Process>())\n        else\n            js(\"self\").unsafeCast<GlobalPerformance?>()?.performance?.let(::PerformanceTimeSource)\n                ?: DateNowTimeSource\n\n    }\n\n    override fun markNow(): TimeMark = actualSource.markNow()\n}\n\ninternal external interface Process {\n    fun hrtime(time: Array<Double> = definedExternally): Array<Double>\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal class HrTimeSource(val process: Process) : TimeSource {\n\n    override fun markNow(): TimeMark = object : TimeMark() {\n        val startedAt = process.hrtime()\n        override fun elapsedNow(): Duration =\n            process.hrtime(startedAt).let { (seconds, nanos) -> seconds.seconds + nanos.nanoseconds }\n    }\n\n    override fun toString(): String = \"TimeSource(process.hrtime())\"\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal class PerformanceTimeSource(val performance: Performance) : AbstractDoubleTimeSource(unit = DurationUnit.MILLISECONDS) {\n    override fun read(): Double = performance.now()\n    override fun toString(): String = \"TimeSource(self.performance.now())\"\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal object DateNowTimeSource : AbstractDoubleTimeSource(unit = DurationUnit.MILLISECONDS) {\n    override fun read(): Double = kotlin.js.Date.now()\n    override fun toString(): String = \"TimeSource(Date.now())\"\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.js.json\nimport kotlin.math.*\n\ninternal actual fun formatToExactDecimals(value: Double, decimals: Int): String {\n    val rounded = if (decimals == 0) {\n        value\n    } else {\n        val pow = 10.0.pow(decimals)\n        @Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\n        kotlin.js.Math.round(abs(value) * pow) / pow * sign(value)\n    }\n    return rounded.asDynamic().toFixed(decimals).unsafeCast<String>()\n}\n\ninternal actual fun formatUpToDecimals(value: Double, decimals: Int): String {\n    return value.asDynamic().toLocaleString(\"en-us\", json(\"maximumFractionDigits\" to decimals)).unsafeCast<String>()\n}\n\ninternal actual fun formatScientific(value: Double): String {\n    return value.asDynamic().toExponential(2).unsafeCast<String>()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] that wraps each element produced by the original iterator\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(checkIndexOverflow(index++), iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'sequence { }' function instead.\", ReplaceWith(\"sequence(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildSequence(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(builderAction) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'iterator { }' function instead.\", ReplaceWith(\"iterator(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildIterator(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Iterator<T> = iterator(builderAction)\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\n@Deprecated(\"Use SequenceScope class instead.\", ReplaceWith(\"SequenceScope<T>\"), level = DeprecationLevel.ERROR)\npublic typealias SequenceBuilder<T> = SequenceScope<T>\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     *\n     * @sample samples.random.Randoms.nextBits\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextInt\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextLong\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + nextInt()\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     *\n     * @sample samples.random.Randoms.nextBoolean\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextDouble\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextFloat\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random() {\n\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray = defaultRandom.nextBytes(array, fromIndex, toIndex)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\n@OptIn(ExperimentalStdlibApi::class)\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom\ninternal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random() {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmStatic\n\n\n\n/**\n * Represents a type projection. Type projection is usually the argument to another type in a type usage.\n * For example, in the type `Array<out Number>`, `out Number` is the covariant projection of the type represented by the class `Number`.\n *\n * Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.\n *\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#type-projections)\n * for more information.\n */\n@SinceKotlin(\"1.1\")\npublic data class KTypeProjection constructor(\n    /**\n     * The use-site variance specified in the projection, or `null` if this is a star projection.\n     */\n    public val variance: KVariance?,\n    /**\n     * The type specified in the projection, or `null` if this is a star projection.\n     */\n    public val type: KType?\n) {\n\n    init {\n        require((variance == null) == (type == null)) {\n            if (variance == null)\n                \"Star projection must have no type specified.\"\n            else\n                \"The projection variance $variance requires type to be specified.\"\n        }\n    }\n\n    override fun toString(): String = when (variance) {\n        null -> \"*\"\n        KVariance.INVARIANT -> type.toString()\n        KVariance.IN -> \"in $type\"\n        KVariance.OUT -> \"out $type\"\n    }\n\n    public companion object {\n        // provided for compiler access\n        @JvmField\n        @PublishedApi\n        internal val star: KTypeProjection = KTypeProjection(null, null)\n\n        /**\n         * Star projection, denoted by the `*` character.\n         * For example, in the type `KClass<*>`, `*` is the star projection.\n         * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#star-projections)\n         * for more information.\n         */\n        public val STAR: KTypeProjection get() = star\n\n        /**\n         * Creates an invariant projection of a given type. Invariant projection is just the type itself,\n         * without any use-site variance modifiers applied to it.\n         * For example, in the type `Set<String>`, `String` is an invariant projection of the type represented by the class `String`.\n         */\n        @JvmStatic\n        public fun invariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.INVARIANT, type)\n\n        /**\n         * Creates a contravariant projection of a given type, denoted by the `in` modifier applied to a type.\n         * For example, in the type `MutableList<in Number>`, `in Number` is a contravariant projection of the type of class `Number`.\n         */\n        @JvmStatic\n        public fun contravariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.IN, type)\n\n        /**\n         * Creates a covariant projection of a given type, denoted by the `out` modifier applied to a type.\n         * For example, in the type `Array<out Number>`, `out Number` is a covariant projection of the type of class `Number`.\n         */\n        @JvmStatic\n        public fun covariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.OUT, type)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\n/**\n * Represents variance applied to a type parameter on the declaration site (*declaration-site variance*),\n * or to a type in a projection (*use-site variance*).\n *\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#variance)\n * for more information.\n *\n * @see [KTypeParameter.variance]\n * @see [KTypeProjection]\n */\n@SinceKotlin(\"1.1\")\nenum class KVariance {\n    /**\n     * The affected type parameter or type is *invariant*, which means it has no variance applied to it.\n     */\n    INVARIANT,\n\n    /**\n     * The affected type parameter or type is *contravariant*. Denoted by the `in` modifier in the source code.\n     */\n    IN,\n\n    /**\n     * The affected type parameter or type is *covariant*. Denoted by the `out` modifier in the source code.\n     */\n    OUT,\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if the Char is one of the ASCII decimal digits '0' through '9'.\n * In this case, `this.code - '0'.code` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToInt(): Int {\n    if (this in '0'..'9') {\n        return this - '0'\n    }\n    throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - The Char is one of the ASCII decimal digits '0' through '9' and its [code] is less than `radix + '0'.code`. In this case, `this.code - '0'.code` is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if the Char is one of the ASCII decimal digits '0' through '9'.\n * In this case, `this.code - '0'.code` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToIntOrNull(): Int? {\n    if (this in '0'..'9') {\n        return this - '0'\n    }\n    return null\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - The Char is one of the ASCII decimal digits '0' through '9' and its [code] is less than `radix + '0'.code`. In this case, `this.code - '0'.code` is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this in '0'..'9') {\n        val digit = this - '0'\n        return if (digit < radix) digit else null\n    }\n    val a = if (this <= 'Z') 'A' else 'a'\n    val digit = 10 + (this - a)\n    return if (digit in 10 until radix) digit else null\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.uppercase(): String\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n *\n * Two characters are considered the same ignoring case if at least one of the following is `true`:\n *   - The two characters are the same (as compared by the == operator)\n *   - Applying the method [uppercaseChar] to each character produces the same result\n *   - Applying the method [lowercaseChar] to each character produces the same result\n *\n * @sample samples.text.Chars.equals\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    if (this.uppercaseChar() == other.uppercaseChar()) return true\n    if (this.lowercaseChar() == other.lowercaseChar()) return true\n    return false\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2 — of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2] — of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.math.abs\n\n@OptIn(ExperimentalTime::class)\nprivate inline val storageUnit get() = DurationUnit.NANOSECONDS\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inHours], [inMinutes], [inSeconds], [inNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\npublic inline class Duration internal constructor(internal val value: Double) : Comparable<Duration> {\n// TODO: backend fails on init block, wait for KT-28055\n\n//    init {\n//        require(_value.isNaN().not())\n//    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0.0)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = Duration(Double.POSITIVE_INFINITY)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = Duration(-value)\n\n    /** Returns a duration whose value is the sum of this and [other] duration values. */\n    public operator fun plus(other: Duration): Duration = Duration(value + other.value)\n\n    /** Returns a duration whose value is the difference between this and [other] duration values. */\n    public operator fun minus(other: Duration): Duration = Duration(value - other.value)\n\n    /** Returns a duration whose value is this duration value multiplied by the given [scale] number. */\n    public operator fun times(scale: Int): Duration = Duration(value * scale)\n\n    /** Returns a duration whose value is this duration value multiplied by the given [scale] number. */\n    public operator fun times(scale: Double): Duration = Duration(value * scale)\n\n    /** Returns a duration whose value is this duration value divided by the given [scale] number. */\n    public operator fun div(scale: Int): Duration = Duration(value / scale)\n\n    /** Returns a duration whose value is this duration value divided by the given [scale] number. */\n    public operator fun div(scale: Double): Duration = Duration(value / scale)\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double = this.value / other.value\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = value < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = value > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = value.isInfinite()\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = value.isFinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int = this.value.compareTo(other.value)\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inDays.toInt(), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inHours.toInt(), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inMinutes.toInt(), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inSeconds.toLong(), nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int get() = (inHours % 24).toInt()\n    @PublishedApi\n    internal val minutesComponent: Int get() = (inMinutes % 60).toInt()\n    @PublishedApi\n    internal val secondsComponent: Int get() = (inSeconds % 60).toInt()\n    @PublishedApi\n    internal val nanosecondsComponent: Int get() = (inNanoseconds % 1e9).toInt()\n\n\n    // conversion to units\n\n    /** Returns the value of this duration expressed as a [Double] number of the specified [unit]. */\n    public fun toDouble(unit: DurationUnit): Double = convertDurationUnit(value, storageUnit, unit)\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     */\n    public fun toLong(unit: DurationUnit): Long = toDouble(unit).toLong()\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the value doesn't fit in the range of [Int] type, it is coerced into that range, see the conversion [Double.toInt] for details.\n     */\n    public fun toInt(unit: DurationUnit): Int = toDouble(unit).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately ±292 years.\n     */\n    public fun toLongNanoseconds(): Long = toLong(DurationUnit.NANOSECONDS)\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately ±292 million years.\n     */\n    public fun toLongMilliseconds(): Long = toLong(DurationUnit.MILLISECONDS)\n\n    /**\n     * Returns a string representation of this duration value expressed in the unit which yields the most compact and readable number value.\n     *\n     * Special cases:\n     *  - zero duration is formatted as `\"0s\"`\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *  - very small durations (less than 1e-15 s) are expressed in seconds and formatted in scientific notation\n     *  - very big durations (more than 1e+7 days) are expressed in days and formatted in scientific notation\n     *\n     * @return the value of duration in the automatically determined unit followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when {\n        isInfinite() -> value.toString()\n        value == 0.0 -> \"0s\"\n        else -> {\n            val absNs = absoluteValue.inNanoseconds\n            var scientific = false\n            var maxDecimals = 0\n            val unit = when {\n                absNs < 1e-6 -> DurationUnit.SECONDS.also { scientific = true }\n                absNs < 1 -> DurationUnit.NANOSECONDS.also { maxDecimals = 7 }\n                absNs < 1e3 -> DurationUnit.NANOSECONDS\n                absNs < 1e6 -> DurationUnit.MICROSECONDS\n                absNs < 1e9 -> DurationUnit.MILLISECONDS\n                absNs < 1000e9 -> DurationUnit.SECONDS\n                absNs < 60_000e9 -> DurationUnit.MINUTES\n                absNs < 3600_000e9 -> DurationUnit.HOURS\n                absNs < 86400e9 * 1e7 -> DurationUnit.DAYS\n                else -> DurationUnit.DAYS.also { scientific = true }\n            }\n            val value = toDouble(unit)\n            when {\n                scientific -> formatScientific(value)\n                maxDecimals > 0 -> formatUpToDecimals(value, maxDecimals)\n                else -> formatToExactDecimals(value, precision(abs(value)))\n            } + unit.shortName()\n        }\n    }\n\n    private fun precision(value: Double): Int = when {\n        value < 1 -> 3\n        value < 10 -> 2\n        value < 100 -> 1\n        else -> 0\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        if (isInfinite()) return value.toString()\n        val number = toDouble(unit)\n        return when {\n            abs(number) < 1e14 -> formatToExactDecimals(number, decimals.coerceAtMost(12))\n            else -> formatScientific(number)\n        } + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            val hasHours = hours != 0\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                append(seconds)\n                if (nanoseconds != 0) {\n                    append('.')\n                    val nss = nanoseconds.toString().padStart(9, '0')\n                    when {\n                        nanoseconds % 1_000_000 == 0 -> appendRange(nss, 0, 3)\n                        nanoseconds % 1_000 == 0 -> appendRange(nss, 0, 6)\n                        else -> append(nss)\n                    }\n                }\n                append('S')\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration = toDouble().toDuration(unit)\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration = toDouble().toDuration(unit)\n\n/** Returns a [Duration] equal to this [Double] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration = Duration(convertDurationUnit(this, unit, storageUnit))\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Double] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Double] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Double] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\ninternal expect fun formatScientific(value: Double): String","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass()\n@file:kotlin.jvm.JvmName(\"DurationUnitKt\")\n\npackage kotlin.time\n\n\n/**\n * The list of possible time measurement units, in which a duration can be expressed.\n *\n * The smallest time unit is [NANOSECONDS] and the largest is [DAYS], which corresponds to exactly 24 [HOURS].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic expect enum class DurationUnit {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS,\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS,\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS,\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS,\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES,\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS,\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS;\n}\n\n/** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal expect fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double\n\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal fun DurationUnit.shortName(): String = when (this) {\n    DurationUnit.NANOSECONDS -> \"ns\"\n    DurationUnit.MICROSECONDS -> \"us\"\n    DurationUnit.MILLISECONDS -> \"ms\"\n    DurationUnit.SECONDS -> \"s\"\n    DurationUnit.MINUTES -> \"m\"\n    DurationUnit.HOURS -> \"h\"\n    DurationUnit.DAYS -> \"d\"\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n/**\n * A source of time for measuring time intervals.\n *\n * The only operation provided by the time source is [markNow]. It returns a [TimeMark], which can be used to query the elapsed time later.\n *\n * @see [measureTime]\n * @see [measureTimedValue]\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic interface TimeSource {\n    /**\n     * Marks a point in time on this time source.\n     *\n     * The returned [TimeMark] instance encapsulates the captured time point and allows querying\n     * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point.\n     */\n    public fun markNow(): TimeMark\n\n    /**\n     * The most precise time source available in the platform.\n     *\n     * This time source returns its readings from a source of monotonic time when it is available in a target platform,\n     * and resorts to a non-monotonic time source otherwise.\n     */\n    public object Monotonic : TimeSource by MonotonicTimeSource {\n        override fun toString(): String = MonotonicTimeSource.toString()\n    }\n\n\n    public companion object {\n\n    }\n}\n\n/**\n * Represents a time point notched on a particular [TimeSource]. Remains bound to the time source it was taken from\n * and allows querying for the duration of time elapsed from that point (see the function [elapsedNow]).\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class TimeMark {\n    /**\n     * Returns the amount of time passed from this mark measured with the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     */\n    public abstract fun elapsedNow(): Duration\n\n    /**\n     * Returns a time mark on the same time source that is ahead of this time mark by the specified [duration].\n     *\n     * The returned time mark is more _late_ when the [duration] is positive, and more _early_ when the [duration] is negative.\n     */\n    public open operator fun plus(duration: Duration): TimeMark = AdjustedTimeMark(this, duration)\n\n    /**\n     * Returns a time mark on the same time source that is behind this time mark by the specified [duration].\n     *\n     * The returned time mark is more _early_ when the [duration] is positive, and more _late_ when the [duration] is negative.\n     */\n    public open operator fun minus(duration: Duration): TimeMark = plus(-duration)\n\n\n    /**\n     * Returns true if this time mark has passed according to the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes behind the current point of the time source.\n     */\n    public fun hasPassedNow(): Boolean = !elapsedNow().isNegative()\n\n    /**\n     * Returns false if this time mark has not passed according to the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     * If the time source is monotonic, it can change only from `true` to `false`, namely, when the time mark becomes behind the current point of the time source.\n     */\n    public fun hasNotPassedNow(): Boolean = elapsedNow().isNegative()\n}\n\n\n@ExperimentalTime\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Deprecated(\n    \"Subtracting one TimeMark from another is not a well defined operation because these time marks could have been obtained from the different time sources.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline operator fun TimeMark.minus(other: TimeMark): Duration = throw Error(\"Operation is disallowed.\")\n\n@ExperimentalTime\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Deprecated(\n    \"Comparing one TimeMark to another is not a well defined operation because these time marks could have been obtained from the different time sources.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline operator fun TimeMark.compareTo(other: TimeMark): Int = throw Error(\"Operation is disallowed.\")\n\n\n@ExperimentalTime\nprivate class AdjustedTimeMark(val mark: TimeMark, val adjustment: Duration) : TimeMark() {\n    override fun elapsedNow(): Duration = mark.elapsedNow() - adjustment\n\n    override fun plus(duration: Duration): TimeMark = AdjustedTimeMark(mark, adjustment + duration)\n}\n\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TimeSource interface instead.\", ReplaceWith(\"TimeSource\", \"kotlin.time.TimeSource\"), DeprecationLevel.ERROR)\npublic typealias Clock = TimeSource\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TimeMark class instead.\", ReplaceWith(\"TimeMark\", \"kotlin.time.TimeMark\"), DeprecationLevel.ERROR)\npublic typealias ClockMark = TimeMark\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal expect object MonotonicTimeSource : TimeSource\n\n/**\n * An abstract class used to implement time sources that return their readings as [Long] values in the specified [unit].\n *\n * @property unit The unit in which this time source's readings are expressed.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class AbstractLongTimeSource(protected val unit: DurationUnit) : TimeSource {\n    /**\n     * This protected method should be overridden to return the current reading of the time source expressed as a [Long] number\n     * in the unit specified by the [unit] property.\n     */\n    protected abstract fun read(): Long\n\n    private class LongTimeMark(private val startedAt: Long, private val timeSource: AbstractLongTimeSource, private val offset: Duration) : TimeMark() {\n        override fun elapsedNow(): Duration = (timeSource.read() - startedAt).toDuration(timeSource.unit) - offset\n        override fun plus(duration: Duration): TimeMark = LongTimeMark(startedAt, timeSource, offset + duration)\n    }\n\n    override fun markNow(): TimeMark = LongTimeMark(read(), this, Duration.ZERO)\n}\n\n/**\n * An abstract class used to implement time sources that return their readings as [Double] values in the specified [unit].\n *\n * @property unit The unit in which this time source's readings are expressed.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class AbstractDoubleTimeSource(protected val unit: DurationUnit) : TimeSource {\n    /**\n     * This protected method should be overridden to return the current reading of the time source expressed as a [Double] number\n     * in the unit specified by the [unit] property.\n     */\n    protected abstract fun read(): Double\n\n    private class DoubleTimeMark(private val startedAt: Double, private val timeSource: AbstractDoubleTimeSource, private val offset: Duration) : TimeMark() {\n        override fun elapsedNow(): Duration = (timeSource.read() - startedAt).toDuration(timeSource.unit) - offset\n        override fun plus(duration: Duration): TimeMark = DoubleTimeMark(startedAt, timeSource, offset + duration)\n    }\n\n    override fun markNow(): TimeMark = DoubleTimeMark(read(), this, Duration.ZERO)\n}\n\n/**\n * A time source that has programmatically updatable readings. It is useful as a predictable source of time in tests.\n *\n * The current reading value can be advanced by the specified duration amount with the operator [plusAssign]:\n *\n * ```\n * val timeSource = TestTimeSource()\n * timeSource += 10.seconds\n * ```\n *\n * Implementation note: the current reading value is stored as a [Long] number of nanoseconds,\n * thus it's capable to represent a time range of approximately ±292 years.\n * Should the reading value overflow as the result of [plusAssign] operation, an [IllegalStateException] is thrown.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic class TestTimeSource : AbstractLongTimeSource(unit = DurationUnit.NANOSECONDS) {\n    private var reading: Long = 0L\n\n    override fun read(): Long = reading\n\n    /**\n     * Advances the current reading value of this time source by the specified [duration].\n     *\n     * [duration] value is rounded down towards zero when converting it to a [Long] number of nanoseconds.\n     * For example, if the duration being added is `0.6.nanoseconds`, the reading doesn't advance because\n     * the duration value is rounded to zero nanoseconds.\n     *\n     * @throws IllegalStateException when the reading value overflows as the result of this operation.\n     */\n    public operator fun plusAssign(duration: Duration) {\n        val delta = duration.toDouble(unit)\n        val longDelta = delta.toLong()\n        reading = if (longDelta != Long.MIN_VALUE && longDelta != Long.MAX_VALUE) {\n            // when delta fits in long, add it as long\n            val newReading = reading + longDelta\n            if (reading xor longDelta >= 0 && reading xor newReading < 0) overflow(duration)\n            newReading\n        } else {\n            // when delta is greater than long, add it as double\n            val newReading = reading + delta\n            if (newReading > Long.MAX_VALUE || newReading < Long.MIN_VALUE) overflow(duration)\n            newReading.toLong()\n        }\n    }\n\n    private fun overflow(duration: Duration) {\n        throw IllegalStateException(\"TestTimeSource will overflow if its reading ${reading}ns is advanced by $duration.\")\n    }\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TimeSource.Monotonic instead.\", ReplaceWith(\"TimeSource.Monotonic\", \"kotlin.time.TimeSource\"), DeprecationLevel.ERROR)\npublic typealias MonoClock = TimeSource.Monotonic\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use AbstractLongTimeSource instead.\", ReplaceWith(\"AbstractLongTimeSource\", \"kotlin.time.AbstractLongTimeSource\"), DeprecationLevel.ERROR)\npublic typealias AbstractLongClock = AbstractLongTimeSource\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use AbstractDoubleTimeSource instead.\", ReplaceWith(\"AbstractDoubleTimeSource\", \"kotlin.time.AbstractDoubleTimeSource\"), DeprecationLevel.ERROR)\npublic typealias AbstractDoubleClock = AbstractDoubleTimeSource\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TestTimeSource instead.\", ReplaceWith(\"TestTimeSource\", \"kotlin.time.TestTimeSource\"), DeprecationLevel.ERROR)\npublic typealias TestClock = TestTimeSource\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return TimeSource.Monotonic.measureTime(block)\n}\n\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun TimeSource.measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    block()\n    return mark.elapsedNow()\n}\n\n\n/**\n * Data class representing a result of executing an action, along with the duration of elapsed time interval.\n *\n * @property value the result of the action.\n * @property duration the time elapsed to execute the action.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic data class TimedValue<T>(val value: T, val duration: Duration)\n\n/**\n * Executes the given function [block] and returns an instance of [TimedValue] class, containing both\n * the result of the function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return TimeSource.Monotonic.measureTimedValue(block)\n}\n\n/**\n * Executes the given [block] and returns an instance of [TimedValue] class, containing both\n * the result of function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> TimeSource.measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    val result = block()\n    return TimedValue(result, mark.elapsedNow())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `UInt`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic class UIntRange(start: UInt, endInclusive: UInt) : UIntProgression(start, endInclusive, 1), ClosedRange<UInt> {\n    override val start: UInt get() = first\n    override val endInclusive: UInt get() = last\n\n    override fun contains(value: UInt): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type UInt. */\n        public val EMPTY: UIntRange = UIntRange(UInt.MAX_VALUE, UInt.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `UInt`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic open class UIntProgression\ninternal constructor(\n    start: UInt,\n    endInclusive: UInt,\n    step: Int\n) : Iterable<UInt> {\n    init {\n        if (step == 0.toInt()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: UInt = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: UInt = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): UIntIterator = UIntProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step.toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates UIntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression = UIntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `UInt`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\nprivate class UIntProgressionIterator(first: UInt, last: UInt, step: Int) : UIntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toUInt() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextUInt(): UInt {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `UByte`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class UByteIterator : Iterator<UByte> {\n    override final fun next() = nextUByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUByte(): UByte\n}\n\n/** An iterator over a sequence of values of type `UShort`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class UShortIterator : Iterator<UShort> {\n    override final fun next() = nextUShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUShort(): UShort\n}\n\n/** An iterator over a sequence of values of type `UInt`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class UIntIterator : Iterator<UInt> {\n    override final fun next() = nextUInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUInt(): UInt\n}\n\n/** An iterator over a sequence of values of type `ULong`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class ULongIterator : Iterator<ULong> {\n    override final fun next() = nextULong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextULong(): ULong\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `ULong`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic class ULongRange(start: ULong, endInclusive: ULong) : ULongProgression(start, endInclusive, 1), ClosedRange<ULong> {\n    override val start: ULong get() = first\n    override val endInclusive: ULong get() = last\n\n    override fun contains(value: ULong): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type ULong. */\n        public val EMPTY: ULongRange = ULongRange(ULong.MAX_VALUE, ULong.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `ULong`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic open class ULongProgression\ninternal constructor(\n    start: ULong,\n    endInclusive: ULong,\n    step: Long\n) : Iterable<ULong> {\n    init {\n        if (step == 0.toLong()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: ULong = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: ULong = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): ULongIterator = ULongProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt()) + (step xor (step ushr 32)).toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates ULongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression = ULongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `ULong`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\nprivate class ULongProgressionIterator(first: ULong, last: ULong, step: Long) : ULongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toULong() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextULong(): ULong {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:OptIn(ExperimentalUnsignedTypes::class)\npackage kotlin.internal\n\n// (a - b) mod c\nprivate fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\nprivate fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toUInt())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toUInt())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toULong())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toULong())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"UStringsKt\")  // string representation of unsigned numbers\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UByte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UShort.toString(radix: Int): String = this.toInt().toString(radix)\n\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UInt.toString(radix: Int): String = this.toLong().toString(radix)\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULong.toString(radix: Int): String = ulongToString(this.toLong(), checkRadix(radix))\n\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByte(): UByte = toUByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByte(radix: Int): UByte = toUByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShort(): UShort = toUShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShort(radix: Int): UShort = toUShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUInt(): UInt = toUIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUInt(radix: Int): UInt = toUIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULong(): ULong = toULongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULong(radix: Int): ULong = toULongOrNull(radix) ?: numberFormatError(this)\n\n\n\n\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByteOrNull(): UByte? = toUByteOrNull(radix = 10)\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByteOrNull(radix: Int): UByte? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UByte.MAX_VALUE) return null\n    return int.toUByte()\n}\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShortOrNull(): UShort? = toUShortOrNull(radix = 10)\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShortOrNull(radix: Int): UShort? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UShort.MAX_VALUE) return null\n    return int.toUShort()\n}\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUIntOrNull(): UInt? = toUIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUIntOrNull(radix: Int): UInt? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: UInt = UInt.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n    val limitForMaxRadix = 119304647u  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toUInt()\n    var result = 0u\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULongOrNull(): ULong? = toULongOrNull(radix = 10)\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULongOrNull(radix: Int): ULong? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: ULong = ULong.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n\n    val limitForMaxRadix = 512409557603043100uL  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toULong()\n    var result = 0uL\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.reflect.KClass\n\n@PublishedApi\ninternal fun <T : Annotation> KClass<*>.findAssociatedObject(@Suppress(\"UNUSED_PARAMETER\") annotationClass: KClass<T>): Any? {\n    // This API is not supported in js-v1. Return `null` to be source-compatible with js-ir.\n    return null\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport getKClass\nimport kotlin.reflect.KClass\nimport kotlin.reflect.js.internal.KClassImpl\n\n/**\n * Represents the constructor of a class. Instances of `JsClass` can be passed to JavaScript APIs that expect a constructor reference.\n */\nexternal interface JsClass<T : Any> {\n    /**\n     * Returns the unqualified name of the class represented by this instance.\n     */\n    val name: String\n}\n\n/**\n * Obtains a constructor reference for the given `KClass`.\n */\nval <T : Any> KClass<T>.js: JsClass<T>\n    get() = (this as KClassImpl<T>).jClass\n\n/**\n * Obtains a `KClass` instance for the given constructor reference.\n */\nval <T : Any> JsClass<T>.kotlin: KClass<T>\n    get() = getKClass(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n// TODO: Remove once JsReflectionAPICallChecker supports more reflection types\n@file:Suppress(\"Unsupported\")\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"createKType\")\ninternal fun createKType(\n    classifier: KClassifier,\n    arguments: Array<KTypeProjection>,\n    isMarkedNullable: Boolean\n) =\n    KTypeImpl(classifier, arguments.asList(), isMarkedNullable)\n\n@JsName(\"createDynamicKType\")\ninternal fun createDynamicKType(): KType = DynamicKType\n\n@JsName(\"markKTypeNullable\")\ninternal fun markKTypeNullable(kType: KType) = KTypeImpl(kType.classifier!!, kType.arguments, true)\n\n@JsName(\"createKTypeParameter\")\ninternal fun createKTypeParameter(\n    name: String,\n    upperBounds: Array<KType>,\n    variance: String\n): KTypeParameter {\n    val kVariance = when (variance) {\n        \"in\" -> KVariance.IN\n        \"out\" -> KVariance.OUT\n        else -> KVariance.INVARIANT\n    }\n\n    return KTypeParameterImpl(name, upperBounds.asList(), kVariance, false)\n}\n\n@JsName(\"getStarKTypeProjection\")\ninternal fun getStarKTypeProjection(): KTypeProjection =\n    KTypeProjection.STAR\n\n@JsName(\"createCovariantKTypeProjection\")\ninternal fun createCovariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.covariant(type)\n\n@JsName(\"createInvariantKTypeProjection\")\ninternal fun createInvariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.invariant(type)\n\n@JsName(\"createContravariantKTypeProjection\")\ninternal fun createContravariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.contravariant(type)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MathKt\")\n\n\npackage kotlin.math\n\n\n\n// constants, can't use them from nativeMath as they are not constants there\n\n/** Ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n@SinceKotlin(\"1.2\")\npublic const val PI: Double = 3.141592653589793\n/** Base of the natural logarithms, approximately 2.71828. */\n@SinceKotlin(\"1.2\")\npublic const val E: Double = 2.718281828459045\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Double): Double\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Double): Double\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Double): Double\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Double): Double\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Double): Double\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Double): Double\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Double, x: Double): Double\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Double): Double\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Double): Double\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Double): Double\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Double, y: Double): Double\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Double): Double\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Double): Double\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Double): Double\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Double, base: Double): Double\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Double): Double\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Double): Double\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Double): Double\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Double): Double\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Double): Double\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Double): Double\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Double): Double\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Double, b: Double): Double\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Double, b: Double): Double\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(x: Double): Double\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(n: Int): Double\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.absoluteValue: Double\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.sign: Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Double): Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Int): Double\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.ulp: Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextUp(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextDown(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextTowards(to: Double): Double\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToInt(): Int\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToLong(): Long\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Float): Float\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Float): Float\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Float): Float\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Float): Float\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Float): Float\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Float): Float\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Float, x: Float): Float\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Float): Float\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Float): Float\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Float): Float\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Float, y: Float): Float\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Float): Float\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Float): Float\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Float): Float\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Float, base: Float): Float\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Float): Float\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Float): Float\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Float): Float\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Float): Float\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Float): Float\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Float): Float\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Float): Float\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Float, b: Float): Float\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Float, b: Float): Float\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(x: Float): Float\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(n: Int): Float\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.absoluteValue: Float\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.sign: Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Float): Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Int): Float\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToInt(): Int\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToLong(): Long\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Int): Int\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Int, b: Int): Int\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Int, b: Int): Int\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.absoluteValue: Int\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.sign: Int\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Long): Long\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Long, b: Long): Long\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Long, b: Long): Long\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.absoluteValue: Long\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.sign: Int\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].toInt()\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].toInt()\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces [StackOverflowError] because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\n@ExperimentalStdlibApi\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\n@ExperimentalStdlibApi\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n","package world.phantasmal.core\n\nimport mu.KLogger\n\nsealed class PwResult<out T>(val problems: List<Problem>) {\n    fun getOrNull(): T? = when (this) {\n        is Success -> value\n        is Failure -> null\n    }\n\n    fun unwrap(): T = when (this) {\n        is Success -> value\n        is Failure -> error(problems.joinToString(\"\\n\") { \"[${it.severity}] ${it.uiMessage}\" })\n    }\n\n    companion object {\n        fun <T> build(logger: KLogger): PwResultBuilder<T> =\n            PwResultBuilder(logger)\n    }\n}\n\nclass Success<T>(val value: T, problems: List<Problem> = emptyList()) : PwResult<T>(problems)\n\nclass Failure(problems: List<Problem>) : PwResult<Nothing>(problems)\n\nopen class Problem(\n    val severity: Severity,\n    /**\n     * Readable message meant for users.\n     */\n    val uiMessage: String,\n    /**\n     * Message meant for developers.\n     */\n    val message: String? = null,\n    val cause: Throwable? = null,\n)\n\nenum class Severity {\n    Trace,\n    Debug,\n    Info,\n    Warning,\n    Error,\n}\n\n/**\n * Useful for building up a [PwResult] and logging problems at the same time.\n */\nclass PwResultBuilder<T>(private val logger: KLogger) {\n    private val problems: MutableList<Problem> = mutableListOf()\n\n    /**\n     * Add a problem to the problems list and log it with [logger].\n     */\n    fun addProblem(\n        problem: Problem,\n    ): PwResultBuilder<T> {\n        when (problem.severity) {\n            Severity.Trace -> logger.trace(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Debug -> logger.debug(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Info -> logger.info(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Warning -> logger.warn(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Error -> logger.error(problem.cause) { problem.message ?: problem.uiMessage }\n        }\n\n        problems.add(problem)\n        return this\n    }\n\n    /**\n     * Add a problem to the problems list and log it with [logger].\n     */\n    fun addProblem(\n        severity: Severity,\n        uiMessage: String,\n        message: String? = null,\n        cause: Throwable? = null,\n    ): PwResultBuilder<T> =\n        addProblem(Problem(severity, uiMessage, message, cause))\n\n    /**\n     * Add the given result's problems.\n     */\n    fun addResult(result: PwResult<*>): PwResultBuilder<T> {\n        problems.addAll(result.problems)\n        return this\n    }\n\n    fun success(value: T): Success<T> =\n        Success(value, problems)\n\n    fun failure(): Failure =\n        Failure(problems)\n}\n","package world.phantasmal.core\n\nimport kotlinx.coroutines.await\nimport world.phantasmal.core.externals.browser.WritableStream\n\nsuspend inline fun <S : WritableStream, R> S.use(block: (S) -> R): R {\n    try {\n        return block(this)\n    } finally {\n        close().await()\n    }\n}\n","package world.phantasmal.core.math\n\nimport kotlin.math.PI\n\nprivate const val TO_DEG = 180 / PI\nprivate const val TO_RAD = PI / 180\n\n/**\n * Converts radians to degrees.\n */\nfun radToDeg(rad: Double): Double = rad * TO_DEG\n\n/**\n * Converts degrees to radians.\n */\nfun degToRad(deg: Double): Double = deg * TO_RAD\n\n/**\n * Returns the floored modulus of its arguments. The computed value will have the same sign as the\n * [divisor].\n */\nfun floorMod(dividend: Double, divisor: Double): Double =\n    ((dividend % divisor) + divisor) % divisor\n",null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport findAssociatedObject\n\n/**\n * The experimental marker for associated objects API.\n *\n * Any usage of a declaration annotated with `@ExperimentalAssociatedObjects` must be accepted either by\n * annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalAssociatedObjects::class)`,\n * or by using the compiler argument `-Xopt-in=kotlin.reflect.ExperimentalAssociatedObjects`.\n */\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Retention(value = AnnotationRetention.BINARY)\npublic annotation class ExperimentalAssociatedObjects\n\n/**\n * Makes the annotated annotation class an associated object key.\n *\n * An associated object key annotation should have single [KClass] parameter.\n * When applied to a class with reference to an object declaration as an argument, it binds\n * the object to the class, making this binding discoverable at runtime using [findAssociatedObject].\n */\n@ExperimentalAssociatedObjects\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.ANNOTATION_CLASS)\npublic annotation class AssociatedObjectKey\n\n/**\n * If [T] is an @[AssociatedObjectKey]-annotated annotation class and [this] class is annotated with @[T] (`S::class`),\n * returns object `S`.\n *\n * Otherwise returns `null`.\n */\n@ExperimentalAssociatedObjects\npublic inline fun <reified T : Annotation> KClass<*>.findAssociatedObject(): Any? =\n    this.findAssociatedObject(T::class)",null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"GroupingKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.collections\n\n/**\n * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.\n *\n * A [Grouping] structure serves as an intermediate step in group-and-fold operations:\n * they group elements by their keys and then fold each group with some aggregating operation.\n *\n * It is created by attaching `keySelector: (T) -> K` function to a source of elements.\n * To get an instance of [Grouping] use one of `groupingBy` extension functions:\n * - [Iterable.groupingBy]\n * - [Sequence.groupingBy]\n * - [Array.groupingBy]\n * - [CharSequence.groupingBy]\n *\n * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.\n */\n@SinceKotlin(\"1.1\")\npublic interface Grouping<T, out K> {\n    /** Returns an [Iterator] over the elements of the source of this grouping. */\n    fun sourceIterator(): Iterator<T>\n    /** Extracts the key of an [element]. */\n    fun keyOf(element: T): K\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation function is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * @return a [Map] associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadix\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.aggregate(\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): Map<K, R> {\n    return aggregateTo(mutableMapOf<K, R>(), operation)\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * If the [destination] map already has a value corresponding to some key,\n * then the elements being aggregated for that key are never considered as `first`.\n *\n * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadixTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(\n    destination: M,\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): M {\n    for (e in this.sourceIterator()) {\n        val key = keyOf(e)\n        val accumulator = destination[key]\n        destination[key] = operation(key, accumulator, e, accumulator == null && !destination.containsKey(key))\n    }\n    return destination\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * If the [destination] map already has a value corresponding to some key, that value is used as an initial value of\n * the accumulator for that group and the [initialValueSelector] function is not called for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in a new map.\n * An initial value of accumulator is the first element of the group.\n *\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowels\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K> Grouping<T, K>.reduce(\n    operation: (key: K, accumulator: S, element: T) -> S\n): Map<K, S> =\n    aggregate { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the first element of the group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group and the first element of that group is also\n * subjected to the [operation].\n\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being folded;\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowelsTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T, K>.reduceTo(\n    destination: M,\n    operation: (key: K, accumulator: S, element: T) -> S\n): M =\n    aggregateTo(destination) { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n\n/**\n * Groups elements from the [Grouping] source by key and counts elements in each group to the given [destination] map.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the counter for that group.\n *\n * @return the [destination] map associating the key of each group with the count of elements in the group.\n *\n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M): M =\n    foldTo(destination, 0) { acc, _ -> acc + 1 }\n\n/*\n/**\n * Groups elements from the [Grouping] source by key and sums values provided by the [valueSelector] function for elements in each group\n * to the given [destination] map.\n *\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the sum for that group.\n *\n * @return the [destination] map associating the key of each group with the sum of elements in the group.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachSumOfTo(destination: M, valueSelector: (T) -> Int): M =\n        foldTo(destination, 0) { acc, e -> acc + valueSelector(e)}\n*/\n\n\n/*\n// TODO: sum by long and by double overloads\n\npublic inline fun <T, K, M : MutableMap<in K, Long>> Grouping<T, K>.sumEachByLongTo(destination: M, valueSelector: (T) -> Long): M =\n        foldTo(destination, 0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByLong(valueSelector: (T) -> Long): Map<K, Long> =\n        fold(0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K, M : MutableMap<in K, Double>> Grouping<T, K>.sumEachByDoubleTo(destination: M, valueSelector: (T) -> Double): M =\n        foldTo(destination, 0.0) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByDouble(valueSelector: (T) -> Double): Map<K, Double> =\n        fold(0.0) { acc, e -> acc + valueSelector(e)}\n*/\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.internal.InlineOnly\n\n\n/**\n * Returns a hash code value for the object or zero if the object is `null`.\n *\n * @see Any.hashCode\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun Any?.hashCode(): Int = this?.hashCode() ?: 0\n",null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n",null,"// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.asm.*\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * Computes the possible values of a register right before a specific instruction.\n */\nfun getRegisterValue(cfg: ControlFlowGraph, instruction: Instruction, register: Int): ValueSet {\n    require(register in 0..255) {\n        \"register should be between 0 and 255, inclusive but was $register.\"\n    }\n\n    val block = cfg.getBlockForInstruction(instruction)\n\n    return RegisterValueFinder().find(\n        mutableSetOf(),\n        block,\n        block.indexOfInstruction(instruction),\n        register\n    )\n}\n\nprivate class RegisterValueFinder {\n    private var iterations = 0\n\n    // TODO: Deal with incorrect argument types.\n    fun find(\n        path: MutableSet<BasicBlock>,\n        block: BasicBlock,\n        end: Int,\n        register: Int,\n    ): ValueSet {\n        if (++iterations > 100) {\n            logger.warn { \"Too many iterations.\" }\n            return ValueSet.all()\n        }\n\n        for (i in end - 1 downTo block.start) {\n            val instruction = block.segment.instructions[i]\n            val args = instruction.args\n\n            when (instruction.opcode.code) {\n                OP_SYNC.code -> {\n                    // After a sync call, concurrent code could have modified the register. We don't\n                    // check whether concurrent code *ever* writes to the register to possibly\n                    // continue the analysis.\n                    return ValueSet.all()\n                }\n\n                OP_VA_CALL.code -> {\n                    val value = vaCall(path, block, i, register)\n                    if (value.isNotEmpty()) return value\n                }\n\n                OP_LET.code -> {\n                    if (args[0].value == register) {\n                        return find(LinkedHashSet(path), block, i, (args[1] as IntArg).value)\n                    }\n                }\n\n                OP_LETI.code,\n                OP_LETB.code,\n                OP_LETW.code,\n                OP_SYNC_LETI.code,\n                -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of((args[1] as IntArg).value)\n                    }\n                }\n\n                OP_SET.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(1)\n                    }\n                }\n\n                OP_CLEAR.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(0)\n                    }\n                }\n\n                OP_REV.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n\n                        return if (prevVals.size == 1L && prevVals[0] == 0) {\n                            ValueSet.of(1)\n                        } else if (0 in prevVals) {\n                            ValueSet.ofInterval(0, 1)\n                        } else {\n                            ValueSet.of(0)\n                        }\n                    }\n                }\n\n                OP_ADDI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals += (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_SUBI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals -= (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_MULI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals *= (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_DIVI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals /= (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_IF_ZONE_CLEAR.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 1)\n                    }\n                }\n\n                OP_GET_DIFFLVL.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 2)\n                    }\n                }\n\n                OP_GET_SLOTNUMBER.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 3)\n                    }\n                }\n\n                OP_GET_RANDOM.code -> {\n                    if (args[1].value == register) {\n                        // TODO: undefined values.\n                        val min = find(\n                            LinkedHashSet(path),\n                            block,\n                            i,\n                            (args[0] as IntArg).value\n                        ).minOrNull()!!\n\n                        val max = max(\n                            find(\n                                LinkedHashSet(path),\n                                block,\n                                i,\n                                (args[0] as IntArg).value + 1\n                            ).maxOrNull()!!,\n                            min + 1,\n                        )\n\n                        return ValueSet.ofInterval(min, max - 1)\n                    }\n                }\n\n                OP_STACK_PUSHM.code,\n                OP_STACK_POPM.code,\n                -> {\n                    val minReg = (args[0] as IntArg).value\n                    val maxReg = (args[0] as IntArg).value + (args[1] as IntArg).value\n\n                    if (register in minReg until maxReg) {\n                        return ValueSet.all()\n                    }\n                }\n\n                else -> {\n                    // Assume any other opcodes that write to the register can produce any value.\n                    val params = instruction.opcode.params\n                    val argLen = min(args.size, params.size)\n\n                    for (j in 0 until argLen) {\n                        val param = params[j]\n\n                        if (param.type is RegType && param.type.registers != null) {\n                            val regRef = (args[j] as IntArg).value\n\n                            for ((k, regParam) in param.type.registers.withIndex()) {\n                                if (regParam.write && regRef + k == register) {\n                                    return ValueSet.all()\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        val values = ValueSet.empty()\n        path.add(block)\n\n        for (from in block.from) {\n            // Bail out from loops.\n            if (from in path) {\n                return ValueSet.all()\n            }\n\n            values.union(find(LinkedHashSet(path), from, from.end, register))\n        }\n\n        // If values is empty at this point, we know nothing ever sets the register's value from\n        // this thread or handler. Concurrent code could have modified it, we don't yet try to\n        // exclude this possibility so we just return all values.\n        if (values.isEmpty()) {\n            return ValueSet.all()\n        }\n\n        return values\n    }\n\n    /**\n     * After a va_start instruction, 0 or more arg_push instructions can be used. When va_call is\n     * executed the values on the stack will become the values of registers r1..r7 (inclusive) in\n     * the order that they were pushed.\n     *\n     * E.g.:\n     *\n     * va_start\n     * arg_pushl 10\n     * arg_pushl 20\n     * va_call 777\n     * va_end\n     *\n     * This means call 777 with r1 = 10 and r2 = 20.\n     */\n    private fun vaCall(\n        path: MutableSet<BasicBlock>,\n        block: BasicBlock,\n        vaCallIdx: Int,\n        register: Int,\n    ): ValueSet {\n        if (register !in 1..7) return ValueSet.empty()\n\n        var vaStartIdx = -1\n        val stack = mutableListOf<Instruction>()\n\n        for (i in block.start until vaCallIdx) {\n            val instruction = block.segment.instructions[i]\n            val opcode = instruction.opcode\n\n            if (opcode.code == OP_VA_START.code) {\n                vaStartIdx = i\n            } else if (vaStartIdx != -1) {\n                when (opcode.code) {\n                    OP_ARG_PUSHR.code,\n                    OP_ARG_PUSHL.code,\n                    OP_ARG_PUSHB.code,\n                    OP_ARG_PUSHW.code,\n                    OP_ARG_PUSHA.code,\n                    OP_ARG_PUSHO.code,\n                    OP_ARG_PUSHS.code,\n                    -> stack.add(instruction)\n                }\n            }\n        }\n\n        return if (register in 1..stack.size) {\n            val instruction = stack[register - 1]\n            val arg = instruction.args.first()\n\n            when (instruction.opcode.code) {\n                OP_ARG_PUSHR.code ->\n                    find(LinkedHashSet(path), block, vaStartIdx, (arg as IntArg).value)\n\n                OP_ARG_PUSHL.code,\n                OP_ARG_PUSHB.code,\n                OP_ARG_PUSHW.code,\n                -> ValueSet.of((arg as IntArg).value)\n\n                // TODO: Deal with strings.\n                else -> ValueSet.all() // String or pointer\n            }\n        } else {\n            ValueSet.of(0)\n        }\n    }\n}\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport kotlin.math.max\nimport kotlin.math.min\n\n/**\n * Represents a sorted set of integers.\n */\nclass ValueSet private constructor(private val intervals: MutableList<Interval>) : Iterable<Int> {\n    val size: Long\n        get() = intervals.fold(0L) { acc, i -> acc + i.end - i.start + 1L }\n\n    operator fun get(i: Int): Int? {\n        var idx = i\n\n        for ((start, end) in intervals) {\n            val size = end - start + 1\n\n            if (idx < size) {\n                return start + idx\n            } else {\n                idx -= size\n            }\n        }\n\n        return null\n    }\n\n    fun isEmpty(): Boolean =\n        intervals.isEmpty()\n\n    fun isNotEmpty(): Boolean =\n        intervals.isNotEmpty()\n\n    fun minOrNull(): Int? =\n        intervals.firstOrNull()?.start\n\n    fun maxOrNull(): Int? =\n        intervals.lastOrNull()?.end\n\n    operator fun contains(value: Int): Boolean {\n        for (int in intervals) {\n            if (value in int) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    /**\n     * Sets this ValueSet to the given integer.\n     */\n    fun setValue(value: Int): ValueSet {\n        intervals.clear()\n        intervals.add(Interval(value, value))\n        return this\n    }\n\n    /**\n     * Sets this ValueSet to the values in the given interval.\n     *\n     * @param start lower bound, inclusive\n     * @param end upper bound, inclusive\n     */\n    fun setInterval(start: Int, end: Int): ValueSet {\n        require(end >= start) {\n            \"Interval upper bound should be greater than or equal to lower bound, got [${start}, ${end}].\"\n        }\n\n        intervals.clear()\n        intervals.add(Interval(start, end))\n        return this\n    }\n\n    /**\n     * Scalar addition.\n     */\n    operator fun plusAssign(scalar: Int) {\n        if (scalar >= 0) {\n            var i = 0\n            var addI = 0\n\n            while (i < intervals.size) {\n                val int = intervals[i]\n                val oldStart = int.start\n                val oldEnd = int.end\n                int.start += scalar\n                int.end += scalar\n\n                if (int.start < oldStart) {\n                    // Integer overflow of both start and end.\n                    intervals.removeAt(i)\n                    intervals.add(addI++, int)\n                } else if (int.end < oldEnd) {\n                    // Integer overflow of end.\n                    val newEnd = int.end\n                    int.end = Int.MAX_VALUE\n\n                    if (newEnd + 1 == intervals.first().start) {\n                        intervals.first().start = Int.MIN_VALUE\n                    } else {\n                        intervals.add(0, Interval(Int.MIN_VALUE, newEnd))\n                        addI++\n                        // Increment i twice because we left this interval and inserted a new one.\n                        i++\n                    }\n                }\n\n                i++\n            }\n        } else {\n            var i = intervals.lastIndex\n            var addI = 0\n\n            while (i >= 0) {\n                val int = intervals[i]\n                val oldStart = int.start\n                val oldEnd = int.end\n                int.start += scalar\n                int.end += scalar\n\n                if (int.end > oldEnd) {\n                    // Integer underflow of both start and end.\n                    intervals.removeAt(i)\n                    intervals.add(intervals.size - addI++, int)\n                } else if (int.start > oldStart) {\n                    // Integer underflow of start.\n                    val newStart = int.start\n                    int.start = Int.MIN_VALUE\n\n                    if (newStart - 1 == intervals.last().end) {\n                        intervals.last().end = Int.MAX_VALUE\n                    } else {\n                        intervals.add(Interval(newStart, Int.MAX_VALUE))\n                        addI++\n                    }\n                }\n\n                i--\n            }\n        }\n    }\n\n    /**\n     * Scalar subtraction.\n     */\n    operator fun minusAssign(scalar: Int) {\n        plusAssign(-scalar)\n    }\n\n    /**\n     * Doesn't take into account integer overflow.\n     */\n    operator fun timesAssign(s: Int) {\n        for (int in intervals) {\n            int.start *= s\n            int.end *= s\n        }\n    }\n\n    /**\n     * Integer division.\n     */\n    operator fun divAssign(s: Int) {\n        for (int in intervals) {\n            int.start /= s\n            int.end /= s\n        }\n    }\n\n    fun union(other: ValueSet): ValueSet {\n        var i = 0\n\n        outer@ for (b in other.intervals) {\n            while (i < intervals.size) {\n                val a = intervals[i]\n\n                if (b.end < a.start - 1L) {\n                    // b lies entirely before a, insert it right before a.\n                    intervals.add(i, b.copy())\n                    i++\n                    continue@outer\n                } else if (b.start <= a.end + 1L) {\n                    // a and b overlap or form a continuous interval (e.g. [1, 2] and [3, 4]).\n                    a.start = min(a.start, b.start)\n\n                    // Merge all intervals that overlap with b.\n                    val j = i + 1\n\n                    while (j < intervals.size) {\n                        if (b.end >= intervals[j].start - 1L) {\n                            a.end = intervals[j].end\n                            intervals.removeAt(j)\n                        } else {\n                            break\n                        }\n                    }\n\n                    a.end = max(a.end, b.end)\n                    i++\n                    continue@outer\n                } else {\n                    // b lies entirely after a, check next a.\n                    i++\n                }\n            }\n\n            // b lies after every a, add it to the end of our intervals.\n            intervals.add(b.copy())\n        }\n\n        return this\n    }\n\n    override fun iterator(): Iterator<Int> =\n        object : Iterator<Int> {\n            private var intIdx = 0\n            private var nextValue: Int? = minOrNull()\n\n            override fun hasNext(): Boolean =\n                nextValue != null\n\n            override fun next(): Int {\n                val v = nextValue ?: throw NoSuchElementException()\n\n                nextValue =\n                    if (v < intervals[intIdx].end) {\n                        v + 1\n                    } else {\n                        intIdx++\n\n                        if (intIdx < intervals.size) {\n                            intervals[intIdx].start\n                        } else {\n                            null\n                        }\n                    }\n\n                return v\n            }\n        }\n\n    companion object {\n        /**\n         * Returns an empty [ValueSet].\n         */\n        fun empty(): ValueSet = ValueSet(mutableListOf())\n\n        /**\n         * Returns a [ValueSet] containing all possible Int values.\n         */\n        fun all(): ValueSet = ofInterval(Int.MIN_VALUE, Int.MAX_VALUE)\n\n        /**\n         * Returns a [ValueSet] with a single initial [value].\n         */\n        fun of(value: Int): ValueSet = ValueSet(mutableListOf(Interval(value, value)))\n\n        /**\n         * Returns a [ValueSet] with all values between [start] and [end], inclusively.\n         */\n        fun ofInterval(start: Int, end: Int): ValueSet =\n            ValueSet(mutableListOf(Interval(start, end)))\n    }\n}\n\n/**\n * Closed interval [start, end].\n */\nprivate data class Interval(var start: Int, var end: Int) {\n    operator fun contains(value: Int): Boolean =\n        value in start..end\n}\n","package world.phantasmal.lib\n\nenum class Endianness {\n    Little,\n    Big\n}\n","package world.phantasmal.lib\n\nenum class Episode {\n    I,\n    II,\n    IV;\n\n    fun toInt(): Int = when(this) {\n        I -> 1\n        II -> 2\n        IV -> 4\n    }\n\n    companion object {\n        fun fromInt(episode: Int) = when (episode) {\n            1 -> I\n            2 -> II\n            4 -> IV\n            else -> error(\"$episode is invalid.\")\n        }\n    }\n}\n","package world.phantasmal.lib.asm\n\nimport world.phantasmal.core.fastIsWhitespace\nimport world.phantasmal.core.fastReplace\nimport world.phantasmal.core.getCodePointAt\nimport world.phantasmal.core.isDigit\n\nprivate val HEX_INT_REGEX = Regex(\"\"\"^0[xX][0-9a-fA-F]+$\"\"\")\nprivate val FLOAT_REGEX = Regex(\"\"\"^-?\\d+(\\.\\d+)?(e-?\\d+)?$\"\"\")\n\nenum class Token {\n    Int32,\n    Float32,\n    InvalidNumber,\n    Register,\n    Label,\n    CodeSection,\n    DataSection,\n    StrSection,\n    InvalidSection,\n    Str,\n    UnterminatedStr,\n    Ident,\n    InvalidIdent,\n    ArgSeparator,\n}\n\nclass LineTokenizer {\n    private var line = \"\"\n    private var index = 0\n    private var startIndex = 0\n\n    var value: Any? = null\n        private set\n\n    var type: Token? = null\n        private set\n\n    val col: Int get() = startIndex + 1\n    val len: Int get() = index - startIndex\n\n    fun tokenize(line: String) {\n        this.line = line\n        index = 0\n        startIndex = 0\n    }\n\n    val intValue: Int\n        get() {\n            require(type === Token.Int32 || type === Token.Register || type === Token.Label)\n            return value as Int\n        }\n\n    val floatValue: Float\n        get() {\n            require(type === Token.Float32)\n            return value as Float\n        }\n\n    val strValue: String\n        get() {\n            require(\n                type === Token.Str ||\n                        type === Token.UnterminatedStr ||\n                        type === Token.Ident ||\n                        type === Token.InvalidIdent\n            )\n            return value as String\n        }\n\n    fun nextToken(): Boolean {\n        type = null\n        value = null\n\n        while (hasNext()) {\n            startIndex = index\n            val char = peek()\n\n            if (char == '/') {\n                skip()\n\n                if (peek() == '/') {\n                    // It's a comment.\n                    break\n                } else {\n                    back()\n                }\n            }\n\n            if (char.fastIsWhitespace()) {\n                skip()\n                continue\n            }\n\n            if (char == '-' || char.isDigit()) {\n                tokenizeNumberOrLabel()\n            } else if (char == ',') {\n                type = Token.ArgSeparator\n                skip()\n            } else if (char == '.') {\n                tokenizeSection()\n            } else if (char == '\"') {\n                tokenizeString()\n            } else if (char == 'r') {\n                tokenizeRegisterOrIdent()\n            } else {\n                tokenizeIdent()\n            }\n\n            break\n        }\n\n        return if (type == null) {\n            startIndex = line.length\n            index = line.length\n            false\n        } else {\n            true\n        }\n    }\n\n    private fun hasNext(): Boolean = index < line.length\n\n    private fun next(): Char = line[index++]\n\n    private fun peek(): Char = line[index]\n\n    private fun skip() {\n        index++\n    }\n\n    private fun back() {\n        index--\n    }\n\n    private fun slice(from: Int = 0, to: Int = 0): String =\n        line.substring(startIndex + from, index - to)\n\n    private fun eatRestOfToken() {\n        while (hasNext()) {\n            val char = next()\n\n            if (char == ',' || char.fastIsWhitespace()) {\n                back()\n                break\n            }\n        }\n    }\n\n    private fun tokenizeNumberOrLabel() {\n        val firstChar = next()\n        var isLabel = false\n\n        while (hasNext()) {\n            val char = peek()\n\n            if (char == '.' || char == 'e') {\n                tokenizeFloat()\n                return\n            } else if (firstChar == '0' && (char == 'x' || char == 'X')) {\n                tokenizeHexNumber()\n                return\n            } else if (char == ':') {\n                isLabel = true\n                break\n            } else if (char == ',' || char.fastIsWhitespace()) {\n                break\n            } else {\n                skip()\n            }\n        }\n\n        value = slice().toIntOrNull()\n\n        if (isLabel) {\n            skip()\n        }\n\n        type = when {\n            value == null -> Token.InvalidNumber\n            isLabel -> Token.Label\n            else -> Token.Int32\n        }\n    }\n\n    private fun tokenizeHexNumber() {\n        eatRestOfToken()\n        val hexStr = slice()\n\n        if (HEX_INT_REGEX.matches(hexStr)) {\n            value = hexStr.drop(2).toIntOrNull(16)\n\n            if (value != null) {\n                type = Token.Int32\n                return\n            }\n        }\n\n        type = Token.InvalidNumber\n    }\n\n    private fun tokenizeFloat() {\n        eatRestOfToken()\n        val floatStr = slice()\n\n        if (FLOAT_REGEX.matches(floatStr)) {\n            value = floatStr.toFloatOrNull()\n\n            if (value != null) {\n                type = Token.Float32\n                return\n            }\n        }\n\n        type = Token.InvalidNumber\n    }\n\n    private fun tokenizeRegisterOrIdent() {\n        skip()\n        var isRegister = false\n\n        while (hasNext()) {\n            val char = peek()\n\n            if (char.isDigit()) {\n                isRegister = true\n                skip()\n            } else {\n                break\n            }\n        }\n\n        if (isRegister) {\n            value = slice(from = 1).toInt()\n            type = Token.Register\n        } else {\n            back()\n            tokenizeIdent()\n        }\n    }\n\n    private fun tokenizeSection() {\n        while (hasNext()) {\n            if (peek().fastIsWhitespace()) {\n                break\n            } else {\n                skip()\n            }\n        }\n\n        type = when (slice()) {\n            \".code\" -> Token.CodeSection\n            \".data\" -> Token.DataSection\n            \".string\" -> Token.StrSection\n            else -> Token.InvalidSection\n        }\n    }\n\n    private fun tokenizeString() {\n        skip()\n        var prevWasBackSpace = false\n        var terminated = false\n\n        loop@ // Use label as workaround for https://youtrack.jetbrains.com/issue/KT-43943.\n        while (hasNext()) {\n            when (peek()) {\n                '\\\\' -> {\n                    prevWasBackSpace = true\n                }\n                '\"' -> {\n                    if (!prevWasBackSpace) {\n                        skip()\n                        terminated = true\n                        break@loop\n                    }\n\n                    prevWasBackSpace = false\n                }\n                else -> {\n                    prevWasBackSpace = false\n                }\n            }\n\n            skip()\n        }\n\n        value = slice(from = 1, to = if (terminated) 1 else 0)\n            .fastReplace(\"\\\\\\\"\", \"\\\"\")\n            .fastReplace(\"\\\\n\", \"\\n\")\n\n        type = if (terminated) {\n            Token.Str\n        } else {\n            Token.UnterminatedStr\n        }\n    }\n\n    private fun tokenizeIdent() {\n        while (hasNext()) {\n            val char = peek()\n\n            if (char == ',' || char.fastIsWhitespace()) {\n                break\n            } else if (char == '/') {\n                skip()\n\n                if (peek() == '/') {\n                    back()\n                    break\n                }\n            } else {\n                skip()\n            }\n        }\n\n        val ident = slice()\n        value = ident\n\n        if (ident.getCodePointAt(0) !in ('a'.toInt())..('z'.toInt())) {\n            type = Token.InvalidIdent\n            return\n        }\n\n        for (i in 1 until ident.length) {\n            when (ident.getCodePointAt(i)) {\n                in ('0'.toInt())..('9'.toInt()),\n                in ('a'.toInt())..('z'.toInt()),\n                ('_').toInt(),\n                ('=').toInt(),\n                ('<').toInt(),\n                ('>').toInt(),\n                ('!').toInt(),\n                -> {\n                    // Valid character.\n                }\n                else -> {\n                    type = Token.InvalidIdent\n                    return\n                }\n            }\n        }\n\n        type = Token.Ident\n    }\n}\n","package world.phantasmal.lib.asm\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.Problem\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.buffer.Buffer\nimport kotlin.time.measureTimedValue\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AssemblyProblem(\n    severity: Severity,\n    uiMessage: String,\n    message: String? = null,\n    cause: Throwable? = null,\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n) : Problem(severity, uiMessage, message, cause)\n\nfun assemble(\n    asm: List<String>,\n    inlineStackArgs: Boolean = true,\n): PwResult<BytecodeIr> {\n    logger.trace {\n        \"Assembling ${asm.size} lines with ${\n            if (inlineStackArgs) \"inline stack arguments\" else \"stack push instructions\"\n        }.\"\n    }\n\n    val (result, time) = measureTimedValue { Assembler(asm, inlineStackArgs).assemble() }\n\n    logger.trace {\n        val warnings = result.problems.count { it.severity == Severity.Warning }\n        val errors = result.problems.count { it.severity == Severity.Error }\n\n        \"Assembly finished in ${time.inMilliseconds}ms with $warnings warnings and $errors errors.\"\n    }\n\n    return result\n}\n\nprivate class Assembler(private val asm: List<String>, private val inlineStackArgs: Boolean) {\n    private var lineNo = 1\n    private val tokenizer = LineTokenizer()\n    private var ir: MutableList<Segment> = mutableListOf()\n\n    /**\n     * The current segment.\n     */\n    private var segment: Segment? = null\n\n    /**\n     * Encountered labels.\n     */\n    private val labels: MutableSet<Int> = mutableSetOf()\n    private var section: SegmentType = SegmentType.Instructions\n    private var firstSectionMarker = true\n    private var prevLineHadLabel = false\n\n    private val result = PwResult.build<BytecodeIr>(logger)\n\n    fun assemble(): PwResult<BytecodeIr> {\n        // Tokenize and assemble line by line.\n        for (line in asm) {\n            tokenizer.tokenize(line)\n            tokenizer.nextToken()\n\n            if (tokenizer.type != null) {\n                var hasLabel = false\n\n                // Token type checks are ordered from most frequent to least frequent for increased\n                // perf.\n                when (tokenizer.type) {\n                    Token.Ident -> {\n                        if (section === SegmentType.Instructions) {\n                            parseInstruction()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.Label -> {\n                        parseLabel()\n                        hasLabel = true\n                    }\n                    Token.CodeSection -> {\n                        parseCodeSection()\n                    }\n                    Token.DataSection -> {\n                        parseDataSection()\n                    }\n                    Token.StrSection -> {\n                        parseStrSection()\n                    }\n                    Token.Int32 -> {\n                        if (section === SegmentType.Data) {\n                            parseBytes()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.Str -> {\n                        if (section === SegmentType.String) {\n                            parseString()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.InvalidSection -> {\n                        addError(\"Invalid section type.\")\n                    }\n                    Token.InvalidIdent -> {\n                        addError(\"Invalid identifier.\")\n                    }\n                    else -> {\n                        addUnexpectedTokenError()\n                    }\n                }\n\n                prevLineHadLabel = hasLabel\n            }\n\n            lineNo++\n        }\n\n        return result.success(BytecodeIr(ir))\n    }\n\n    private fun addInstruction(\n        opcode: Opcode,\n        args: List<Arg>,\n        mnemonicSrcLoc: SrcLoc?,\n        valid: Boolean,\n        argSrcLocs: List<ArgSrcLoc>,\n        trailingArgSeparator: Boolean,\n    ) {\n        when (val seg = segment) {\n            null -> {\n                // Unreachable code, technically valid.\n                segment = InstructionSegment(\n                    labels = mutableListOf(),\n                    instructions = mutableListOf(),\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is InstructionSegment -> {\n                seg.instructions.add(\n                    Instruction(\n                        opcode,\n                        args,\n                        valid,\n                        InstructionSrcLoc(\n                            mnemonic = mnemonicSrcLoc,\n                            args = argSrcLocs,\n                            trailingArgSeparator,\n                        ),\n                    )\n                )\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected instructions segment.\" }\n            }\n        }\n    }\n\n    private fun addBytes(bytes: ByteArray) {\n        when (val seg = segment) {\n            null -> {\n                // Unaddressable data, technically valid.\n                segment = DataSegment(\n                    labels = mutableListOf(),\n                    data = Buffer.fromByteArray(bytes),\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is DataSegment -> {\n                val oldSize = seg.data.size\n                seg.data.size += bytes.size\n\n                for (i in bytes.indices) {\n                    seg.data.setByte(i + oldSize, bytes[i])\n                }\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected data segment.\" }\n            }\n        }\n    }\n\n    private fun addString(str: String) {\n        when (val seg = segment) {\n            null -> {\n                // Unaddressable data, technically valid.\n                segment = StringSegment(\n                    labels = mutableListOf(),\n                    value = str,\n                    bytecodeSize = null,\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is StringSegment -> {\n                seg.value += str\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected string segment.\" }\n            }\n        }\n    }\n\n    private fun addError(col: Int, len: Int, uiMessage: String, message: String? = null) {\n        result.addProblem(\n            AssemblyProblem(\n                Severity.Error,\n                uiMessage,\n                message ?: \"$uiMessage At $lineNo:$col.\",\n                lineNo = lineNo,\n                col = col,\n                len = len\n            )\n        )\n    }\n\n    private fun addError(uiMessage: String, message: String? = null) {\n        addError(tokenizer.col, tokenizer.len, uiMessage, message)\n    }\n\n    private fun addUnexpectedTokenError() {\n        addError(\n            \"Unexpected token.\",\n            \"Unexpected ${tokenizer.type?.name} at $lineNo:${tokenizer.col}.\",\n        )\n    }\n\n    private fun addWarning(uiMessage: String) {\n        result.addProblem(\n            AssemblyProblem(\n                Severity.Warning,\n                uiMessage,\n                lineNo = lineNo,\n                col = tokenizer.col,\n                len = tokenizer.len,\n            )\n        )\n    }\n\n    private fun parseLabel() {\n        val label = tokenizer.intValue\n\n        if (!labels.add(label)) {\n            addError(\"Duplicate label.\")\n        }\n\n        val srcLoc = srcLocFromTokenizer()\n\n        if (prevLineHadLabel) {\n            val segment = ir.last()\n            segment.labels.add(label)\n            segment.srcLoc.labels.add(srcLoc)\n        }\n\n        tokenizer.nextToken()\n\n        when (section) {\n            SegmentType.Instructions -> {\n                if (!prevLineHadLabel) {\n                    segment = InstructionSegment(\n                        labels = mutableListOf(label),\n                        instructions = mutableListOf(),\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Ident) {\n                    parseInstruction()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected opcode mnemonic.\")\n                }\n            }\n\n            SegmentType.Data -> {\n                if (!prevLineHadLabel) {\n                    segment = DataSegment(\n                        labels = mutableListOf(label),\n                        data = Buffer.withCapacity(0),\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Int32) {\n                    parseBytes()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected bytes.\")\n                }\n            }\n\n            SegmentType.String -> {\n                if (!prevLineHadLabel) {\n                    segment = StringSegment(\n                        labels = mutableListOf(label),\n                        value = \"\",\n                        bytecodeSize = null,\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Str) {\n                    parseString()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected a string.\")\n                }\n            }\n        }\n    }\n\n    private fun parseCodeSection() {\n        parseSection(SegmentType.Instructions)\n    }\n\n    private fun parseDataSection() {\n        parseSection(SegmentType.Data)\n    }\n\n    private fun parseStrSection() {\n        parseSection(SegmentType.String)\n    }\n\n    private fun parseSection(section: SegmentType) {\n        if (this.section == section && !firstSectionMarker) {\n            addWarning(\"Unnecessary section marker.\")\n        }\n\n        this.section = section\n        firstSectionMarker = false\n\n        if (tokenizer.nextToken()) {\n            addUnexpectedTokenError()\n        }\n    }\n\n    private fun parseInstruction() {\n        val opcode = mnemonicToOpcode(tokenizer.strValue)\n        val mnemonicSrcLoc = srcLocFromTokenizer()\n\n        if (opcode == null) {\n            addError(\"Unknown opcode.\")\n        } else {\n            if (opcode.stack !== StackInteraction.Pop) {\n                // Arguments should be inlined immediately after the opcode.\n                parseArgs(\n                    opcode,\n                    mnemonicSrcLoc,\n                    stack = false,\n                )\n            } else {\n                // Arguments should be passed to the opcode via the stack.\n                parseArgs(\n                    opcode,\n                    mnemonicSrcLoc,\n                    stack = true,\n                )\n            }\n        }\n    }\n\n    private fun parseArgs(opcode: Opcode, mnemonicSrcLoc: SrcLoc, stack: Boolean) {\n        val immediateArgs = mutableListOf<Arg>()\n        val srcLocs = mutableListOf<ArgSrcLoc>()\n        var argCount = 0\n        var valid = true\n        var shouldBeArg = true\n        var paramI = 0\n        var prevToken: Token?\n        var prevCol: Int\n        var prevLen: Int\n        var token = tokenizer.type\n        var col = tokenizer.col\n        var len = tokenizer.len\n\n        tokenizer.nextToken()\n\n        while (true) {\n            // Previous token data.\n            prevToken = token\n            prevCol = col\n            prevLen = len\n\n            // Current token data.\n            token = tokenizer.type\n            col = tokenizer.col\n            len = tokenizer.len\n            val value = tokenizer.value\n\n            if (token == null) {\n                break\n            }\n\n            // Next token data.\n            tokenizer.nextToken()\n            val nextToken = tokenizer.type\n            val nextCol = tokenizer.col\n            val nextLen = tokenizer.len\n\n            val param = opcode.params.getOrNull(paramI)\n            val paramType = param?.type\n\n            // Coarse source position, including surrounding whitespace.\n            val coarseCol = prevCol + prevLen\n            val coarseLen = when (nextToken) {\n                Token.ArgSeparator -> nextCol + nextLen - coarseCol\n                null -> nextCol - coarseCol + 1\n                else -> nextCol - coarseCol\n            }\n\n            if (token === Token.ArgSeparator) {\n                if (shouldBeArg) {\n                    addError(\"Expected an argument.\")\n                } else if (param == null || !param.varargs) {\n                    paramI++\n                }\n\n                shouldBeArg = true\n            } else {\n                if (!shouldBeArg) {\n                    addError(coarseCol, col - coarseCol, \"Expected a comma.\")\n                }\n\n                shouldBeArg = false\n\n                argCount++\n\n                // Try to match token type to parameter type.\n                var typeMatch: Boolean\n\n                // If arg is nonnull, types match and argument is syntactically valid.\n                val arg: Arg = when (token) {\n                    Token.Int32 -> {\n                        value as Int\n\n                        when (paramType) {\n                            ByteType -> {\n                                typeMatch = true\n                                checkIntValue(col, len, value, 1)\n                            }\n                            ShortType,\n                            is LabelType,\n                            -> {\n                                typeMatch = true\n                                checkIntValue(col, len, value, 2)\n                            }\n                            IntType -> {\n                                typeMatch = true\n                                checkIntValue(col, len, value, 4)\n                            }\n                            FloatType -> {\n                                typeMatch = true\n                                FloatArg(value.toFloat())\n                            }\n                            else -> {\n                                typeMatch = false\n                                IntArg(value)\n                            }\n                        }\n                    }\n\n                    Token.Float32 -> {\n                        typeMatch = paramType === FloatType\n                        FloatArg(value as Float)\n                    }\n\n                    Token.Register -> {\n                        typeMatch = stack ||\n                                paramType === RegVarType ||\n                                paramType is RegType\n\n                        value as Int\n\n                        if (value > 255) {\n                            addError(col, len, \"Invalid register reference, expected r0-r255.\")\n                        }\n\n                        IntArg(value)\n                    }\n\n                    Token.Str -> {\n                        typeMatch = paramType === StringType\n                        StringArg(value as String)\n                    }\n\n                    else -> {\n                        typeMatch = false\n                        UnknownArg(value)\n                    }\n                }\n\n                val srcLoc = ArgSrcLoc(\n                    precise = SrcLoc(lineNo, col, len),\n                    coarse = SrcLoc(lineNo, coarseCol, coarseLen),\n                )\n\n                if (!stack) {\n                    immediateArgs.add(arg)\n                }\n\n                srcLocs.add(srcLoc)\n\n                if (!typeMatch) {\n                    valid = false\n\n                    // Don't add a type errors for surplus arguments.\n                    if (param != null) {\n                        val typeStr = when (param.type) {\n                            ByteType -> \"an 8-bit integer\"\n                            ShortType -> \"a 16-bit integer\"\n                            IntType -> \"a 32-bit integer\"\n                            FloatType -> \"a float\"\n\n                            ILabelType,\n                            ILabelVarType,\n                            -> \"an instruction label\"\n\n                            DLabelType -> \"a data label\"\n                            SLabelType -> \"a string label\"\n\n                            is LabelType -> \"a label\"\n\n                            StringType -> \"a string\"\n\n                            RegVarType,\n                            is RegType,\n                            -> \"a register reference\"\n\n                            PointerType -> \"a pointer\" // No known opcodes directly take a pointer.\n\n                            AnyType.Instance -> \"an argument\" // Should never happen.\n                        }\n\n                        addError(col, len, \"Expected ${typeStr}.\")\n                    }\n                }\n\n                // Inject stack push instructions if necessary. Don't inject push instruction if\n                // there's no parameter for the argument (i.e. too many arguments).\n                if (stack && paramType != null) {\n                    // If the token is a register, push it as a register, otherwise coerce type.\n                    if (token === Token.Register) {\n                        if (paramType is RegType) {\n                            addInstruction(\n                                OP_ARG_PUSHB,\n                                listOf(arg),\n                                mnemonicSrcLoc = null,\n                                valid = true,\n                                listOf(srcLoc),\n                                trailingArgSeparator = false,\n                            )\n                        } else {\n                            addInstruction(\n                                OP_ARG_PUSHR,\n                                listOf(arg),\n                                mnemonicSrcLoc = null,\n                                valid = true,\n                                listOf(srcLoc),\n                                trailingArgSeparator = false,\n                            )\n                        }\n                    } else {\n                        when (paramType) {\n                            ByteType,\n                            is RegType,\n                            -> {\n                                addInstruction(\n                                    OP_ARG_PUSHB,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            ShortType,\n                            is LabelType,\n                            -> {\n                                addInstruction(\n                                    OP_ARG_PUSHW,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            IntType -> {\n                                addInstruction(\n                                    OP_ARG_PUSHL,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            // Floats are pushed as ints.\n                            FloatType -> {\n                                addInstruction(\n                                    OP_ARG_PUSHL,\n                                    listOf(IntArg((arg as FloatArg).value.toRawBits())),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            StringType -> {\n                                addInstruction(\n                                    OP_ARG_PUSHS,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            else -> {\n                                logger.error {\n                                    \"Line $lineNo: Type ${paramType::class} not implemented.\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        val paramCount =\n            if (!inlineStackArgs && opcode.stack === StackInteraction.Pop) 0\n            else opcode.params.size\n\n        val trailingArgSeparator = prevToken === Token.ArgSeparator\n\n        // Length from the start of the mnemonic until the end of the last token.\n        val errorLength = prevCol + prevLen - mnemonicSrcLoc.col\n\n        if (opcode.varargs) {\n            // Argument count should be equal to or greater than the amount of parameters for variadic\n            // opcodes.\n            if (argCount < paramCount) {\n                valid = false\n                addError(\n                    mnemonicSrcLoc.col,\n                    errorLength,\n                    \"Expected at least $paramCount argument${\n                        if (paramCount == 1) \"\" else \"s\"\n                    }, got $argCount.\",\n                )\n            }\n        } else {\n            // Argument count should match parameter count exactly for non-variadic opcodes.\n            if (argCount != paramCount) {\n                valid = false\n                addError(\n                    mnemonicSrcLoc.col,\n                    errorLength,\n                    \"Expected $paramCount argument${\n                        if (paramCount == 1) \"\" else \"s\"\n                    }, got $argCount.\",\n                )\n            }\n        }\n\n        // Trailing argument separators are not allowed.\n        if (trailingArgSeparator) {\n            addError(prevCol, prevLen, \"Unexpected comma.\")\n        }\n\n        addInstruction(opcode, immediateArgs, mnemonicSrcLoc, valid, srcLocs, trailingArgSeparator)\n    }\n\n    private fun checkIntValue(col: Int, len: Int, value: Int, size: Int): Arg {\n        // Fast-path 32-bit ints for improved JS perf. Otherwise maxValue would have to be a Long\n        // or UInt, which incurs a perf hit in JS.\n        if (size != 4) {\n            val bitSize = 8 * size\n            // Minimum of the signed version of this integer type.\n            val minValue = -(1 shl (bitSize - 1))\n            // Maximum of the unsigned version of this integer type.\n            val maxValue = (1 shl (bitSize)) - 1\n\n            when {\n                value < minValue -> {\n                    addError(col, len, \"${bitSize}-Bit integer can't be less than ${minValue}.\")\n                }\n                value > maxValue -> {\n                    addError(col, len, \"${bitSize}-Bit integer can't be greater than ${maxValue}.\")\n                }\n            }\n        }\n\n        return IntArg(value)\n    }\n\n    private fun parseBytes() {\n        val bytes = mutableListOf<Byte>()\n\n        while (tokenizer.type === Token.Int32) {\n            val value = tokenizer.intValue\n\n            if (value < 0) {\n                addError(\"Unsigned 8-bit integer can't be less than 0.\")\n            } else if (value > 255) {\n                addError(\"Unsigned 8-bit integer can't be greater than 255.\")\n            }\n\n            bytes.add(value.toByte())\n\n            tokenizer.nextToken()\n        }\n\n        if (tokenizer.type != null) {\n            addError(\"Expected an unsigned 8-bit integer.\")\n        }\n\n        addBytes(bytes.toByteArray())\n    }\n\n    private fun parseString() {\n        addString(tokenizer.strValue.replace(\"\\n\", \"<cr>\"))\n\n        if (tokenizer.nextToken()) {\n            addUnexpectedTokenError()\n        }\n    }\n\n    private fun srcLocFromTokenizer(): SrcLoc = SrcLoc(lineNo, tokenizer.col, tokenizer.len)\n}\n","package world.phantasmal.lib.asm\n\nimport world.phantasmal.core.unsafe.unsafeAssertNotNull\nimport world.phantasmal.lib.buffer.Buffer\nimport kotlin.math.ceil\n\n/**\n * Intermediate representation of PSO bytecode. Used by most ASM/bytecode analysis code.\n */\nclass BytecodeIr(\n    val segments: List<Segment>,\n) {\n    fun instructionSegments(): List<InstructionSegment> =\n        segments.filterIsInstance<InstructionSegment>()\n\n    fun copy(): BytecodeIr =\n        BytecodeIr(segments.map { it.copy() })\n}\n\nenum class SegmentType {\n    Instructions,\n    Data,\n    String,\n}\n\n/**\n * Segment of bytecode. A segment starts with an instruction, data block or string that is\n * referenced by one or more labels. The segment ends right before the next instruction, data block\n * or string that is referenced by a label.\n */\nsealed class Segment(\n    val type: SegmentType,\n    val labels: MutableList<Int>,\n    val srcLoc: SegmentSrcLoc,\n) {\n    abstract fun size(dcGcFormat: Boolean): Int\n    abstract fun copy(): Segment\n}\n\nclass InstructionSegment(\n    labels: MutableList<Int>,\n    val instructions: MutableList<Instruction>,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.Instructions, labels, srcLoc) {\n    override fun size(dcGcFormat: Boolean): Int =\n        instructions.sumBy { it.getSize(dcGcFormat) }\n\n    override fun copy(): InstructionSegment =\n        InstructionSegment(\n            ArrayList(labels),\n            instructions.mapTo(ArrayList(instructions.size)) { it.copy() },\n            srcLoc.copy(),\n        )\n}\n\nclass DataSegment(\n    labels: MutableList<Int>,\n    val data: Buffer,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.Data, labels, srcLoc) {\n    override fun size(dcGcFormat: Boolean): Int =\n        data.size\n\n    override fun copy(): DataSegment =\n        DataSegment(ArrayList(labels), data.copy(), srcLoc.copy())\n}\n\nclass StringSegment(\n    labels: MutableList<Int>,\n    value: String,\n    /**\n     * Normally string segments have a byte length that is a multiple of 4, but some bytecode is\n     * malformed so we store the initial size in the bytecode.\n     */\n    private var bytecodeSize: Int?,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.String, labels, srcLoc) {\n    var value: String = value\n        set(value) {\n            bytecodeSize = null\n            field = value\n        }\n\n    override fun size(dcGcFormat: Boolean): Int =\n        // String segments should be multiples of 4 bytes.\n        bytecodeSize\n            ?: if (dcGcFormat) {\n                4 * ceil((value.length + 1) / 4.0).toInt()\n            } else {\n                4 * ceil((value.length + 1) / 2.0).toInt()\n            }\n\n    override fun copy(): StringSegment =\n        StringSegment(ArrayList(labels), value, bytecodeSize, srcLoc.copy())\n}\n\n/**\n * Opcode invocation.\n */\nclass Instruction(\n    val opcode: Opcode,\n    /**\n     * Immediate arguments for the opcode.\n     */\n    val args: List<Arg>,\n    val valid: Boolean,\n    val srcLoc: InstructionSrcLoc?,\n) {\n    /**\n     * Maps each parameter by index to its immediate arguments.\n     */\n    // Avoid using lazy to keep GC pressure low.\n    private var paramToArgs: List<List<Arg>>? = null\n\n    /**\n     * Returns the immediate arguments for the parameter at the given index.\n     */\n    fun getArgs(paramIndex: Int): List<Arg> {\n        if (paramToArgs == null) {\n            val paramToArgs: MutableList<List<Arg>> = mutableListOf()\n            this.paramToArgs = paramToArgs\n\n            if (opcode.stack !== StackInteraction.Pop) {\n                for (i in opcode.params.indices) {\n                    val param = opcode.params[i]\n\n                    // Variable length arguments are always last, so we can just gobble up all\n                    // arguments from this point.\n                    val pArgs = if (param.varargs) {\n                        check(i == opcode.params.lastIndex)\n                        args.drop(i)\n                    } else {\n                        listOfNotNull(args.getOrNull(i))\n                    }\n\n                    paramToArgs.add(pArgs)\n                }\n            }\n        }\n\n        return unsafeAssertNotNull(paramToArgs)[paramIndex]\n    }\n\n    /**\n     * Returns the source locations of the (immediate or stack) arguments for the parameter at the\n     * given index.\n     */\n    fun getArgSrcLocs(paramIndex: Int): List<ArgSrcLoc> {\n        val argSrcLocs = srcLoc?.args\n            ?: return emptyList()\n\n        return if (opcode.params[paramIndex].varargs) {\n            // Variadic parameters are always last, so we can just gobble up all SrcLocs from\n            // paramIndex onward.\n            argSrcLocs.drop(paramIndex)\n        } else {\n            listOfNotNull(argSrcLocs.getOrNull(paramIndex))\n        }\n    }\n\n    /**\n     * Returns the byte size of the entire instruction, i.e. the sum of the opcode size and all\n     * argument sizes.\n     */\n    fun getSize(dcGcFormat: Boolean): Int {\n        var size = opcode.size\n\n        if (opcode.stack === StackInteraction.Pop) return size\n\n        for (i in opcode.params.indices) {\n            val type = opcode.params[i].type\n            val args = getArgs(i)\n\n            size += when (type) {\n                ByteType -> 1\n\n                // Ensure this case is before the LabelType case because ILabelVarType extends\n                // LabelType.\n                ILabelVarType -> 1 + 2 * args.size\n\n                ShortType -> 2\n\n                IntType,\n                FloatType,\n                -> 4\n\n                StringType -> {\n                    if (dcGcFormat) {\n                        (args[0] as StringArg).value.length + 1\n                    } else {\n                        2 * (args[0] as StringArg).value.length + 2\n                    }\n                }\n\n                RegVarType -> 1 + args.size\n\n                // Check RegRefType and LabelType last, because \"is\" checks are very slow in JS.\n\n                is RegType -> 1\n\n                is LabelType -> 2\n\n                else -> error(\"Parameter type ${type::class} not implemented.\")\n            }\n        }\n\n        return size\n    }\n\n    fun copy(): Instruction =\n        Instruction(opcode, args, valid, srcLoc).also { it.paramToArgs = paramToArgs }\n}\n\n/**\n * Instruction argument.\n */\nsealed class Arg {\n    abstract val value: Any?\n\n    abstract fun coerceInt(): Int\n    abstract fun coerceFloat(): Float\n    abstract fun coerceString(): String\n}\n\ndata class IntArg(override val value: Int) : Arg() {\n    override fun coerceInt(): Int = value\n    override fun coerceFloat(): Float = Float.fromBits(value)\n    override fun coerceString(): String = value.toString()\n}\n\ndata class FloatArg(override val value: Float) : Arg() {\n    override fun coerceInt(): Int = value.toRawBits()\n    override fun coerceFloat(): Float = value\n    override fun coerceString(): String = value.toString()\n}\n\ndata class StringArg(override val value: String) : Arg() {\n    override fun coerceInt(): Int = 0\n    override fun coerceFloat(): Float = 0f\n    override fun coerceString(): String = value\n}\n\ndata class UnknownArg(override val value: Any?) : Arg() {\n    override fun coerceInt(): Int = 0\n    override fun coerceFloat(): Float = 0f\n    override fun coerceString(): String = \"\"\n}\n\n/**\n * Position and length of related source assembly code.\n */\nclass SrcLoc(\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n)\n\n/**\n * Locations of the instruction parts in the source assembly code.\n */\nclass InstructionSrcLoc(\n    val mnemonic: SrcLoc?,\n    /**\n     * Immediate or stack argument locations.\n     */\n    val args: List<ArgSrcLoc> = emptyList(),\n    /**\n     * Does the instruction end with a comma? This can be the case when a user has partially typed\n     * an instruction.\n     */\n    val trailingArgSeparator: Boolean,\n)\n\n/**\n * Location of an instruction argument in the source assembly code.\n */\nclass ArgSrcLoc(\n    /**\n     * The precise location of this argument.\n     */\n    val precise: SrcLoc,\n    /**\n     * The location of this argument, its surrounding whitespace and the following comma if there is\n     * one.\n     */\n    val coarse: SrcLoc,\n)\n\n/**\n * Locations of a segment's labels in the source assembly code.\n */\nclass SegmentSrcLoc(val labels: MutableList<SrcLoc> = mutableListOf()) {\n    fun copy(): SegmentSrcLoc =\n        SegmentSrcLoc(ArrayList(labels))\n}\n","package world.phantasmal.lib.asm\n\nimport world.phantasmal.core.unsafe.UnsafeMap\n\nprivate val MNEMONIC_TO_OPCODES: UnsafeMap<String, Opcode> by lazy {\n    val map = UnsafeMap<String, Opcode>()\n\n    OPCODES.forEach { if (it != null) map.set(it.mnemonic, it) }\n    OPCODES_F8.forEach { if (it != null) map.set(it.mnemonic, it) }\n    OPCODES_F9.forEach { if (it != null) map.set(it.mnemonic, it) }\n\n    map\n}\nprivate val UNKNOWN_OPCODE_MNEMONIC_REGEX = Regex(\"\"\"^unknown_((f8|f9)?[0-9a-f]{2})$\"\"\")\n\n/**\n * Abstract super type of all types.\n */\nsealed class AnyType {\n    object Instance : AnyType()\n}\n\n/**\n * Purely abstract super type of all value types.\n */\nsealed class ValueType : AnyType()\n\n/**\n * 8-Bit integer.\n */\nobject ByteType : ValueType()\n\n/**\n * 16-Bit integer.\n */\nobject ShortType : ValueType()\n\n/**\n * 32-Bit integer.\n */\nobject IntType : ValueType()\n\n/**\n * 32-Bit floating point number.\n */\nobject FloatType : ValueType()\n\n/**\n * Abstract super type of all label types.\n */\nsealed class LabelType : ValueType() {\n    object Instance : LabelType()\n}\n\n/**\n * Named reference to an instruction.\n */\nobject ILabelType : LabelType()\n\n/**\n * Named reference to a data segment.\n */\nobject DLabelType : LabelType()\n\n/**\n * Named reference to a string segment.\n */\nobject SLabelType : LabelType()\n\n/**\n * Arbitrary amount of instruction labels (variadic arguments).\n */\nobject ILabelVarType : LabelType()\n\n/**\n * String of arbitrary size.\n */\nobject StringType : ValueType()\n\n/**\n * Purely abstract super type of all register reference types.\n */\nsealed class RegRefType : AnyType()\n\n/**\n * Register reference. If [registers] is null, references one or more consecutive registers of any\n * type (only stack_pushm and stack_popm use this). If [registers] is not null, references a fixed\n * amount of consecutive registers of specific types. [Param.type] can't be a variadic type.\n */\nclass RegType(val registers: List<Param>?) : RegRefType()\n\n/**\n * Arbitrary amount of register references (variadic arguments).\n */\nobject RegVarType : RegRefType()\n\n/**\n * Raw memory pointer.\n */\nobject PointerType : AnyType()\n\nclass Param(\n    val type: AnyType,\n    val name: String?,\n    /**\n     * Documentation string.\n     */\n    val doc: String?,\n    /**\n     * Whether or not the instruction reads this parameter. Only set when type is a register\n     * reference.\n     */\n    val read: Boolean,\n    /**\n     * Whether or not the instruction writes this parameter. Only set when type is a register\n     * reference.\n     */\n    val write: Boolean,\n) {\n    /**\n     * Whether or not this parameter takes a variable number of arguments.\n     */\n    val varargs: Boolean = type === ILabelVarType || type === RegVarType\n}\n\nenum class StackInteraction {\n    Push,\n    Pop,\n}\n\n/**\n * Opcode for script byte code. Invoked by instructions.\n * Don't directly instantiate this class, use the global constants and lookup functions.\n */\nclass Opcode internal constructor(\n    /**\n     * 1- Or 2-byte big-endian representation of this opcode as used in byte code.\n     */\n    val code: Int,\n    /**\n     * String representation of this opcode as used in assembly.\n     */\n    val mnemonic: String,\n    /**\n     * Documentation string.\n     */\n    val doc: String?,\n    /**\n     * Parameters passed in directly or via the stack, depending on the value of [stack].\n     */\n    val params: List<Param>,\n    /**\n     * Stack interaction.\n     */\n    val stack: StackInteraction?,\n    /**\n     * Whether or not the last parameter of this opcode takes a variable number of arguments.\n     */\n    val varargs: Boolean,\n    /**\n     * Whether or not the working of this opcode is known.\n     */\n    val known: Boolean,\n) {\n    /**\n     * Byte size of the opcode, either 1 or 2.\n     */\n    val size: Int = if (code < 0xFF) 1 else 2\n\n    override fun equals(other: Any?): Boolean = this === other\n\n    override fun hashCode(): Int = code\n\n    override fun toString(): String = mnemonic\n}\n\nfun codeToOpcode(code: Int): Opcode =\n    when {\n        code <= 0xFF -> getOpcode(code, code, OPCODES)\n        code <= 0xF8FF -> getOpcode(code, code and 0xFF, OPCODES_F8)\n        else -> getOpcode(code, code and 0xFF, OPCODES_F9)\n    }\n\nfun mnemonicToOpcode(mnemonic: String): Opcode? {\n    var opcode = MNEMONIC_TO_OPCODES.get(mnemonic)\n\n    if (opcode == null) {\n        UNKNOWN_OPCODE_MNEMONIC_REGEX.matchEntire(mnemonic)?.destructured?.let { (codeStr) ->\n            val code = codeStr.toInt(16)\n            opcode = codeToOpcode(code)\n            MNEMONIC_TO_OPCODES.set(mnemonic, opcode!!)\n        }\n    }\n\n    return opcode\n}\n\nprivate fun getOpcode(code: Int, index: Int, opcodes: Array<Opcode?>): Opcode {\n    var opcode = opcodes[index]\n\n    if (opcode == null) {\n        opcode = Opcode(\n            code,\n            mnemonic = \"unknown_${code.toString(16)}\",\n            doc = null,\n            params = emptyList(),\n            stack = null,\n            varargs = false,\n            known = false,\n        )\n        opcodes[index] = opcode\n    }\n\n    return opcode\n}\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun Char.fastIsWhitespace(): Boolean =\n    asDynamic() == 0x20 || (asDynamic() >= 0x09 && asDynamic() <= 0x0D)\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun Char.isDigit(): Boolean =\n    asDynamic() >= 0x30 && asDynamic() <= 0x39\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun String.fastReplace(oldValue: String, newValue: String): String =\n    asDynamic().replaceAll(oldValue, newValue).unsafeCast<String>()\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun String.getCodePointAt(index: Int): Int =\n    asDynamic().charCodeAt(index).unsafeCast<Int>()\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport world.phantasmal.lib.asm.*\n\n// See https://en.wikipedia.org/wiki/Control-flow_graph.\n\nenum class BranchType {\n    /**\n     * Only encountered when the last segment of a script has no jump or return.\n     */\n    None,\n\n    /**\n     * ret.\n     */\n    Return,\n\n    /**\n     * jmp.\n     */\n    Jump,\n\n    /**\n     * Every other jump instruction.\n     */\n    ConditionalJump,\n\n    /**\n     * call, switch_call or va_call.\n     */\n    Call,\n}\n\n/**\n * Instruction sequence into which control flow only enters at the start and only leaves at the end.\n * No code jumps/returns/calls into the middle of a basic block or branches out of a basic block\n * from the middle.\n */\ninterface BasicBlock {\n    /**\n     * The instruction segment that this block is a part of.\n     */\n    val segment: InstructionSegment\n\n    /**\n     * Index of this block's first instruction.\n     */\n    val start: Int\n\n    /**\n     * Index of the instruction right after this block's last instruction.\n     */\n    val end: Int\n\n    /**\n     * The way control flow leaves this block.\n     */\n    val branchType: BranchType\n\n    /**\n     * Either jumps or calls when non-empty, depending on [branchType].\n     */\n    val branchLabels: List<Int>\n\n    /**\n     * The blocks which branch to this block.\n     */\n    val from: List<BasicBlock>\n\n    /**\n     * The blocks this block branches to.\n     */\n    val to: List<BasicBlock>\n\n    fun indexOfInstruction(instruction: Instruction): Int\n}\n\n/**\n * Graph representing the flow of control through the [BasicBlock]s of a script.\n */\nclass ControlFlowGraph internal constructor(\n    val blocks: List<BasicBlock>,\n    private val instructionToBlock: Map<Instruction, BasicBlock>,\n) {\n    fun getBlockForInstruction(instruction: Instruction): BasicBlock {\n        val block = instructionToBlock[instruction]\n        requireNotNull(block) { \"Instruction is not part of the control-flow graph.\" }\n        return block\n    }\n\n    companion object {\n        fun create(bytecodeIr: BytecodeIr): ControlFlowGraph =\n            create(bytecodeIr.instructionSegments())\n\n        fun create(segments: List<InstructionSegment>): ControlFlowGraph {\n            val cfg = ControlFlowGraphBuilder()\n\n            // Mapping of labels to basic blocks.\n            for (segment in segments) {\n                createBasicBlocks(cfg, segment)\n            }\n\n            linkBlocks(cfg)\n            return cfg.build()\n        }\n    }\n}\n\nprivate class ControlFlowGraphBuilder {\n    val blocks: MutableList<BasicBlockImpl> = mutableListOf()\n    val instructionsToBlock: MutableMap<Instruction, BasicBlockImpl> = mutableMapOf()\n    val labelsToBlock: MutableMap<Int, BasicBlockImpl> = mutableMapOf()\n\n    fun build(): ControlFlowGraph =\n        ControlFlowGraph(blocks, instructionsToBlock)\n}\n\nprivate class BasicBlockImpl(\n    override val segment: InstructionSegment,\n    override val start: Int,\n    override val end: Int,\n    override val branchType: BranchType,\n    override val branchLabels: List<Int>,\n) : BasicBlock {\n    override val from: MutableList<BasicBlockImpl> = mutableListOf()\n    override val to: MutableList<BasicBlockImpl> = mutableListOf()\n\n    override fun indexOfInstruction(instruction: Instruction): Int {\n        var index = -1\n\n        for (i in start until end) {\n            if (instruction == segment.instructions[i]) {\n                index = i\n                break\n            }\n        }\n\n        return index\n    }\n\n    fun linkTo(other: BasicBlockImpl) {\n        if (other !in to) {\n            to.add(other)\n            other.from.add(this)\n        }\n    }\n}\n\nprivate fun createBasicBlocks(cfg: ControlFlowGraphBuilder, segment: InstructionSegment) {\n    val len = segment.instructions.size\n    var start = 0\n    var firstBlock = true\n\n    for (i in 0 until len) {\n        val inst = segment.instructions[i]\n\n        var branchType: BranchType\n        var branchLabels: List<Int>\n\n        when (inst.opcode.code) {\n            // Return.\n            OP_RET.code -> {\n                branchType = BranchType.Return\n                branchLabels = emptyList()\n            }\n\n            // Unconditional jump.\n            OP_JMP.code -> {\n                branchType = BranchType.Jump\n                branchLabels = listOfNotNull((inst.args[0] as? IntArg)?.value)\n            }\n\n            // Conditional jumps.\n            OP_JMP_ON.code,\n            OP_JMP_OFF.code,\n            -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = listOfNotNull((inst.args[0] as? IntArg)?.value)\n            }\n            OP_JMP_E.code,\n            OP_JMPI_E.code,\n            OP_JMP_NE.code,\n            OP_JMPI_NE.code,\n            OP_UJMP_G.code,\n            OP_UJMPI_G.code,\n            OP_JMP_G.code,\n            OP_JMPI_G.code,\n            OP_UJMP_L.code,\n            OP_UJMPI_L.code,\n            OP_JMP_L.code,\n            OP_JMPI_L.code,\n            OP_UJMP_GE.code,\n            OP_UJMPI_GE.code,\n            OP_JMP_GE.code,\n            OP_JMPI_GE.code,\n            OP_UJMP_LE.code,\n            OP_UJMPI_LE.code,\n            OP_JMP_LE.code,\n            OP_JMPI_LE.code,\n            -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = listOfNotNull((inst.args[2] as? IntArg)?.value)\n            }\n            OP_SWITCH_JMP.code -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = inst.args.drop(1).mapNotNull { (it as? IntArg)?.value }\n            }\n\n            // Calls.\n            OP_CALL.code,\n            OP_VA_CALL.code,\n            -> {\n                branchType = BranchType.Call\n                branchLabels = listOfNotNull((inst.args[0] as? IntArg)?.value)\n            }\n            OP_SWITCH_CALL.code -> {\n                branchType = BranchType.Call\n                branchLabels = inst.args.drop(1).mapNotNull { (it as? IntArg)?.value }\n            }\n\n            // All other opcodes.\n            else -> {\n                if (i == len - 1) {\n                    // This is the last block of the segment.\n                    branchType = BranchType.None\n                    branchLabels = emptyList()\n                } else {\n                    // Non-branching instruction, part of the current block.\n                    continue\n                }\n            }\n        }\n\n        val block = BasicBlockImpl(segment, start, i + 1, branchType, branchLabels)\n\n        for (j in block.start until block.end) {\n            cfg.instructionsToBlock[block.segment.instructions[j]] = block\n        }\n\n        cfg.blocks.add(block)\n\n        if (firstBlock) {\n            for (label in segment.labels) {\n                cfg.labelsToBlock[label] = block\n            }\n\n            firstBlock = false\n        }\n\n        start = i + 1\n    }\n}\n\nprivate fun linkBlocks(cfg: ControlFlowGraphBuilder) {\n    // Pairs of calling block and block to which callees should return to.\n    val callers = mutableListOf<Pair<BasicBlockImpl, BasicBlockImpl>>()\n\n    for ((i, block) in cfg.blocks.withIndex()) {\n        val nextBlock = cfg.blocks.getOrNull(i + 1)\n\n        when (block.branchType) {\n            BranchType.Return ->\n                continue\n\n            BranchType.Call ->\n                nextBlock?.let { callers.add(block to nextBlock) }\n\n            BranchType.None,\n            BranchType.ConditionalJump,\n            -> nextBlock?.let(block::linkTo)\n\n            BranchType.Jump -> {\n                // Ignore.\n            }\n        }\n\n        for (label in block.branchLabels) {\n            cfg.labelsToBlock[label]?.let { toBlock ->\n                block.linkTo(toBlock)\n            }\n        }\n    }\n\n    for ((caller, ret) in callers) {\n        linkReturningBlocks(cfg.labelsToBlock, ret, caller)\n    }\n}\n\n/**\n * Links returning blocks to their callers.\n *\n * @param labelBlocks Mapping of labels to basic blocks.\n * @param ret Basic block the caller should return to.\n * @param caller Calling basic block.\n */\nprivate fun linkReturningBlocks(\n    labelBlocks: Map<Int, BasicBlockImpl>,\n    ret: BasicBlockImpl,\n    caller: BasicBlockImpl,\n) {\n    for (label in caller.branchLabels) {\n        labelBlocks[label]?.let { callee ->\n            if (callee.branchType === BranchType.Return) {\n                callee.linkTo(ret)\n            } else {\n                linkReturningBlocksRecurse(mutableSetOf(), ret, callee)\n            }\n        }\n    }\n}\n\n/**\n * @param encountered For avoiding infinite loops.\n * @param ret\n * @param block\n */\nprivate fun linkReturningBlocksRecurse(\n    encountered: MutableSet<BasicBlockImpl>,\n    ret: BasicBlockImpl,\n    block: BasicBlockImpl,\n) {\n    if (block in encountered) {\n        return\n    } else {\n        encountered.add(block)\n    }\n\n    for (toBlock in block.to) {\n        if (toBlock.branchType === BranchType.Return) {\n            toBlock.linkTo(ret)\n        } else {\n            linkReturningBlocksRecurse(encountered, ret, toBlock)\n        }\n    }\n}\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.asm.*\n\nprivate val logger = KotlinLogging.logger {}\n\nfun getMapDesignations(\n    func0Segment: InstructionSegment,\n    createCfg: () -> ControlFlowGraph,\n): MutableMap<Int, Int> {\n    val mapDesignations = mutableMapOf<Int, Int>()\n    var cfg: ControlFlowGraph? = null\n\n    for (inst in func0Segment.instructions) {\n        when (inst.opcode.code) {\n            OP_MAP_DESIGNATE.code,\n            OP_MAP_DESIGNATE_EX.code,\n            -> {\n                if (cfg == null) {\n                    cfg = createCfg()\n                }\n\n                val areaId = getRegisterValue(cfg, inst, (inst.args[0] as IntArg).value)\n\n                if (areaId.size > 1) {\n                    logger.warn {\n                        \"Couldn't determine area ID for ${inst.opcode.mnemonic} instruction.\"\n                    }\n                    continue\n                }\n\n                val variantIdRegister =\n                    (inst.args[0] as IntArg).value + (if (inst.opcode == OP_MAP_DESIGNATE) 2 else 3)\n                val variantId = getRegisterValue(cfg, inst, variantIdRegister)\n\n                if (variantId.size > 1) {\n                    logger.warn {\n                        \"Couldn't determine area variant ID for ${inst.opcode.mnemonic} instruction.\"\n                    }\n                    continue\n                }\n\n                mapDesignations[areaId[0]!!] = variantId[0]!!\n            }\n\n            OP_BB_MAP_DESIGNATE.code -> {\n                mapDesignations[(inst.args[0] as IntArg).value] = (inst.args[2] as IntArg).value\n            }\n        }\n    }\n\n    return mapDesignations\n}\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.asm.*\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * Computes the possible values of a stack element at the nth position from the top, right before a\n * specific instruction. If the stack element's value can be traced back to a single push\n * instruction, that instruction is also returned.\n */\nfun getStackValue(\n    cfg: ControlFlowGraph,\n    instruction: Instruction,\n    position: Int,\n): Pair<ValueSet, Instruction?> {\n    val block = cfg.getBlockForInstruction(instruction)\n\n    return StackValueFinder().find(\n        mutableSetOf(),\n        cfg,\n        block,\n        block.indexOfInstruction(instruction),\n        position,\n    )\n}\n\nprivate class StackValueFinder {\n    private var iterations = 0\n\n    fun find(\n        path: MutableSet<BasicBlock>,\n        cfg: ControlFlowGraph,\n        block: BasicBlock,\n        end: Int,\n        position: Int,\n    ): Pair<ValueSet, Instruction?> {\n        if (++iterations > 100) {\n            logger.warn { \"Too many iterations.\" }\n            return Pair(ValueSet.all(), null)\n        }\n\n        var pos = position\n\n        for (i in end - 1 downTo block.start) {\n            val instruction = block.segment.instructions[i]\n\n            if (instruction.opcode.stack == StackInteraction.Pop) {\n                pos += instruction.opcode.params.size\n                continue\n            }\n\n            val args = instruction.args\n\n            when (instruction.opcode.code) {\n                OP_ARG_PUSHR.code -> {\n                    if (pos == 0) {\n                        val arg = args[0]\n\n                        return if (arg is IntArg) {\n                            Pair(getRegisterValue(cfg, instruction, arg.value), instruction)\n                        } else {\n                            Pair(ValueSet.all(), instruction)\n                        }\n                    } else {\n                        pos--\n                    }\n                }\n\n                OP_ARG_PUSHL.code,\n                OP_ARG_PUSHB.code,\n                OP_ARG_PUSHW.code,\n                -> {\n                    if (pos == 0) {\n                        val arg = args[0]\n\n                        return if (arg is IntArg) {\n                            Pair(ValueSet.of(arg.value), instruction)\n                        } else {\n                            Pair(ValueSet.all(), instruction)\n                        }\n                    } else {\n                        pos--\n                    }\n                }\n\n                OP_ARG_PUSHA.code,\n                OP_ARG_PUSHO.code,\n                OP_ARG_PUSHS.code,\n                -> {\n                    if (pos == 0) {\n                        return Pair(ValueSet.all(), instruction)\n                    } else {\n                        pos--\n                    }\n                }\n            }\n        }\n\n        val values = ValueSet.empty()\n        var instruction: Instruction? = null\n        var multipleInstructions = false\n        path.add(block)\n\n        for (from in block.from) {\n            // Bail out from loops.\n            if (from in path) {\n                return Pair(ValueSet.all(), null)\n            }\n\n            val (fromValues, fromInstruction) = find(LinkedHashSet(path), cfg, from, from.end, pos)\n            values.union(fromValues)\n\n            if (!multipleInstructions) {\n                if (instruction == null) {\n                    instruction = fromInstruction\n                } else if (instruction != fromInstruction) {\n                    instruction = null\n                    multipleInstructions = true\n                }\n            }\n        }\n\n        return Pair(values, instruction)\n    }\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport world.phantasmal.lib.Episode\n\nclass Area(\n    val id: Int,\n    val name: String,\n    val order: Int,\n    val areaVariants: List<AreaVariant>,\n)\n\nclass AreaVariant(\n    val id: Int,\n    val area: Area,\n)\n\nfun getAreasForEpisode(episode: Episode): List<Area> =\n    AREAS.getValue(episode)\n\nprivate val AREAS by lazy {\n    var order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep1 = listOf(\n        createArea(0, \"Pioneer II\", order++, 1),\n        createArea(1, \"Forest 1\", order++, 1),\n        createArea(2, \"Forest 2\", order++, 1),\n        createArea(11, \"Under the Dome\", order++, 1),\n        createArea(3, \"Cave 1\", order++, 6),\n        createArea(4, \"Cave 2\", order++, 5),\n        createArea(5, \"Cave 3\", order++, 6),\n        createArea(12, \"Underground Channel\", order++, 1),\n        createArea(6, \"Mine 1\", order++, 6),\n        createArea(7, \"Mine 2\", order++, 6),\n        createArea(13, \"Monitor Room\", order++, 1),\n        createArea(8, \"Ruins 1\", order++, 5),\n        createArea(9, \"Ruins 2\", order++, 5),\n        createArea(10, \"Ruins 3\", order++, 5),\n        createArea(14, \"Dark Falz\", order++, 1),\n        // TODO:\n        // createArea(15, \"BA Ruins\", order++, 3),\n        // createArea(16, \"BA Spaceship\", order++, 3),\n        // createArea(17, \"Lobby\", order++, 15),\n    )\n\n    order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep2 = listOf(\n        createArea(0, \"Lab\", order++, 1),\n        createArea(1, \"VR Temple Alpha\", order++, 3),\n        createArea(2, \"VR Temple Beta\", order++, 3),\n        createArea(14, \"VR Temple Final\", order++, 1),\n        createArea(3, \"VR Spaceship Alpha\", order++, 3),\n        createArea(4, \"VR Spaceship Beta\", order++, 3),\n        createArea(15, \"VR Spaceship Final\", order++, 1),\n        createArea(5, \"Central Control Area\", order++, 1),\n        createArea(6, \"Jungle Area East\", order++, 1),\n        createArea(7, \"Jungle Area North\", order++, 1),\n        createArea(8, \"Mountain Area\", order++, 3),\n        createArea(9, \"Seaside Area\", order++, 1),\n        createArea(12, \"Cliffs of Gal Da Val\", order++, 1),\n        createArea(10, \"Seabed Upper Levels\", order++, 3),\n        createArea(11, \"Seabed Lower Levels\", order++, 3),\n        createArea(13, \"Test Subject Disposal Area\", order++, 1),\n        createArea(16, \"Seaside Area at Night\", order++, 2),\n        createArea(17, \"Control Tower\", order++, 5),\n    )\n\n    order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep4 = listOf(\n        createArea(0, \"Pioneer II\", order++, 1),\n        createArea(1, \"Crater Route 1\", order++, 1),\n        createArea(2, \"Crater Route 2\", order++, 1),\n        createArea(3, \"Crater Route 3\", order++, 1),\n        createArea(4, \"Crater Route 4\", order++, 1),\n        createArea(5, \"Crater Interior\", order++, 1),\n        createArea(6, \"Subterranean Desert 1\", order++, 3),\n        createArea(7, \"Subterranean Desert 2\", order++, 3),\n        createArea(8, \"Subterranean Desert 3\", order++, 3),\n        createArea(9, \"Meteor Impact Site\", order++, 1),\n    )\n\n    mapOf(\n        Episode.I to ep1,\n        Episode.II to ep2,\n        Episode.IV to ep4,\n    )\n}\n\nprivate fun createArea(id: Int, name: String, order: Int, variants: Int): Area {\n    val avs = mutableListOf<AreaVariant>()\n    val area = Area(id, name, order, avs)\n\n    for (avId in 0 until variants) {\n        avs.add(AreaVariant(avId, area))\n    }\n\n    return area\n}\n","package world.phantasmal.lib.fileFormats.quest\n\n/**\n * Represents an entity type-specific property for accessing ambiguous parts of the entity data.\n */\nclass EntityProp(\n    val name: String,\n    val offset: Int,\n    val type: EntityPropType,\n)\n\nenum class EntityPropType {\n    I32,\n    F32,\n\n    /**\n     * Signed 32-bit integer that represents an angle. 0x10000 is 360°.\n     */\n    Angle,\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport world.phantasmal.lib.Episode\n\nprivate val FRIENDLY_NPC_PROPERTIES = listOf(\n    EntityProp(name = \"Movement distance\", offset = 44, type = EntityPropType.F32),\n    EntityProp(name = \"Hide register\", offset = 52, type = EntityPropType.F32),\n    EntityProp(name = \"Character ID\", offset = 56, type = EntityPropType.F32),\n    EntityProp(name = \"Script label\", offset = 60, type = EntityPropType.F32),\n    EntityProp(name = \"Movement flag\", offset = 64, type = EntityPropType.I32)\n)\n\nenum class NpcType(\n    override val uniqueName: String,\n    override val simpleName: String = uniqueName,\n    val ultimateName: String = simpleName,\n    val episode: Episode? = null,\n    val enemy: Boolean = false,\n    rareType: (() -> NpcType)? = null,\n    /**\n     * IDs of the areas this NPC can be found in.\n     */\n    val areaIds: List<Int>,\n    /**\n     * Type ID used by the game.\n     */\n    val typeId: Int? = null,\n    /**\n     * Skin value used by the game.\n     */\n    val skin: Int? = null,\n    /**\n     * Boolean specifying whether an NPC is the regular or special variant.\n     * Sometimes signifies a variant (e.g. Barbarous Wolf), sometimes a rare variant (e.g. Pouilly\n     * Slime).\n     */\n    val special: Boolean? = null,\n    /**\n     * NPC-specific properties.\n     */\n    override val properties: List<EntityProp> = emptyList(),\n) : EntityType {\n    //\n    // Unknown NPCs\n    //\n\n    Unknown(\n        uniqueName = \"Unknown\",\n        areaIds = listOf(),\n    ),\n\n    //\n    // Friendly NPCs\n    //\n\n    FemaleFat(\n        uniqueName = \"Female Fat\",\n        areaIds = listOf(0),\n        typeId = 4,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    FemaleMacho(\n        uniqueName = \"Female Macho\",\n        areaIds = listOf(0),\n        typeId = 5,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    FemaleTall(\n        uniqueName = \"Female Tall\",\n        areaIds = listOf(0),\n        typeId = 7,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleDwarf(\n        uniqueName = \"Male Dwarf\",\n        areaIds = listOf(0),\n        typeId = 10,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleFat(\n        uniqueName = \"Male Fat\",\n        areaIds = listOf(0),\n        typeId = 11,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleMacho(\n        uniqueName = \"Male Macho\",\n        areaIds = listOf(0),\n        typeId = 12,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleOld(\n        uniqueName = \"Male Old\",\n        areaIds = listOf(0),\n        typeId = 13,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    BlueSoldier(\n        uniqueName = \"Blue Soldier\",\n        areaIds = listOf(0),\n        typeId = 25,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    RedSoldier(\n        uniqueName = \"Red Soldier\",\n        areaIds = listOf(0),\n        typeId = 26,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Principal(\n        uniqueName = \"Principal\",\n        areaIds = listOf(0),\n        typeId = 27,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Tekker(\n        uniqueName = \"Tekker\",\n        areaIds = listOf(0),\n        typeId = 28,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    GuildLady(\n        uniqueName = \"Guild Lady\",\n        areaIds = listOf(0),\n        typeId = 29,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Scientist(\n        uniqueName = \"Scientist\",\n        areaIds = listOf(0),\n        typeId = 30,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Nurse(\n        uniqueName = \"Nurse\",\n        areaIds = listOf(0),\n        typeId = 31,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Irene(\n        uniqueName = \"Irene\",\n        areaIds = listOf(0),\n        typeId = 32,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    ItemShop(\n        uniqueName = \"Item Shop\",\n        areaIds = listOf(0),\n        typeId = 241,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Nurse2(\n        uniqueName = \"Nurse (Ep. II)\",\n        simpleName = \"Nurse\",\n        episode = Episode.II,\n        areaIds = listOf(0),\n        typeId = 254,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n\n    //\n    // Enemy NPCs\n    //\n\n    // Episode I Forest\n\n    Hildebear(\n        uniqueName = \"Hildebear\",\n        ultimateName = \"Hildelt\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { Hildeblue },\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 0,\n        special = false,\n    ),\n    Hildeblue(\n        uniqueName = \"Hildeblue\",\n        ultimateName = \"Hildetorr\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 1,\n        special = false,\n    ),\n    RagRappy(\n        uniqueName = \"Rag Rappy\",\n        ultimateName = \"El Rappy\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { AlRappy },\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    AlRappy(\n        uniqueName = \"Al Rappy\",\n        ultimateName = \"Pal Rappy\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    Monest(\n        uniqueName = \"Monest\",\n        ultimateName = \"Mothvist\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 66,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"State\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Start number\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Total number\", offset = 52, type = EntityPropType.F32)\n        ),\n    ),\n    Mothmant(\n        uniqueName = \"Mothmant\",\n        ultimateName = \"Mothvert\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    SavageWolf(\n        uniqueName = \"Savage Wolf\",\n        ultimateName = \"Gulgus\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 67,\n        skin = 0,\n        special = false,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    BarbarousWolf(\n        uniqueName = \"Barbarous Wolf\",\n        ultimateName = \"Gulgus-Gue\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 67,\n        skin = 0,\n        special = true,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    Booma(\n        uniqueName = \"Booma\",\n        ultimateName = \"Bartle\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Gobooma(\n        uniqueName = \"Gobooma\",\n        ultimateName = \"Barble\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Gigobooma(\n        uniqueName = \"Gigobooma\",\n        ultimateName = \"Tollaw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Dragon(\n        uniqueName = \"Dragon\",\n        ultimateName = \"Sil Dragon\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(11),\n        typeId = 192,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Caves\n\n    GrassAssassin(\n        uniqueName = \"Grass Assassin\",\n        ultimateName = \"Crimson Assassin\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 96,\n        skin = 0,\n        special = false,\n    ),\n    PoisonLily(\n        uniqueName = \"Poison Lily\",\n        ultimateName = \"Ob Lily\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { NarLily },\n        areaIds = listOf(3, 4, 5),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    NarLily(\n        uniqueName = \"Nar Lily\",\n        ultimateName = \"Mil Lily\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 97,\n        skin = 1,\n        special = true,\n    ),\n    NanoDragon(\n        uniqueName = \"Nano Dragon\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 98,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spawn flag\", offset = 64, type = EntityPropType.I32)\n        ),\n    ),\n    EvilShark(\n        uniqueName = \"Evil Shark\",\n        ultimateName = \"Vulmer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    PalShark(\n        uniqueName = \"Pal Shark\",\n        ultimateName = \"Govulmer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    GuilShark(\n        uniqueName = \"Guil Shark\",\n        ultimateName = \"Melqueek\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    PofuillySlime(\n        uniqueName = \"Pofuilly Slime\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { PouillySlime },\n        areaIds = listOf(3, 4, 5),\n        typeId = 100,\n        skin = 0,\n        special = false,\n    ),\n    PouillySlime(\n        uniqueName = \"Pouilly Slime\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 100,\n        skin = 0,\n        special = true,\n    ),\n    PanArms(\n        uniqueName = \"Pan Arms\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 101,\n        skin = 0,\n        special = false,\n    ),\n    Migium(\n        uniqueName = \"Migium\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Hidoom(\n        uniqueName = \"Hidoom\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    DeRolLe(\n        uniqueName = \"De Rol Le\",\n        ultimateName = \"Dal Ra Lie\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(12),\n        typeId = 193,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Mines\n\n    Dubchic(\n        uniqueName = \"Dubchic\",\n        ultimateName = \"Dubchich\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 128,\n        skin = 0,\n        special = false,\n    ),\n    Gilchic(\n        uniqueName = \"Gilchic\",\n        ultimateName = \"Gilchich\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 128,\n        skin = 1,\n        special = false,\n    ),\n    Garanz(\n        uniqueName = \"Garanz\",\n        ultimateName = \"Baranz\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 129,\n        skin = 0,\n        special = false,\n    ),\n    SinowBeat(\n        uniqueName = \"Sinow Beat\",\n        ultimateName = \"Sinow Blue\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 130,\n        skin = 0,\n        special = false,\n    ),\n    SinowGold(\n        uniqueName = \"Sinow Gold\",\n        ultimateName = \"Sinow Red\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 130,\n        skin = 0,\n        special = true,\n    ),\n    Canadine(\n        uniqueName = \"Canadine\",\n        ultimateName = \"Canabin\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 131,\n        skin = 0,\n        special = false,\n    ),\n    Canane(\n        uniqueName = \"Canane\",\n        ultimateName = \"Canune\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 132,\n        skin = 0,\n        special = false,\n    ),\n    Dubswitch(\n        uniqueName = \"Dubswitch\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 133,\n        skin = 0,\n        special = false,\n    ),\n    VolOptPart1(\n        uniqueName = \"Vol Opt (Part 1)\",\n        simpleName = \"Vol Opt\",\n        ultimateName = \"Vol Opt ver.2\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 194,\n        skin = 0,\n        special = false,\n    ),\n    VolOptPart2(\n        uniqueName = \"Vol Opt (Part 2)\",\n        simpleName = \"Vol Opt\",\n        ultimateName = \"Vol Opt ver.2\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 197,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Ruins\n\n    Delsaber(\n        uniqueName = \"Delsaber\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 160,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Jump distance\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Block HP\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    ChaosSorcerer(\n        uniqueName = \"Chaos Sorcerer\",\n        ultimateName = \"Gran Sorcerer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 161,\n        skin = 0,\n        special = false,\n    ),\n    DarkGunner(\n        uniqueName = \"Dark Gunner\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 162,\n        skin = 0,\n        special = false,\n    ),\n    DeathGunner(\n        uniqueName = \"Death Gunner\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    ChaosBringer(\n        uniqueName = \"Chaos Bringer\",\n        ultimateName = \"Dark Bringer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 164,\n        skin = 0,\n        special = false,\n    ),\n    DarkBelra(\n        uniqueName = \"Dark Belra\",\n        ultimateName = \"Indi Belra\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 165,\n        skin = 0,\n        special = false,\n    ),\n    Dimenian(\n        uniqueName = \"Dimenian\",\n        ultimateName = \"Arlan\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    LaDimenian(\n        uniqueName = \"La Dimenian\",\n        ultimateName = \"Merlan\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    SoDimenian(\n        uniqueName = \"So Dimenian\",\n        ultimateName = \"Del-D\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Bulclaw(\n        uniqueName = \"Bulclaw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 167,\n        skin = 0,\n        special = false,\n    ),\n    Bulk(\n        uniqueName = \"Bulk\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Claw(\n        uniqueName = \"Claw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 168,\n        skin = 0,\n        special = false,\n    ),\n    DarkFalz(\n        uniqueName = \"Dark Falz\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(14),\n        typeId = 200,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II VR Temple\n\n    Hildebear2(\n        uniqueName = \"Hildebear (Ep. II)\",\n        simpleName = \"Hildebear\",\n        ultimateName = \"Hildelt\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { Hildeblue2 },\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 0,\n        special = false,\n    ),\n    Hildeblue2(\n        uniqueName = \"Hildeblue (Ep. II)\",\n        simpleName = \"Hildeblue\",\n        ultimateName = \"Hildetorr\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 1,\n        special = false,\n    ),\n    RagRappy2(\n        uniqueName = \"Rag Rappy (Ep. II)\",\n        simpleName = \"Rag Rappy\",\n        ultimateName = \"El Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { LoveRappy },\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    LoveRappy(\n        uniqueName = \"Love Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    StRappy(\n        uniqueName = \"St. Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    HalloRappy(\n        uniqueName = \"Hallo Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    EggRappy(\n        uniqueName = \"Egg Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Monest2(\n        uniqueName = \"Monest (Ep. II)\",\n        simpleName = \"Monest\",\n        ultimateName = \"Mothvist\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 66,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"State\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Start number\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Total number\", offset = 52, type = EntityPropType.F32)\n        ),\n    ),\n    Mothmant2(\n        uniqueName = \"Mothmant\",\n        ultimateName = \"Mothvert\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    PoisonLily2(\n        uniqueName = \"Poison Lily (Ep. II)\",\n        simpleName = \"Poison Lily\",\n        ultimateName = \"Ob Lily\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { NarLily2 },\n        areaIds = listOf(1, 2),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    NarLily2(\n        uniqueName = \"Nar Lily (Ep. II)\",\n        simpleName = \"Nar Lily\",\n        ultimateName = \"Mil Lily\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 97,\n        skin = 1,\n        special = false,\n    ),\n    GrassAssassin2(\n        uniqueName = \"Grass Assassin (Ep. II)\",\n        simpleName = \"Grass Assassin\",\n        ultimateName = \"Crimson Assassin\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 96,\n        skin = 0,\n        special = false,\n    ),\n    Dimenian2(\n        uniqueName = \"Dimenian (Ep. II)\",\n        simpleName = \"Dimenian\",\n        ultimateName = \"Arlan\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    LaDimenian2(\n        uniqueName = \"La Dimenian (Ep. II)\",\n        simpleName = \"La Dimenian\",\n        ultimateName = \"Merlan\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    SoDimenian2(\n        uniqueName = \"So Dimenian (Ep. II)\",\n        simpleName = \"So Dimenian\",\n        ultimateName = \"Del-D\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    DarkBelra2(\n        uniqueName = \"Dark Belra (Ep. II)\",\n        simpleName = \"Dark Belra\",\n        ultimateName = \"Indi Belra\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 165,\n        skin = 0,\n        special = false,\n    ),\n    BarbaRay(\n        uniqueName = \"Barba Ray\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(14),\n        typeId = 203,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II VR Spaceship\n\n    SavageWolf2(\n        uniqueName = \"Savage Wolf (Ep. II)\",\n        simpleName = \"Savage Wolf\",\n        ultimateName = \"Gulgus\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 67,\n        skin = 0,\n        special = false,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    BarbarousWolf2(\n        uniqueName = \"Barbarous Wolf (Ep. II)\",\n        simpleName = \"Barbarous Wolf\",\n        ultimateName = \"Gulgus-Gue\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 67,\n        skin = 0,\n        special = true,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    PanArms2(\n        uniqueName = \"Pan Arms (Ep. II)\",\n        simpleName = \"Pan Arms\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 101,\n        skin = 0,\n        special = false,\n    ),\n    Migium2(\n        uniqueName = \"Migium (Ep. II)\",\n        simpleName = \"Migium\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Hidoom2(\n        uniqueName = \"Hidoom (Ep. II)\",\n        simpleName = \"Hidoom\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Dubchic2(\n        uniqueName = \"Dubchic (Ep. II)\",\n        simpleName = \"Dubchic\",\n        ultimateName = \"Dubchich\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 128,\n        skin = 0,\n        special = false,\n    ),\n    Gilchic2(\n        uniqueName = \"Gilchic (Ep. II)\",\n        simpleName = \"Gilchic\",\n        ultimateName = \"Gilchich\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 128,\n        skin = 1,\n        special = false,\n    ),\n    Garanz2(\n        uniqueName = \"Garanz (Ep. II)\",\n        simpleName = \"Garanz\",\n        ultimateName = \"Baranz\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 129,\n        skin = 0,\n        special = false,\n    ),\n    Dubswitch2(\n        uniqueName = \"Dubswitch (Ep. II)\",\n        simpleName = \"Dubswitch\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 133,\n        skin = 0,\n        special = false,\n    ),\n    Delsaber2(\n        uniqueName = \"Delsaber (Ep. II)\",\n        simpleName = \"Delsaber\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 160,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Jump distance\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Block HP\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    ChaosSorcerer2(\n        uniqueName = \"Chaos Sorcerer (Ep. II)\",\n        simpleName = \"Chaos Sorcerer\",\n        ultimateName = \"Gran Sorcerer\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 161,\n        skin = 0,\n        special = false,\n    ),\n    GolDragon(\n        uniqueName = \"Gol Dragon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(15),\n        typeId = 204,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II Central Control Area\n\n    SinowBerill(\n        uniqueName = \"Sinow Berill\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 212,\n        skin = 0,\n        special = false,\n    ),\n    SinowSpigell(\n        uniqueName = \"Sinow Spigell\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 212,\n        skin = 1,\n        special = false,\n    ),\n    Merillia(\n        uniqueName = \"Merillia\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 213,\n        skin = 0,\n        special = false,\n    ),\n    Meriltas(\n        uniqueName = \"Meriltas\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 213,\n        skin = 1,\n        special = false,\n    ),\n    Mericarol(\n        uniqueName = \"Mericarol\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 0,\n        special = false,\n    ),\n    Mericus(\n        uniqueName = \"Mericus\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 1,\n        special = false,\n    ),\n    Merikle(\n        uniqueName = \"Merikle\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 2,\n        special = false,\n    ),\n    UlGibbon(\n        uniqueName = \"Ul Gibbon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 215,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spot appear\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Jump appear\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Back jump\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Run tech\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Back tech\", offset = 60, type = EntityPropType.F32)\n        ),\n    ),\n    ZolGibbon(\n        uniqueName = \"Zol Gibbon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 215,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spot appear\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Jump appear\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Back jump\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Run tech\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Back tech\", offset = 60, type = EntityPropType.F32)\n        ),\n    ),\n    Gibbles(\n        uniqueName = \"Gibbles\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 216,\n        skin = 0,\n        special = false,\n    ),\n    Gee(\n        uniqueName = \"Gee\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 217,\n        skin = 0,\n        special = false,\n    ),\n    GiGue(\n        uniqueName = \"Gi Gue\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 218,\n        skin = 0,\n        special = false,\n    ),\n    IllGill(\n        uniqueName = \"Ill Gill\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 225,\n        skin = 0,\n        special = false,\n    ),\n    DelLily(\n        uniqueName = \"Del Lily\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    Epsilon(\n        uniqueName = \"Epsilon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 224,\n        skin = 0,\n        special = false,\n    ),\n    GalGryphon(\n        uniqueName = \"Gal Gryphon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(12),\n        typeId = 192,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II Seabed\n\n    Deldepth(\n        uniqueName = \"Deldepth\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 219,\n        skin = 0,\n        special = false,\n    ),\n    Delbiter(\n        uniqueName = \"Delbiter\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11, 17),\n        typeId = 220,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Howl percent\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Confuse percent\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Confuse distance\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Laser percent\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Charge percent\", offset = 60, type = EntityPropType.F32),\n            EntityProp(name = \"Type\", offset = 64, type = EntityPropType.I32)\n        ),\n    ),\n    Dolmolm(\n        uniqueName = \"Dolmolm\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 221,\n        skin = 0,\n        special = false,\n    ),\n    Dolmdarl(\n        uniqueName = \"Dolmdarl\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 221,\n        skin = 1,\n        special = false,\n    ),\n    Morfos(\n        uniqueName = \"Morfos\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 222,\n        skin = 0,\n        special = false,\n    ),\n    Recobox(\n        uniqueName = \"Recobox\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11, 17),\n        typeId = 223,\n        skin = 0,\n        special = false,\n    ),\n    Recon(\n        uniqueName = \"Recon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    SinowZoa(\n        uniqueName = \"Sinow Zoa\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 224,\n        skin = 0,\n        special = false,\n    ),\n    SinowZele(\n        uniqueName = \"Sinow Zele\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 224,\n        skin = 1,\n        special = false,\n    ),\n    OlgaFlow(\n        uniqueName = \"Olga Flow\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 202,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode IV\n\n    SandRappy(\n        uniqueName = \"Sand Rappy\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { DelRappy },\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    DelRappy(\n        uniqueName = \"Del Rappy\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    Astark(\n        uniqueName = \"Astark\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 272,\n        skin = 0,\n        special = false,\n    ),\n    SatelliteLizard(\n        uniqueName = \"Satellite Lizard\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 273,\n        skin = 0,\n        special = false,\n    ),\n    Yowie(\n        uniqueName = \"Yowie\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 273,\n        skin = 0,\n        special = true,\n    ),\n    MerissaA(\n        uniqueName = \"Merissa A\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { MerissaAA },\n        areaIds = listOf(6, 7, 8),\n        typeId = 274,\n        skin = 0,\n        special = false,\n    ),\n    MerissaAA(\n        uniqueName = \"Merissa AA\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 274,\n        skin = 1,\n        special = false,\n    ),\n    Girtablulu(\n        uniqueName = \"Girtablulu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 275,\n        skin = 0,\n        special = false,\n    ),\n    Zu(\n        uniqueName = \"Zu\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Pazuzu },\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 276,\n        skin = 0,\n        special = false,\n    ),\n    Pazuzu(\n        uniqueName = \"Pazuzu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 276,\n        skin = 1,\n        special = false,\n    ),\n    Boota(\n        uniqueName = \"Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 0,\n        special = false,\n    ),\n    ZeBoota(\n        uniqueName = \"Ze Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 1,\n        special = false,\n    ),\n    BaBoota(\n        uniqueName = \"Ba Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 2,\n        special = false,\n    ),\n    Dorphon(\n        uniqueName = \"Dorphon\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { DorphonEclair },\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 278,\n        skin = 0,\n        special = false,\n    ),\n    DorphonEclair(\n        uniqueName = \"Dorphon Eclair\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 278,\n        skin = 1,\n        special = false,\n    ),\n    Goran(\n        uniqueName = \"Goran\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 0,\n        special = false,\n    ),\n    PyroGoran(\n        uniqueName = \"Pyro Goran\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 1,\n        special = false,\n    ),\n    GoranDetonator(\n        uniqueName = \"Goran Detonator\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 2,\n        special = false,\n    ),\n    SaintMilion(\n        uniqueName = \"Saint-Milion\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Kondrieu },\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 0,\n        special = false,\n    ),\n    Shambertin(\n        uniqueName = \"Shambertin\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Kondrieu },\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 1,\n        special = false,\n    ),\n    Kondrieu(\n        uniqueName = \"Kondrieu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 0,\n        special = true,\n    );\n\n    /**\n     * The type of this NPC's rare variant if it has one.\n     */\n    val rareType: NpcType? by lazy { rareType?.invoke() }\n\n    companion object {\n        /**\n         * Use this instead of [values] to avoid unnecessary copying.\n         */\n        val VALUES: Array<NpcType> = values()\n    }\n}\n","package world.phantasmal.lib.buffer\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.DataView\nimport org.khronos.webgl.Int8Array\nimport org.khronos.webgl.Uint8Array\nimport org.w3c.dom.WindowOrWorkerGlobalScope\nimport world.phantasmal.lib.Endianness\n\nexternal val self: WindowOrWorkerGlobalScope\n\nactual class Buffer private constructor(\n    arrayBuffer: ArrayBuffer,\n    size: Int,\n    endianness: Endianness,\n) {\n    var arrayBuffer = arrayBuffer\n        private set\n\n    private var dataView = DataView(arrayBuffer)\n    private var littleEndian = endianness == Endianness.Little\n\n    actual var size: Int = size\n        set(value) {\n            ensureCapacity(value)\n            field = value\n        }\n\n    actual var endianness: Endianness\n        get() = if (littleEndian) Endianness.Little else Endianness.Big\n        set(value) {\n            littleEndian = value == Endianness.Little\n        }\n\n    actual val capacity: Int\n        get() = arrayBuffer.byteLength\n\n    actual fun getUByte(offset: Int): UByte {\n        checkOffset(offset, 1)\n        return dataView.getUint8(offset).toUByte()\n    }\n\n    actual fun getUShort(offset: Int): UShort {\n        checkOffset(offset, 2)\n        return dataView.getUint16(offset, littleEndian).toUShort()\n    }\n\n    actual fun getUInt(offset: Int): UInt {\n        checkOffset(offset, 4)\n        return dataView.getUint32(offset, littleEndian).toUInt()\n    }\n\n    actual fun getByte(offset: Int): Byte {\n        checkOffset(offset, 1)\n        return dataView.getInt8(offset)\n    }\n\n    actual fun getShort(offset: Int): Short {\n        checkOffset(offset, 2)\n        return dataView.getInt16(offset, littleEndian)\n    }\n\n    actual fun getInt(offset: Int): Int {\n        checkOffset(offset, 4)\n        return dataView.getInt32(offset, littleEndian)\n    }\n\n    actual fun getFloat(offset: Int): Float {\n        checkOffset(offset, 4)\n        return dataView.getFloat32(offset, littleEndian)\n    }\n\n    actual fun getStringUtf16(\n        offset: Int,\n        maxByteLength: Int,\n        nullTerminated: Boolean,\n    ): String =\n        buildString {\n            val len = maxByteLength / 2\n\n            for (i in 0 until len) {\n                val codePoint = getShort(offset + i * 2).toChar()\n\n                if (nullTerminated && codePoint == '0') {\n                    break\n                }\n\n                append(codePoint)\n            }\n        }\n\n    actual fun slice(offset: Int, size: Int): Buffer {\n        checkOffset(offset, size)\n        return fromArrayBuffer(\n            arrayBuffer.slice(offset, (offset + size)),\n            endianness\n        )\n    }\n\n    actual fun setUByte(offset: Int, value: UByte): Buffer {\n        checkOffset(offset, 1)\n        dataView.setUint8(offset, value.toByte())\n        return this\n    }\n\n    actual fun setUShort(offset: Int, value: UShort): Buffer {\n        checkOffset(offset, 2)\n        dataView.setUint16(offset, value.toShort(), littleEndian)\n        return this\n    }\n\n    actual fun setUInt(offset: Int, value: UInt): Buffer {\n        checkOffset(offset, 4)\n        dataView.setUint32(offset, value.toInt(), littleEndian)\n        return this\n    }\n\n    actual fun setByte(offset: Int, value: Byte): Buffer {\n        checkOffset(offset, 1)\n        dataView.setInt8(offset, value)\n        return this\n    }\n\n    actual fun setShort(offset: Int, value: Short): Buffer {\n        checkOffset(offset, 2)\n        dataView.setInt16(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setInt(offset: Int, value: Int): Buffer {\n        checkOffset(offset, 4)\n        dataView.setInt32(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setFloat(offset: Int, value: Float): Buffer {\n        checkOffset(offset, 4)\n        dataView.setFloat32(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun zero(): Buffer =\n        fillByte(0)\n\n    actual fun fillByte(value: Byte): Buffer {\n        (Int8Array(arrayBuffer, 0, size).asDynamic()).fill(value)\n        return this\n    }\n\n    actual fun toBase64(): String {\n        var str = \"\"\n\n        for (i in 0 until size) {\n            str += (getByte(i).toInt() and 0xff).toChar()\n        }\n\n        return self.btoa(str)\n    }\n\n    actual fun copy(): Buffer =\n        Buffer(arrayBuffer.slice(0, size), size, endianness)\n\n    /**\n     * Checks whether we can read [size] bytes at [offset].\n     */\n    private fun checkOffset(offset: Int, size: Int) {\n        require(offset >= 0 && offset + size <= this.size) {\n            \"Offset $offset is out of bounds.\"\n        }\n    }\n\n    /**\n     * Reallocates the underlying ArrayBuffer if necessary.\n     */\n    private fun ensureCapacity(minNewSize: Int) {\n        if (minNewSize > capacity) {\n            var newSize = if (capacity == 0) minNewSize else capacity\n\n            do {\n                newSize *= 2\n            } while (newSize < minNewSize)\n\n            val newBuffer = ArrayBuffer(newSize)\n            Uint8Array(newBuffer).set(Uint8Array(arrayBuffer, 0, size))\n            arrayBuffer = newBuffer\n            dataView = DataView(arrayBuffer)\n        }\n    }\n\n    actual companion object {\n        actual fun withCapacity(\n            initialCapacity: Int,\n            endianness: Endianness,\n        ): Buffer =\n            Buffer(ArrayBuffer(initialCapacity), size = 0, endianness)\n\n        actual fun withSize(initialSize: Int, endianness: Endianness): Buffer =\n            Buffer(ArrayBuffer(initialSize), initialSize, endianness)\n\n        actual fun fromByteArray(array: ByteArray, endianness: Endianness): Buffer {\n            val arrayBuffer = ArrayBuffer(array.size)\n            Int8Array(arrayBuffer).set(array.toTypedArray())\n            return Buffer(arrayBuffer, array.size, endianness)\n        }\n\n        fun fromArrayBuffer(arrayBuffer: ArrayBuffer, endianness: Endianness): Buffer =\n            Buffer(arrayBuffer, arrayBuffer.byteLength, endianness)\n\n        actual fun fromBase64(data: String, endianness: Endianness): Buffer {\n            val str = self.atob(data)\n            val buf = withSize(str.length, endianness)\n\n            for (i in 0 until buf.size) {\n                buf.setByte(i, str[i].toByte())\n            }\n\n            return buf\n        }\n    }\n}\n","@file:Suppress(\"unused\")\n\npackage world.phantasmal.lib.asm\n\nval OPCODES: Array<Opcode?> = Array(256) { null }\nval OPCODES_F8: Array<Opcode?> = Array(256) { null }\nval OPCODES_F9: Array<Opcode?> = Array(256) { null }\n\nval OP_NOP = Opcode(\n    code = 0x00,\n    mnemonic = \"nop\",\n    doc = \"No operation, does nothing.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x00] = it }\n\nval OP_RET = Opcode(\n    code = 0x01,\n    mnemonic = \"ret\",\n    doc = \"Returns control to caller.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x01] = it }\n\nval OP_SYNC = Opcode(\n    code = 0x02,\n    mnemonic = \"sync\",\n    doc = \"Yields control for the rest of the current frame. Execution will continue the following frame.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x02] = it }\n\nval OP_EXIT = Opcode(\n    code = 0x03,\n    mnemonic = \"exit\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x03] = it }\n\nval OP_THREAD = Opcode(\n    code = 0x04,\n    mnemonic = \"thread\",\n    doc = \"Starts a new thread. Thread execution will start at the given label.\\nOften used to check a register every frame. Make sure to yield control with sync when looping.\",\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x04] = it }\n\nval OP_VA_START = Opcode(\n    code = 0x05,\n    mnemonic = \"va_start\",\n    doc = \"Initializes a variable argument list.\\nMake sure to call va_end after va_start and va_call.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x05] = it }\n\nval OP_VA_END = Opcode(\n    code = 0x06,\n    mnemonic = \"va_end\",\n    doc = \"Restores the registers overwritten by arg_push* instructions.\\nCalled after va_call.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x06] = it }\n\nval OP_VA_CALL = Opcode(\n    code = 0x07,\n    mnemonic = \"va_call\",\n    doc = \"Calls the variable argument function at the given label.\\nCalled after initializing the argument list with va_start and pushing arguments onto the stack with arg_push* instructions. Make sure to call va_end afterwards.\",\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x07] = it }\n\nval OP_LET = Opcode(\n    code = 0x08,\n    mnemonic = \"let\",\n    doc = \"Sets a register to a given register's value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x08] = it }\n\nval OP_LETI = Opcode(\n    code = 0x09,\n    mnemonic = \"leti\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x09] = it }\n\nval OP_LETB = Opcode(\n    code = 0x0A,\n    mnemonic = \"letb\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ByteType, null, null, false, true),\n        )), null, null, false, false),\n        Param(ByteType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0A] = it }\n\nval OP_LETW = Opcode(\n    code = 0x0B,\n    mnemonic = \"letw\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ShortType, null, null, false, true),\n        )), null, null, false, false),\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0B] = it }\n\nval OP_LETA = Opcode(\n    code = 0x0C,\n    mnemonic = \"leta\",\n    doc = \"Sets a register to the memory address of a given register. Not used by Sega.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(PointerType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0C] = it }\n\nval OP_LETO = Opcode(\n    code = 0x0D,\n    mnemonic = \"leto\",\n    doc = \"Sets a register to the memory address of the given label. Not used by Sega.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(PointerType, null, null, false, true),\n        )), null, null, false, false),\n        Param(LabelType.Instance, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0D] = it }\n\nval OP_SET = Opcode(\n    code = 0x10,\n    mnemonic = \"set\",\n    doc = \"Sets a register to 1.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x10] = it }\n\nval OP_CLEAR = Opcode(\n    code = 0x11,\n    mnemonic = \"clear\",\n    doc = \"Sets a register to 0.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x11] = it }\n\nval OP_REV = Opcode(\n    code = 0x12,\n    mnemonic = \"rev\",\n    doc = \"Sets a register to 1 if its current value is 0, otherwise sets it to 0.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x12] = it }\n\nval OP_GSET = Opcode(\n    code = 0x13,\n    mnemonic = \"gset\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x13] = it }\n\nval OP_GCLEAR = Opcode(\n    code = 0x14,\n    mnemonic = \"gclear\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x14] = it }\n\nval OP_GREV = Opcode(\n    code = 0x15,\n    mnemonic = \"grev\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x15] = it }\n\nval OP_GLET = Opcode(\n    code = 0x16,\n    mnemonic = \"glet\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x16] = it }\n\nval OP_GGET = Opcode(\n    code = 0x17,\n    mnemonic = \"gget\",\n    doc = \"Sets a register to value of the given flag.\",\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(ShortType, \"flag\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x17] = it }\n\nval OP_ADD = Opcode(\n    code = 0x18,\n    mnemonic = \"add\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x18] = it }\n\nval OP_ADDI = Opcode(\n    code = 0x19,\n    mnemonic = \"addi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x19] = it }\n\nval OP_SUB = Opcode(\n    code = 0x1A,\n    mnemonic = \"sub\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1A] = it }\n\nval OP_SUBI = Opcode(\n    code = 0x1B,\n    mnemonic = \"subi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1B] = it }\n\nval OP_MUL = Opcode(\n    code = 0x1C,\n    mnemonic = \"mul\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1C] = it }\n\nval OP_MULI = Opcode(\n    code = 0x1D,\n    mnemonic = \"muli\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1D] = it }\n\nval OP_DIV = Opcode(\n    code = 0x1E,\n    mnemonic = \"div\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1E] = it }\n\nval OP_DIVI = Opcode(\n    code = 0x1F,\n    mnemonic = \"divi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1F] = it }\n\nval OP_AND = Opcode(\n    code = 0x20,\n    mnemonic = \"and\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x20] = it }\n\nval OP_ANDI = Opcode(\n    code = 0x21,\n    mnemonic = \"andi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x21] = it }\n\nval OP_OR = Opcode(\n    code = 0x22,\n    mnemonic = \"or\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x22] = it }\n\nval OP_ORI = Opcode(\n    code = 0x23,\n    mnemonic = \"ori\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x23] = it }\n\nval OP_XOR = Opcode(\n    code = 0x24,\n    mnemonic = \"xor\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x24] = it }\n\nval OP_XORI = Opcode(\n    code = 0x25,\n    mnemonic = \"xori\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x25] = it }\n\nval OP_MOD = Opcode(\n    code = 0x26,\n    mnemonic = \"mod\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x26] = it }\n\nval OP_MODI = Opcode(\n    code = 0x27,\n    mnemonic = \"modi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x27] = it }\n\nval OP_JMP = Opcode(\n    code = 0x28,\n    mnemonic = \"jmp\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x28] = it }\n\nval OP_CALL = Opcode(\n    code = 0x29,\n    mnemonic = \"call\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x29] = it }\n\nval OP_JMP_ON = Opcode(\n    code = 0x2A,\n    mnemonic = \"jmp_on\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n        Param(RegVarType, null, null, true, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x2A] = it }\n\nval OP_JMP_OFF = Opcode(\n    code = 0x2B,\n    mnemonic = \"jmp_off\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n        Param(RegVarType, null, null, true, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x2B] = it }\n\nval OP_JMP_E = Opcode(\n    code = 0x2C,\n    mnemonic = \"jmp_=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2C] = it }\n\nval OP_JMPI_E = Opcode(\n    code = 0x2D,\n    mnemonic = \"jmpi_=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2D] = it }\n\nval OP_JMP_NE = Opcode(\n    code = 0x2E,\n    mnemonic = \"jmp_!=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2E] = it }\n\nval OP_JMPI_NE = Opcode(\n    code = 0x2F,\n    mnemonic = \"jmpi_!=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2F] = it }\n\nval OP_UJMP_G = Opcode(\n    code = 0x30,\n    mnemonic = \"ujmp_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x30] = it }\n\nval OP_UJMPI_G = Opcode(\n    code = 0x31,\n    mnemonic = \"ujmpi_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x31] = it }\n\nval OP_JMP_G = Opcode(\n    code = 0x32,\n    mnemonic = \"jmp_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x32] = it }\n\nval OP_JMPI_G = Opcode(\n    code = 0x33,\n    mnemonic = \"jmpi_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x33] = it }\n\nval OP_UJMP_L = Opcode(\n    code = 0x34,\n    mnemonic = \"ujmp_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x34] = it }\n\nval OP_UJMPI_L = Opcode(\n    code = 0x35,\n    mnemonic = \"ujmpi_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x35] = it }\n\nval OP_JMP_L = Opcode(\n    code = 0x36,\n    mnemonic = \"jmp_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x36] = it }\n\nval OP_JMPI_L = Opcode(\n    code = 0x37,\n    mnemonic = \"jmpi_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x37] = it }\n\nval OP_UJMP_GE = Opcode(\n    code = 0x38,\n    mnemonic = \"ujmp_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x38] = it }\n\nval OP_UJMPI_GE = Opcode(\n    code = 0x39,\n    mnemonic = \"ujmpi_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x39] = it }\n\nval OP_JMP_GE = Opcode(\n    code = 0x3A,\n    mnemonic = \"jmp_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3A] = it }\n\nval OP_JMPI_GE = Opcode(\n    code = 0x3B,\n    mnemonic = \"jmpi_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3B] = it }\n\nval OP_UJMP_LE = Opcode(\n    code = 0x3C,\n    mnemonic = \"ujmp_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3C] = it }\n\nval OP_UJMPI_LE = Opcode(\n    code = 0x3D,\n    mnemonic = \"ujmpi_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3D] = it }\n\nval OP_JMP_LE = Opcode(\n    code = 0x3E,\n    mnemonic = \"jmp_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3E] = it }\n\nval OP_JMPI_LE = Opcode(\n    code = 0x3F,\n    mnemonic = \"jmpi_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3F] = it }\n\nval OP_SWITCH_JMP = Opcode(\n    code = 0x40,\n    mnemonic = \"switch_jmp\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelVarType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x40] = it }\n\nval OP_SWITCH_CALL = Opcode(\n    code = 0x41,\n    mnemonic = \"switch_call\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelVarType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x41] = it }\n\nval OP_STACK_PUSH = Opcode(\n    code = 0x42,\n    mnemonic = \"stack_push\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x42] = it }\n\nval OP_STACK_POP = Opcode(\n    code = 0x43,\n    mnemonic = \"stack_pop\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x43] = it }\n\nval OP_STACK_PUSHM = Opcode(\n    code = 0x44,\n    mnemonic = \"stack_pushm\",\n    doc = \"Pushes the values of an arbitrary amount of registers onto the stack.\",\n    params = listOf(\n        Param(RegType(null), null, null, true, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x44] = it }\n\nval OP_STACK_POPM = Opcode(\n    code = 0x45,\n    mnemonic = \"stack_popm\",\n    doc = \"Pops an arbitrary amount of values from the stack and writes them to registers.\",\n    params = listOf(\n        Param(RegType(null), null, null, false, true),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x45] = it }\n\nval OP_ARG_PUSHR = Opcode(\n    code = 0x48,\n    mnemonic = \"arg_pushr\",\n    doc = \"Pushes the value of the given register onto the stack.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x48] = it }\n\nval OP_ARG_PUSHL = Opcode(\n    code = 0x49,\n    mnemonic = \"arg_pushl\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x49] = it }\n\nval OP_ARG_PUSHB = Opcode(\n    code = 0x4A,\n    mnemonic = \"arg_pushb\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(ByteType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4A] = it }\n\nval OP_ARG_PUSHW = Opcode(\n    code = 0x4B,\n    mnemonic = \"arg_pushw\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4B] = it }\n\nval OP_ARG_PUSHA = Opcode(\n    code = 0x4C,\n    mnemonic = \"arg_pusha\",\n    doc = \"Pushes the memory address of the given register onto the stack. Not used by Sega.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4C] = it }\n\nval OP_ARG_PUSHO = Opcode(\n    code = 0x4D,\n    mnemonic = \"arg_pusho\",\n    doc = \"Pushes the memory address of the given label onto the stack. Not used by Sega.\",\n    params = listOf(\n        Param(LabelType.Instance, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4D] = it }\n\nval OP_ARG_PUSHS = Opcode(\n    code = 0x4E,\n    mnemonic = \"arg_pushs\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4E] = it }\n\nval OP_UNKNOWN_4F = Opcode(\n    code = 0x4F,\n    mnemonic = \"unknown_4f\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0x4F] = it }\n\nval OP_MESSAGE = Opcode(\n    code = 0x50,\n    mnemonic = \"message\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x50] = it }\n\nval OP_LIST = Opcode(\n    code = 0x51,\n    mnemonic = \"list\",\n    doc = \"Used to display a list of items and retrieve the item selected by the player.\\nList items should be seperated by newlines. The selected item's index will be written to the given register.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ByteType, null, null, false, true),\n        )), null, null, false, false),\n        Param(StringType, \"list\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x51] = it }\n\nval OP_FADEIN = Opcode(\n    code = 0x52,\n    mnemonic = \"fadein\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x52] = it }\n\nval OP_FADEOUT = Opcode(\n    code = 0x53,\n    mnemonic = \"fadeout\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x53] = it }\n\nval OP_SE = Opcode(\n    code = 0x54,\n    mnemonic = \"se\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x54] = it }\n\nval OP_BGM = Opcode(\n    code = 0x55,\n    mnemonic = \"bgm\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x55] = it }\n\nval OP_ENABLE = Opcode(\n    code = 0x58,\n    mnemonic = \"enable\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x58] = it }\n\nval OP_DISABLE = Opcode(\n    code = 0x59,\n    mnemonic = \"disable\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x59] = it }\n\nval OP_WINDOW_MSG = Opcode(\n    code = 0x5A,\n    mnemonic = \"window_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5A] = it }\n\nval OP_ADD_MSG = Opcode(\n    code = 0x5B,\n    mnemonic = \"add_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5B] = it }\n\nval OP_MESEND = Opcode(\n    code = 0x5C,\n    mnemonic = \"mesend\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5C] = it }\n\nval OP_GETTIME = Opcode(\n    code = 0x5D,\n    mnemonic = \"gettime\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5D] = it }\n\nval OP_WINEND = Opcode(\n    code = 0x5E,\n    mnemonic = \"winend\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5E] = it }\n\nval OP_NPC_CRT_V3 = Opcode(\n    code = 0x60,\n    mnemonic = \"npc_crt_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x60] = it }\n\nval OP_NPC_STOP = Opcode(\n    code = 0x61,\n    mnemonic = \"npc_stop\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x61] = it }\n\nval OP_NPC_PLAY = Opcode(\n    code = 0x62,\n    mnemonic = \"npc_play\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x62] = it }\n\nval OP_NPC_KILL = Opcode(\n    code = 0x63,\n    mnemonic = \"npc_kill\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x63] = it }\n\nval OP_NPC_NONT = Opcode(\n    code = 0x64,\n    mnemonic = \"npc_nont\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x64] = it }\n\nval OP_NPC_TALK = Opcode(\n    code = 0x65,\n    mnemonic = \"npc_talk\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x65] = it }\n\nval OP_NPC_CRP_V3 = Opcode(\n    code = 0x66,\n    mnemonic = \"npc_crp_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x66] = it }\n\nval OP_CREATE_PIPE = Opcode(\n    code = 0x68,\n    mnemonic = \"create_pipe\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x68] = it }\n\nval OP_P_HPSTAT_V3 = Opcode(\n    code = 0x69,\n    mnemonic = \"p_hpstat_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x69] = it }\n\nval OP_P_DEAD_V3 = Opcode(\n    code = 0x6A,\n    mnemonic = \"p_dead_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6A] = it }\n\nval OP_P_DISABLEWARP = Opcode(\n    code = 0x6B,\n    mnemonic = \"p_disablewarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6B] = it }\n\nval OP_P_ENABLEWARP = Opcode(\n    code = 0x6C,\n    mnemonic = \"p_enablewarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6C] = it }\n\nval OP_P_MOVE_V3 = Opcode(\n    code = 0x6D,\n    mnemonic = \"p_move_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6D] = it }\n\nval OP_P_LOOK = Opcode(\n    code = 0x6E,\n    mnemonic = \"p_look\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6E] = it }\n\nval OP_P_ACTION_DISABLE = Opcode(\n    code = 0x70,\n    mnemonic = \"p_action_disable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x70] = it }\n\nval OP_P_ACTION_ENABLE = Opcode(\n    code = 0x71,\n    mnemonic = \"p_action_enable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x71] = it }\n\nval OP_DISABLE_MOVEMENT1 = Opcode(\n    code = 0x72,\n    mnemonic = \"disable_movement1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x72] = it }\n\nval OP_ENABLE_MOVEMENT1 = Opcode(\n    code = 0x73,\n    mnemonic = \"enable_movement1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x73] = it }\n\nval OP_P_NONCOL = Opcode(\n    code = 0x74,\n    mnemonic = \"p_noncol\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x74] = it }\n\nval OP_P_COL = Opcode(\n    code = 0x75,\n    mnemonic = \"p_col\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x75] = it }\n\nval OP_P_SETPOS = Opcode(\n    code = 0x76,\n    mnemonic = \"p_setpos\",\n    doc = \"Sets a player's position.\",\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n            Param(IntType, \"y_rot\", null, true, false),\n        )), null, \"Coordinates and rotation around y-axis.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x76] = it }\n\nval OP_P_RETURN_GUILD = Opcode(\n    code = 0x77,\n    mnemonic = \"p_return_guild\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x77] = it }\n\nval OP_P_TALK_GUILD = Opcode(\n    code = 0x78,\n    mnemonic = \"p_talk_guild\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x78] = it }\n\nval OP_NPC_TALK_PL_V3 = Opcode(\n    code = 0x79,\n    mnemonic = \"npc_talk_pl_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x79] = it }\n\nval OP_NPC_TALK_KILL = Opcode(\n    code = 0x7A,\n    mnemonic = \"npc_talk_kill\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7A] = it }\n\nval OP_NPC_CRTPK_V3 = Opcode(\n    code = 0x7B,\n    mnemonic = \"npc_crtpk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7B] = it }\n\nval OP_NPC_CRPPK_V3 = Opcode(\n    code = 0x7C,\n    mnemonic = \"npc_crppk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7C] = it }\n\nval OP_NPC_CRPTALK_V3 = Opcode(\n    code = 0x7D,\n    mnemonic = \"npc_crptalk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7D] = it }\n\nval OP_P_LOOK_AT_V1 = Opcode(\n    code = 0x7E,\n    mnemonic = \"p_look_at_v1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7E] = it }\n\nval OP_NPC_CRP_ID_V3 = Opcode(\n    code = 0x7F,\n    mnemonic = \"npc_crp_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7F] = it }\n\nval OP_CAM_QUAKE = Opcode(\n    code = 0x80,\n    mnemonic = \"cam_quake\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x80] = it }\n\nval OP_CAM_ADJ = Opcode(\n    code = 0x81,\n    mnemonic = \"cam_adj\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x81] = it }\n\nval OP_CAM_ZMIN = Opcode(\n    code = 0x82,\n    mnemonic = \"cam_zmin\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x82] = it }\n\nval OP_CAM_ZMOUT = Opcode(\n    code = 0x83,\n    mnemonic = \"cam_zmout\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x83] = it }\n\nval OP_CAM_PAN_V3 = Opcode(\n    code = 0x84,\n    mnemonic = \"cam_pan_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x84] = it }\n\nval OP_GAME_LEV_SUPER = Opcode(\n    code = 0x85,\n    mnemonic = \"game_lev_super\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x85] = it }\n\nval OP_GAME_LEV_RESET = Opcode(\n    code = 0x86,\n    mnemonic = \"game_lev_reset\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x86] = it }\n\nval OP_POS_PIPE_V3 = Opcode(\n    code = 0x87,\n    mnemonic = \"pos_pipe_v3\",\n    doc = \"Create a telepipe at a specific position for the given player slot that takes players back to Pioneer 2 or the Lab.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x87] = it }\n\nval OP_IF_ZONE_CLEAR = Opcode(\n    code = 0x88,\n    mnemonic = \"if_zone_clear\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x88] = it }\n\nval OP_CHK_ENE_NUM = Opcode(\n    code = 0x89,\n    mnemonic = \"chk_ene_num\",\n    doc = \"Retrieves the amount of enemies killed during the quest.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x89] = it }\n\nval OP_UNHIDE_OBJ = Opcode(\n    code = 0x8A,\n    mnemonic = \"unhide_obj\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8A] = it }\n\nval OP_UNHIDE_ENE = Opcode(\n    code = 0x8B,\n    mnemonic = \"unhide_ene\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8B] = it }\n\nval OP_AT_COORDS_CALL = Opcode(\n    code = 0x8C,\n    mnemonic = \"at_coords_call\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8C] = it }\n\nval OP_AT_COORDS_TALK = Opcode(\n    code = 0x8D,\n    mnemonic = \"at_coords_talk\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8D] = it }\n\nval OP_COL_NPCIN = Opcode(\n    code = 0x8E,\n    mnemonic = \"col_npcin\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8E] = it }\n\nval OP_COL_NPCINR = Opcode(\n    code = 0x8F,\n    mnemonic = \"col_npcinr\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8F] = it }\n\nval OP_SWITCH_ON = Opcode(\n    code = 0x90,\n    mnemonic = \"switch_on\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x90] = it }\n\nval OP_SWITCH_OFF = Opcode(\n    code = 0x91,\n    mnemonic = \"switch_off\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x91] = it }\n\nval OP_PLAYBGM_EPI = Opcode(\n    code = 0x92,\n    mnemonic = \"playbgm_epi\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x92] = it }\n\nval OP_SET_MAINWARP = Opcode(\n    code = 0x93,\n    mnemonic = \"set_mainwarp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x93] = it }\n\nval OP_SET_OBJ_PARAM = Opcode(\n    code = 0x94,\n    mnemonic = \"set_obj_param\",\n    doc = \"Creates a targetable object.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n            Param(IntType, \"radius\", null, true, false),\n            Param(ILabelType, \"func\", null, true, false),\n            Param(IntType, \"cursor_y\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, \"Object handle.\", false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x94] = it }\n\nval OP_SET_FLOOR_HANDLER = Opcode(\n    code = 0x95,\n    mnemonic = \"set_floor_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, \"Floor number.\", false, false),\n        Param(ILabelType, null, \"Handler function label.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x95] = it }\n\nval OP_CLR_FLOOR_HANDLER = Opcode(\n    code = 0x96,\n    mnemonic = \"clr_floor_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, \"Floor number.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x96] = it }\n\nval OP_COL_PLINAW = Opcode(\n    code = 0x97,\n    mnemonic = \"col_plinaw\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x97] = it }\n\nval OP_HUD_HIDE = Opcode(\n    code = 0x98,\n    mnemonic = \"hud_hide\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x98] = it }\n\nval OP_HUD_SHOW = Opcode(\n    code = 0x99,\n    mnemonic = \"hud_show\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x99] = it }\n\nval OP_CINE_ENABLE = Opcode(\n    code = 0x9A,\n    mnemonic = \"cine_enable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x9A] = it }\n\nval OP_CINE_DISABLE = Opcode(\n    code = 0x9B,\n    mnemonic = \"cine_disable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x9B] = it }\n\nval OP_SET_QT_FAILURE = Opcode(\n    code = 0xA1,\n    mnemonic = \"set_qt_failure\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA1] = it }\n\nval OP_SET_QT_SUCCESS = Opcode(\n    code = 0xA2,\n    mnemonic = \"set_qt_success\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA2] = it }\n\nval OP_CLR_QT_FAILURE = Opcode(\n    code = 0xA3,\n    mnemonic = \"clr_qt_failure\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA3] = it }\n\nval OP_CLR_QT_SUCCESS = Opcode(\n    code = 0xA4,\n    mnemonic = \"clr_qt_success\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA4] = it }\n\nval OP_SET_QT_CANCEL = Opcode(\n    code = 0xA5,\n    mnemonic = \"set_qt_cancel\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA5] = it }\n\nval OP_CLR_QT_CANCEL = Opcode(\n    code = 0xA6,\n    mnemonic = \"clr_qt_cancel\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA6] = it }\n\nval OP_PL_WALK_V3 = Opcode(\n    code = 0xA8,\n    mnemonic = \"pl_walk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA8] = it }\n\nval OP_PL_ADD_MESETA = Opcode(\n    code = 0xB0,\n    mnemonic = \"pl_add_meseta\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB0] = it }\n\nval OP_THREAD_STG = Opcode(\n    code = 0xB1,\n    mnemonic = \"thread_stg\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB1] = it }\n\nval OP_DEL_OBJ_PARAM = Opcode(\n    code = 0xB2,\n    mnemonic = \"del_obj_param\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, \"Object handle.\", false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB2] = it }\n\nval OP_ITEM_CREATE = Opcode(\n    code = 0xB3,\n    mnemonic = \"item_create\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB3] = it }\n\nval OP_ITEM_CREATE2 = Opcode(\n    code = 0xB4,\n    mnemonic = \"item_create2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB4] = it }\n\nval OP_ITEM_DELETE = Opcode(\n    code = 0xB5,\n    mnemonic = \"item_delete\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB5] = it }\n\nval OP_ITEM_DELETE2 = Opcode(\n    code = 0xB6,\n    mnemonic = \"item_delete2\",\n    doc = \"Deletes an item from the player's inventory.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB6] = it }\n\nval OP_ITEM_CHECK = Opcode(\n    code = 0xB7,\n    mnemonic = \"item_check\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB7] = it }\n\nval OP_SETEVT = Opcode(\n    code = 0xB8,\n    mnemonic = \"setevt\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB8] = it }\n\nval OP_GET_DIFFLVL = Opcode(\n    code = 0xB9,\n    mnemonic = \"get_difflvl\",\n    doc = \"Sets the given register to the current difficulty. 0 For normal, 1 for hard and 2 for both very hard and ultimate.\\nUse get_difficulty_level2 if you want to differentiate between very hard and ultimate.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB9] = it }\n\nval OP_SET_QT_EXIT = Opcode(\n    code = 0xBA,\n    mnemonic = \"set_qt_exit\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xBA] = it }\n\nval OP_CLR_QT_EXIT = Opcode(\n    code = 0xBB,\n    mnemonic = \"clr_qt_exit\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xBB] = it }\n\nval OP_PARTICLE_V3 = Opcode(\n    code = 0xC0,\n    mnemonic = \"particle_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC0] = it }\n\nval OP_NPC_TEXT = Opcode(\n    code = 0xC1,\n    mnemonic = \"npc_text\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC1] = it }\n\nval OP_NPC_CHKWARP = Opcode(\n    code = 0xC2,\n    mnemonic = \"npc_chkwarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC2] = it }\n\nval OP_PL_PKOFF = Opcode(\n    code = 0xC3,\n    mnemonic = \"pl_pkoff\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC3] = it }\n\nval OP_MAP_DESIGNATE = Opcode(\n    code = 0xC4,\n    mnemonic = \"map_designate\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC4] = it }\n\nval OP_MASTERKEY_ON = Opcode(\n    code = 0xC5,\n    mnemonic = \"masterkey_on\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC5] = it }\n\nval OP_MASTERKEY_OFF = Opcode(\n    code = 0xC6,\n    mnemonic = \"masterkey_off\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC6] = it }\n\nval OP_WINDOW_TIME = Opcode(\n    code = 0xC7,\n    mnemonic = \"window_time\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC7] = it }\n\nval OP_WINEND_TIME = Opcode(\n    code = 0xC8,\n    mnemonic = \"winend_time\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC8] = it }\n\nval OP_WINSET_TIME = Opcode(\n    code = 0xC9,\n    mnemonic = \"winset_time\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC9] = it }\n\nval OP_GETMTIME = Opcode(\n    code = 0xCA,\n    mnemonic = \"getmtime\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCA] = it }\n\nval OP_SET_QUEST_BOARD_HANDLER = Opcode(\n    code = 0xCB,\n    mnemonic = \"set_quest_board_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCB] = it }\n\nval OP_CLEAR_QUEST_BOARD_HANDLER = Opcode(\n    code = 0xCC,\n    mnemonic = \"clear_quest_board_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCC] = it }\n\nval OP_PARTICLE_ID_V3 = Opcode(\n    code = 0xCD,\n    mnemonic = \"particle_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCD] = it }\n\nval OP_NPC_CRPTALK_ID_V3 = Opcode(\n    code = 0xCE,\n    mnemonic = \"npc_crptalk_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCE] = it }\n\nval OP_NPC_LANG_CLEAN = Opcode(\n    code = 0xCF,\n    mnemonic = \"npc_lang_clean\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCF] = it }\n\nval OP_PL_PKON = Opcode(\n    code = 0xD0,\n    mnemonic = \"pl_pkon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD0] = it }\n\nval OP_PL_CHK_ITEM2 = Opcode(\n    code = 0xD1,\n    mnemonic = \"pl_chk_item2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD1] = it }\n\nval OP_ENABLE_MAINMENU = Opcode(\n    code = 0xD2,\n    mnemonic = \"enable_mainmenu\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD2] = it }\n\nval OP_DISABLE_MAINMENU = Opcode(\n    code = 0xD3,\n    mnemonic = \"disable_mainmenu\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD3] = it }\n\nval OP_START_BATTLEBGM = Opcode(\n    code = 0xD4,\n    mnemonic = \"start_battlebgm\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD4] = it }\n\nval OP_END_BATTLEBGM = Opcode(\n    code = 0xD5,\n    mnemonic = \"end_battlebgm\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD5] = it }\n\nval OP_DISP_MSG_QB = Opcode(\n    code = 0xD6,\n    mnemonic = \"disp_msg_qb\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD6] = it }\n\nval OP_CLOSE_MSG_QB = Opcode(\n    code = 0xD7,\n    mnemonic = \"close_msg_qb\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD7] = it }\n\nval OP_SET_EVENTFLAG_V3 = Opcode(\n    code = 0xD8,\n    mnemonic = \"set_eventflag_v3\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD8] = it }\n\nval OP_SYNC_LETI = Opcode(\n    code = 0xD9,\n    mnemonic = \"sync_leti\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD9] = it }\n\nval OP_SET_RETURNHUNTER = Opcode(\n    code = 0xDA,\n    mnemonic = \"set_returnhunter\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDA] = it }\n\nval OP_SET_RETURNCITY = Opcode(\n    code = 0xDB,\n    mnemonic = \"set_returncity\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDB] = it }\n\nval OP_LOAD_PVR = Opcode(\n    code = 0xDC,\n    mnemonic = \"load_pvr\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDC] = it }\n\nval OP_LOAD_MIDI = Opcode(\n    code = 0xDD,\n    mnemonic = \"load_midi\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDD] = it }\n\nval OP_UNKNOWN_DE = Opcode(\n    code = 0xDE,\n    mnemonic = \"unknown_de\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDE] = it }\n\nval OP_NPC_PARAM_V3 = Opcode(\n    code = 0xDF,\n    mnemonic = \"npc_param_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDF] = it }\n\nval OP_PAD_DRAGON = Opcode(\n    code = 0xE0,\n    mnemonic = \"pad_dragon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE0] = it }\n\nval OP_CLEAR_MAINWARP = Opcode(\n    code = 0xE1,\n    mnemonic = \"clear_mainwarp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE1] = it }\n\nval OP_PCAM_PARAM_V3 = Opcode(\n    code = 0xE2,\n    mnemonic = \"pcam_param_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE2] = it }\n\nval OP_START_SETEVT_V3 = Opcode(\n    code = 0xE3,\n    mnemonic = \"start_setevt_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE3] = it }\n\nval OP_WARP_ON = Opcode(\n    code = 0xE4,\n    mnemonic = \"warp_on\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE4] = it }\n\nval OP_WARP_OFF = Opcode(\n    code = 0xE5,\n    mnemonic = \"warp_off\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE5] = it }\n\nval OP_GET_SLOTNUMBER = Opcode(\n    code = 0xE6,\n    mnemonic = \"get_slotnumber\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE6] = it }\n\nval OP_GET_SERVERNUMBER = Opcode(\n    code = 0xE7,\n    mnemonic = \"get_servernumber\",\n    doc = \"Returns the index of the player who is the leader of the party.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE7] = it }\n\nval OP_SET_EVENTFLAG2 = Opcode(\n    code = 0xE8,\n    mnemonic = \"set_eventflag2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE8] = it }\n\nval OP_RES = Opcode(\n    code = 0xE9,\n    mnemonic = \"res\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE9] = it }\n\nval OP_UNKNOWN_EA = Opcode(\n    code = 0xEA,\n    mnemonic = \"unknown_ea\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0xEA] = it }\n\nval OP_ENABLE_BGMCTRL = Opcode(\n    code = 0xEB,\n    mnemonic = \"enable_bgmctrl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEB] = it }\n\nval OP_SW_SEND = Opcode(\n    code = 0xEC,\n    mnemonic = \"sw_send\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEC] = it }\n\nval OP_CREATE_BGMCTRL = Opcode(\n    code = 0xED,\n    mnemonic = \"create_bgmctrl\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xED] = it }\n\nval OP_PL_ADD_MESETA2 = Opcode(\n    code = 0xEE,\n    mnemonic = \"pl_add_meseta2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEE] = it }\n\nval OP_SYNC_REGISTER = Opcode(\n    code = 0xEF,\n    mnemonic = \"sync_register\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEF] = it }\n\nval OP_SEND_REGWORK = Opcode(\n    code = 0xF0,\n    mnemonic = \"send_regwork\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF0] = it }\n\nval OP_LETI_FIXED_CAMERA_V3 = Opcode(\n    code = 0xF1,\n    mnemonic = \"leti_fixed_camera_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF1] = it }\n\nval OP_DEFAULT_CAMERA_POS1 = Opcode(\n    code = 0xF2,\n    mnemonic = \"default_camera_pos1\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF2] = it }\n\nval OP_GET_GC_NUMBER = Opcode(\n    code = 0xFA,\n    mnemonic = \"get_gc_number\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xFA] = it }\n\nval OP_UNKNOWN_FB = Opcode(\n    code = 0xFB,\n    mnemonic = \"unknown_fb\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0xFB] = it }\n\nval OP_SET_CHAT_CALLBACK = Opcode(\n    code = 0xF801,\n    mnemonic = \"set_chat_callback\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x01] = it }\n\nval OP_GET_DIFFICULTY_LEVEL2 = Opcode(\n    code = 0xF808,\n    mnemonic = \"get_difficulty_level2\",\n    doc = \"Sets the given register to the current difficulty. 0 For normal, 1 for hard, 2 for very hard and 3 for ultimate.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x08] = it }\n\nval OP_GET_NUMBER_OF_PLAYER1 = Opcode(\n    code = 0xF809,\n    mnemonic = \"get_number_of_player1\",\n    doc = \"Set the given register to the current number of players. Either 1, 2, 3 or 4.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x09] = it }\n\nval OP_GET_COORD_OF_PLAYER = Opcode(\n    code = 0xF80A,\n    mnemonic = \"get_coord_of_player\",\n    doc = \"Retrieves a player's position.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0A] = it }\n\nval OP_ENABLE_MAP = Opcode(\n    code = 0xF80B,\n    mnemonic = \"enable_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0B] = it }\n\nval OP_DISABLE_MAP = Opcode(\n    code = 0xF80C,\n    mnemonic = \"disable_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0C] = it }\n\nval OP_MAP_DESIGNATE_EX = Opcode(\n    code = 0xF80D,\n    mnemonic = \"map_designate_ex\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0D] = it }\n\nval OP_UNKNOWN_F80E = Opcode(\n    code = 0xF80E,\n    mnemonic = \"unknown_f80e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x0E] = it }\n\nval OP_UNKNOWN_F80F = Opcode(\n    code = 0xF80F,\n    mnemonic = \"unknown_f80f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x0F] = it }\n\nval OP_BA_INITIAL_FLOOR = Opcode(\n    code = 0xF810,\n    mnemonic = \"ba_initial_floor\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x10] = it }\n\nval OP_SET_BA_RULES = Opcode(\n    code = 0xF811,\n    mnemonic = \"set_ba_rules\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x11] = it }\n\nval OP_UNKNOWN_F812 = Opcode(\n    code = 0xF812,\n    mnemonic = \"unknown_f812\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x12] = it }\n\nval OP_UNKNOWN_F813 = Opcode(\n    code = 0xF813,\n    mnemonic = \"unknown_f813\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x13] = it }\n\nval OP_UNKNOWN_F814 = Opcode(\n    code = 0xF814,\n    mnemonic = \"unknown_f814\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x14] = it }\n\nval OP_UNKNOWN_F815 = Opcode(\n    code = 0xF815,\n    mnemonic = \"unknown_f815\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x15] = it }\n\nval OP_UNKNOWN_F816 = Opcode(\n    code = 0xF816,\n    mnemonic = \"unknown_f816\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x16] = it }\n\nval OP_UNKNOWN_F817 = Opcode(\n    code = 0xF817,\n    mnemonic = \"unknown_f817\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x17] = it }\n\nval OP_UNKNOWN_F818 = Opcode(\n    code = 0xF818,\n    mnemonic = \"unknown_f818\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x18] = it }\n\nval OP_UNKNOWN_F819 = Opcode(\n    code = 0xF819,\n    mnemonic = \"unknown_f819\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x19] = it }\n\nval OP_UNKNOWN_F81A = Opcode(\n    code = 0xF81A,\n    mnemonic = \"unknown_f81a\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x1A] = it }\n\nval OP_UNKNOWN_F81B = Opcode(\n    code = 0xF81B,\n    mnemonic = \"unknown_f81b\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x1B] = it }\n\nval OP_BA_DISP_MSG = Opcode(\n    code = 0xF81C,\n    mnemonic = \"ba_disp_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1C] = it }\n\nval OP_DEATH_LVL_UP = Opcode(\n    code = 0xF81D,\n    mnemonic = \"death_lvl_up\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1D] = it }\n\nval OP_DEATH_TECH_LVL_UP = Opcode(\n    code = 0xF81E,\n    mnemonic = \"death_tech_lvl_up\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1E] = it }\n\nval OP_CMODE_STAGE = Opcode(\n    code = 0xF820,\n    mnemonic = \"cmode_stage\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x20] = it }\n\nval OP_UNKNOWN_F823 = Opcode(\n    code = 0xF823,\n    mnemonic = \"unknown_f823\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x23] = it }\n\nval OP_UNKNOWN_F824 = Opcode(\n    code = 0xF824,\n    mnemonic = \"unknown_f824\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x24] = it }\n\nval OP_EXP_MULTIPLICATION = Opcode(\n    code = 0xF825,\n    mnemonic = \"exp_multiplication\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x25] = it }\n\nval OP_EXP_DIVISION = Opcode(\n    code = 0xF826,\n    mnemonic = \"exp_division\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x26] = it }\n\nval OP_GET_USER_IS_DEAD = Opcode(\n    code = 0xF827,\n    mnemonic = \"get_user_is_dead\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x27] = it }\n\nval OP_GO_FLOOR = Opcode(\n    code = 0xF828,\n    mnemonic = \"go_floor\",\n    doc = \"Sends a player to the given floor.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"floor_id\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x28] = it }\n\nval OP_GET_NUM_KILLS = Opcode(\n    code = 0xF829,\n    mnemonic = \"get_num_kills\",\n    doc = \"Returns the number of enemies a player has killed during the quest.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"num_kills\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x29] = it }\n\nval OP_UNLOCK_DOOR2 = Opcode(\n    code = 0xF82B,\n    mnemonic = \"unlock_door2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2B] = it }\n\nval OP_LOCK_DOOR2 = Opcode(\n    code = 0xF82C,\n    mnemonic = \"lock_door2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2C] = it }\n\nval OP_IF_SWITCH_NOT_PRESSED = Opcode(\n    code = 0xF82D,\n    mnemonic = \"if_switch_not_pressed\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2D] = it }\n\nval OP_IF_SWITCH_PRESSED = Opcode(\n    code = 0xF82E,\n    mnemonic = \"if_switch_pressed\",\n    doc = \"Returns 1 if the switch is pressed, 0 otherwise.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"floor_id\", null, true, false),\n            Param(IntType, \"switch_id\", null, true, false),\n            Param(IntType, \"is_set\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2E] = it }\n\nval OP_UNKNOWN_F82F = Opcode(\n    code = 0xF82F,\n    mnemonic = \"unknown_f82f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x2F] = it }\n\nval OP_CONTROL_DRAGON = Opcode(\n    code = 0xF830,\n    mnemonic = \"control_dragon\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x30] = it }\n\nval OP_RELEASE_DRAGON = Opcode(\n    code = 0xF831,\n    mnemonic = \"release_dragon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x31] = it }\n\nval OP_SHRINK = Opcode(\n    code = 0xF838,\n    mnemonic = \"shrink\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x38] = it }\n\nval OP_UNSHRINK = Opcode(\n    code = 0xF839,\n    mnemonic = \"unshrink\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x39] = it }\n\nval OP_DISPLAY_CLOCK2 = Opcode(\n    code = 0xF83C,\n    mnemonic = \"display_clock2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x3C] = it }\n\nval OP_UNKNOWN_F83D = Opcode(\n    code = 0xF83D,\n    mnemonic = \"unknown_f83d\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x3D] = it }\n\nval OP_DELETE_AREA_TITLE = Opcode(\n    code = 0xF83E,\n    mnemonic = \"delete_area_title\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x3E] = it }\n\nval OP_LOAD_NPC_DATA = Opcode(\n    code = 0xF840,\n    mnemonic = \"load_npc_data\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x40] = it }\n\nval OP_GET_NPC_DATA = Opcode(\n    code = 0xF841,\n    mnemonic = \"get_npc_data\",\n    doc = null,\n    params = listOf(\n        Param(DLabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x41] = it }\n\nval OP_GIVE_DAMAGE_SCORE = Opcode(\n    code = 0xF848,\n    mnemonic = \"give_damage_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x48] = it }\n\nval OP_TAKE_DAMAGE_SCORE = Opcode(\n    code = 0xF849,\n    mnemonic = \"take_damage_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x49] = it }\n\nval OP_UNK_SCORE_F84A = Opcode(\n    code = 0xF84A,\n    mnemonic = \"unk_score_f84a\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4A] = it }\n\nval OP_UNK_SCORE_F84B = Opcode(\n    code = 0xF84B,\n    mnemonic = \"unk_score_f84b\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4B] = it }\n\nval OP_KILL_SCORE = Opcode(\n    code = 0xF84C,\n    mnemonic = \"kill_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4C] = it }\n\nval OP_DEATH_SCORE = Opcode(\n    code = 0xF84D,\n    mnemonic = \"death_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4D] = it }\n\nval OP_UNK_SCORE_F84E = Opcode(\n    code = 0xF84E,\n    mnemonic = \"unk_score_f84e\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4E] = it }\n\nval OP_ENEMY_DEATH_SCORE = Opcode(\n    code = 0xF84F,\n    mnemonic = \"enemy_death_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4F] = it }\n\nval OP_MESETA_SCORE = Opcode(\n    code = 0xF850,\n    mnemonic = \"meseta_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x50] = it }\n\nval OP_UNKNOWN_F851 = Opcode(\n    code = 0xF851,\n    mnemonic = \"unknown_f851\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x51] = it }\n\nval OP_UNKNOWN_F852 = Opcode(\n    code = 0xF852,\n    mnemonic = \"unknown_f852\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x52] = it }\n\nval OP_REVERSE_WARPS = Opcode(\n    code = 0xF853,\n    mnemonic = \"reverse_warps\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x53] = it }\n\nval OP_UNREVERSE_WARPS = Opcode(\n    code = 0xF854,\n    mnemonic = \"unreverse_warps\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x54] = it }\n\nval OP_SET_ULT_MAP = Opcode(\n    code = 0xF855,\n    mnemonic = \"set_ult_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x55] = it }\n\nval OP_UNSET_ULT_MAP = Opcode(\n    code = 0xF856,\n    mnemonic = \"unset_ult_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x56] = it }\n\nval OP_SET_AREA_TITLE = Opcode(\n    code = 0xF857,\n    mnemonic = \"set_area_title\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x57] = it }\n\nval OP_EQUIP_ITEM = Opcode(\n    code = 0xF85A,\n    mnemonic = \"equip_item\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x5A] = it }\n\nval OP_UNEQUIP_ITEM = Opcode(\n    code = 0xF85B,\n    mnemonic = \"unequip_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x5B] = it }\n\nval OP_UNKNOWN_F85E = Opcode(\n    code = 0xF85E,\n    mnemonic = \"unknown_f85e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x5E] = it }\n\nval OP_UNKNOWN_F85F = Opcode(\n    code = 0xF85F,\n    mnemonic = \"unknown_f85f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x5F] = it }\n\nval OP_UNKNOWN_F860 = Opcode(\n    code = 0xF860,\n    mnemonic = \"unknown_f860\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x60] = it }\n\nval OP_UNKNOWN_F861 = Opcode(\n    code = 0xF861,\n    mnemonic = \"unknown_f861\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x61] = it }\n\nval OP_CMODE_RANK = Opcode(\n    code = 0xF864,\n    mnemonic = \"cmode_rank\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x64] = it }\n\nval OP_AWARD_ITEM_NAME = Opcode(\n    code = 0xF865,\n    mnemonic = \"award_item_name\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x65] = it }\n\nval OP_AWARD_ITEM_SELECT = Opcode(\n    code = 0xF866,\n    mnemonic = \"award_item_select\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x66] = it }\n\nval OP_AWARD_ITEM_GIVE_TO = Opcode(\n    code = 0xF867,\n    mnemonic = \"award_item_give_to\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x67] = it }\n\nval OP_UNKNOWN_F868 = Opcode(\n    code = 0xF868,\n    mnemonic = \"unknown_f868\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x68] = it }\n\nval OP_UNKNOWN_F869 = Opcode(\n    code = 0xF869,\n    mnemonic = \"unknown_f869\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x69] = it }\n\nval OP_ITEM_CREATE_CMODE = Opcode(\n    code = 0xF86A,\n    mnemonic = \"item_create_cmode\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6A] = it }\n\nval OP_UNKNOWN_F86B = Opcode(\n    code = 0xF86B,\n    mnemonic = \"unknown_f86b\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x6B] = it }\n\nval OP_AWARD_ITEM_OK = Opcode(\n    code = 0xF86C,\n    mnemonic = \"award_item_ok\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6C] = it }\n\nval OP_BA_SET_LIVES = Opcode(\n    code = 0xF86F,\n    mnemonic = \"ba_set_lives\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6F] = it }\n\nval OP_BA_SET_TECH_LVL = Opcode(\n    code = 0xF870,\n    mnemonic = \"ba_set_tech_lvl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x70] = it }\n\nval OP_BA_SET_LVL = Opcode(\n    code = 0xF871,\n    mnemonic = \"ba_set_lvl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x71] = it }\n\nval OP_BA_SET_TIME_LIMIT = Opcode(\n    code = 0xF872,\n    mnemonic = \"ba_set_time_limit\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x72] = it }\n\nval OP_BOSS_IS_DEAD = Opcode(\n    code = 0xF873,\n    mnemonic = \"boss_is_dead\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x73] = it }\n\nval OP_ENABLE_TECHS = Opcode(\n    code = 0xF877,\n    mnemonic = \"enable_techs\",\n    doc = \"Enables technique use for the given player.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x77] = it }\n\nval OP_DISABLE_TECHS = Opcode(\n    code = 0xF878,\n    mnemonic = \"disable_techs\",\n    doc = \"Disables technique use for the given player.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x78] = it }\n\nval OP_GET_GENDER = Opcode(\n    code = 0xF879,\n    mnemonic = \"get_gender\",\n    doc = \"Retrieves the player's gender. 0 If male, 1 if female.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"gender\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x79] = it }\n\nval OP_GET_CHARA_CLASS = Opcode(\n    code = 0xF87A,\n    mnemonic = \"get_chara_class\",\n    doc = \"Retrieves the player's race and character class. race will be 0 if human, 1 if newman and 2 if cast. class will be 0 if hunter, 1 if ranger and 2 if force.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"race\", null, false, true),\n            Param(IntType, \"class\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7A] = it }\n\nval OP_TAKE_SLOT_MESETA = Opcode(\n    code = 0xF87B,\n    mnemonic = \"take_slot_meseta\",\n    doc = \"Takes an amount of meseta from a player's inventory. Returns 1 if the meseta was taken, 0 otherwise.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n            Param(IntType, \"amount\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"taken\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7B] = it }\n\nval OP_READ_GUILDCARD_FLAG = Opcode(\n    code = 0xF87F,\n    mnemonic = \"read_guildcard_flag\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7F] = it }\n\nval OP_UNKNOWN_F880 = Opcode(\n    code = 0xF880,\n    mnemonic = \"unknown_f880\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x80] = it }\n\nval OP_GET_PL_NAME = Opcode(\n    code = 0xF881,\n    mnemonic = \"get_pl_name\",\n    doc = \"Sets the value of <pl_name> to the given player's name.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x81] = it }\n\nval OP_GET_PL_JOB = Opcode(\n    code = 0xF882,\n    mnemonic = \"get_pl_job\",\n    doc = \"Sets the value of <pl_job> to the given player's job (Hunter/Ranger/Force).\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x82] = it }\n\nval OP_UNKNOWN_F883 = Opcode(\n    code = 0xF883,\n    mnemonic = \"unknown_f883\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x83] = it }\n\nval OP_GET_PLAYER_STATUS = Opcode(\n    code = 0xF88A,\n    mnemonic = \"get_player_status\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8A] = it }\n\nval OP_SEND_MAIL = Opcode(\n    code = 0xF88B,\n    mnemonic = \"send_mail\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8B] = it }\n\nval OP_ONLINE_CHECK = Opcode(\n    code = 0xF88C,\n    mnemonic = \"online_check\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8C] = it }\n\nval OP_CHL_SET_TIMERECORD = Opcode(\n    code = 0xF88D,\n    mnemonic = \"chl_set_timerecord\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8D] = it }\n\nval OP_CHL_GET_TIMERECORD = Opcode(\n    code = 0xF88E,\n    mnemonic = \"chl_get_timerecord\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8E] = it }\n\nval OP_UNKNOWN_F88F = Opcode(\n    code = 0xF88F,\n    mnemonic = \"unknown_f88f\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x8F] = it }\n\nval OP_LOAD_ENEMY_DATA = Opcode(\n    code = 0xF891,\n    mnemonic = \"load_enemy_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x91] = it }\n\nval OP_GET_PHYSICAL_DATA = Opcode(\n    code = 0xF892,\n    mnemonic = \"get_physical_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x92] = it }\n\nval OP_GET_ATTACK_DATA = Opcode(\n    code = 0xF893,\n    mnemonic = \"get_attack_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x93] = it }\n\nval OP_GET_RESIST_DATA = Opcode(\n    code = 0xF894,\n    mnemonic = \"get_resist_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x94] = it }\n\nval OP_GET_MOVEMENT_DATA = Opcode(\n    code = 0xF895,\n    mnemonic = \"get_movement_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x95] = it }\n\nval OP_SHIFT_LEFT = Opcode(\n    code = 0xF898,\n    mnemonic = \"shift_left\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x98] = it }\n\nval OP_SHIFT_RIGHT = Opcode(\n    code = 0xF899,\n    mnemonic = \"shift_right\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x99] = it }\n\nval OP_GET_RANDOM = Opcode(\n    code = 0xF89A,\n    mnemonic = \"get_random\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9A] = it }\n\nval OP_RESET_MAP = Opcode(\n    code = 0xF89B,\n    mnemonic = \"reset_map\",\n    doc = \"Sets all registers to 0 and resets the quest.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9B] = it }\n\nval OP_DISP_CHL_RETRY_MENU = Opcode(\n    code = 0xF89C,\n    mnemonic = \"disp_chl_retry_menu\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9C] = it }\n\nval OP_CHL_REVERSER = Opcode(\n    code = 0xF89D,\n    mnemonic = \"chl_reverser\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9D] = it }\n\nval OP_UNKNOWN_F89E = Opcode(\n    code = 0xF89E,\n    mnemonic = \"unknown_f89e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x9E] = it }\n\nval OP_UNKNOWN_F89F = Opcode(\n    code = 0xF89F,\n    mnemonic = \"unknown_f89f\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x9F] = it }\n\nval OP_UNKNOWN_F8A8 = Opcode(\n    code = 0xF8A8,\n    mnemonic = \"unknown_f8a8\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xA8] = it }\n\nval OP_UNKNOWN_F8A9 = Opcode(\n    code = 0xF8A9,\n    mnemonic = \"unknown_f8a9\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xA9] = it }\n\nval OP_GET_NUMBER_OF_PLAYER2 = Opcode(\n    code = 0xF8AD,\n    mnemonic = \"get_number_of_player2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xAD] = it }\n\nval OP_READ1 = Opcode(\n    code = 0xF8B0,\n    mnemonic = \"read1\",\n    doc = \"Reads a 1-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ByteType, null, null, false, true),\n        )), null, \"Register to store the result to.\", false, false),\n        Param(IntType, null, \"Address to read from.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB0] = it }\n\nval OP_READ2 = Opcode(\n    code = 0xF8B1,\n    mnemonic = \"read2\",\n    doc = \"Reads a 2-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ShortType, null, null, false, true),\n        )), null, \"Register to store the result to.\", false, false),\n        Param(IntType, null, \"Address to read from.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB1] = it }\n\nval OP_READ4 = Opcode(\n    code = 0xF8B2,\n    mnemonic = \"read4\",\n    doc = \"Reads a 4-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, \"Register to store the result to.\", false, false),\n        Param(IntType, null, \"Address to read from.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB2] = it }\n\nval OP_WRITE1 = Opcode(\n    code = 0xF8B3,\n    mnemonic = \"write1\",\n    doc = \"Writes a 1-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, null, \"Address to write to.\", false, false),\n        Param(ByteType, null, \"Value to be written.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB3] = it }\n\nval OP_WRITE2 = Opcode(\n    code = 0xF8B4,\n    mnemonic = \"write2\",\n    doc = \"Writes a 2-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, null, \"Address to write to.\", false, false),\n        Param(ShortType, null, \"Value to be written.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB4] = it }\n\nval OP_WRITE4 = Opcode(\n    code = 0xF8B5,\n    mnemonic = \"write4\",\n    doc = \"Writes a 4-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, null, \"Address to write to.\", false, false),\n        Param(IntType, null, \"Value to be written.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB5] = it }\n\nval OP_CHL_RECOVERY = Opcode(\n    code = 0xF8B9,\n    mnemonic = \"chl_recovery\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB9] = it }\n\nval OP_SET_EPISODE = Opcode(\n    code = 0xF8BC,\n    mnemonic = \"set_episode\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xBC] = it }\n\nval OP_FILE_DL_REQ = Opcode(\n    code = 0xF8C0,\n    mnemonic = \"file_dl_req\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC0] = it }\n\nval OP_GET_DL_STATUS = Opcode(\n    code = 0xF8C1,\n    mnemonic = \"get_dl_status\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC1] = it }\n\nval OP_GBA_UNKNOWN4 = Opcode(\n    code = 0xF8C2,\n    mnemonic = \"gba_unknown4\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC2] = it }\n\nval OP_GET_GBA_STATE = Opcode(\n    code = 0xF8C3,\n    mnemonic = \"get_gba_state\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC3] = it }\n\nval OP_UNKNOWN_F8C4 = Opcode(\n    code = 0xF8C4,\n    mnemonic = \"unknown_f8c4\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xC4] = it }\n\nval OP_UNKNOWN_F8C5 = Opcode(\n    code = 0xF8C5,\n    mnemonic = \"unknown_f8c5\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xC5] = it }\n\nval OP_QEXIT = Opcode(\n    code = 0xF8C6,\n    mnemonic = \"qexit\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC6] = it }\n\nval OP_USE_ANIMATION = Opcode(\n    code = 0xF8C7,\n    mnemonic = \"use_animation\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"animation\", null, true, false),\n            Param(IntType, \"duration\", null, true, false),\n        )), null, \"Animation ID and duration in number of frames.\", false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC7] = it }\n\nval OP_STOP_ANIMATION = Opcode(\n    code = 0xF8C8,\n    mnemonic = \"stop_animation\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC8] = it }\n\nval OP_RUN_TO_COORD = Opcode(\n    code = 0xF8C9,\n    mnemonic = \"run_to_coord\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC9] = it }\n\nval OP_SET_SLOT_INVINCIBLE = Opcode(\n    code = 0xF8CA,\n    mnemonic = \"set_slot_invincible\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCA] = it }\n\nval OP_UNKNOWN_F8CB = Opcode(\n    code = 0xF8CB,\n    mnemonic = \"unknown_f8cb\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xCB] = it }\n\nval OP_SET_SLOT_POISON = Opcode(\n    code = 0xF8CC,\n    mnemonic = \"set_slot_poison\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCC] = it }\n\nval OP_SET_SLOT_PARALYZE = Opcode(\n    code = 0xF8CD,\n    mnemonic = \"set_slot_paralyze\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCD] = it }\n\nval OP_SET_SLOT_SHOCK = Opcode(\n    code = 0xF8CE,\n    mnemonic = \"set_slot_shock\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCE] = it }\n\nval OP_SET_SLOT_FREEZE = Opcode(\n    code = 0xF8CF,\n    mnemonic = \"set_slot_freeze\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCF] = it }\n\nval OP_SET_SLOT_SLOW = Opcode(\n    code = 0xF8D0,\n    mnemonic = \"set_slot_slow\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD0] = it }\n\nval OP_SET_SLOT_CONFUSE = Opcode(\n    code = 0xF8D1,\n    mnemonic = \"set_slot_confuse\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD1] = it }\n\nval OP_SET_SLOT_SHIFTA = Opcode(\n    code = 0xF8D2,\n    mnemonic = \"set_slot_shifta\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD2] = it }\n\nval OP_SET_SLOT_DEBAND = Opcode(\n    code = 0xF8D3,\n    mnemonic = \"set_slot_deband\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD3] = it }\n\nval OP_SET_SLOT_JELLEN = Opcode(\n    code = 0xF8D4,\n    mnemonic = \"set_slot_jellen\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD4] = it }\n\nval OP_SET_SLOT_ZALURE = Opcode(\n    code = 0xF8D5,\n    mnemonic = \"set_slot_zalure\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD5] = it }\n\nval OP_FLETI_FIXED_CAMERA = Opcode(\n    code = 0xF8D6,\n    mnemonic = \"fleti_fixed_camera\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD6] = it }\n\nval OP_FLETI_LOCKED_CAMERA = Opcode(\n    code = 0xF8D7,\n    mnemonic = \"fleti_locked_camera\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD7] = it }\n\nval OP_DEFAULT_CAMERA_POS2 = Opcode(\n    code = 0xF8D8,\n    mnemonic = \"default_camera_pos2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD8] = it }\n\nval OP_SET_MOTION_BLUR = Opcode(\n    code = 0xF8D9,\n    mnemonic = \"set_motion_blur\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD9] = it }\n\nval OP_SET_SCREEN_BW = Opcode(\n    code = 0xF8DA,\n    mnemonic = \"set_screen_bw\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDA] = it }\n\nval OP_UNKNOWN_F8DB = Opcode(\n    code = 0xF8DB,\n    mnemonic = \"unknown_f8db\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xDB] = it }\n\nval OP_NPC_ACTION_STRING = Opcode(\n    code = 0xF8DC,\n    mnemonic = \"npc_action_string\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(SLabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDC] = it }\n\nval OP_GET_PAD_COND = Opcode(\n    code = 0xF8DD,\n    mnemonic = \"get_pad_cond\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDD] = it }\n\nval OP_GET_BUTTON_COND = Opcode(\n    code = 0xF8DE,\n    mnemonic = \"get_button_cond\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDE] = it }\n\nval OP_FREEZE_ENEMIES = Opcode(\n    code = 0xF8DF,\n    mnemonic = \"freeze_enemies\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDF] = it }\n\nval OP_UNFREEZE_ENEMIES = Opcode(\n    code = 0xF8E0,\n    mnemonic = \"unfreeze_enemies\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE0] = it }\n\nval OP_FREEZE_EVERYTHING = Opcode(\n    code = 0xF8E1,\n    mnemonic = \"freeze_everything\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE1] = it }\n\nval OP_UNFREEZE_EVERYTHING = Opcode(\n    code = 0xF8E2,\n    mnemonic = \"unfreeze_everything\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE2] = it }\n\nval OP_RESTORE_HP = Opcode(\n    code = 0xF8E3,\n    mnemonic = \"restore_hp\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE3] = it }\n\nval OP_RESTORE_TP = Opcode(\n    code = 0xF8E4,\n    mnemonic = \"restore_tp\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE4] = it }\n\nval OP_CLOSE_CHAT_BUBBLE = Opcode(\n    code = 0xF8E5,\n    mnemonic = \"close_chat_bubble\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE5] = it }\n\nval OP_MOVE_COORDS_OBJECT = Opcode(\n    code = 0xF8E6,\n    mnemonic = \"move_coords_object\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE6] = it }\n\nval OP_AT_COORDS_CALL_EX = Opcode(\n    code = 0xF8E7,\n    mnemonic = \"at_coords_call_ex\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE7] = it }\n\nval OP_UNKNOWN_F8E8 = Opcode(\n    code = 0xF8E8,\n    mnemonic = \"unknown_f8e8\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xE8] = it }\n\nval OP_UNKNOWN_F8E9 = Opcode(\n    code = 0xF8E9,\n    mnemonic = \"unknown_f8e9\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xE9] = it }\n\nval OP_UNKNOWN_F8EA = Opcode(\n    code = 0xF8EA,\n    mnemonic = \"unknown_f8ea\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEA] = it }\n\nval OP_UNKNOWN_F8EB = Opcode(\n    code = 0xF8EB,\n    mnemonic = \"unknown_f8eb\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEB] = it }\n\nval OP_UNKNOWN_F8EC = Opcode(\n    code = 0xF8EC,\n    mnemonic = \"unknown_f8ec\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEC] = it }\n\nval OP_ANIMATION_CHECK = Opcode(\n    code = 0xF8ED,\n    mnemonic = \"animation_check\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xED] = it }\n\nval OP_CALL_IMAGE_DATA = Opcode(\n    code = 0xF8EE,\n    mnemonic = \"call_image_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xEE] = it }\n\nval OP_TURN_OFF_BGM_P2 = Opcode(\n    code = 0xF8F0,\n    mnemonic = \"turn_off_bgm_p2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF0] = it }\n\nval OP_TURN_ON_BGM_P2 = Opcode(\n    code = 0xF8F1,\n    mnemonic = \"turn_on_bgm_p2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF1] = it }\n\nval OP_LOAD_UNK_DATA = Opcode(\n    code = 0xF8F2,\n    mnemonic = \"load_unk_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(DLabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF2] = it }\n\nval OP_PARTICLE2 = Opcode(\n    code = 0xF8F3,\n    mnemonic = \"particle2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF3] = it }\n\nval OP_DEC2FLOAT = Opcode(\n    code = 0xF901,\n    mnemonic = \"dec2float\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x01] = it }\n\nval OP_FLOAT2DEC = Opcode(\n    code = 0xF902,\n    mnemonic = \"float2dec\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x02] = it }\n\nval OP_FLET = Opcode(\n    code = 0xF903,\n    mnemonic = \"flet\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x03] = it }\n\nval OP_FLETI = Opcode(\n    code = 0xF904,\n    mnemonic = \"fleti\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x04] = it }\n\nval OP_FADD = Opcode(\n    code = 0xF908,\n    mnemonic = \"fadd\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x08] = it }\n\nval OP_FADDI = Opcode(\n    code = 0xF909,\n    mnemonic = \"faddi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x09] = it }\n\nval OP_FSUB = Opcode(\n    code = 0xF90A,\n    mnemonic = \"fsub\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0A] = it }\n\nval OP_FSUBI = Opcode(\n    code = 0xF90B,\n    mnemonic = \"fsubi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0B] = it }\n\nval OP_FMUL = Opcode(\n    code = 0xF90C,\n    mnemonic = \"fmul\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0C] = it }\n\nval OP_FMULI = Opcode(\n    code = 0xF90D,\n    mnemonic = \"fmuli\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0D] = it }\n\nval OP_FDIV = Opcode(\n    code = 0xF90E,\n    mnemonic = \"fdiv\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0E] = it }\n\nval OP_FDIVI = Opcode(\n    code = 0xF90F,\n    mnemonic = \"fdivi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0F] = it }\n\nval OP_GET_UNKNOWN_COUNT = Opcode(\n    code = 0xF910,\n    mnemonic = \"get_unknown_count\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x10] = it }\n\nval OP_GET_STACKABLE_ITEM_COUNT = Opcode(\n    code = 0xF911,\n    mnemonic = \"get_stackable_item_count\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x11] = it }\n\nval OP_FREEZE_AND_HIDE_EQUIP = Opcode(\n    code = 0xF912,\n    mnemonic = \"freeze_and_hide_equip\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x12] = it }\n\nval OP_THAW_AND_SHOW_EQUIP = Opcode(\n    code = 0xF913,\n    mnemonic = \"thaw_and_show_equip\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x13] = it }\n\nval OP_SET_PALETTEX_CALLBACK = Opcode(\n    code = 0xF914,\n    mnemonic = \"set_palettex_callback\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x14] = it }\n\nval OP_ACTIVATE_PALETTEX = Opcode(\n    code = 0xF915,\n    mnemonic = \"activate_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x15] = it }\n\nval OP_ENABLE_PALETTEX = Opcode(\n    code = 0xF916,\n    mnemonic = \"enable_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x16] = it }\n\nval OP_RESTORE_PALETTEX = Opcode(\n    code = 0xF917,\n    mnemonic = \"restore_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x17] = it }\n\nval OP_DISABLE_PALETTEX = Opcode(\n    code = 0xF918,\n    mnemonic = \"disable_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x18] = it }\n\nval OP_GET_PALETTEX_ACTIVATED = Opcode(\n    code = 0xF919,\n    mnemonic = \"get_palettex_activated\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x19] = it }\n\nval OP_GET_UNKNOWN_PALETTEX_STATUS = Opcode(\n    code = 0xF91A,\n    mnemonic = \"get_unknown_palettex_status\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1A] = it }\n\nval OP_DISABLE_MOVEMENT2 = Opcode(\n    code = 0xF91B,\n    mnemonic = \"disable_movement2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1B] = it }\n\nval OP_ENABLE_MOVEMENT2 = Opcode(\n    code = 0xF91C,\n    mnemonic = \"enable_movement2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1C] = it }\n\nval OP_GET_TIME_PLAYED = Opcode(\n    code = 0xF91D,\n    mnemonic = \"get_time_played\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1D] = it }\n\nval OP_GET_GUILDCARD_TOTAL = Opcode(\n    code = 0xF91E,\n    mnemonic = \"get_guildcard_total\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1E] = it }\n\nval OP_GET_SLOT_MESETA = Opcode(\n    code = 0xF91F,\n    mnemonic = \"get_slot_meseta\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1F] = it }\n\nval OP_GET_PLAYER_LEVEL = Opcode(\n    code = 0xF920,\n    mnemonic = \"get_player_level\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x20] = it }\n\nval OP_GET_SECTION_ID = Opcode(\n    code = 0xF921,\n    mnemonic = \"get_section_id\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x21] = it }\n\nval OP_GET_PLAYER_HP = Opcode(\n    code = 0xF922,\n    mnemonic = \"get_player_hp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"max_hp\", null, false, true),\n            Param(IntType, \"hp\", null, false, true),\n            Param(IntType, \"max_tp\", null, false, true),\n            Param(IntType, \"tp\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x22] = it }\n\nval OP_GET_FLOOR_NUMBER = Opcode(\n    code = 0xF923,\n    mnemonic = \"get_floor_number\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x23] = it }\n\nval OP_GET_COORD_PLAYER_DETECT = Opcode(\n    code = 0xF924,\n    mnemonic = \"get_coord_player_detect\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x24] = it }\n\nval OP_READ_GLOBAL_FLAG = Opcode(\n    code = 0xF925,\n    mnemonic = \"read_global_flag\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x25] = it }\n\nval OP_WRITE_GLOBAL_FLAG = Opcode(\n    code = 0xF926,\n    mnemonic = \"write_global_flag\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x26] = it }\n\nval OP_UNKNOWN_F927 = Opcode(\n    code = 0xF927,\n    mnemonic = \"unknown_f927\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x27] = it }\n\nval OP_FLOOR_PLAYER_DETECT = Opcode(\n    code = 0xF928,\n    mnemonic = \"floor_player_detect\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n            Param(IntType, null, null, false, true),\n            Param(IntType, null, null, false, true),\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x28] = it }\n\nval OP_READ_DISK_FILE = Opcode(\n    code = 0xF929,\n    mnemonic = \"read_disk_file\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x29] = it }\n\nval OP_OPEN_PACK_SELECT = Opcode(\n    code = 0xF92A,\n    mnemonic = \"open_pack_select\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2A] = it }\n\nval OP_ITEM_SELECT = Opcode(\n    code = 0xF92B,\n    mnemonic = \"item_select\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2B] = it }\n\nval OP_GET_ITEM_ID = Opcode(\n    code = 0xF92C,\n    mnemonic = \"get_item_id\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2C] = it }\n\nval OP_COLOR_CHANGE = Opcode(\n    code = 0xF92D,\n    mnemonic = \"color_change\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2D] = it }\n\nval OP_SEND_STATISTIC = Opcode(\n    code = 0xF92E,\n    mnemonic = \"send_statistic\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2E] = it }\n\nval OP_UNKNOWN_F92F = Opcode(\n    code = 0xF92F,\n    mnemonic = \"unknown_f92f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x2F] = it }\n\nval OP_CHAT_BOX = Opcode(\n    code = 0xF930,\n    mnemonic = \"chat_box\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x30] = it }\n\nval OP_CHAT_BUBBLE = Opcode(\n    code = 0xF931,\n    mnemonic = \"chat_bubble\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x31] = it }\n\nval OP_UNKNOWN_F933 = Opcode(\n    code = 0xF933,\n    mnemonic = \"unknown_f933\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x33] = it }\n\nval OP_SCROLL_TEXT = Opcode(\n    code = 0xF934,\n    mnemonic = \"scroll_text\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x34] = it }\n\nval OP_GBA_UNKNOWN1 = Opcode(\n    code = 0xF935,\n    mnemonic = \"gba_unknown1\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x35] = it }\n\nval OP_GBA_UNKNOWN2 = Opcode(\n    code = 0xF936,\n    mnemonic = \"gba_unknown2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x36] = it }\n\nval OP_GBA_UNKNOWN3 = Opcode(\n    code = 0xF937,\n    mnemonic = \"gba_unknown3\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x37] = it }\n\nval OP_ADD_DAMAGE_TO = Opcode(\n    code = 0xF938,\n    mnemonic = \"add_damage_to\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x38] = it }\n\nval OP_ITEM_DELETE3 = Opcode(\n    code = 0xF939,\n    mnemonic = \"item_delete3\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x39] = it }\n\nval OP_GET_ITEM_INFO = Opcode(\n    code = 0xF93A,\n    mnemonic = \"get_item_info\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3A] = it }\n\nval OP_ITEM_PACKING1 = Opcode(\n    code = 0xF93B,\n    mnemonic = \"item_packing1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3B] = it }\n\nval OP_ITEM_PACKING2 = Opcode(\n    code = 0xF93C,\n    mnemonic = \"item_packing2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3C] = it }\n\nval OP_GET_LANG_SETTING = Opcode(\n    code = 0xF93D,\n    mnemonic = \"get_lang_setting\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3D] = it }\n\nval OP_PREPARE_STATISTIC = Opcode(\n    code = 0xF93E,\n    mnemonic = \"prepare_statistic\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3E] = it }\n\nval OP_KEYWORD_DETECT = Opcode(\n    code = 0xF93F,\n    mnemonic = \"keyword_detect\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3F] = it }\n\nval OP_KEYWORD = Opcode(\n    code = 0xF940,\n    mnemonic = \"keyword\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, \"slot\", null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x40] = it }\n\nval OP_GET_GUILDCARD_NUM = Opcode(\n    code = 0xF941,\n    mnemonic = \"get_guildcard_num\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x41] = it }\n\nval OP_GET_WRAP_STATUS = Opcode(\n    code = 0xF944,\n    mnemonic = \"get_wrap_status\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x44] = it }\n\nval OP_INITIAL_FLOOR = Opcode(\n    code = 0xF945,\n    mnemonic = \"initial_floor\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x45] = it }\n\nval OP_SIN = Opcode(\n    code = 0xF946,\n    mnemonic = \"sin\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x46] = it }\n\nval OP_COS = Opcode(\n    code = 0xF947,\n    mnemonic = \"cos\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x47] = it }\n\nval OP_BOSS_IS_DEAD2 = Opcode(\n    code = 0xF94A,\n    mnemonic = \"boss_is_dead2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x4A] = it }\n\nval OP_UNKNOWN_F94B = Opcode(\n    code = 0xF94B,\n    mnemonic = \"unknown_f94b\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x4B] = it }\n\nval OP_UNKNOWN_F94C = Opcode(\n    code = 0xF94C,\n    mnemonic = \"unknown_f94c\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x4C] = it }\n\nval OP_IS_THERE_CARDBATTLE = Opcode(\n    code = 0xF94D,\n    mnemonic = \"is_there_cardbattle\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x4D] = it }\n\nval OP_BB_P2_MENU = Opcode(\n    code = 0xF950,\n    mnemonic = \"bb_p2_menu\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x50] = it }\n\nval OP_BB_MAP_DESIGNATE = Opcode(\n    code = 0xF951,\n    mnemonic = \"bb_map_designate\",\n    doc = null,\n    params = listOf(\n        Param(ByteType, null, null, false, false),\n        Param(ShortType, null, null, false, false),\n        Param(ByteType, null, null, false, false),\n        Param(ByteType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x51] = it }\n\nval OP_BB_GET_NUMBER_IN_PACK = Opcode(\n    code = 0xF952,\n    mnemonic = \"bb_get_number_in_pack\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x52] = it }\n\nval OP_BB_SWAP_ITEM = Opcode(\n    code = 0xF953,\n    mnemonic = \"bb_swap_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x53] = it }\n\nval OP_BB_CHECK_WRAP = Opcode(\n    code = 0xF954,\n    mnemonic = \"bb_check_wrap\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x54] = it }\n\nval OP_BB_EXCHANGE_PD_ITEM = Opcode(\n    code = 0xF955,\n    mnemonic = \"bb_exchange_pd_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x55] = it }\n\nval OP_BB_EXCHANGE_PD_SRANK = Opcode(\n    code = 0xF956,\n    mnemonic = \"bb_exchange_pd_srank\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x56] = it }\n\nval OP_BB_EXCHANGE_PD_SPECIAL = Opcode(\n    code = 0xF957,\n    mnemonic = \"bb_exchange_pd_special\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x57] = it }\n\nval OP_BB_EXCHANGE_PD_PERCENT = Opcode(\n    code = 0xF958,\n    mnemonic = \"bb_exchange_pd_percent\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x58] = it }\n\nval OP_UNKNOWN_F959 = Opcode(\n    code = 0xF959,\n    mnemonic = \"unknown_f959\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x59] = it }\n\nval OP_BB_EXCHANGE_SLT = Opcode(\n    code = 0xF95C,\n    mnemonic = \"bb_exchange_slt\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5C] = it }\n\nval OP_BB_EXCHANGE_PC = Opcode(\n    code = 0xF95D,\n    mnemonic = \"bb_exchange_pc\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5D] = it }\n\nval OP_BB_BOX_CREATE_BP = Opcode(\n    code = 0xF95E,\n    mnemonic = \"bb_box_create_bp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5E] = it }\n\nval OP_BB_EXCHANGE_PT = Opcode(\n    code = 0xF95F,\n    mnemonic = \"bb_exchange_pt\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5F] = it }\n\nval OP_UNKNOWN_F960 = Opcode(\n    code = 0xF960,\n    mnemonic = \"unknown_f960\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x60] = it }\n\nval OP_UNKNOWN_F961 = Opcode(\n    code = 0xF961,\n    mnemonic = \"unknown_f961\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x61] = it }\n","package world.phantasmal.lib.asm\n\nimport mu.KotlinLogging\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val INDENT_WIDTH = 4\nprivate val INDENT = \" \".repeat(INDENT_WIDTH)\n\n/**\n * @param inlineStackArgs If true, will output stack arguments inline instead of outputting stack\n * management instructions (argpush variants).\n */\nfun disassemble(bytecodeIr: BytecodeIr, inlineStackArgs: Boolean = true): List<String> {\n    logger.trace {\n        \"Disassembling ${bytecodeIr.segments.size} segments with ${\n            if (inlineStackArgs) \"inline stack arguments\" else \"stack push instructions\"\n        }.\"\n    }\n\n    val lines = mutableListOf<String>()\n    val stack = mutableListOf<ArgWithType>()\n    var sectionType: SegmentType? = null\n\n    for (segment in bytecodeIr.segments) {\n        // Section marker (.code, .data or .string).\n        if (sectionType != segment.type) {\n            sectionType = segment.type\n\n            if (lines.isNotEmpty()) {\n                lines.add(\"\")\n            }\n\n            val sectionMarker = when (segment) {\n                is InstructionSegment -> \".code\"\n                is DataSegment -> \".data\"\n                is StringSegment -> \".string\"\n            }\n\n            lines.add(sectionMarker)\n            lines.add(\"\")\n        }\n\n        // Labels.\n        for (label in segment.labels) {\n            lines.add(\"$label:\")\n        }\n\n        // Code or data lines.\n        when (segment) {\n            is InstructionSegment -> {\n                var inVaList = false\n\n                segment.instructions.forEachIndexed { i, instruction ->\n                    val opcode = instruction.opcode\n\n                    if (opcode.code == OP_VA_START.code) {\n                        inVaList = true\n                    } else if (opcode.code == OP_VA_END.code) {\n                        inVaList = false\n                    }\n\n                    if (inlineStackArgs &&\n                        !inVaList &&\n                        opcode.stack == StackInteraction.Push &&\n                        canInlinePushedArg(segment, i)\n                    ) {\n                        stack.addAll(addTypeToArgs(opcode.params, instruction.args))\n                    } else {\n                        val sb = StringBuilder(INDENT)\n                        sb.append(opcode.mnemonic)\n\n                        if (opcode.stack == StackInteraction.Pop) {\n                            if (inlineStackArgs) {\n                                sb.appendArgs(\n                                    opcode.params,\n                                    stack.takeLast(opcode.params.size),\n                                    stack = true,\n                                )\n                            }\n                        } else {\n                            sb.appendArgs(\n                                opcode.params,\n                                addTypeToArgs(opcode.params, instruction.args),\n                                stack = false\n                            )\n                        }\n\n                        if (opcode.stack != StackInteraction.Push) {\n                            stack.clear()\n                        }\n\n                        lines.add(sb.toString())\n                    }\n                }\n            }\n\n            is DataSegment -> {\n                val sb = StringBuilder(INDENT)\n\n                for (i in 0 until segment.data.size) {\n                    sb.append(\"0x\")\n                    sb.append(segment.data.getUByte(i).toString(16).padStart(2, '0'))\n\n                    when {\n                        // Last line.\n                        i == segment.data.size - 1 -> {\n                            lines.add(sb.toString())\n                        }\n                        // Start a new line after every 16 bytes.\n                        i % 16 == 15 -> {\n                            lines.add(sb.toString())\n                            sb.setLength(0)\n                            sb.append(INDENT)\n                        }\n                        // Add a space between each byte.\n                        else -> {\n                            sb.append(\" \")\n                        }\n                    }\n                }\n            }\n\n            is StringSegment -> {\n                lines.add(StringBuilder(INDENT).appendStringSegment(segment.value).toString())\n            }\n        }\n    }\n\n    // Ensure newline at the end.\n    lines.add(\"\")\n\n    logger.trace { \"Disassembly finished, line count: ${lines.size}.\" }\n\n    return lines\n}\n\nprivate data class ArgWithType(val arg: Arg, val type: AnyType)\n\nprivate fun canInlinePushedArg(segment: InstructionSegment, index: Int): Boolean {\n    var pushedArgCount = 0\n\n    for (i in index until segment.instructions.size) {\n        val opcode = segment.instructions[i].opcode\n\n        when (opcode.stack) {\n            StackInteraction.Push -> pushedArgCount++\n\n            StackInteraction.Pop -> {\n                var paramCount = 0\n                var varArgs = false\n\n                for (param in opcode.params) {\n                    when (param.type) {\n                        is ILabelVarType -> varArgs = true\n                        is RegVarType -> varArgs = true\n                        else -> paramCount++\n                    }\n                }\n\n                return pushedArgCount <= paramCount || (pushedArgCount > paramCount && varArgs)\n            }\n\n            null -> return false\n        }\n    }\n\n    return false\n}\n\nprivate fun addTypeToArgs(params: List<Param>, args: List<Arg>): List<ArgWithType> {\n    val argsWithType = mutableListOf<ArgWithType>()\n\n    for (i in 0 until min(params.size, args.size)) {\n        argsWithType.add(ArgWithType(args[i], params[i].type))\n    }\n\n    // Deal with varargs.\n    val lastParam = params.lastOrNull()\n\n    if (lastParam?.varargs == true) {\n        for (i in argsWithType.size until args.size) {\n            argsWithType.add(ArgWithType(args[i], lastParam.type))\n        }\n    }\n\n    return argsWithType\n}\n\nprivate fun StringBuilder.appendArgs(params: List<Param>, args: List<ArgWithType>, stack: Boolean) {\n    var i = 0\n\n    while (i < params.size) {\n        val paramType = params[i].type\n\n        if (i == 0) {\n            append(\" \")\n        } else {\n            append(\", \")\n        }\n\n        if (i < args.size) {\n            val (arg, argType) = args[i]\n\n            if (argType is RegType) {\n                append(\"r\")\n                append(arg.value)\n            } else {\n                when (paramType) {\n                    FloatType -> {\n                        // Floats are pushed onto the stack as integers with arg_pushl.\n                        if (stack) {\n                            append(Float.fromBits((arg as IntArg).value))\n                        } else {\n                            append(arg.value)\n                        }\n                    }\n\n                    ILabelVarType -> {\n                        while (i < args.size) {\n                            append(args[i].arg.value)\n                            if (i < args.lastIndex) append(\", \")\n                            i++\n                        }\n                    }\n\n                    RegVarType -> {\n                        while (i < args.size) {\n                            append(\"r\")\n                            append(args[i].arg.value)\n                            if (i < args.lastIndex) append(\", \")\n                            i++\n                        }\n                    }\n\n                    is RegType -> {\n                        append(\"r\")\n                        append(arg.value)\n                    }\n\n                    StringType -> {\n                        appendStringArg((arg as StringArg).value)\n                    }\n\n                    else -> {\n                        append(arg.value)\n                    }\n                }\n            }\n        }\n\n        i++\n    }\n}\n\nprivate fun StringBuilder.appendStringArg(value: String): StringBuilder {\n    append(\"\\\"\")\n\n    for (char in value) {\n        when (char) {\n            '\\r' -> append(\"\\\\r\")\n            '\\n' -> append(\"\\\\n\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            else -> append(char)\n        }\n    }\n\n    append(\"\\\"\")\n    return this\n}\n\nprivate fun StringBuilder.appendStringSegment(value: String): StringBuilder {\n    append(\"\\\"\")\n\n    var i = 0\n\n    while (i < value.length) {\n        when (val char = value[i]) {\n            // Replace <cr> with \\n.\n            '<' -> {\n                if (i + 3 < value.length &&\n                    value[i + 1] == 'c' &&\n                    value[i + 2] == 'r' &&\n                    value[i + 3] == '>'\n                ) {\n                    append(\"\\\\n\")\n                    i += 3\n                } else {\n                    append(char)\n                }\n            }\n            '\\r' -> append(\"\\\\r\")\n            '\\n' -> append(\"\\\\n\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            else -> append(char)\n        }\n\n        i++\n    }\n\n    append(\"\\\"\")\n    return this\n}\n","package world.phantasmal.lib.compression.prs\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.WritableCursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n// This code uses signed types for better KJS performance. In KJS unsigned types are always boxed.\n\nfun prsDecompress(cursor: Cursor): PwResult<Cursor> =\n    PrsDecompressor(cursor).decompress()\n\nprivate class PrsDecompressor(private val src: Cursor) {\n    private val dst: WritableCursor =\n        Buffer.withCapacity(6 * src.size, src.endianness).cursor()\n    private var flags = 0\n    private var flagBitsLeft = 0\n\n    fun decompress(): PwResult<Cursor> {\n        try {\n            while (true) {\n                if (readFlagBit() == 1) {\n                    // Single byte copy.\n                    copyByte()\n                } else {\n                    // Multi byte copy.\n                    if (readFlagBit() == 0) {\n                        // Short copy.\n                        val size = 2 + ((readFlagBit() shl 1) or readFlagBit())\n                        val offset = readUByte() - 256\n\n                        offsetCopy(offset, size)\n                    } else {\n                        // Long copy or end of file.\n                        var offset = readUShort()\n\n                        // Two zero bytes implies that this is the end of the file.\n                        if (offset == 0) {\n                            break\n                        }\n\n                        // Do we need to read a size byte, or is it encoded in what we already have?\n                        var size = offset and 0b111\n                        offset = offset ushr 3\n\n                        if (size == 0) {\n                            size = readUByte()\n                            size += 1\n                        } else {\n                            size += 2\n                        }\n\n                        offset -= 8192\n\n                        offsetCopy(offset, size)\n                    }\n                }\n            }\n\n            return Success(dst.seekStart(0))\n        } catch (e: Exception) {\n            return PwResult.build<Cursor>(logger)\n                .addProblem(Severity.Error, \"PRS-compressed stream is corrupt.\", cause = e)\n                .failure()\n        }\n    }\n\n    private fun readFlagBit(): Int {\n        // Fetch a new flag byte when the previous byte has been processed.\n        if (flagBitsLeft == 0) {\n            flags = readUByte()\n            flagBitsLeft = 8\n        }\n\n        val bit = flags and 1\n        flags = flags ushr 1\n        flagBitsLeft -= 1\n        return bit\n    }\n\n    private fun copyByte() {\n        dst.writeByte(src.byte())\n    }\n\n    private fun readUByte(): Int = src.byte().toInt() and 0xFF\n\n    private fun readUShort(): Int = src.short().toInt() and 0xFFFF\n\n    private fun offsetCopy(offset: Int, size: Int) {\n        require(offset in -8192..0) {\n            \"offset was ${offset}, should be between -8192 and 0.\"\n        }\n\n        require(size in 1..256) {\n            \"size was ${size}, should be between 1 and 256.\"\n        }\n\n        // Size can be larger than -offset, in that case we copy -offset bytes size/-offset times.\n        val bufSize = min(-offset, size)\n\n        dst.seek(offset)\n        val buf = dst.take(bufSize)\n        dst.seek(-offset - bufSize)\n\n        repeat(size / bufSize) {\n            dst.writeCursor(buf)\n            buf.seekStart(0)\n        }\n\n        dst.writeCursor(buf.take(size % bufSize))\n    }\n}\n","package world.phantasmal.lib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val AFS = 0x00534641\n\n/**\n * Returns the files contained in the given AFS archive. AFS is a simple archive format used by SEGA\n * for e.g. player character textures.\n */\nfun parseAfs(cursor: Cursor): PwResult<List<Buffer>> {\n    val result = PwResult.build<List<Buffer>>(logger)\n\n    if (cursor.bytesLeft < 8) {\n        return result\n            .addProblem(\n                Severity.Error,\n                \"AFS archive is corrupted.\",\n                \"Expected at least 8 bytes for the header, got ${cursor.bytesLeft} bytes.\",\n            )\n            .failure()\n    }\n\n    val magic = cursor.int()\n\n    if (magic != AFS) {\n        return result\n            .addProblem(Severity.Error, \"AFS archive is corrupted.\", \"Magic bytes not present.\")\n            .failure()\n    }\n\n    val fileCount = cursor.short()\n\n    // Skip two unused bytes (are these just part of the file count field?).\n    cursor.seek(2)\n\n    val files = mutableListOf<Buffer>()\n\n    for (i in 1..fileCount) {\n        if (cursor.bytesLeft < 8) {\n            result.addProblem(\n                Severity.Warning,\n                \"AFS file entry $i is invalid.\",\n                \"Couldn't read file entry $i, only ${cursor.bytesLeft} bytes left.\",\n            )\n\n            break\n        }\n\n        val offset = cursor.int()\n        val size = cursor.int()\n\n        when {\n            offset > cursor.size -> {\n                result.addProblem(\n                    Severity.Warning,\n                    \"AFS file entry $i is invalid.\",\n                    \"Invalid file offset $offset for entry $i.\",\n                )\n            }\n\n            offset + size > cursor.size -> {\n                result.addProblem(\n                    Severity.Warning,\n                    \"AFS file entry $i is invalid.\",\n                    \"File size $size (offset: $offset) of entry $i too large.\",\n                )\n            }\n\n            else -> {\n                val startPos = cursor.position\n                cursor.seekStart(offset)\n                files.add(cursor.buffer(size))\n                cursor.seekStart(startPos)\n            }\n        }\n    }\n\n    return result.success(files)\n}\n","package world.phantasmal.lib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.isBitSet\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.ninja.*\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AreaGeometry(\n    val sections: List<AreaSection>,\n)\n\nclass AreaSection(\n    val id: Int,\n    val position: Vec3,\n    val rotation: Vec3,\n    val radius: Float,\n    val objects: List<AreaObject.Simple>,\n    val animatedObjects: List<AreaObject.Animated>,\n)\n\nsealed class AreaObject {\n    abstract val offset: Int\n    abstract val xjObject: XjObject\n    abstract val flags: Int\n\n    class Simple(\n        override val offset: Int,\n        override val xjObject: XjObject,\n        override val flags: Int,\n    ) : AreaObject()\n\n    class Animated(\n        override val offset: Int,\n        override val xjObject: XjObject,\n        val njMotion: NjMotion,\n        val speed: Float,\n        override val flags: Int,\n    ) : AreaObject()\n}\n\nfun parseAreaRenderGeometry(cursor: Cursor): AreaGeometry {\n    val dataOffset = parseRel(cursor, parseIndex = false).dataOffset\n\n    cursor.seekStart(dataOffset)\n    val format = cursor.stringAscii(maxByteLength = 4, nullTerminated = true, dropRemaining = true)\n\n    if (format != \"fmt2\") {\n        logger.warn { \"\"\"Expected format to be \"fmt2\" but was \"$format\".\"\"\" }\n    }\n\n    cursor.seek(4)\n    val sectionsCount = cursor.int()\n    cursor.seek(4)\n    val sectionsOffset = cursor.int()\n\n    val sections = mutableListOf<AreaSection>()\n\n    // Cache keys are offsets.\n    val simpleAreaObjectCache = mutableMapOf<Int, List<AreaObject.Simple>>()\n    val animatedAreaObjectCache = mutableMapOf<Int, List<AreaObject.Animated>>()\n    val njMotionCache = mutableMapOf<Int, NjMotion>()\n\n    for (i in 0 until sectionsCount) {\n        cursor.seekStart(sectionsOffset + 52 * i)\n\n        val sectionId = cursor.int()\n        val sectionPosition = cursor.vec3Float()\n        val sectionRotation = Vec3(\n            angleToRad(cursor.int()),\n            angleToRad(cursor.int()),\n            angleToRad(cursor.int()),\n        )\n\n        val radius = cursor.float()\n\n        val simpleAreaObjectsOffset = cursor.int()\n        val animatedAreaObjectsOffset = cursor.int()\n        val simpleAreaObjectsCount = cursor.int()\n        val animatedAreaObjectsCount = cursor.int()\n        // Ignore the last 4 bytes.\n\n//        println(\"section $sectionId (index $i), simple geom at $simpleGeometryTableOffset, animated geom at $animatedGeometryTableOffset\")\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val simpleObjects = simpleAreaObjectCache.getOrPut(simpleAreaObjectsOffset) {\n            parseAreaObjects(\n                cursor,\n                njMotionCache,\n                simpleAreaObjectsOffset,\n                simpleAreaObjectsCount,\n                animated = false,\n            ) as List<AreaObject.Simple>\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val animatedObjects = animatedAreaObjectCache.getOrPut(animatedAreaObjectsOffset) {\n            parseAreaObjects(\n                cursor,\n                njMotionCache,\n                animatedAreaObjectsOffset,\n                animatedAreaObjectsCount,\n                animated = true,\n            ) as List<AreaObject.Animated>\n        }\n\n        sections.add(AreaSection(\n            sectionId,\n            sectionPosition,\n            sectionRotation,\n            radius,\n            simpleObjects,\n            animatedObjects,\n        ))\n    }\n\n    return AreaGeometry(sections)\n}\n\nprivate fun parseAreaObjects(\n    cursor: Cursor,\n    njMotionCache: MutableMap<Int, NjMotion>,\n    offset: Int,\n    count: Int,\n    animated: Boolean,\n): List<AreaObject> {\n    val objectSize = if (animated) 32 else 16\n    val objects = mutableListOf<AreaObject>()\n\n    for (i in 0 until count) {\n        val objectOffset = offset + objectSize * i\n        cursor.seekStart(objectOffset)\n\n        var xjObjectOffset = cursor.int()\n        val speed: Float?\n        val njMotionOffset: Int?\n\n        if (animated) {\n            njMotionOffset = cursor.int()\n            cursor.seek(8)\n            speed = cursor.float()\n        } else {\n            speed = null\n            njMotionOffset = null\n        }\n\n        cursor.seek(8) // Skip slide texture ID offset and swap texture ID offset.\n\n        val flags = cursor.int()\n\n        if (flags.isBitSet(2)) {\n            xjObjectOffset = cursor.seekStart(xjObjectOffset).int()\n        }\n\n        cursor.seekStart(xjObjectOffset)\n        val xjObjects = parseXjObject(cursor)\n\n        if (xjObjects.size > 1) {\n            logger.warn {\n                \"Expected exactly one xjObject at ${xjObjectOffset}, got ${xjObjects.size}.\"\n            }\n        }\n\n        val xjObject = xjObjects.first()\n\n        val njMotion = njMotionOffset?.let {\n            njMotionCache.getOrPut(njMotionOffset) {\n                cursor.seekStart(njMotionOffset)\n                parseMotion(cursor, v2Format = false)\n            }\n        }\n\n        objects.add(\n            if (animated) {\n                AreaObject.Animated(objectOffset, xjObject, njMotion!!, speed!!, flags)\n            } else {\n                AreaObject.Simple(objectOffset, xjObject, flags)\n            }\n        )\n    }\n\n    return objects\n}\n","package world.phantasmal.lib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.cursor.Cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nclass IffChunk(val type: Int, val data: Cursor)\n\nclass IffChunkHeader(val type: Int, val size: Int)\n\n/**\n * PSO uses a little endian variant of the IFF format.\n * IFF files contain chunks preceded by an 8-byte header.\n * The header consists of 4 ASCII characters for the \"Type ID\" and a 32-bit integer specifying the chunk size.\n */\nfun parseIff(cursor: Cursor, silent: Boolean = false): PwResult<List<IffChunk>> =\n    parse(cursor, silent) { chunkCursor, type, size -> IffChunk(type, chunkCursor.take(size)) }\n\n/**\n * Parses just the chunk headers.\n */\nfun parseIffHeaders(cursor: Cursor, silent: Boolean = false): PwResult<List<IffChunkHeader>> =\n    parse(cursor, silent) { _, type, size -> IffChunkHeader(type, size) }\n\nprivate fun <T> parse(\n    cursor: Cursor,\n    silent: Boolean,\n    getChunk: (Cursor, type: Int, size: Int) -> T,\n): PwResult<List<T>> {\n    val result = PwResult.build<List<T>>(logger)\n    val chunks = mutableListOf<T>()\n    var corrupted = false\n\n    while (cursor.bytesLeft >= 8) {\n        val type = cursor.int()\n        val sizePos = cursor.position\n        val size = cursor.int()\n\n        if (size > cursor.bytesLeft) {\n            corrupted = true\n\n            if (!silent) {\n                result.addProblem(\n                    if (chunks.isEmpty()) Severity.Error else Severity.Warning,\n                    \"IFF file corrupted.\",\n                    \"Size $size was too large (only ${cursor.bytesLeft} bytes left) at position $sizePos.\"\n                )\n            }\n\n            break\n        }\n\n        chunks.add(getChunk(cursor, type, size))\n    }\n\n    return if (corrupted && chunks.isEmpty()) {\n        result.failure()\n    } else {\n        result.success(chunks)\n    }\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport kotlin.math.PI\nimport kotlin.math.round\n\nprivate const val ANGLE_TO_RAD = ((2 * PI) / 0x10000).toFloat()\nprivate const val RAD_TO_ANGLE = (0x10000 / (2 * PI)).toFloat()\n\nfun angleToRad(angle: Int): Float {\n    return angle * ANGLE_TO_RAD\n}\n\nfun radToAngle(rad: Float): Int {\n    return round(rad * RAD_TO_ANGLE).toInt()\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.isBitSet\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.Vec2\nimport world.phantasmal.lib.fileFormats.Vec3\nimport world.phantasmal.lib.fileFormats.vec3Float\nimport kotlin.math.abs\n\n// TODO:\n//  - colors\n//  - bump maps\n\nprivate val logger = KotlinLogging.logger {}\n\n// TODO: Simplify parser by not parsing chunks into vertices and meshes. Do the chunk to vertex/mesh\n//       conversion at a higher level.\nfun parseNjModel(cursor: Cursor, cachedChunks: MutableMap<Int, List<NjChunk>>): NjModel {\n    val vlistOffset = cursor.int() // Vertex list\n    val plistOffset = cursor.int() // Triangle strip index list\n    val collisionSphereCenter = cursor.vec3Float()\n    val collisionSphereRadius = cursor.float()\n    val vertices: MutableList<NjVertex?> = mutableListOf()\n    val meshes: MutableList<NjTriangleStrip> = mutableListOf()\n\n    if (vlistOffset != 0) {\n        cursor.seekStart(vlistOffset)\n\n        for (chunk in parseChunks(cursor)) {\n            if (chunk is NjChunk.Vertex) {\n                for (vertex in chunk.vertices) {\n                    while (vertices.size <= vertex.index) {\n                        vertices.add(null)\n                    }\n\n                    vertices[vertex.index] = NjVertex(\n                        vertex.position,\n                        vertex.normal,\n                        vertex.boneWeight,\n                        vertex.boneWeightStatus,\n                        vertex.calcContinue,\n                    )\n                }\n            }\n        }\n    }\n\n    if (plistOffset > 0) {\n        cursor.seekStart(plistOffset)\n\n        PolygonChunkProcessor(cachedChunks, meshes).process(parseChunks(cursor))\n    }\n\n    return NjModel(\n        vertices,\n        meshes,\n        collisionSphereCenter,\n        collisionSphereRadius,\n    )\n}\n\nprivate class PolygonChunkProcessor(\n    private val cachedChunks: MutableMap<Int, List<NjChunk>>,\n    private val meshes: MutableList<NjTriangleStrip>,\n) {\n    private var textureId: Int? = null\n    private var srcAlpha: Int? = null\n    private var dstAlpha: Int? = null\n\n    /**\n     * When [cacheList] is non-null we are caching chunks.\n     */\n    private var cacheList: MutableList<NjChunk>? = null\n\n    fun process(chunks: List<NjChunk>) {\n        for (chunk in chunks) {\n            if (cacheList == null) {\n                when (chunk) {\n                    is NjChunk.BlendAlpha -> {\n                        srcAlpha = chunk.srcAlpha\n                        dstAlpha = chunk.dstAlpha\n                    }\n\n                    is NjChunk.CachePolygonList -> {\n                        cacheList = mutableListOf()\n                        cachedChunks[chunk.cacheIndex] = cacheList!!\n                    }\n\n                    is NjChunk.DrawPolygonList -> {\n                        val cached = cachedChunks[chunk.cacheIndex]\n\n                        if (cached == null) {\n                            logger.debug {\n                                \"Draw Polygon List chunk pointed to nonexistent cache index ${chunk.cacheIndex}.\"\n                            }\n                        } else {\n                            process(cached)\n                        }\n                    }\n\n                    is NjChunk.Tiny -> {\n                        textureId = chunk.textureId\n                    }\n\n                    is NjChunk.Material -> {\n                        srcAlpha = chunk.srcAlpha\n                        dstAlpha = chunk.dstAlpha\n                    }\n\n                    is NjChunk.Strip -> {\n                        for (strip in chunk.triangleStrips) {\n                            strip.textureId = textureId\n                            strip.srcAlpha = srcAlpha\n                            strip.dstAlpha = dstAlpha\n                        }\n\n                        meshes.addAll(chunk.triangleStrips)\n                    }\n\n                    else -> {\n                        // Ignore\n                    }\n                }\n            } else {\n                cacheList!!.add(chunk)\n            }\n        }\n    }\n}\n\nprivate fun parseChunks(cursor: Cursor): List<NjChunk> {\n    val chunks: MutableList<NjChunk> = mutableListOf()\n\n    do {\n        val chunkStartPosition = cursor.position\n        val typeId = cursor.uByte().toInt()\n        val flags = cursor.uByte().toInt()\n        val chunkDataPosition = cursor.position\n        var size = 0\n        val chunk: NjChunk\n\n        when (typeId) {\n            0 -> {\n                chunk = NjChunk.Null\n            }\n            1 -> {\n                chunk = NjChunk.BlendAlpha(\n                    srcAlpha = (flags ushr 3) and 0b111,\n                    dstAlpha = flags and 0b111,\n                )\n            }\n            2 -> {\n                chunk = NjChunk.MipmapDAdjust(\n                    adjust = flags and 0b1111,\n                )\n            }\n            3 -> {\n                chunk = NjChunk.SpecularExponent(\n                    specular = flags and 0b11111,\n                )\n            }\n            4 -> {\n                chunk = NjChunk.CachePolygonList(\n                    cacheIndex = flags,\n                )\n            }\n            5 -> {\n                chunk = NjChunk.DrawPolygonList(\n                    cacheIndex = flags,\n                )\n            }\n            in 8..9 -> {\n                size = 2\n                val textureBitsAndId = cursor.uShort().toInt()\n\n                chunk = NjChunk.Tiny(\n                    typeId,\n                    flipU = flags.isBitSet(7),\n                    flipV = flags.isBitSet(6),\n                    clampU = flags.isBitSet(5),\n                    clampV = flags.isBitSet(4),\n                    mipmapDAdjust = flags.toUInt() and 0b1111u,\n                    filterMode = textureBitsAndId ushr 14,\n                    superSample = (textureBitsAndId and 0x40) != 0,\n                    textureId = textureBitsAndId and 0x1FFF,\n                )\n            }\n            in 17..31 -> {\n                val bodySize = 2 * cursor.short()\n                size = 2 + bodySize\n\n                var diffuse: NjArgb? = null\n                var ambient: NjArgb? = null\n                var specular: NjErgb? = null\n\n                if (typeId == 24) {\n                    // Skip bump map data.\n                    cursor.seek(bodySize)\n                } else {\n                    if (typeId.isBitSet(0)) {\n                        diffuse = NjArgb(\n                            b = cursor.uByte().toFloat() / 255f,\n                            g = cursor.uByte().toFloat() / 255f,\n                            r = cursor.uByte().toFloat() / 255f,\n                            a = cursor.uByte().toFloat() / 255f,\n                        )\n                    }\n\n                    if (typeId.isBitSet(1)) {\n                        ambient = NjArgb(\n                            b = cursor.uByte().toFloat() / 255f,\n                            g = cursor.uByte().toFloat() / 255f,\n                            r = cursor.uByte().toFloat() / 255f,\n                            a = cursor.uByte().toFloat() / 255f,\n                        )\n                    }\n\n                    if (typeId.isBitSet(2)) {\n                        specular = NjErgb(\n                            b = cursor.uByte(),\n                            g = cursor.uByte(),\n                            r = cursor.uByte(),\n                            e = cursor.uByte(),\n                        )\n                    }\n                }\n\n                chunk = NjChunk.Material(\n                    typeId,\n                    srcAlpha = (flags ushr 3) and 0b111,\n                    dstAlpha = flags and 0b111,\n                    diffuse,\n                    ambient,\n                    specular,\n                )\n            }\n            in 32..50 -> {\n                size = 2 + 4 * cursor.short()\n                chunk = NjChunk.Vertex(\n                    typeId,\n                    vertices = parseVertexChunk(cursor, typeId, flags),\n                )\n            }\n            in 56..58 -> {\n                size = 2 + 2 * cursor.short()\n                chunk = NjChunk.Volume(\n                    typeId,\n                )\n\n                // Skip volume information.\n                cursor.seek(2 * cursor.short())\n            }\n            in 64..75 -> {\n                size = 2 + 2 * cursor.short()\n                chunk = NjChunk.Strip(\n                    typeId,\n                    triangleStrips = parseTriangleStripChunk(cursor, typeId, flags),\n                )\n            }\n            255 -> {\n                chunk = NjChunk.End\n            }\n            else -> {\n                val bodySize = 2 * cursor.short()\n                size = 2 + bodySize\n                chunk = NjChunk.Unknown(\n                    typeId,\n                )\n                // Skip unknown data.\n                cursor.seek(bodySize)\n                logger.warn { \"Unknown chunk type $typeId at offset ${chunkStartPosition}.\" }\n            }\n        }\n\n        chunks.add(chunk)\n\n        val bytesRead = cursor.position - chunkDataPosition\n\n        check(bytesRead <= size) {\n            \"Expected to read at most $size bytes, actually read $bytesRead.\"\n        }\n\n        cursor.seekStart(chunkDataPosition + size)\n    } while (chunk != NjChunk.End)\n\n    return chunks\n}\n\nprivate fun parseVertexChunk(\n    cursor: Cursor,\n    chunkTypeId: Int,\n    flags: Int,\n): List<NjChunkVertex> {\n    val boneWeightStatus = flags and 0b11\n    val calcContinue = (flags and 0x80) != 0\n\n    val index = cursor.uShort()\n    val vertexCount = cursor.uShort()\n\n    val vertices: MutableList<NjChunkVertex> = mutableListOf()\n\n    for (i in (0u).toUShort() until vertexCount) {\n        var vertexIndex = index + i\n        val position = cursor.vec3Float()\n        var normal: Vec3? = null\n        var boneWeight: Float? = null\n\n        when (chunkTypeId) {\n            32 -> {\n                // NJD_CV_SH\n                cursor.seek(4) // Always 1.0\n            }\n            33 -> {\n                // NJD_CV_VN_SH\n                cursor.seek(4) // Always 1.0\n                normal = cursor.vec3Float()\n                cursor.seek(4) // Always 0.0\n            }\n            34 -> {\n                // NJD_CV\n                // Nothing to do.\n            }\n            in 35..40 -> {\n                if (chunkTypeId == 37) {\n                    // NJD_CV_NF\n                    // NinjaFlags32\n                    vertexIndex = index + cursor.uShort()\n                    boneWeight = cursor.uShort().toFloat() / 255f\n                } else {\n                    // NJD_CV_D8\n                    // NJD_CV_UF\n                    // NJD_CV_S5\n                    // NJD_CV_S4\n                    // NJD_CV_IN\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            41 -> {\n                // NJD_CV_VN\n                normal = cursor.vec3Float()\n            }\n            in 42..47 -> {\n                normal = cursor.vec3Float()\n\n                if (chunkTypeId == 44) {\n                    // NJD_CV_VN_NF\n                    // NinjaFlags32\n                    vertexIndex = index + cursor.uShort()\n                    boneWeight = cursor.uShort().toFloat() / 255f\n                } else {\n                    // NJD_CV_VN_D8\n                    // NJD_CV_VN_UF\n                    // NJD_CV_VN_S5\n                    // NJD_CV_VN_S4\n                    // NJD_CV_VN_IN\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            in 48..50 -> {\n                // NJD_CV_VNX\n                // 32-Bit vertex normal in format: reserved(2)|x(10)|y(10)|z(10)\n                val n = cursor.uInt()\n                normal = Vec3(\n                    ((n shr 20) and 0x3FFu).toFloat() / 0x3FF,\n                    ((n shr 10) and 0x3FFu).toFloat() / 0x3FF,\n                    (n and 0x3FFu).toFloat() / 0x3FF,\n                )\n\n                if (chunkTypeId >= 49) {\n                    // NJD_CV_VNX_D8\n                    // NJD_CV_VNX_UF\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            else -> error(\"Unexpected chunk type ID ${chunkTypeId}.\")\n        }\n\n        vertices.add(NjChunkVertex(\n            vertexIndex.toInt(),\n            position,\n            normal,\n            boneWeight,\n            boneWeightStatus,\n            calcContinue,\n        ))\n    }\n\n    return vertices\n}\n\nprivate fun parseTriangleStripChunk(\n    cursor: Cursor,\n    chunkTypeId: Int,\n    flags: Int,\n): List<NjTriangleStrip> {\n    val ignoreLight = flags.isBitSet(0)\n    val ignoreSpecular = flags.isBitSet(1)\n    val ignoreAmbient = flags.isBitSet(2)\n    val useAlpha = flags.isBitSet(3)\n    val doubleSide = flags.isBitSet(4)\n    val flatShading = flags.isBitSet(5)\n    val environmentMapping = flags.isBitSet(6)\n\n    val userOffsetAndStripCount = cursor.short().toInt()\n    val userFlagsSize = 2 * (userOffsetAndStripCount ushr 14)\n    val stripCount = userOffsetAndStripCount and 0x3FFF\n\n    var hasTexCoords = false\n    var hasColor = false\n    var hasNormal = false\n    var hasDoubleTexCoords = false\n\n    when (chunkTypeId) {\n        64 -> {\n        }\n        65, 66 -> {\n            hasTexCoords = true\n        }\n        67 -> {\n            hasNormal = true\n        }\n        68, 69 -> {\n            hasTexCoords = true\n            hasNormal = true\n        }\n        70 -> {\n            hasColor = true\n        }\n        71, 72 -> {\n            hasTexCoords = true\n            hasColor = true\n        }\n        73 -> {\n        }\n        74, 75 -> {\n            hasDoubleTexCoords = true\n        }\n        else -> error(\"Unexpected chunk type ID: ${chunkTypeId}.\")\n    }\n\n    val strips: MutableList<NjTriangleStrip> = mutableListOf()\n\n    repeat(stripCount) {\n        val windingFlagAndIndexCount = cursor.short().toInt()\n        val clockwiseWinding = windingFlagAndIndexCount < 0\n        val indexCount = abs(windingFlagAndIndexCount)\n\n        val vertices: MutableList<NjMeshVertex> = mutableListOf()\n\n        for (j in 0 until indexCount) {\n            val index = cursor.uShort().toInt()\n\n            val texCoords = if (hasTexCoords) {\n                Vec2(cursor.uShort().toFloat() / 255f, cursor.uShort().toFloat() / 255f)\n            } else null\n\n            // Ignore ARGB8888 color.\n            if (hasColor) {\n                cursor.seek(4)\n            }\n\n            val normal = if (hasNormal) {\n                Vec3(\n                    cursor.uShort().toFloat() / 255f,\n                    cursor.uShort().toFloat() / 255f,\n                    cursor.uShort().toFloat() / 255f,\n                )\n            } else null\n\n            // Ignore double texture coordinates (Ua, Vb, Ua, Vb).\n            if (hasDoubleTexCoords) {\n                cursor.seek(8)\n            }\n\n            // User flags start at the third vertex because they are per-triangle.\n            if (j >= 2) {\n                cursor.seek(userFlagsSize)\n            }\n\n            vertices.add(NjMeshVertex(\n                index,\n                normal,\n                texCoords,\n            ))\n        }\n\n        strips.add(NjTriangleStrip(\n            ignoreLight,\n            ignoreSpecular,\n            ignoreAmbient,\n            useAlpha,\n            doubleSide,\n            flatShading,\n            environmentMapping,\n            clockwiseWinding,\n            hasTexCoords,\n            hasNormal,\n            textureId = null,\n            srcAlpha = null,\n            dstAlpha = null,\n            vertices,\n        ))\n    }\n\n    return strips\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.Failure\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.parseIff\nimport world.phantasmal.lib.fileFormats.parseIffHeaders\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val XVMH = 0x484d5658\nprivate const val XVRT = 0x54525658\n\nclass Xvm(\n    val textures: List<XvrTexture>,\n)\n\nclass XvrTexture(\n    val id: Int,\n    val format: Pair<Int, Int>,\n    val width: Int,\n    val height: Int,\n    val size: Int,\n    val data: Buffer,\n)\n\nfun parseXvr(cursor: Cursor): XvrTexture {\n    val format1 = cursor.int()\n    val format2 = cursor.int()\n    val id = cursor.int()\n    val width = cursor.uShort().toInt()\n    val height = cursor.uShort().toInt()\n    val size = cursor.int()\n    cursor.seek(36)\n    val data = cursor.buffer(size)\n    return XvrTexture(\n        id,\n        format = Pair(format1, format2),\n        width,\n        height,\n        size,\n        data,\n    )\n}\n\nfun isXvm(cursor: Cursor): Boolean {\n    val iffResult = parseIffHeaders(cursor, silent = true)\n    cursor.seekStart(0)\n\n    return iffResult is Success &&\n            iffResult.value.any { chunk -> chunk.type == XVMH || chunk.type == XVRT }\n}\n\nfun parseXvm(cursor: Cursor): PwResult<Xvm> {\n    val iffResult = parseIff(cursor)\n\n    if (iffResult !is Success) {\n        return iffResult as Failure\n    }\n\n    val result = PwResult.build<Xvm>(logger)\n    result.addResult(iffResult)\n    val chunks = iffResult.value\n    val headerChunk = chunks.find { it.type == XVMH }\n    val header = headerChunk?.data?.let(::parseHeader)\n\n    val textures = chunks\n        .filter { it.type == XVRT }\n        .map { parseXvr(it.data) }\n\n    if (header == null && textures.isEmpty()) {\n        result.addProblem(\n            Severity.Error,\n            \"Corrupted XVM file.\",\n            \"No header and no XVRT chunks found.\",\n        )\n\n        return result.failure()\n    }\n\n    if (header != null && header.textureCount != textures.size) {\n        result.addProblem(\n            Severity.Warning,\n            \"Corrupted XVM file.\",\n            \"Found ${textures.size} textures instead of ${header.textureCount} as defined in the header.\",\n        )\n    }\n\n    return result.success(Xvm(textures))\n}\n\nprivate class Header(\n    val textureCount: Int,\n)\n\nprivate fun parseHeader(cursor: Cursor): Header {\n    val textureCount = cursor.uShort().toInt()\n    return Header(textureCount)\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.Vec2\nimport world.phantasmal.lib.fileFormats.Vec3\nimport world.phantasmal.lib.fileFormats.vec2Float\nimport world.phantasmal.lib.fileFormats.vec3Float\n\nprivate val logger = KotlinLogging.logger {}\n\nfun parseXjModel(cursor: Cursor): XjModel {\n    cursor.seek(4) // Flags according to QEdit, seemingly always 0.\n    val vertexInfoTableOffset = cursor.int()\n    val vertexInfoCount = cursor.int()\n    val triangleStripTableOffset = cursor.int()\n    val triangleStripCount = cursor.int()\n    val transparentTriangleStripTableOffset = cursor.int()\n    val transparentTriangleStripCount = cursor.int()\n    val collisionSpherePosition = cursor.vec3Float()\n    val collisionSphereRadius = cursor.float()\n\n    val vertices = mutableListOf<XjVertex>()\n\n    if (vertexInfoCount > 0) {\n        // TODO: parse all vertex info tables.\n        vertices.addAll(parseVertexInfoTable(cursor, vertexInfoTableOffset))\n    }\n\n    val meshes = mutableListOf<XjMesh>()\n\n    meshes.addAll(\n        parseTriangleStripTable(cursor, triangleStripTableOffset, triangleStripCount),\n    )\n\n    meshes.addAll(\n        parseTriangleStripTable(\n            cursor,\n            transparentTriangleStripTableOffset,\n            transparentTriangleStripCount,\n        ),\n    )\n\n    return XjModel(\n        vertices,\n        meshes,\n        collisionSpherePosition,\n        collisionSphereRadius,\n    )\n}\n\nprivate fun parseVertexInfoTable(cursor: Cursor, vertexInfoTableOffset: Int): List<XjVertex> {\n    cursor.seekStart(vertexInfoTableOffset)\n    val vertexType = cursor.short().toInt()\n    cursor.seek(2) // Flags?\n    val vertexTableOffset = cursor.int()\n    val vertexSize = cursor.int()\n    val vertexCount = cursor.int()\n\n    return (0 until vertexCount).map { i ->\n        cursor.seekStart(vertexTableOffset + i * vertexSize)\n\n        val position = cursor.vec3Float()\n        var normal: Vec3? = null\n        var uv: Vec2? = null\n\n        when (vertexType) {\n            2 -> {\n                normal = cursor.vec3Float()\n            }\n            3 -> {\n                normal = cursor.vec3Float()\n                uv = cursor.vec2Float()\n            }\n            4 -> {\n                // Skip 4 bytes.\n            }\n            5 -> {\n                cursor.seek(4)\n                uv = cursor.vec2Float()\n            }\n            6 -> {\n                normal = cursor.vec3Float()\n                // Skip 4 bytes.\n            }\n            7 -> {\n                normal = cursor.vec3Float()\n                uv = cursor.vec2Float()\n            }\n            else -> {\n                logger.warn { \"Unknown vertex type $vertexType with size ${vertexSize}.\" }\n            }\n        }\n\n        XjVertex(\n            position,\n            normal,\n            uv,\n        )\n    }\n}\n\nprivate fun parseTriangleStripTable(\n    cursor: Cursor,\n    triangleStripListOffset: Int,\n    triangleStripCount: Int,\n): List<XjMesh> {\n    return (0 until triangleStripCount).map { i ->\n        cursor.seekStart(triangleStripListOffset + i * 20)\n\n        val materialTableOffset = cursor.int()\n        val materialTableSize = cursor.int()\n        val indexListOffset = cursor.int()\n        val indexCount = cursor.int()\n\n        val material = parseTriangleStripMaterial(\n            cursor,\n            materialTableOffset,\n            materialTableSize,\n        )\n\n        cursor.seekStart(indexListOffset)\n        val indices = cursor.uShortArray(indexCount)\n\n        XjMesh(\n            material,\n            indices = indices.map { it.toInt() },\n        )\n    }\n}\n\nprivate fun parseTriangleStripMaterial(\n    cursor: Cursor,\n    offset: Int,\n    size: Int,\n): XjMaterial {\n    var srcAlpha: Int? = null\n    var dstAlpha: Int? = null\n    var textureId: Int? = null\n    var diffuseR: Int? = null\n    var diffuseG: Int? = null\n    var diffuseB: Int? = null\n    var diffuseA: Int? = null\n\n    for (i in 0 until size) {\n        cursor.seekStart(offset + i * 16)\n\n        when (cursor.int()) {\n            2 -> {\n                srcAlpha = cursor.int()\n                dstAlpha = cursor.int()\n            }\n            3 -> {\n                textureId = cursor.int()\n            }\n            5 -> {\n                diffuseR = cursor.uByte().toInt()\n                diffuseG = cursor.uByte().toInt()\n                diffuseB = cursor.uByte().toInt()\n                diffuseA = cursor.uByte().toInt()\n            }\n        }\n    }\n\n    return XjMaterial(\n        srcAlpha,\n        dstAlpha,\n        textureId,\n        diffuseR,\n        diffuseG,\n        diffuseB,\n        diffuseA,\n    )\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val DC_GC_OBJECT_CODE_OFFSET = 468\nprivate const val PC_OBJECT_CODE_OFFSET = 920\nprivate const val BB_OBJECT_CODE_OFFSET = 4652\n\nclass BinFile(\n    var format: BinFormat,\n    var questId: Int,\n    var language: Int,\n    var questName: String,\n    var shortDescription: String,\n    var longDescription: String,\n    val bytecode: Buffer,\n    val labelOffsets: IntArray,\n    val shopItems: UIntArray,\n)\n\nenum class BinFormat {\n    /**\n     * Dreamcast/GameCube\n     */\n    DC_GC,\n\n    /**\n     * Desktop\n     */\n    PC,\n\n    /**\n     * BlueBurst\n     */\n    BB,\n}\n\nfun parseBin(cursor: Cursor): BinFile {\n    val bytecodeOffset = cursor.int()\n    val labelOffsetTableOffset = cursor.int() // Relative offsets\n    val size = cursor.int()\n    cursor.seek(4) // Always seems to be 0xFFFFFFFF.\n\n    val format = when (bytecodeOffset) {\n        DC_GC_OBJECT_CODE_OFFSET -> BinFormat.DC_GC\n        PC_OBJECT_CODE_OFFSET -> BinFormat.PC\n        BB_OBJECT_CODE_OFFSET -> BinFormat.BB\n        else -> {\n            logger.warn {\n                \"Byte code at unexpected offset $bytecodeOffset, assuming file is a PC file.\"\n            }\n            BinFormat.PC\n        }\n    }\n\n    val questId: Int\n    val language: Int\n    val questName: String\n    val shortDescription: String\n    val longDescription: String\n\n    if (format == BinFormat.DC_GC) {\n        cursor.seek(1)\n        language = cursor.byte().toInt()\n        questId = cursor.short().toInt()\n        questName = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n        shortDescription = cursor.stringAscii(128, nullTerminated = true, dropRemaining = true)\n        longDescription = cursor.stringAscii(288, nullTerminated = true, dropRemaining = true)\n    } else {\n        if (format == BinFormat.PC) {\n            language = cursor.short().toInt()\n            questId = cursor.short().toInt()\n        } else {\n            questId = cursor.int()\n            language = cursor.int()\n        }\n\n        questName = cursor.stringUtf16(64, nullTerminated = true, dropRemaining = true)\n        shortDescription = cursor.stringUtf16(256, nullTerminated = true, dropRemaining = true)\n        longDescription = cursor.stringUtf16(576, nullTerminated = true, dropRemaining = true)\n    }\n\n    if (size != cursor.size) {\n        logger.warn { \"Value $size in bin size field does not match actual size ${cursor.size}.\" }\n    }\n\n    val shopItems = if (format == BinFormat.BB) {\n        cursor.seek(4) // Skip padding.\n        cursor.uIntArray(932)\n    } else {\n        UIntArray(0)\n    }\n\n    val labelOffsetCount = (cursor.size - labelOffsetTableOffset) / 4\n    val labelOffsets = cursor\n        .seekStart(labelOffsetTableOffset)\n        .intArray(labelOffsetCount)\n\n    val bytecode = cursor\n        .seekStart(bytecodeOffset)\n        .buffer(labelOffsetTableOffset - bytecodeOffset)\n\n    return BinFile(\n        format,\n        questId,\n        language,\n        questName,\n        shortDescription,\n        longDescription,\n        bytecode,\n        labelOffsets,\n        shopItems,\n    )\n}\n\nfun writeBin(bin: BinFile): Buffer {\n    require(bin.questName.length <= 32) {\n        \"questName can't be longer than 32 characters, was ${bin.questName.length}\"\n    }\n    require(bin.shortDescription.length <= 127) {\n        \"shortDescription can't be longer than 127 characters, was ${bin.shortDescription.length}\"\n    }\n    require(bin.longDescription.length <= 287) {\n        \"longDescription can't be longer than 287 characters, was ${bin.longDescription.length}\"\n    }\n    require(bin.shopItems.isEmpty() || bin.format == BinFormat.BB) {\n        \"shopItems is only supported in BlueBurst quests.\"\n    }\n    require(bin.shopItems.size <= 932) {\n        \"shopItems can't be larger than 932, was ${bin.shopItems.size}.\"\n    }\n\n    val bytecodeOffset = when (bin.format) {\n        BinFormat.DC_GC -> DC_GC_OBJECT_CODE_OFFSET\n        BinFormat.PC -> PC_OBJECT_CODE_OFFSET\n        BinFormat.BB -> BB_OBJECT_CODE_OFFSET\n    }\n\n    val fileSize = bytecodeOffset + bin.bytecode.size + 4 * bin.labelOffsets.size\n    val buffer = Buffer.withCapacity(fileSize)\n    val cursor = buffer.cursor()\n\n    cursor.writeInt(bytecodeOffset)\n    cursor.writeInt(bytecodeOffset + bin.bytecode.size) // Label table offset.\n    cursor.writeInt(fileSize)\n    cursor.writeInt(-1)\n\n    if (bin.format == BinFormat.DC_GC) {\n        cursor.writeByte(0)\n        cursor.writeByte(bin.language.toByte())\n        cursor.writeShort(bin.questId.toShort())\n        cursor.writeStringAscii(bin.questName, 32)\n        cursor.writeStringAscii(bin.shortDescription, 128)\n        cursor.writeStringAscii(bin.longDescription, 288)\n    } else {\n        if (bin.format == BinFormat.PC) {\n            cursor.writeShort(bin.language.toShort())\n            cursor.writeShort(bin.questId.toShort())\n        } else {\n            cursor.writeInt(bin.questId)\n            cursor.writeInt(bin.language)\n        }\n\n        cursor.writeStringUtf16(bin.questName, 64)\n        cursor.writeStringUtf16(bin.shortDescription, 256)\n        cursor.writeStringUtf16(bin.longDescription, 576)\n    }\n\n    if (bin.format == BinFormat.BB) {\n        cursor.writeInt(0)\n        cursor.writeUIntArray(bin.shopItems)\n\n        repeat(932 - bin.shopItems.size) {\n            cursor.writeUInt(0u)\n        }\n    }\n\n    check(cursor.position == bytecodeOffset) {\n        \"Expected to write $bytecodeOffset bytes before bytecode, but wrote ${cursor.position}.\"\n    }\n\n    cursor.writeCursor(bin.bytecode.cursor())\n\n    cursor.writeIntArray(bin.labelOffsets)\n\n    check(cursor.position == fileSize) {\n        \"Expected to write $fileSize bytes, but wrote ${cursor.position}.\"\n    }\n\n    return buffer\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.asm.*\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getRegisterValue\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getStackValue\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.BufferCursor\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val MAX_TOTAL_NOPS = 20\nprivate const val MAX_SEQUENTIAL_NOPS = 10\nprivate const val MAX_UNKNOWN_OPCODE_RATIO = 0.2\nprivate const val MAX_STACK_POP_WITHOUT_PRECEDING_PUSH_RATIO = 0.2\nprivate const val MAX_UNKNOWN_LABEL_RATIO = 0.2\n\nval SEGMENT_PRIORITY = mapOf(\n    SegmentType.Instructions to 2,\n    SegmentType.String to 1,\n    SegmentType.Data to 0,\n)\n\n/**\n * These functions are built into the client and can optionally be overridden on BB. Other versions\n * require you to always specify them in the script.\n */\nval BUILTIN_FUNCTIONS = setOf(\n    60,\n    70,\n    80,\n    90,\n    100,\n    110,\n    120,\n    130,\n    140,\n    800,\n    810,\n    820,\n    830,\n    840,\n    850,\n    860,\n    900,\n    910,\n    920,\n    930,\n    940,\n    950,\n    960,\n)\n\n/**\n * Parses bytecode into bytecode IR.\n */\nfun parseBytecode(\n    bytecode: Buffer,\n    labelOffsets: IntArray,\n    entryLabels: Set<Int>,\n    dcGcFormat: Boolean,\n    lenient: Boolean,\n): PwResult<BytecodeIr> {\n    val cursor = BufferCursor(bytecode)\n    val labelHolder = LabelHolder(labelOffsets)\n    val result = PwResult.build<BytecodeIr>(logger)\n    val offsetToSegment = mutableMapOf<Int, Segment>()\n\n    findAndParseSegments(\n        cursor,\n        labelHolder,\n        entryLabels.associateWith { SegmentType.Instructions },\n        offsetToSegment,\n        lenient,\n        dcGcFormat,\n    )\n\n    val segments: MutableList<Segment> = mutableListOf()\n\n    // Put segments in an array and try to parse leftover segments as instructions segments. When a\n    // segment can't be parsed as instructions, fall back to parsing it as a data segment.\n    var offset = 0\n\n    while (offset < cursor.size) {\n        var segment: Segment? = offsetToSegment[offset]\n\n        // If we have a segment, add it. Otherwise create a new data segment.\n        if (segment == null) {\n            val labels = labelHolder.getLabels(offset)\n            var endOffset: Int\n\n            if (labels == null) {\n                endOffset = cursor.size\n\n                for (label in labelHolder.labels) {\n                    if (label.offset > offset) {\n                        endOffset = label.offset\n                        break\n                    }\n                }\n            } else {\n                val info = labelHolder.getInfo(labels[0])!!\n                endOffset = info.next?.offset ?: cursor.size\n            }\n\n            cursor.seekStart(offset)\n\n            val isInstructionsSegment = tryParseInstructionsSegment(\n                offsetToSegment,\n                labelHolder,\n                cursor,\n                endOffset,\n                labels?.toMutableList() ?: mutableListOf(),\n                dcGcFormat,\n            )\n\n            if (!isInstructionsSegment) {\n                cursor.seekStart(offset)\n\n                parseDataSegment(\n                    offsetToSegment,\n                    cursor,\n                    endOffset,\n                    labels?.toMutableList() ?: mutableListOf()\n                )\n            }\n\n            segment = offsetToSegment[offset]\n\n            check(endOffset > offset) {\n                \"Next offset $endOffset was smaller than or equal to current offset ${offset}.\"\n            }\n            checkNotNull(segment) { \"Couldn't create segment for offset ${offset}.\" }\n        }\n\n        segments.add(segment)\n\n        offset += segment.size(dcGcFormat)\n    }\n\n    // Add unreferenced labels to their segment.\n    for ((label, labelOffset) in labelHolder.labels) {\n        val segment = offsetToSegment[labelOffset]\n\n        if (segment == null) {\n            result.addProblem(\n                Severity.Warning,\n                \"Label $label doesn't point to anything.\",\n                \"Label $label with offset $labelOffset doesn't point to anything.\",\n            )\n        } else {\n            if (label !in segment.labels) {\n                segment.labels.add(label)\n                segment.labels.sort()\n            }\n        }\n    }\n\n    // Sanity check parsed byte code.\n    if (cursor.size != offset) {\n        result.addProblem(\n            Severity.Error,\n            \"The script code is corrupt.\",\n            \"Expected to parse ${cursor.size} bytes but parsed $offset instead.\",\n        )\n\n        if (!lenient) {\n            return result.failure()\n        }\n    }\n\n    return result.success(BytecodeIr(segments))\n}\n\nprivate fun findAndParseSegments(\n    cursor: Cursor,\n    labelHolder: LabelHolder,\n    labels: Map<Int, SegmentType>,\n    offsetToSegment: MutableMap<Int, Segment>,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    var newLabels = labels\n    var startSegmentCount: Int\n    // Instruction segments which we've been able to fully analyze for label references so far.\n    val analyzedSegments = mutableSetOf<InstructionSegment>()\n\n    // Iteratively parse segments from label references.\n    do {\n        startSegmentCount = offsetToSegment.size\n\n        // Parse segments of which the type is known.\n        for ((label, type) in newLabels) {\n            parseSegment(offsetToSegment, labelHolder, cursor, label, type, lenient, dcGcFormat)\n        }\n\n        // Find label references.\n        val sortedSegments = offsetToSegment.entries\n            .filter { (_, s) -> s is InstructionSegment }\n            .sortedBy { it.key }\n            .map { (_, s) -> s as InstructionSegment }\n\n        val cfg = ControlFlowGraph.create(sortedSegments)\n\n        newLabels = mutableMapOf()\n\n        for (segment in sortedSegments) {\n            if (segment in analyzedSegments) continue\n\n            var foundAllLabels = true\n\n            for (instructionIdx in segment.instructions.indices) {\n                val instruction = segment.instructions[instructionIdx]\n                var i = 0\n\n                while (i < instruction.opcode.params.size) {\n                    val param = instruction.opcode.params[i]\n\n                    when (param.type) {\n                        is ILabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.Instructions,\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is ILabelVarType -> {\n                            // Never on the stack.\n                            // Eat all remaining arguments.\n                            while (i < instruction.args.size) {\n                                newLabels[(instruction.args[i] as IntArg).value] =\n                                    SegmentType.Instructions\n\n                                i++\n                            }\n                        }\n\n                        is DLabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.Data\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is SLabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.String\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is RegType -> if (param.type.registers != null) {\n                            for (j in param.type.registers.indices) {\n                                val registerParam = param.type.registers[j]\n\n                                // Never on the stack.\n                                if (registerParam.type is ILabelType) {\n                                    val firstRegister = instruction.args[0].value as Int\n                                    val labelValues = getRegisterValue(\n                                        cfg,\n                                        instruction,\n                                        firstRegister + j,\n                                    )\n\n                                    if (labelValues.size <= 20) {\n                                        for (label in labelValues) {\n                                            newLabels[label] = SegmentType.Instructions\n                                        }\n                                    } else {\n                                        foundAllLabels = false\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    i++\n                }\n            }\n\n            if (foundAllLabels) {\n                analyzedSegments.add(segment)\n            }\n        }\n    } while (offsetToSegment.size > startSegmentCount)\n}\n\n/**\n * Returns immediate arguments or stack arguments.\n */\nprivate fun getArgLabelValues(\n    cfg: ControlFlowGraph,\n    labels: MutableMap<Int, SegmentType>,\n    instructionSegment: InstructionSegment,\n    instructionIdx: Int,\n    paramIdx: Int,\n    segmentType: SegmentType,\n): Boolean {\n    val instruction = instructionSegment.instructions[instructionIdx]\n\n    if (instruction.opcode.stack === StackInteraction.Pop) {\n        val stackValues = getStackValue(\n            cfg,\n            instruction,\n            instruction.opcode.params.size - paramIdx - 1,\n        ).first\n\n        if (stackValues.size <= 20) {\n            for (value in stackValues) {\n                val oldType = labels[value]\n\n                if (\n                    oldType == null ||\n                    SEGMENT_PRIORITY.getValue(segmentType) > SEGMENT_PRIORITY.getValue(oldType)\n                ) {\n                    labels[value] = segmentType\n                }\n            }\n\n            return true\n        }\n    } else {\n        val value = (instruction.args[paramIdx] as IntArg).value\n        val oldType = labels[value]\n\n        if (\n            oldType == null ||\n            SEGMENT_PRIORITY.getValue(segmentType) > SEGMENT_PRIORITY.getValue(oldType)\n        ) {\n            labels[value] = segmentType\n        }\n\n        return true\n    }\n\n    return false\n}\n\nprivate fun parseSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    label: Int,\n    type: SegmentType,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    try {\n        val info = labelHolder.getInfo(label)\n\n        if (info == null) {\n            if (label !in BUILTIN_FUNCTIONS) {\n                logger.warn { \"Label $label is not registered in the label table.\" }\n            }\n\n            return\n        }\n\n        // Check whether we've already parsed this segment and reparse it if necessary.\n        val segment = offsetToSegment[info.offset]\n\n        val labels: MutableList<Int> =\n            if (segment == null) {\n                mutableListOf(label)\n            } else {\n                if (label !in segment.labels) {\n                    segment.labels.add(label)\n                    segment.labels.sort()\n                }\n\n                if (SEGMENT_PRIORITY.getValue(type) > SEGMENT_PRIORITY.getValue(segment.type)) {\n                    segment.labels\n                } else {\n                    return\n                }\n            }\n\n        val endOffset = info.next?.offset ?: cursor.size\n        cursor.seekStart(info.offset)\n\n        return when (type) {\n            SegmentType.Instructions ->\n                parseInstructionsSegment(\n                    offsetToSegment,\n                    labelHolder,\n                    cursor,\n                    endOffset,\n                    labels,\n                    info.next?.label,\n                    lenient,\n                    dcGcFormat,\n                )\n\n            SegmentType.Data ->\n                parseDataSegment(offsetToSegment, cursor, endOffset, labels)\n\n            SegmentType.String ->\n                parseStringSegment(offsetToSegment, cursor, endOffset, labels, dcGcFormat)\n        }\n    } catch (e: Exception) {\n        if (lenient) {\n            logger.error(e) { \"Couldn't fully parse byte code segment.\" }\n        } else {\n            throw e\n        }\n    }\n}\n\nprivate fun parseInstructionsSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    nextLabel: Int?,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    val instructions = mutableListOf<Instruction>()\n\n    val segment = InstructionSegment(\n        labels,\n        instructions,\n        SegmentSrcLoc()\n    )\n    offsetToSegment[cursor.position] = segment\n\n    while (cursor.position < endOffset) {\n        // Parse the opcode.\n        val mainOpcode = cursor.uByte()\n\n        val fullOpcode = when (mainOpcode.toInt()) {\n            0xF8, 0xF9 -> ((mainOpcode.toInt() shl 8) or cursor.uByte().toInt())\n            else -> mainOpcode.toInt()\n        }\n\n        val opcode = codeToOpcode(fullOpcode)\n\n        // Parse the arguments.\n        try {\n            val args = parseInstructionArguments(cursor, opcode, dcGcFormat)\n            instructions.add(Instruction(opcode, args, srcLoc = null, valid = true))\n        } catch (e: Exception) {\n            if (lenient) {\n                logger.error(e) {\n                    \"Exception occurred while parsing arguments for instruction ${opcode.mnemonic}.\"\n                }\n                instructions.add(Instruction(opcode, emptyList(), srcLoc = null, valid = false))\n            } else {\n                throw e\n            }\n        }\n    }\n\n    // Recurse on label drop-through.\n    if (nextLabel != null) {\n        // Find the last ret or jmp.\n        var dropThrough = true\n\n        for (i in instructions.lastIndex downTo 0) {\n            val opcode = instructions[i].opcode.code\n\n            if (opcode == OP_RET.code || opcode == OP_JMP.code) {\n                dropThrough = false\n                break\n            }\n        }\n\n        if (dropThrough) {\n            parseSegment(\n                offsetToSegment,\n                labelHolder,\n                cursor,\n                nextLabel,\n                SegmentType.Instructions,\n                lenient,\n                dcGcFormat,\n            )\n        }\n    }\n}\n\nprivate fun parseDataSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n) {\n    val startOffset = cursor.position\n    val segment = DataSegment(\n        labels,\n        cursor.buffer(endOffset - startOffset),\n        SegmentSrcLoc(),\n    )\n    offsetToSegment[startOffset] = segment\n}\n\nprivate fun parseStringSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    dcGcFormat: Boolean,\n) {\n    val startOffset = cursor.position\n    val byteLength = endOffset - startOffset\n    val segment = StringSegment(\n        labels,\n        if (dcGcFormat) {\n            cursor.stringAscii(\n                byteLength,\n                nullTerminated = true,\n                dropRemaining = true\n            )\n        } else {\n            cursor.stringUtf16(\n                byteLength,\n                nullTerminated = true,\n                dropRemaining = true\n            )\n        },\n        byteLength,\n        SegmentSrcLoc()\n    )\n    offsetToSegment[startOffset] = segment\n}\n\nprivate fun parseInstructionArguments(\n    cursor: Cursor,\n    opcode: Opcode,\n    dcGcFormat: Boolean,\n): List<Arg> {\n    val args = mutableListOf<Arg>()\n\n    if (opcode.stack != StackInteraction.Pop) {\n        var varargCount = 0\n\n        for (param in opcode.params) {\n            when (param.type) {\n                is ByteType ->\n                    args.add(IntArg(cursor.uByte().toInt()))\n\n                is ShortType ->\n                    args.add(IntArg(cursor.uShort().toInt()))\n\n                is IntType ->\n                    args.add(IntArg(cursor.int()))\n\n                is FloatType ->\n                    args.add(FloatArg(cursor.float()))\n\n                // Ensure this case is before the LabelType case because ILabelVarType extends\n                // LabelType.\n                is ILabelVarType -> {\n                    varargCount++\n                    val argSize = cursor.uByte()\n                    args.addAll(cursor.uShortArray(argSize.toInt()).map { IntArg(it.toInt()) })\n                }\n\n                is LabelType -> {\n                    args.add(IntArg(cursor.uShort().toInt()))\n                }\n\n                is StringType -> {\n                    val maxBytes = min(4096, cursor.bytesLeft)\n                    args.add(\n                        StringArg(\n                            if (dcGcFormat) {\n                                cursor.stringAscii(\n                                    maxBytes,\n                                    nullTerminated = true,\n                                    dropRemaining = false\n                                )\n                            } else {\n                                cursor.stringUtf16(\n                                    maxBytes,\n                                    nullTerminated = true,\n                                    dropRemaining = false\n                                )\n                            },\n                        )\n                    )\n                }\n\n                is RegType -> {\n                    args.add(IntArg(cursor.uByte().toInt()))\n                }\n\n                is RegVarType -> {\n                    varargCount++\n                    val argSize = cursor.uByte()\n                    args.addAll(cursor.uByteArray(argSize.toInt()).map { IntArg(it.toInt()) })\n                }\n\n                else -> error(\"Parameter type ${param.type} not implemented.\")\n            }\n        }\n\n        val minExpectedArgs = opcode.params.size - varargCount\n\n        check(args.size >= minExpectedArgs) {\n            \"Expected to parse at least $minExpectedArgs, only parsed ${args.size}.\"\n        }\n    }\n\n    return args\n}\n\nprivate fun tryParseInstructionsSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    dcGcFormat: Boolean,\n): Boolean {\n    val offset = cursor.position\n\n    fun logReason(reason: String, t: Throwable? = null) {\n        logger.trace(t) {\n            buildString {\n                append(\"Determined that segment \")\n\n                if (labels.isEmpty()) {\n                    append(\"without label\")\n                } else {\n                    if (labels.size == 1) append(\"with label \")\n                    else append(\"with labels \")\n\n                    labels.joinTo(this)\n                }\n\n                append(\" at offset \")\n                append(offset)\n                append(\" is not an instructions segment because \")\n                append(reason)\n                append(\".\")\n            }\n        }\n    }\n\n    try {\n        parseInstructionsSegment(\n            offsetToSegment,\n            labelHolder,\n            cursor,\n            endOffset,\n            labels,\n            nextLabel = null,\n            lenient = false,\n            dcGcFormat,\n        )\n\n        val segment = offsetToSegment[offset]\n        val instructions = (segment as InstructionSegment).instructions\n\n        // Heuristically try to detect whether the segment is actually a data segment.\n        var prevOpcode: Opcode? = null\n        var totalNopCount = 0\n        var sequentialNopCount = 0\n        var unknownOpcodeCount = 0\n        var stackPopCount = 0\n        var stackPopWithoutPrecedingPushCount = 0\n        var labelCount = 0\n        var unknownLabelCount = 0\n\n        for (inst in instructions) {\n            if (inst.opcode.code == OP_NOP.code) {\n                if (++totalNopCount > MAX_TOTAL_NOPS) {\n                    logReason(\"it has more than $MAX_TOTAL_NOPS nop instructions\")\n                    return false\n                }\n\n                if (++sequentialNopCount > MAX_SEQUENTIAL_NOPS) {\n                    logReason(\"it has more than $MAX_SEQUENTIAL_NOPS sequential nop instructions\")\n                    return false\n                }\n            } else {\n                sequentialNopCount = 0\n            }\n\n            if (!inst.opcode.known) {\n                unknownOpcodeCount++\n            }\n\n            if (inst.opcode.stack == StackInteraction.Pop) {\n                stackPopCount++\n\n                if (prevOpcode?.stack != StackInteraction.Push) {\n                    stackPopWithoutPrecedingPushCount++\n                }\n            }\n\n            for ((index, param) in inst.opcode.params.withIndex()) {\n                if (index >= inst.args.size) break\n\n                if (param.type is LabelType) {\n                    for (arg in inst.getArgs(index)) {\n                        labelCount++\n\n                        if (!labelHolder.hasLabel((arg as IntArg).value)) {\n                            unknownLabelCount++\n                        }\n                    }\n                }\n            }\n\n            prevOpcode = inst.opcode\n        }\n\n        val unknownLabelRatio = unknownLabelCount.toDouble() / labelCount\n\n        if (unknownLabelRatio > MAX_UNKNOWN_LABEL_RATIO) {\n            logReason(\n                \"${100 * unknownLabelRatio}% of its label references are to nonexistent labels\"\n            )\n            return false\n        }\n\n        val stackPopWithoutPrecedingPushRatio =\n            stackPopWithoutPrecedingPushCount.toDouble() / stackPopCount\n\n        if (stackPopWithoutPrecedingPushRatio > MAX_STACK_POP_WITHOUT_PRECEDING_PUSH_RATIO) {\n            logReason(\n                \"${100 * stackPopWithoutPrecedingPushRatio}% of its stack pop instructions don't have a preceding push instruction\"\n            )\n            return false\n        }\n\n        val unknownOpcodeRatio = unknownOpcodeCount.toDouble() / instructions.size\n\n        if (unknownOpcodeRatio > MAX_UNKNOWN_OPCODE_RATIO) {\n            logReason(\"${100 * unknownOpcodeRatio}% of its opcodes are unknown\")\n            return false\n        }\n\n        return true\n    } catch (e: Exception) {\n        logReason(\"parsing it resulted in an exception\", e)\n        return false\n    }\n}\n\nfun writeBytecode(bytecodeIr: BytecodeIr, dcGcFormat: Boolean): BytecodeAndLabelOffsets {\n    val buffer = Buffer.withCapacity(100 * bytecodeIr.segments.size, Endianness.Little)\n    val cursor = buffer.cursor()\n    // Keep track of label offsets.\n    val largestLabel = bytecodeIr.segments.asSequence().flatMap { it.labels }.maxOrNull() ?: -1\n    val labelOffsets = IntArray(largestLabel + 1) { -1 }\n\n    for (segment in bytecodeIr.segments) {\n        for (label in segment.labels) {\n            labelOffsets[label] = cursor.position\n        }\n\n        when (segment) {\n            is InstructionSegment -> {\n                for (instruction in segment.instructions) {\n                    val opcode = instruction.opcode\n\n                    if (opcode.size == 2) {\n                        cursor.writeByte((opcode.code ushr 8).toByte())\n                    }\n\n                    cursor.writeByte(opcode.code.toByte())\n\n                    if (opcode.stack != StackInteraction.Pop) {\n                        for (i in opcode.params.indices) {\n                            val param = opcode.params[i]\n                            val args = instruction.getArgs(i)\n                            val arg = args.firstOrNull()\n\n                            if (arg == null) {\n                                logger.warn {\n                                    \"No argument passed to ${opcode.mnemonic} for parameter ${i + 1}.\"\n                                }\n                                continue\n                            }\n\n                            when (param.type) {\n                                ByteType -> cursor.writeByte(arg.coerceInt().toByte())\n                                ShortType -> cursor.writeShort(arg.coerceInt().toShort())\n                                IntType -> cursor.writeInt(arg.coerceInt())\n                                FloatType -> cursor.writeFloat(arg.coerceFloat())\n                                // Ensure this case is before the LabelType case because\n                                // ILabelVarType extends LabelType.\n                                ILabelVarType -> {\n                                    cursor.writeByte(args.size.toByte())\n\n                                    for (a in args) {\n                                        cursor.writeShort(a.coerceInt().toShort())\n                                    }\n                                }\n                                is LabelType -> cursor.writeShort(arg.coerceInt().toShort())\n                                StringType -> {\n                                    val str = arg.coerceString()\n\n                                    if (dcGcFormat) cursor.writeStringAscii(str, str.length + 1)\n                                    else cursor.writeStringUtf16(str, 2 * str.length + 2)\n                                }\n                                is RegType -> {\n                                    cursor.writeByte(arg.coerceInt().toByte())\n                                }\n                                RegVarType -> {\n                                    cursor.writeByte(args.size.toByte())\n\n                                    for (a in args) {\n                                        cursor.writeByte(a.coerceInt().toByte())\n                                    }\n                                }\n                                else -> error(\n                                    \"Parameter type ${param.type::class.simpleName} not supported.\"\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n\n            is StringSegment -> {\n                // String segments should be multiples of 4 bytes.\n                if (dcGcFormat) {\n                    cursor.writeStringAscii(segment.value, segment.size(dcGcFormat))\n                } else {\n                    cursor.writeStringUtf16(segment.value, segment.size(dcGcFormat))\n                }\n            }\n\n            is DataSegment -> {\n                cursor.writeCursor(segment.data.cursor())\n            }\n        }\n    }\n\n    return BytecodeAndLabelOffsets(buffer, labelOffsets)\n}\n\nclass BytecodeAndLabelOffsets(\n    val bytecode: Buffer,\n    val labelOffsets: IntArray,\n) {\n    operator fun component1(): Buffer = bytecode\n    operator fun component2(): IntArray = labelOffsets\n}\n\nprivate data class LabelAndOffset(val label: Int, val offset: Int)\nprivate data class OffsetAndIndex(val offset: Int, val index: Int)\nprivate class LabelInfo(val offset: Int, val next: LabelAndOffset?)\n\nprivate class LabelHolder(labelOffsets: IntArray) {\n    /**\n     * Mapping of labels to their offset and index into [labels].\n     */\n    private val labelMap: MutableMap<Int, OffsetAndIndex> = mutableMapOf()\n\n    /**\n     * Mapping of offsets to lists of labels.\n     */\n    private val offsetMap: MutableMap<Int, MutableList<Int>> = mutableMapOf()\n\n    /**\n     * Labels and their offset sorted by offset and then label.\n     */\n    val labels: List<LabelAndOffset>\n\n    init {\n        val labels = mutableListOf<LabelAndOffset>()\n\n        // Populate the main label list.\n        for (label in labelOffsets.indices) {\n            val offset = labelOffsets[label]\n\n            if (offset != -1) {\n                labels.add(LabelAndOffset(label, offset))\n            }\n        }\n\n        // Sort by offset, then label.\n        labels.sortWith { a, b ->\n            if (a.offset - b.offset != 0) a.offset - b.offset\n            else a.label - b.label\n        }\n\n        this.labels = labels\n\n        // Populate the label and offset maps.\n        for (index in 0 until labels.size) {\n            val (label, offset) = labels[index]\n\n            labelMap[label] = OffsetAndIndex(offset, index)\n\n            offsetMap.getOrPut(offset) { mutableListOf() }.add(label)\n        }\n    }\n\n    fun hasLabel(label: Int): Boolean = label in labelMap\n\n    fun getLabels(offset: Int): List<Int>? = offsetMap[offset]\n\n    fun getInfo(label: Int): LabelInfo? {\n        val offsetAndIndex = labelMap[label] ?: return null\n\n        // Find the next label with a different offset.\n        var next: LabelAndOffset? = null\n\n        for (i in offsetAndIndex.index + 1 until labels.size) {\n            next = labels[i]\n\n            // Skip the label if it points to the same offset.\n            if (next.offset > offsetAndIndex.offset) {\n                break\n            } else {\n                next = null\n            }\n        }\n\n        return LabelInfo(offsetAndIndex.offset, next)\n    }\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.WritableCursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.max\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val EVENT_ACTION_SPAWN_NPCS: Byte = 0x8\nprivate const val EVENT_ACTION_UNLOCK: Byte = 0xA\nprivate const val EVENT_ACTION_LOCK: Byte = 0xB\nprivate const val EVENT_ACTION_TRIGGER_EVENT: Byte = 0xC\n\nconst val OBJECT_BYTE_SIZE = 68\nconst val NPC_BYTE_SIZE = 72\n\nclass DatFile(\n    val objs: MutableList<DatEntity>,\n    val npcs: MutableList<DatEntity>,\n    val events: MutableList<DatEvent>,\n    val unknowns: MutableList<DatUnknown>,\n)\n\nclass DatEntity(\n    var areaId: Int,\n    val data: Buffer,\n)\n\nclass DatEvent(\n    var id: Int,\n    var sectionId: Short,\n    var wave: Short,\n    var delay: Short,\n    val actions: MutableList<DatEventAction>,\n    var areaId: Int,\n    var unknown: Short,\n)\n\nsealed class DatEventAction {\n    class SpawnNpcs(\n        var sectionId: Short,\n        var appearFlag: Short,\n    ) : DatEventAction()\n\n    class Unlock(\n        var doorId: Short,\n    ) : DatEventAction()\n\n    class Lock(\n        var doorId: Short,\n    ) : DatEventAction()\n\n    class TriggerEvent(\n        var eventId: Int,\n    ) : DatEventAction()\n}\n\nclass DatUnknown(\n    var entityType: Int,\n    var totalSize: Int,\n    var areaId: Int,\n    var entitiesSize: Int,\n    val data: ByteArray,\n)\n\nfun parseDat(cursor: Cursor): DatFile {\n    val objs = mutableListOf<DatEntity>()\n    val npcs = mutableListOf<DatEntity>()\n    val events = mutableListOf<DatEvent>()\n    val unknowns = mutableListOf<DatUnknown>()\n\n    while (cursor.hasBytesLeft()) {\n        val entityType = cursor.int()\n        val totalSize = cursor.int()\n        val areaId = cursor.int()\n        val entitiesSize = cursor.int()\n\n        if (entityType == 0) {\n            break\n        } else {\n            require(entitiesSize == totalSize - 16) {\n                \"Malformed DAT file. Expected an entities size of ${totalSize - 16}, got ${entitiesSize}.\"\n            }\n\n            val entitiesCursor = cursor.take(entitiesSize)\n\n            when (entityType) {\n                1 -> parseEntities(entitiesCursor, areaId, objs, OBJECT_BYTE_SIZE)\n                2 -> parseEntities(entitiesCursor, areaId, npcs, NPC_BYTE_SIZE)\n                3 -> parseEvents(entitiesCursor, areaId, events)\n                else -> {\n                    // Unknown entity types 4 and 5 (challenge mode).\n                    unknowns.add(DatUnknown(\n                        entityType,\n                        totalSize,\n                        areaId,\n                        entitiesSize,\n                        data = cursor.byteArray(entitiesSize),\n                    ))\n                }\n            }\n\n            if (entitiesCursor.hasBytesLeft()) {\n                logger.warn {\n                    \"Read ${entitiesCursor.position} bytes instead of expected ${entitiesCursor.size} for entity type ${entityType}.\"\n                }\n            }\n        }\n    }\n\n    return DatFile(\n        objs,\n        npcs,\n        events,\n        unknowns\n    )\n}\n\nprivate fun parseEntities(\n    cursor: Cursor,\n    areaId: Int,\n    entities: MutableList<DatEntity>,\n    entitySize: Int,\n) {\n    val entityCount = cursor.size / entitySize\n\n    repeat(entityCount) {\n        entities.add(DatEntity(\n            areaId,\n            data = cursor.buffer(entitySize),\n        ))\n    }\n}\n\nprivate fun parseEvents(cursor: Cursor, areaId: Int, events: MutableList<DatEvent>) {\n    val actionsOffset = cursor.int()\n    cursor.seek(4) // Always 0x10\n    val eventCount = cursor.int()\n    cursor.seek(3) // Always 0\n    val eventType = cursor.byte()\n\n    require(eventType.toInt() != 0x32) {\n        \"Can't parse challenge mode quests yet.\"\n    }\n\n    cursor.seekStart(actionsOffset)\n    val actionsCursor = cursor.take(cursor.bytesLeft)\n    cursor.seekStart(16)\n\n    repeat(eventCount) {\n        val id = cursor.int()\n        cursor.seek(4) // Always 0x100\n        val sectionId = cursor.short()\n        val wave = cursor.short()\n        val delay = cursor.short()\n        val unknown = cursor.short() // \"wavesetting\"?\n        val eventActionsOffset = cursor.int()\n\n        val actions: MutableList<DatEventAction> =\n            if (eventActionsOffset < actionsCursor.size) {\n                actionsCursor.seekStart(eventActionsOffset)\n                parseEventActions(actionsCursor)\n            } else {\n                logger.warn { \"Invalid event actions offset $eventActionsOffset for event ${id}.\" }\n                mutableListOf()\n            }\n\n        events.add(DatEvent(\n            id,\n            sectionId,\n            wave,\n            delay,\n            actions,\n            areaId,\n            unknown,\n        ))\n    }\n\n    if (cursor.position != actionsOffset) {\n        logger.warn {\n            \"Read ${cursor.position - 16} bytes of event data instead of expected ${actionsOffset - 16}.\"\n        }\n    }\n\n    var lastByte: Byte = -1\n\n    while (actionsCursor.hasBytesLeft()) {\n        lastByte = actionsCursor.byte()\n\n        if (lastByte.toInt() != -1) {\n            break\n        }\n    }\n\n    if (lastByte.toInt() != -1) {\n        actionsCursor.seek(-1)\n    }\n\n    // Make sure the cursor position represents the amount of bytes we've consumed.\n    cursor.seekStart(actionsOffset + actionsCursor.position)\n}\n\nprivate fun parseEventActions(cursor: Cursor): MutableList<DatEventAction> {\n    val actions = mutableListOf<DatEventAction>()\n\n    outer@ while (cursor.hasBytesLeft()) {\n        when (val type = cursor.byte()) {\n            (1).toByte() -> break@outer\n\n            EVENT_ACTION_SPAWN_NPCS ->\n                actions.add(DatEventAction.SpawnNpcs(\n                    sectionId = cursor.short(),\n                    appearFlag = cursor.short(),\n                ))\n\n            EVENT_ACTION_UNLOCK ->\n                actions.add(DatEventAction.Unlock(\n                    doorId = cursor.short(),\n                ))\n\n            EVENT_ACTION_LOCK ->\n                actions.add(DatEventAction.Lock(\n                    doorId = cursor.short(),\n                ))\n\n            EVENT_ACTION_TRIGGER_EVENT ->\n                actions.add(DatEventAction.TriggerEvent(\n                    eventId = cursor.int(),\n                ))\n\n            else -> {\n                logger.warn { \"Unexpected event action type ${type}.\" }\n                break@outer\n            }\n        }\n    }\n\n    return actions\n}\n\nfun writeDat(dat: DatFile): Buffer {\n    val buffer = Buffer.withCapacity(\n        dat.objs.size * (16 + OBJECT_BYTE_SIZE) +\n                dat.npcs.size * (16 + NPC_BYTE_SIZE) +\n                dat.unknowns.sumBy { it.totalSize },\n        endianness = Endianness.Little,\n    )\n    val cursor = buffer.cursor()\n\n    writeEntities(cursor, dat.objs, 1, OBJECT_BYTE_SIZE)\n    writeEntities(cursor, dat.npcs, 2, NPC_BYTE_SIZE)\n    writeEvents(cursor, dat.events)\n\n    for (unknown in dat.unknowns) {\n        cursor.writeInt(unknown.entityType)\n        cursor.writeInt(unknown.totalSize)\n        cursor.writeInt(unknown.areaId)\n        cursor.writeInt(unknown.entitiesSize)\n        cursor.writeByteArray(unknown.data)\n    }\n\n    // Final header.\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n\n    return buffer\n}\n\nprivate fun writeEntities(\n    cursor: WritableCursor,\n    entities: List<DatEntity>,\n    entityType: Int,\n    entitySize: Int,\n) {\n    val groupedEntities = entities.groupBy { it.areaId }\n\n    for ((areaId, areaEntities) in groupedEntities.entries) {\n        val entitiesSize = areaEntities.size * entitySize\n        cursor.writeInt(entityType)\n        cursor.writeInt(16 + entitiesSize)\n        cursor.writeInt(areaId)\n        cursor.writeInt(entitiesSize)\n        val startPos = cursor.position\n\n        for (entity in areaEntities) {\n            require(entity.data.size == entitySize) {\n                \"Malformed entity in area $areaId, data buffer was of size ${\n                    entity.data.size\n                } instead of expected $entitySize.\"\n            }\n\n            cursor.writeCursor(entity.data.cursor())\n        }\n\n        check(cursor.position == startPos + entitiesSize) {\n            \"Wrote ${\n                cursor.position - startPos\n            } bytes of entity data instead of expected $entitiesSize bytes for area $areaId.\"\n        }\n    }\n}\n\nprivate fun writeEvents(cursor: WritableCursor, events: List<DatEvent>) {\n    val groupedEvents = events.groupBy { it.areaId }\n\n    for ((areaId, areaEvents) in groupedEvents.entries) {\n        // Standard header.\n        cursor.writeInt(3) // Entity type\n        val totalSizeOffset = cursor.position\n        cursor.writeInt(0) // Placeholder for the total size.\n        cursor.writeInt(areaId)\n        val entitiesSizeOffset = cursor.position\n        cursor.writeInt(0) // Placeholder for the entities size.\n\n        // Event header.\n        val startPos = cursor.position\n        // TODO: actual event size is dependent on the event type (challenge mode).\n        // Absolute offset.\n        val actionsOffset = startPos + 16 + 20 * areaEvents.size\n        cursor.size = max(actionsOffset, cursor.size)\n\n        cursor.writeInt(actionsOffset - startPos)\n        cursor.writeInt(0x10)\n        cursor.writeInt(areaEvents.size)\n        cursor.writeInt(0) // TODO: write event type (challenge mode).\n\n        // Relative offset.\n        var eventActionsOffset = 0\n\n        for (event in areaEvents) {\n            cursor.writeInt(event.id)\n            cursor.writeInt(0x10000)\n            cursor.writeShort(event.sectionId)\n            cursor.writeShort(event.wave)\n            cursor.writeShort(event.delay)\n            cursor.writeShort(event.unknown)\n            cursor.writeInt(eventActionsOffset)\n            val nextEventPos = cursor.position\n\n            cursor.seekStart(actionsOffset + eventActionsOffset)\n\n            for (action in event.actions) {\n                when (action) {\n                    is DatEventAction.SpawnNpcs -> {\n                        cursor.writeByte(EVENT_ACTION_SPAWN_NPCS)\n                        cursor.writeShort(action.sectionId)\n                        cursor.writeShort(action.appearFlag)\n                    }\n                    is DatEventAction.Unlock -> {\n                        cursor.writeByte(EVENT_ACTION_UNLOCK)\n                        cursor.writeShort(action.doorId)\n                    }\n                    is DatEventAction.Lock -> {\n                        cursor.writeByte(EVENT_ACTION_LOCK)\n                        cursor.writeShort(action.doorId)\n                    }\n                    is DatEventAction.TriggerEvent -> {\n                        cursor.writeByte(EVENT_ACTION_TRIGGER_EVENT)\n                        cursor.writeInt(action.eventId)\n                    }\n                }\n            }\n\n            // End of event actions.\n            cursor.writeByte(1)\n\n            eventActionsOffset = cursor.position - actionsOffset\n\n            cursor.seekStart(nextEventPos)\n        }\n\n        cursor.seekStart(actionsOffset + eventActionsOffset)\n\n        while ((cursor.position - actionsOffset) % 4 != 0) {\n            cursor.writeByte(-1)\n        }\n\n        val endPos = cursor.position\n\n        cursor.seekStart(totalSizeOffset)\n        cursor.writeInt(16 + endPos - startPos)\n\n        cursor.seekStart(entitiesSizeOffset)\n        cursor.writeInt(endPos - startPos)\n\n        cursor.seekStart(endPos)\n    }\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport world.phantasmal.lib.Episode\n\nprivate val EP_AND_NAME_TO_NPC_TYPE: Map<Pair<String, Episode>, NpcType> =\n    mutableMapOf<Pair<String, Episode>, NpcType>().also { map ->\n        for (npcType in NpcType.VALUES) {\n            if (npcType.episode != null) {\n                map[Pair(npcType.simpleName, npcType.episode)] = npcType\n                map[Pair(npcType.ultimateName, npcType.episode)] = npcType\n            }\n        }\n    }\n\n/**\n * Uniquely identifies an NPC. Tries to match on [NpcType.simpleName] and [NpcType.ultimateName].\n */\nfun NpcType.Companion.fromNameAndEpisode(name: String, episode: Episode): NpcType? =\n    EP_AND_NAME_TO_NPC_TYPE[Pair(name, episode)]\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.core.filenameBase\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.WritableCursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.ceil\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n// .qst format\nprivate const val DC_GC_PC_HEADER_SIZE = 60\nprivate const val BB_HEADER_SIZE = 88\nprivate const val ONLINE_QUEST = 0x44\nprivate const val DOWNLOAD_QUEST = 0xa6\n\n// Chunks\nprivate const val CHUNK_BODY_SIZE = 1024\nprivate const val DC_GC_PC_CHUNK_HEADER_SIZE = 20\nprivate const val DC_GC_PC_CHUNK_TRAILER_SIZE = 4\nprivate const val DC_GC_PC_CHUNK_SIZE =\n    CHUNK_BODY_SIZE + DC_GC_PC_CHUNK_HEADER_SIZE + DC_GC_PC_CHUNK_TRAILER_SIZE\nprivate const val BB_CHUNK_HEADER_SIZE = 24\nprivate const val BB_CHUNK_TRAILER_SIZE = 8\nprivate const val BB_CHUNK_SIZE = CHUNK_BODY_SIZE + BB_CHUNK_HEADER_SIZE + BB_CHUNK_TRAILER_SIZE\n\nclass QstContent(\n    val version: Version,\n    val online: Boolean,\n    val files: List<QstContainedFile>,\n)\n\nclass QstContainedFile(\n    val id: Int?,\n    val filename: String,\n    val questName: String?,\n    val data: Buffer,\n)\n\n/**\n * Low level parsing function for .qst files.\n */\nfun parseQst(cursor: Cursor): PwResult<QstContent> {\n    val result = PwResult.build<QstContent>(logger)\n\n    // A .qst file contains two headers that describe the embedded .dat and .bin files.\n    // Read headers and contained files.\n    val headers = parseHeaders(cursor)\n\n    if (headers.size < 2) {\n        return result\n            .addProblem(\n                Severity.Error,\n                \"This .qst file is corrupt.\",\n                \"Corrupt .qst file, expected at least 2 headers but only found ${headers.size}.\",\n            )\n            .failure()\n    }\n\n    var version: Version? = null\n    var online: Boolean? = null\n\n    for (header in headers) {\n        if (version != null && header.version != version) {\n            return result\n                .addProblem(\n                    Severity.Error,\n                    \"This .qst file is corrupt.\",\n                    \"Corrupt .qst file, header version ${header.version} for file ${\n                        header.filename\n                    } doesn't match the previous header's version ${version}.\",\n                )\n                .failure()\n        }\n\n        if (online != null && header.online != online) {\n            return result\n                .addProblem(\n                    Severity.Error,\n                    \"This .qst file is corrupt.\",\n                    \"Corrupt .qst file, header type ${\n                        if (header.online) \"\\\"online\\\"\" else \"\\\"download\\\"\"\n                    } for file ${header.filename} doesn't match the previous header's type ${\n                        if (online) \"\\\"online\\\"\" else \"\\\"download\\\"\"\n                    }.\",\n                )\n                .failure()\n        }\n\n        version = header.version\n        online = header.online\n    }\n\n    checkNotNull(version)\n    checkNotNull(online)\n\n    val parseFilesResult: PwResult<List<QstContainedFile>> = parseFiles(\n        cursor,\n        version,\n        headers.map { it.filename to it }.toMap()\n    )\n    result.addResult(parseFilesResult)\n\n    if (parseFilesResult !is Success) {\n        return result.failure()\n    }\n\n    return result.success(QstContent(\n        version,\n        online,\n        parseFilesResult.value\n    ))\n}\n\nprivate class QstHeader(\n    val version: Version,\n    val online: Boolean,\n    val questId: Int,\n    val name: String,\n    val filename: String,\n    val size: Int,\n)\n\nprivate fun parseHeaders(cursor: Cursor): List<QstHeader> {\n    val headers = mutableListOf<QstHeader>()\n\n    var prevQuestId: Int? = null\n    var prevFilename: String? = null\n\n    // .qst files should have two headers. Some malformed files have more, so we tried to detect at\n    // most 4 headers.\n    repeat(4) {\n        // Detect version and whether it's an online or download quest.\n        val version: Version\n        val online: Boolean\n\n        val versionA = cursor.uByte().toInt()\n        cursor.seek(1)\n        val versionB = cursor.uByte().toInt()\n        cursor.seek(-3)\n\n        if (versionA == BB_HEADER_SIZE && versionB == ONLINE_QUEST) {\n            version = Version.BB\n            online = true\n        } else if (versionA == DC_GC_PC_HEADER_SIZE && versionB == ONLINE_QUEST) {\n            version = Version.PC\n            online = true\n        } else if (versionB == DC_GC_PC_HEADER_SIZE) {\n            val pos = cursor.position\n            cursor.seek(35)\n\n            version = if (cursor.byte().toInt() == 0) {\n                Version.GC\n            } else {\n                Version.DC\n            }\n\n            cursor.seekStart(pos)\n\n            online = when (versionA) {\n                ONLINE_QUEST -> true\n                DOWNLOAD_QUEST -> false\n                else -> return@repeat\n            }\n        } else {\n            return@repeat\n        }\n\n        // Read header.\n        val headerSize: Int\n        val questId: Int\n        val name: String\n        val filename: String\n        val size: Int\n\n        when (version) {\n            Version.DC -> {\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                headerSize = cursor.uShort().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(3)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                cursor.seek(1)\n                size = cursor.int()\n            }\n\n            Version.GC -> {\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                headerSize = cursor.uShort().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(4)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n            }\n\n            Version.PC -> {\n                headerSize = cursor.uShort().toInt()\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(4)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n            }\n\n            Version.BB -> {\n                headerSize = cursor.uShort().toInt()\n                cursor.seek(2) // Skip online/download.\n                questId = cursor.uShort().toInt()\n                cursor.seek(38)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n                name = cursor.stringAscii(24, nullTerminated = true, dropRemaining = true)\n            }\n        }\n\n        // Use some simple heuristics to figure out whether the file contains more than two headers.\n        // Some malformed .qst files have extra headers.\n        if (\n            prevQuestId != null &&\n            prevFilename != null &&\n            (questId != prevQuestId || filenameBase(filename) != filenameBase(prevFilename!!))\n        ) {\n            cursor.seek(-headerSize)\n            return@repeat\n        }\n\n        prevQuestId = questId\n        prevFilename = filename\n\n        headers.add(QstHeader(\n            version,\n            online,\n            questId,\n            name,\n            filename,\n            size,\n        ))\n    }\n\n    return headers\n}\n\nprivate class QstFileData(\n    val name: String,\n    val expectedSize: Int?,\n    val cursor: WritableCursor,\n    var chunkNos: MutableSet<Int>,\n)\n\nprivate fun parseFiles(\n    cursor: Cursor,\n    version: Version,\n    headers: Map<String, QstHeader>,\n): PwResult<List<QstContainedFile>> {\n    val result = PwResult.build<List<QstContainedFile>>(logger)\n\n    // Files are interleaved in 1048 or 1056 byte chunks, depending on the version.\n    // Each chunk has a 20 or 24 byte header, 1024 byte data segment and a 4 or 8 byte trailer.\n    val files = mutableMapOf<String, QstFileData>()\n\n    val chunkSize: Int // Size including padding, header and trailer.\n    val trailerSize: Int\n\n    when (version) {\n        Version.DC,\n        Version.GC,\n        Version.PC,\n        -> {\n            chunkSize = DC_GC_PC_CHUNK_SIZE\n            trailerSize = DC_GC_PC_CHUNK_TRAILER_SIZE\n        }\n\n        Version.BB -> {\n            chunkSize = BB_CHUNK_SIZE\n            trailerSize = BB_CHUNK_TRAILER_SIZE\n        }\n    }\n\n    while (cursor.bytesLeft >= chunkSize) {\n        val startPosition = cursor.position\n\n        // Read chunk header.\n        var chunkNo: Int\n\n        when (version) {\n            Version.DC,\n            Version.GC,\n            -> {\n                cursor.seek(1)\n                chunkNo = cursor.uByte().toInt()\n                cursor.seek(2)\n            }\n\n            Version.PC -> {\n                cursor.seek(3)\n                chunkNo = cursor.uByte().toInt()\n            }\n\n            Version.BB -> {\n                cursor.seek(4)\n                chunkNo = cursor.int()\n            }\n        }\n\n        val fileName = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n\n        val file = files.getOrPut(fileName) {\n            val header = headers[fileName]\n            QstFileData(\n                fileName,\n                header?.size,\n                Buffer.withCapacity(\n                    header?.size ?: (10 * CHUNK_BODY_SIZE),\n                    Endianness.Little\n                ).cursor(),\n                mutableSetOf()\n            )\n        }\n\n        if (chunkNo in file.chunkNos) {\n            result.addProblem(\n                Severity.Warning,\n                \"File chunk Int $chunkNo of file $fileName was already encountered, overwriting previous chunk.\",\n            )\n        } else {\n            file.chunkNos.add(chunkNo)\n        }\n\n        // Read file data.\n        var size = cursor.seek(CHUNK_BODY_SIZE).int()\n        cursor.seek(-CHUNK_BODY_SIZE - 4)\n\n        if (size > CHUNK_BODY_SIZE) {\n            result.addProblem(\n                Severity.Warning,\n                \"Data segment size of $size is larger than expected maximum size, reading just $CHUNK_BODY_SIZE bytes.\",\n            )\n            size = CHUNK_BODY_SIZE\n        }\n\n        val data = cursor.take(size)\n        val chunkPosition = chunkNo * CHUNK_BODY_SIZE\n        file.cursor.size = max(chunkPosition + size, file.cursor.size)\n        file.cursor.seekStart(chunkPosition).writeCursor(data)\n\n        // Skip the padding and the trailer.\n        cursor.seek(CHUNK_BODY_SIZE - data.size + trailerSize)\n\n        check(cursor.position == startPosition + chunkSize) {\n            \"Read ${\n                cursor.position - startPosition\n            } file chunk message bytes instead of expected ${chunkSize}.\"\n        }\n    }\n\n    if (cursor.hasBytesLeft()) {\n        result.addProblem(Severity.Warning, \"${cursor.bytesLeft} Bytes left in file.\")\n    }\n\n    for (file in files.values) {\n        // Clean up file properties.\n        file.cursor.seekStart(0)\n        file.chunkNos = file.chunkNos.sorted().toMutableSet()\n\n        // Check whether the expected size was correct.\n        if (file.expectedSize != null && file.cursor.size != file.expectedSize) {\n            result.addProblem(\n                Severity.Warning,\n                \"File ${file.name} has an actual size of ${\n                    file.cursor.size\n                } instead of the expected size ${file.expectedSize}.\",\n            )\n        }\n\n        // Detect missing file chunks.\n        val actualSize = max(file.cursor.size, file.expectedSize ?: 0)\n        val expectedChunkCount = ceil(actualSize.toDouble() / CHUNK_BODY_SIZE).toInt()\n\n        for (chunkNo in 0 until expectedChunkCount) {\n            if (chunkNo !in file.chunkNos) {\n                result.addProblem(\n                    Severity.Warning,\n                    \"File ${file.name} is missing chunk ${chunkNo}.\",\n                )\n            }\n        }\n    }\n\n    return result.success(\n        files.values.map { file ->\n            val header = headers[file.name]\n            QstContainedFile(\n                header?.questId,\n                file.name,\n                header?.name,\n                file.cursor.seekStart(0).buffer(),\n            )\n        }\n    )\n}\n\nfun writeQst(qst: QstContent): Buffer {\n    val fileHeaderSize: Int\n    val chunkSize: Int\n\n    when (qst.version) {\n        Version.DC, Version.GC, Version.PC -> {\n            fileHeaderSize = DC_GC_PC_HEADER_SIZE\n            chunkSize = DC_GC_PC_CHUNK_SIZE\n        }\n        Version.BB -> {\n            fileHeaderSize = BB_HEADER_SIZE\n            chunkSize = BB_CHUNK_SIZE\n        }\n    }\n\n    val totalSize = qst.files.sumOf {\n        fileHeaderSize + ceil(it.data.size.toDouble() / CHUNK_BODY_SIZE).toInt() * chunkSize\n    }\n\n    val buffer = Buffer.withCapacity(totalSize)\n    val cursor = buffer.cursor()\n\n    writeFileHeaders(cursor, qst.files, qst.version, qst.online, fileHeaderSize)\n    writeFileChunks(cursor, qst.files, qst.version)\n\n    check(cursor.position == totalSize) {\n        \"Expected a final file size of $totalSize, but got ${cursor.position}.\"\n    }\n\n    return buffer\n}\n\nprivate fun writeFileHeaders(\n    cursor: WritableCursor,\n    files: List<QstContainedFile>,\n    version: Version,\n    online: Boolean,\n    headerSize: Int,\n) {\n    val maxId: Int\n    val maxQuestNameLength: Int\n\n    if (version == Version.BB) {\n        maxId = 0xffff\n        maxQuestNameLength = 23\n    } else {\n        maxId = 0xff\n        maxQuestNameLength = 31\n    }\n\n    for (file in files) {\n        require(file.id == null || (file.id in 0..maxId)) {\n            \"Quest ID should be between 0 and $maxId, inclusive.\"\n        }\n        require(file.questName == null || file.questName.length <= maxQuestNameLength) {\n            \"File ${file.filename} has a quest name longer than $maxQuestNameLength characters (${file.questName}).\"\n        }\n        require(file.filename.length <= 15) {\n            \"File ${file.filename} has a filename longer than 15 characters.\"\n        }\n\n        when (version) {\n            Version.DC -> {\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeByte(0)\n                cursor.writeByte(0)\n                cursor.writeByte(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeByte(0)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.GC -> {\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeInt(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.PC -> {\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeInt(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.BB -> {\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeUShort((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUShort())\n                cursor.writeUShort(file.id?.toUShort() ?: 0u)\n                repeat(38) { cursor.writeByte(0) }\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n                cursor.writeStringAscii(file.questName ?: file.filename, 24)\n            }\n        }\n    }\n}\n\nprivate class FileToChunk(\n    var no: Int,\n    val data: Cursor,\n    val name: String,\n)\n\nprivate fun writeFileChunks(\n    cursor: WritableCursor,\n    files: List<QstContainedFile>,\n    version: Version,\n) {\n    // Files are interleaved in chunks. Each chunk has a header, fixed-size data segment and a\n    // trailer.\n    val filesToChunk = files.map { file ->\n        FileToChunk(\n            no = 0,\n            data = file.data.cursor(),\n            name = file.filename,\n        )\n    }\n    var done = 0\n\n    while (done < filesToChunk.size) {\n        for (fileToChunk in filesToChunk) {\n            if (fileToChunk.data.hasBytesLeft()) {\n                if (\n                    !writeFileChunk(\n                        cursor,\n                        fileToChunk.data,\n                        fileToChunk.no++,\n                        fileToChunk.name,\n                        version,\n                    )\n                ) {\n                    done++\n                }\n            }\n        }\n    }\n\n    for (fileToChunk in filesToChunk) {\n        val expectedChunks = ceil(fileToChunk.data.size.toDouble() / CHUNK_BODY_SIZE).toInt()\n\n        check(fileToChunk.no == expectedChunks) {\n            \"\"\"Expected to write $expectedChunks chunks for file \"${\n                fileToChunk.name\n            }\" but ${fileToChunk.no} where written.\"\"\"\n        }\n    }\n}\n\n/**\n * Returns true if there are bytes left to write in [data], false otherwise.\n */\nprivate fun writeFileChunk(\n    cursor: WritableCursor,\n    data: Cursor,\n    chunkNo: Int,\n    name: String,\n    version: Version,\n): Boolean {\n    when (version) {\n        Version.DC,\n        Version.GC,\n        -> {\n            cursor.writeByte(0)\n            cursor.writeUByte(chunkNo.toUByte())\n            cursor.writeShort(0)\n        }\n\n        Version.PC -> {\n            cursor.writeByte(0)\n            cursor.writeByte(0)\n            cursor.writeByte(0)\n            cursor.writeUByte(chunkNo.toUByte())\n        }\n\n        Version.BB -> {\n            cursor.writeByte(28)\n            cursor.writeByte(4)\n            cursor.writeByte(19)\n            cursor.writeByte(0)\n            cursor.writeInt(chunkNo)\n        }\n    }\n\n    cursor.writeStringAscii(name, 16)\n\n    val size = min(CHUNK_BODY_SIZE, data.bytesLeft)\n    cursor.writeCursor(data.take(size))\n\n    // Padding.\n    repeat(CHUNK_BODY_SIZE - size) {\n        cursor.writeByte(0)\n    }\n\n    cursor.writeInt(size)\n\n    if (version == Version.BB) {\n        cursor.writeInt(0)\n    }\n\n    return data.hasBytesLeft()\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.*\nimport world.phantasmal.lib.Episode\nimport world.phantasmal.lib.asm.BytecodeIr\nimport world.phantasmal.lib.asm.InstructionSegment\nimport world.phantasmal.lib.asm.OP_SET_EPISODE\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getMapDesignations\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.compression.prs.prsCompress\nimport world.phantasmal.lib.compression.prs.prsDecompress\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nclass Quest(\n    var id: Int,\n    var language: Int,\n    var name: String,\n    var shortDescription: String,\n    var longDescription: String,\n    var episode: Episode,\n    val objects: MutableList<QuestObject>,\n    val npcs: MutableList<QuestNpc>,\n    val events: MutableList<DatEvent>,\n    /**\n     * (Partial) raw DAT data that can't be parsed yet by Phantasmal.\n     */\n    val datUnknowns: MutableList<DatUnknown>,\n    var bytecodeIr: BytecodeIr,\n    val shopItems: UIntArray,\n    val mapDesignations: MutableMap<Int, Int>,\n)\n\n/**\n * High level quest parsing function that delegates to [parseBin] and [parseDat].\n */\nfun parseBinDatToQuest(\n    binCursor: Cursor,\n    datCursor: Cursor,\n    lenient: Boolean = false,\n): PwResult<Quest> {\n    val result = PwResult.build<Quest>(logger)\n\n    // Decompress and parse files.\n    val binDecompressed = prsDecompress(binCursor)\n    result.addResult(binDecompressed)\n\n    if (binDecompressed !is Success) {\n        return result.failure()\n    }\n\n    val bin = parseBin(binDecompressed.value)\n\n    val datDecompressed = prsDecompress(datCursor)\n    result.addResult(datDecompressed)\n\n    if (datDecompressed !is Success) {\n        return result.failure()\n    }\n\n    val dat = parseDat(datDecompressed.value)\n    val objects = dat.objs.mapTo(mutableListOf()) { QuestObject(it.areaId, it.data) }\n    // Initialize NPCs with random episode and correct it later.\n    val npcs = dat.npcs.mapTo(mutableListOf()) { QuestNpc(Episode.I, it.areaId, it.data) }\n\n    // Extract episode and map designations from byte code.\n    var episode = Episode.I\n    var mapDesignations = mutableMapOf<Int, Int>()\n\n    val parseBytecodeResult = parseBytecode(\n        bin.bytecode,\n        bin.labelOffsets,\n        extractScriptEntryPoints(objects, npcs),\n        bin.format == BinFormat.DC_GC,\n        lenient,\n    )\n\n    result.addResult(parseBytecodeResult)\n\n    if (parseBytecodeResult !is Success) {\n        return result.failure()\n    }\n\n    val bytecodeIr = parseBytecodeResult.value\n\n    if (bytecodeIr.segments.isEmpty()) {\n        result.addProblem(Severity.Warning, \"File contains no instruction labels.\")\n    } else {\n        val instructionSegments = bytecodeIr.instructionSegments()\n\n        var label0Segment: InstructionSegment? = null\n\n        for (segment in instructionSegments) {\n            if (0 in segment.labels) {\n                label0Segment = segment\n                break\n            }\n        }\n\n        if (label0Segment != null) {\n            episode = getEpisode(result, label0Segment)\n\n            for (npc in npcs) {\n                npc.episode = episode\n            }\n\n            mapDesignations =\n                getMapDesignations(label0Segment) { ControlFlowGraph.create(bytecodeIr) }\n        } else {\n            result.addProblem(Severity.Warning, \"No instruction segment for label 0 found.\")\n        }\n    }\n\n    return result.success(Quest(\n        id = bin.questId,\n        language = bin.language,\n        name = bin.questName,\n        shortDescription = bin.shortDescription,\n        longDescription = bin.longDescription,\n        episode,\n        objects,\n        npcs,\n        events = dat.events,\n        datUnknowns = dat.unknowns,\n        bytecodeIr,\n        shopItems = bin.shopItems,\n        mapDesignations,\n    ))\n}\n\nclass QuestData(\n    val quest: Quest,\n    val version: Version,\n    val online: Boolean,\n)\n\n/**\n * High level .qst parsing function that delegates to [parseQst], [parseBin] and [parseDat].\n */\nfun parseQstToQuest(cursor: Cursor, lenient: Boolean = false): PwResult<QuestData> {\n    val result = PwResult.build<QuestData>(logger)\n\n    // Extract contained .dat and .bin files.\n    val qstResult = parseQst(cursor)\n    result.addResult(qstResult)\n\n    if (qstResult !is Success) {\n        return result.failure()\n    }\n\n    val version = qstResult.value.version\n    val online = qstResult.value.online\n    val files = qstResult.value.files\n    var datFile: QstContainedFile? = null\n    var binFile: QstContainedFile? = null\n\n    for (file in files) {\n        val fileName = file.filename.trim().toLowerCase()\n\n        if (fileName.endsWith(\".dat\")) {\n            datFile = file\n        } else if (fileName.endsWith(\".bin\")) {\n            binFile = file\n        }\n    }\n\n    if (datFile == null) {\n        return result.addProblem(Severity.Error, \"File contains no DAT file.\").failure()\n    }\n\n    if (binFile == null) {\n        return result.addProblem(Severity.Error, \"File contains no BIN file.\").failure()\n    }\n\n    val questResult = parseBinDatToQuest(\n        binFile.data.cursor(),\n        datFile.data.cursor(),\n        lenient,\n    )\n    result.addResult(questResult)\n\n    if (questResult !is Success) {\n        return result.failure()\n    }\n\n    return result.success(QuestData(\n        questResult.value,\n        version,\n        online,\n    ))\n}\n\n/**\n * Defaults to episode I.\n */\nprivate fun getEpisode(rb: PwResultBuilder<*>, func0Segment: InstructionSegment): Episode {\n    val setEpisode = func0Segment.instructions.find {\n        it.opcode == OP_SET_EPISODE\n    }\n\n    if (setEpisode == null) {\n        logger.debug { \"Function 0 has no set_episode instruction.\" }\n        return Episode.I\n    }\n\n    return when (val episode = setEpisode.args[0].value) {\n        0 -> Episode.I\n        1 -> Episode.II\n        2 -> Episode.IV\n        else -> {\n            rb.addProblem(\n                Severity.Warning,\n                \"Unknown episode $episode in function 0 set_episode instruction.\"\n            )\n            Episode.I\n        }\n    }\n}\n\nprivate fun extractScriptEntryPoints(\n    objects: List<QuestObject>,\n    npcs: List<QuestNpc>,\n): Set<Int> {\n    val entryPoints = mutableSetOf(0)\n\n    objects.forEach { obj ->\n        obj.scriptLabel?.let(entryPoints::add)\n        obj.scriptLabel2?.let(entryPoints::add)\n    }\n\n    npcs.forEach { npc ->\n        entryPoints.add(npc.scriptLabel)\n    }\n\n    return entryPoints\n}\n\n/**\n * Returns a .bin and .dat file in that order.\n */\nfun writeQuestToBinDat(quest: Quest, version: Version): Pair<Buffer, Buffer> {\n    val dat = writeDat(DatFile(\n        objs = quest.objects.mapTo(mutableListOf()) { DatEntity(it.areaId, it.data) },\n        npcs = quest.npcs.mapTo(mutableListOf()) { DatEntity(it.areaId, it.data) },\n        events = quest.events,\n        unknowns = quest.datUnknowns,\n    ))\n\n    val binFormat = when (version) {\n        Version.DC, Version.GC -> BinFormat.DC_GC\n        Version.PC -> BinFormat.PC\n        Version.BB -> BinFormat.BB\n    }\n\n    val (bytecode, labelOffsets) = writeBytecode(quest.bytecodeIr, binFormat == BinFormat.DC_GC)\n\n    val bin = writeBin(BinFile(\n        binFormat,\n        quest.id,\n        quest.language,\n        quest.name,\n        quest.shortDescription,\n        quest.longDescription,\n        bytecode,\n        labelOffsets,\n        quest.shopItems,\n    ))\n\n    return Pair(bin, dat)\n}\n\n/**\n * Creates a .qst file from [quest].\n */\nfun writeQuestToQst(quest: Quest, filename: String, version: Version, online: Boolean): Buffer {\n    val (bin, dat) = writeQuestToBinDat(quest, version)\n\n    val baseFilename = (filenameBase(filename) ?: filename).take(11)\n    val questName = quest.name.take(if (version == Version.BB) 23 else 31)\n\n    return writeQst(QstContent(\n        version,\n        online,\n        files = listOf(\n            QstContainedFile(\n                id = quest.id,\n                filename = \"$baseFilename.dat\",\n                questName = questName,\n                data = prsCompress(dat.cursor()).buffer(),\n            ),\n            QstContainedFile(\n                id = quest.id,\n                filename = \"$baseFilename.bin\",\n                questName = questName,\n                data = prsCompress(bin.cursor()).buffer(),\n            ),\n        ),\n    ))\n}\n","package world.phantasmal.lib.vm\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.Episode\nimport world.phantasmal.lib.asm.*\nimport world.phantasmal.lib.buffer.Buffer\n\nprivate val logger = KotlinLogging.logger {}\n\nenum class ExecutionResult {\n    /**\n     * There are no live threads, nothing to do.\n     */\n    Suspended,\n\n    /**\n     * Execution is paused because of the [ExecutionInterceptor].\n     */\n    Paused,\n\n    /**\n     * All threads have yielded.\n     */\n    WaitingVsync,\n\n    /**\n     * Execution has halted because the VM encountered an `exit` instruction, a fatal error was\n     * raised or the VM was halted from outside.\n     */\n    Halted,\n}\n\ninterface ExecutionInterceptor {\n    /**\n     * Called before the VM executes an instruction. If false is returned, the VM won't execute the\n     * instruction and pause.\n     */\n    fun intercept(instruction: InstructionReference): Boolean\n}\n\n/**\n * This class emulates the PSO script engine. It's in charge of memory, threading and executing\n * instructions.\n */\nclass VirtualMachine {\n    // Quest Details\n\n    private var episode: Episode = Episode.I\n\n    var bytecode: BytecodeIr = BytecodeIr(emptyList())\n        private set\n\n    private val labelToSegIdx: MutableMap<Int, Int> = mutableMapOf()\n\n    // VM State\n\n    private val registers = Buffer.withSize(REGISTER_COUNT * REGISTER_SIZE, Endianness.Little)\n    private var stringArgStore = \"\"\n\n    /**\n     * All live threads.\n     */\n    private val threads: MutableList<Thread> = mutableListOf()\n\n    /**\n     * Current thread index into [threads].\n     */\n    private var threadIdx = 0\n\n    var halted = true\n        private set\n\n    var executionInterceptor: ExecutionInterceptor? = null\n\n    /**\n     * Halts and resets the VM, then loads new bytecode.\n     */\n    fun loadBytecode(bytecode: BytecodeIr, episode: Episode) {\n        halt()\n\n        logger.debug { \"Starting.\" }\n\n        this.bytecode = bytecode\n        this.episode = episode\n\n        labelToSegIdx.clear()\n\n        for ((segIdx, segment) in bytecode.segments.withIndex()) {\n            for (label in segment.labels) {\n                labelToSegIdx[label] = segIdx\n            }\n        }\n\n        halted = false\n    }\n\n    /**\n     * Executes instructions while possible.\n     */\n    fun execute(): ExecutionResult {\n        require(!halted) { \"Halted.\" }\n        require(threads.isNotEmpty()) { \"Suspended.\" }\n        require(threadIdx < threads.size) { \"Awaiting vsync.\" }\n\n        try {\n            // Limit amount of instructions executed to prevent infinite loops.\n            var executionCounter = 0\n\n            while (executionCounter++ < 10_000) {\n                // Execute the instruction pointed to by the current thread.\n                val thread = currentThread()!!\n                val instRef = thread.instructionPointer!!\n\n                if (executionInterceptor?.intercept(instRef) == false) {\n                    return ExecutionResult.Paused\n                } else {\n                    val result = executeInstruction()\n\n                    if (result != null && result != ExecutionResult.WaitingVsync) {\n                        return result\n                    }\n                }\n\n                if (threads.isEmpty()) {\n                    return ExecutionResult.Suspended\n                }\n\n                if (threadIdx > threads.lastIndex) {\n                    return ExecutionResult.WaitingVsync\n                }\n            }\n\n            // TODO: Output error \"Maximum execution count reached. The code probably contains an infinite loop.\".\n            halt()\n            return ExecutionResult.Halted\n        } catch (e: Throwable) {\n            // TODO: Output error.\n            halt()\n            return ExecutionResult.Halted\n        }\n    }\n\n    /**\n     * Signal to the VM that a vsync has happened.\n     */\n    fun vsync() {\n        if (threadIdx > threads.lastIndex) {\n            threadIdx = 0\n        }\n    }\n\n    /**\n     * Halts execution of all threads.\n     */\n    fun halt() {\n        if (!halted) {\n            logger.debug { \"Halting.\" }\n\n            registers.zero()\n            stringArgStore = \"\"\n            threads.clear()\n            threadIdx = 0\n            // TODO:\n//            window_msg_open = false\n//            set_episode_called = false\n//            list_open = false\n//            selection_reg = 0\n            halted = true\n//            paused = false\n//            breakpoints.splice(0, Infinity)\n//            unsupported_opcodes_logged.clear()\n            Thread.resetIdCounter()\n        }\n    }\n\n    private fun executeInstruction(): ExecutionResult? {\n        val thread = threads[threadIdx]\n        val inst = thread.instructionPointer!!.instruction\n        val args = inst.args.map { it.value }\n\n        var advance = true\n        var result: ExecutionResult? = null\n\n        when (inst.opcode.code) {\n            OP_NOP.code -> {\n            }\n            OP_RET.code -> {\n                popFrame(threadIdx)\n            }\n            OP_SYNC.code -> {\n                advanceInstructionPointer(threadIdx)\n                threadIdx++\n                advance = false\n                result = ExecutionResult.WaitingVsync\n            }\n            OP_EXIT.code -> {\n                halt()\n            }\n            OP_THREAD.code -> {\n                TODO()\n            }\n            OP_CALL.code -> {\n                pushFrame(thread, args[0] as Int)\n                advance = false\n            }\n            OP_JMP.code -> {\n                jumpToLabel(thread, args[0] as Int)\n                advance = false\n            }\n        }\n\n        if (advance) {\n            advanceInstructionPointer(threadIdx)\n        }\n\n        return result\n    }\n\n    /**\n     * Simply advance to the next instruction no matter what the current instruction is. I.e. this\n     * method simply advances past jumps and calls.\n     */\n    private fun advanceInstructionPointer(threadIdx: Int) {\n        val thread = threads[threadIdx]\n        require(thread.live) { \"Trying to advance the instruction pointer within a dead thread.\" }\n\n        val frame = thread.currentStackFrame()!!\n        val next = frame.instructionPointer.next()\n\n        if (next == null) {\n            // Reached EOF.\n            // Game will crash if call stack is not empty.\n            require(thread.callStack.isEmpty()) {\n                \"Reached EOF but call stack was not empty\"\n            }\n\n            thread.popFrame()\n            terminateThread(threadIdx)\n        } else {\n            frame.instructionPointer = next\n        }\n    }\n\n    private fun currentThread(): Thread? = threads.getOrNull(threadIdx)\n\n    private fun terminateThread(idx: Int) {\n        val thread = threads.removeAt(idx)\n\n        if (threadIdx >= idx && threadIdx > 0) {\n            threadIdx--\n        }\n\n        logger.debug { \"Thread #${thread.id} terminated.\" }\n    }\n\n    private fun pushFrame(thread: Thread, label: Int) {\n        val segIdx = getSegmentIndexByLabel(label)\n        val segment = bytecode.segments[segIdx]\n\n        require(segment.type == SegmentType.Instructions) {\n            \"Label $label points to a ${segment.type} segment, expecting ${\n                SegmentType.Instructions\n            }.\"\n        }\n\n        thread.pushFrame(InstructionReference(segIdx, 0, bytecode))\n    }\n\n    private fun popFrame(threadIdx: Int) {\n        val thread = threads[threadIdx]\n        thread.popFrame()\n\n        if (!thread.live) {\n            terminateThread(threadIdx)\n        }\n    }\n\n    private fun jumpToLabel(thread: Thread, label: Int) {\n        thread.currentStackFrame()!!.instructionPointer =\n            InstructionReference(getSegmentIndexByLabel(label), 0, bytecode)\n    }\n\n    private fun getSegmentIndexByLabel(label: Int): Int =\n        labelToSegIdx[label] ?: error(\"Invalid argument: No such label $label.\")\n\n    companion object {\n        private const val REGISTER_SIZE = 4\n\n        const val REGISTER_COUNT = 256\n    }\n}\n","package world.phantasmal.web.assemblyWorker\n\nimport world.phantasmal.core.*\nimport world.phantasmal.lib.asm.*\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ValueSet\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getMapDesignations\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getStackValue\nimport world.phantasmal.web.shared.messages.*\nimport world.phantasmal.web.shared.messages.AssemblyProblem\nimport kotlin.math.max\nimport kotlin.math.min\nimport world.phantasmal.lib.asm.AssemblyProblem as LibAssemblyProblem\n\nclass AsmAnalyser {\n    // User input.\n    private var inlineStackArgs: Boolean = true\n    private val asm: JsArray<String> = jsArrayOf()\n\n    // Output.\n    private var bytecodeIr = BytecodeIr(emptyList())\n    private var problems: List<AssemblyProblem>? = null\n\n    // Derived data.\n    private var _cfg: ControlFlowGraph? = null\n    private val cfg: ControlFlowGraph\n        get() {\n            if (_cfg == null) _cfg = ControlFlowGraph.create(bytecodeIr)\n            return _cfg!!\n        }\n\n    private var mapDesignations: Map<Int, Int>? = null\n\n    fun setAsm(asm: List<String>, inlineStackArgs: Boolean) {\n        this.inlineStackArgs = inlineStackArgs\n        this.asm.splice(0, this.asm.length, *asm.toTypedArray())\n        mapDesignations = null\n    }\n\n    fun updateAsm(changes: List<AsmChange>) {\n        for (change in changes) {\n            val (startLineNo, startCol, endLineNo, endCol) = change.range\n            val linesChanged = endLineNo - startLineNo + 1\n            val newLines = change.newAsm.split(\"\\n\").toJsArray()\n\n            when {\n                linesChanged == 1 -> {\n                    replaceLinePart(startLineNo, startCol, endCol, newLines)\n                }\n\n                newLines.length == 1 -> {\n                    replaceLinesAndMergeLineParts(\n                        startLineNo,\n                        endLineNo,\n                        startCol,\n                        endCol,\n                        newLines[0],\n                    )\n                }\n\n                else -> {\n                    // Keep the left part of the first changed line.\n                    replaceLinePartRight(startLineNo, startCol, newLines[0])\n\n                    // Keep the right part of the last changed line.\n                    replaceLinePartLeft(endLineNo, endCol, newLines[newLines.length - 1])\n\n                    // Replace all the lines in between.\n                    // It's important that we do this last.\n                    replaceLines(\n                        startLineNo + 1,\n                        endLineNo - 1,\n                        newLines.slice(1, newLines.length - 1),\n                    )\n                }\n            }\n        }\n    }\n\n    private fun replaceLinePart(\n        lineNo: Int,\n        startCol: Int,\n        endCol: Int,\n        newLineParts: JsArray<String>,\n    ) {\n        val line = asm[lineNo - 1]\n        // We keep the parts of the line that weren't affected by the edit.\n        val lineStart = line.substring(0, startCol - 1)\n        val lineEnd = line.substring(endCol - 1)\n\n        if (newLineParts.length == 1) {\n            asm[lineNo - 1] = lineStart + newLineParts[0] + lineEnd\n        } else {\n            asm.splice(\n                lineNo - 1,\n                1,\n                lineStart + newLineParts[0],\n                *newLineParts.slice(1, newLineParts.length - 1).asArray(),\n                newLineParts[newLineParts.length - 1] + lineEnd,\n            )\n        }\n    }\n\n    private fun replaceLinePartLeft(lineNo: Int, endCol: Int, newLinePart: String) {\n        asm[lineNo - 1] = newLinePart + asm[lineNo - 1].substring(endCol - 1)\n    }\n\n    private fun replaceLinePartRight(lineNo: Int, startCol: Int, newLinePart: String) {\n        asm[lineNo - 1] = asm[lineNo - 1].substring(0, startCol - 1) + newLinePart\n    }\n\n    private fun replaceLines(startLineNo: Int, endLineNo: Int, newLines: JsArray<String>) {\n        asm.splice(startLineNo - 1, endLineNo - startLineNo + 1, *newLines.asArray())\n    }\n\n    private fun replaceLinesAndMergeLineParts(\n        startLineNo: Int,\n        endLineNo: Int,\n        startCol: Int,\n        endCol: Int,\n        newLinePart: String,\n    ) {\n        val startLine = asm[startLineNo - 1]\n        val endLine = asm[endLineNo - 1]\n        // We keep the parts of the lines that weren't affected by the edit.\n        val startLineStart = startLine.substring(0, startCol - 1)\n        val endLineEnd = endLine.substring(endCol - 1)\n\n        asm.splice(\n            startLineNo - 1,\n            endLineNo - startLineNo + 1,\n            startLineStart + newLinePart + endLineEnd,\n        )\n    }\n\n    fun processAsm(): List<ServerNotification> {\n        _cfg = null\n\n        val notifications = mutableListOf<ServerNotification>()\n        val assemblyResult = assemble(asm.asArray().toList(), inlineStackArgs)\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val problems =\n            (assemblyResult.problems as List<LibAssemblyProblem>).map {\n                AssemblyProblem(it.severity, it.uiMessage, it.lineNo, it.col, it.len)\n            }\n\n        if (problems != this.problems) {\n            this.problems = problems\n            notifications.add(ServerNotification.Problems(problems))\n        }\n\n        if (assemblyResult is Success) {\n            bytecodeIr = assemblyResult.value\n\n            val instructionSegments = bytecodeIr.instructionSegments()\n\n            instructionSegments.find { 0 in it.labels }?.let { label0Segment ->\n                val designations = getMapDesignations(label0Segment) { cfg }\n\n                if (designations != mapDesignations) {\n                    mapDesignations = designations\n                    notifications.add(\n                        ServerNotification.MapDesignations(designations)\n                    )\n                }\n            }\n        }\n\n        return notifications\n    }\n\n    fun getCompletions(requestId: Int, lineNo: Int, col: Int): Response.GetCompletions {\n        val text = getLine(lineNo)?.take(col)?.trim()?.toLowerCase() ?: \"\"\n\n        val completions: List<CompletionItem> = when {\n            KEYWORD_REGEX.matches(text) -> KEYWORD_SUGGESTIONS\n\n            INSTRUCTION_REGEX.matches(text) -> {\n                val suggestions = INSTRUCTION_SUGGESTIONS.asSequence()\n                val startingWith = suggestions.filter { it.label.startsWith(text) }\n                val containing = suggestions.filter { it.label.contains(text) }\n\n                (startingWith + containing)\n                    .take(20)\n                    .toList()\n            }\n\n            else -> emptyList()\n        }\n\n        return Response.GetCompletions(requestId, completions)\n    }\n\n    fun getSignatureHelp(requestId: Int, lineNo: Int, col: Int): Response.GetSignatureHelp =\n        Response.GetSignatureHelp(requestId, signatureHelp(lineNo, col))\n\n    private fun signatureHelp(lineNo: Int, col: Int): SignatureHelp? {\n        var signature: Signature? = null\n        var activeParam = -1\n\n        getInstructionForSrcLoc(lineNo, col)?.let { result ->\n            signature = getSignature(result.inst.opcode)\n            activeParam = result.paramIdx\n        }\n\n        return signature?.let { sig ->\n            SignatureHelp(\n                signature = sig,\n                activeParameter = activeParam,\n            )\n        }\n    }\n\n    fun getHover(requestId: Int, lineNo: Int, col: Int): Response.GetHover {\n        val hover = signatureHelp(lineNo, col)?.let { help ->\n            val sig = help.signature\n            val param = sig.parameters.getOrNull(help.activeParameter)\n\n            val contents = mutableListOf<String>()\n\n            // Instruction signature. Parameter highlighted if possible.\n            contents.add(\n                if (param == null) {\n                    sig.label\n                } else {\n                    // TODO: Figure out how to underline the active parameter in addition to\n                    //  bolding it to make it match the look of the signature help.\n                    sig.label.substring(0, param.labelStart) +\n                            \"__\" +\n                            sig.label.substring(param.labelStart, param.labelEnd) +\n                            \"__\" +\n                            sig.label.substring(param.labelEnd)\n                }\n            )\n\n            // Put the parameter doc and the instruction doc in the same string to match the look of\n            // the signature help.\n            var doc = \"\"\n\n            // Parameter doc.\n            if (param?.documentation != null) {\n                doc += param.documentation\n\n                // TODO: Figure out how add an empty line here to make it match the look of the\n                //  signature help.\n                doc += \"\\n\\n\"\n            }\n\n            // Instruction doc.\n            sig.documentation?.let { doc += it }\n\n            if (doc.isNotEmpty()) {\n                contents.add(doc)\n            }\n\n            Hover(contents)\n        }\n\n        return Response.GetHover(requestId, hover)\n    }\n\n    fun getDefinition(requestId: Int, lineNo: Int, col: Int): Response.GetDefinition {\n        var result = emptyList<AsmRange>()\n\n        getInstructionForSrcLoc(lineNo, col)?.inst?.let { inst ->\n            visitLabelArguments(\n                inst,\n                accept = { argSrcLoc -> positionInside(lineNo, col, argSrcLoc.coarse) },\n                processImmediateArg = { label, _ ->\n                    result = getLabelDefinitionsAndReferences(label, references = false)\n                    VisitAction.Return\n                },\n                processStackArg = { labels, _, _ ->\n                    if (labels.size <= 5) {\n                        result = labels.flatMap {\n                            getLabelDefinitionsAndReferences(it, references = false)\n                        }\n                    }\n\n                    VisitAction.Return\n                },\n            )\n        }\n\n        return Response.GetDefinition(requestId, result)\n    }\n\n    fun getLabels(requestId: Int): Response.GetLabels {\n        val result = bytecodeIr.segments.asSequence()\n            .flatMap { segment ->\n                segment.labels.mapIndexed { labelIdx, label ->\n                    val range = segment.srcLoc.labels.getOrNull(labelIdx)?.toAsmRange()\n                    Label(name = label, range)\n                }\n            }\n            .toList()\n\n        return Response.GetLabels(requestId, result)\n    }\n\n    fun getHighlights(requestId: Int, lineNo: Int, col: Int): Response.GetHighlights {\n        val results = mutableListOf<AsmRange>()\n\n        when (val ir = getIrForSrcLoc(lineNo, col)) {\n            is Ir.Label -> {\n                results.addAll(getLabelDefinitionsAndReferences(ir.label))\n            }\n\n            is Ir.Inst -> {\n                val srcLoc = ir.inst.srcLoc?.mnemonic\n\n                if (ir.paramIdx == -1 ||\n                    // Also return this instruction if we're right past the mnemonic. E.g. at the\n                    // first whitespace character preceding the first argument.\n                    (srcLoc != null && col <= srcLoc.col + srcLoc.len)\n                ) {\n                    // Find all instructions with the same opcode.\n                    for (segment in bytecodeIr.segments) {\n                        if (segment is InstructionSegment) {\n                            for (inst in segment.instructions) {\n                                if (inst.opcode.code == ir.inst.opcode.code) {\n                                    inst.srcLoc?.mnemonic?.toAsmRange()?.let(results::add)\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    visitArgs(\n                        ir.inst,\n                        processParam = { VisitAction.Go },\n                        processImmediateArg = { param, arg, argSrcLoc ->\n                            if (positionInside(lineNo, col, argSrcLoc.coarse)) {\n                                (arg as? IntArg)?.let {\n                                    when (param.type) {\n                                        is LabelType -> {\n                                            results.addAll(\n                                                getLabelDefinitionsAndReferences(arg.value)\n                                            )\n                                        }\n                                        is RegRefType -> {\n                                            results.addAll(getRegisterReferences(arg.value))\n                                        }\n                                        else -> Unit\n                                    }\n                                }\n\n                                VisitAction.Return\n                            } else {\n                                VisitAction.Continue\n                            }\n                        },\n                        processStackArgSrcLoc = { _, argSrcLoc ->\n                            if (positionInside(lineNo, col, argSrcLoc.coarse)) {\n                                VisitAction.Go\n                            } else {\n                                VisitAction.Continue\n                            }\n                        },\n                        processStackArg = { param, _, pushInst, _ ->\n                            if (pushInst != null) {\n                                val pushArg = pushInst.args.firstOrNull()\n\n                                if (pushArg is IntArg) {\n                                    if (pushInst.opcode.code == OP_ARG_PUSHR.code ||\n                                        param.type is RegRefType\n                                    ) {\n                                        results.addAll(getRegisterReferences(pushArg.value))\n                                    } else if (param.type is LabelType) {\n                                        results.addAll(\n                                            getLabelDefinitionsAndReferences(pushArg.value)\n                                        )\n                                    }\n                                }\n                            }\n\n                            VisitAction.Return\n                        }\n                    )\n                }\n            }\n        }\n\n        return Response.GetHighlights(requestId, results)\n    }\n\n    private fun getInstructionForSrcLoc(lineNo: Int, col: Int): Ir.Inst? =\n        getIrForSrcLoc(lineNo, col) as? Ir.Inst\n\n    private fun getIrForSrcLoc(lineNo: Int, col: Int): Ir? {\n        for (segment in bytecodeIr.segments) {\n            for ((index, srcLoc) in segment.srcLoc.labels.withIndex()) {\n                if (srcLoc.lineNo == lineNo &&\n                    col >= srcLoc.col &&\n                    col < srcLoc.col + srcLoc.len\n                ) {\n                    return Ir.Label(segment.labels[index])\n                }\n            }\n\n            if (segment is InstructionSegment) {\n                // Loop over instructions in reverse order so stack popping instructions will be\n                // handled before the related stack pushing instructions when inlineStackArgs is on.\n                for (i in segment.instructions.lastIndex downTo 0) {\n                    val inst = segment.instructions[i]\n\n                    inst.srcLoc?.let { srcLoc ->\n                        var instLineNo = -1\n                        var lastCol = -1\n\n                        srcLoc.mnemonic?.let { mnemonicSrcLoc ->\n                            instLineNo = mnemonicSrcLoc.lineNo\n                            lastCol = mnemonicSrcLoc.col + mnemonicSrcLoc.len\n\n                            if (positionInside(lineNo, col, mnemonicSrcLoc)) {\n                                return Ir.Inst(inst, paramIdx = -1)\n                            }\n                        }\n\n                        for ((argIdx, argSrcLoc) in srcLoc.args.withIndex()) {\n                            instLineNo = argSrcLoc.coarse.lineNo\n                            lastCol = argSrcLoc.coarse.col + argSrcLoc.coarse.len\n\n                            if (positionInside(lineNo, col, argSrcLoc.coarse)) {\n                                return Ir.Inst(inst, argIdx)\n                            }\n                        }\n\n                        if (lineNo == instLineNo && col >= lastCol) {\n                            val argIdx = max(0, srcLoc.args.lastIndex) +\n                                    (if (srcLoc.trailingArgSeparator) 1 else 0)\n\n                            val paramIdx = min(argIdx, inst.opcode.params.lastIndex)\n\n                            return Ir.Inst(inst, paramIdx)\n                        }\n                    }\n                }\n            }\n        }\n\n        return null\n    }\n\n    private fun getRegisterReferences(register: Int): List<AsmRange> {\n        val results = mutableListOf<AsmRange>()\n\n        for (segment in bytecodeIr.segments) {\n            if (segment is InstructionSegment) {\n                for (inst in segment.instructions) {\n                    visitArgs(\n                        inst,\n                        processParam = { VisitAction.Go },\n                        processImmediateArg = { param, arg, argSrcLoc ->\n                            if (param.type is RegRefType &&\n                                arg is IntArg &&\n                                arg.value == register\n                            ) {\n                                results.add(argSrcLoc.precise.toAsmRange())\n                            }\n\n                            VisitAction.Go\n                        },\n                        processStackArgSrcLoc = { param, _ ->\n                            if (param.type is RegRefType) VisitAction.Go\n                            else VisitAction.Continue\n                        },\n                        processStackArg = { _, _, pushInst, argSrcLoc ->\n                            if (pushInst != null &&\n                                pushInst.opcode.code != OP_ARG_PUSHR.code\n                            ) {\n                                val pushArg = pushInst.args.firstOrNull()\n\n                                if (pushArg is IntArg && pushArg.value == register) {\n                                    results.add(argSrcLoc.precise.toAsmRange())\n                                }\n                            }\n\n                            VisitAction.Go\n                        }\n                    )\n                }\n            }\n        }\n\n        return results\n    }\n\n    /**\n     * Returns all definitions and all arguments that references the given [label].\n     */\n    private fun getLabelDefinitionsAndReferences(\n        label: Int,\n        definitions: Boolean = true,\n        references: Boolean = true,\n    ): List<AsmRange> {\n        val results = mutableListOf<AsmRange>()\n\n        for (segment in bytecodeIr.segments) {\n            // Add label definitions to the results.\n            if (definitions) {\n                val labelIdx = segment.labels.indexOf(label)\n\n                if (labelIdx != -1) {\n                    segment.srcLoc.labels.getOrNull(labelIdx)?.let { srcLoc ->\n                        results.add(\n                            AsmRange(\n                                startLineNo = srcLoc.lineNo,\n                                startCol = srcLoc.col,\n                                endLineNo = srcLoc.lineNo,\n                                // Exclude the trailing \":\" character.\n                                endCol = srcLoc.col + srcLoc.len - 1,\n                            )\n                        )\n                    }\n                }\n            }\n\n            // Find all instruction arguments that reference the label.\n            if (references) {\n                if (segment is InstructionSegment) {\n                    for (inst in segment.instructions) {\n                        visitLabelArguments(\n                            inst,\n                            accept = { true },\n                            processImmediateArg = { labelArg, argSrcLoc ->\n                                if (labelArg == label) {\n                                    results.add(argSrcLoc.precise.toAsmRange())\n                                }\n\n                                VisitAction.Go\n                            },\n                            processStackArg = { labelArg, pushInst, argSrcLoc ->\n                                // Filter out arg_pushr labels, because register values could be\n                                // used for anything.\n                                if (pushInst != null &&\n                                    pushInst.opcode.code != OP_ARG_PUSHR.code &&\n                                    labelArg.size == 1L &&\n                                    label in labelArg\n                                ) {\n                                    results.add(argSrcLoc.precise.toAsmRange())\n                                }\n\n                                VisitAction.Go\n                            },\n                        )\n                    }\n                }\n            }\n        }\n\n        return results\n    }\n\n    /**\n     * Visits all label arguments of [instruction] with their value.\n     */\n    private fun visitLabelArguments(\n        instruction: Instruction,\n        accept: (ArgSrcLoc) -> Boolean,\n        processImmediateArg: (label: Int, ArgSrcLoc) -> VisitAction,\n        processStackArg: (label: ValueSet, Instruction?, ArgSrcLoc) -> VisitAction,\n    ) {\n        visitArgs(\n            instruction,\n            processParam = { if (it.type is LabelType) VisitAction.Go else VisitAction.Continue },\n            processImmediateArg = { _, arg, srcLoc ->\n                if (accept(srcLoc) && arg is IntArg) {\n                    processImmediateArg(arg.value, srcLoc)\n                } else VisitAction.Continue\n            },\n            processStackArgSrcLoc = { _, srcLoc ->\n                if (accept(srcLoc)) VisitAction.Go\n                else VisitAction.Continue\n            },\n            processStackArg = { _, value, pushInst, srcLoc ->\n                processStackArg(value, pushInst, srcLoc)\n            }\n        )\n    }\n\n    private enum class VisitAction {\n        Go, Break, Continue, Return\n    }\n\n    /**\n     * Visits all arguments of [instruction], including stack arguments.\n     */\n    private fun visitArgs(\n        instruction: Instruction,\n        processParam: (Param) -> VisitAction,\n        processImmediateArg: (Param, Arg, ArgSrcLoc) -> VisitAction,\n        processStackArgSrcLoc: (Param, ArgSrcLoc) -> VisitAction,\n        processStackArg: (Param, ValueSet, Instruction?, ArgSrcLoc) -> VisitAction,\n    ) {\n        for ((paramIdx, param) in instruction.opcode.params.withIndex()) {\n            when (processParam(param)) {\n                VisitAction.Go -> Unit // Keep going.\n                VisitAction.Break -> break // Same as Stop.\n                VisitAction.Continue -> continue\n                VisitAction.Return -> return\n            }\n\n            if (instruction.opcode.stack !== StackInteraction.Pop) {\n                // Immediate arguments.\n                val args = instruction.getArgs(paramIdx)\n                val argSrcLocs = instruction.getArgSrcLocs(paramIdx)\n\n                for (i in 0 until min(args.size, argSrcLocs.size)) {\n                    val arg = args[i]\n                    val srcLoc = argSrcLocs[i]\n\n                    when (processImmediateArg(param, arg, srcLoc)) {\n                        VisitAction.Go -> Unit // Keep going.\n                        VisitAction.Break -> break\n                        VisitAction.Continue -> continue // Same as Down.\n                        VisitAction.Return -> return\n                    }\n                }\n            } else {\n                // Stack arguments.\n                val argSrcLocs = instruction.getArgSrcLocs(paramIdx)\n\n                // Never varargs.\n                for (srcLoc in argSrcLocs) {\n                    when (processStackArgSrcLoc(param, srcLoc)) {\n                        VisitAction.Go -> Unit // Keep going.\n                        VisitAction.Break -> break\n                        VisitAction.Continue -> continue\n                        VisitAction.Return -> return\n                    }\n\n                    val (labelValues, pushInstruction) = getStackValue(\n                        cfg,\n                        instruction,\n                        instruction.opcode.params.lastIndex - paramIdx,\n                    )\n\n                    when (processStackArg(param, labelValues, pushInstruction, srcLoc)) {\n                        VisitAction.Go -> Unit // Keep going.\n                        VisitAction.Break -> break\n                        VisitAction.Continue -> continue // Same as Down.\n                        VisitAction.Return -> return\n                    }\n                }\n            }\n        }\n    }\n\n    private fun positionInside(lineNo: Int, col: Int, srcLoc: SrcLoc?): Boolean =\n        if (srcLoc == null) {\n            false\n        } else {\n            lineNo == srcLoc.lineNo && col >= srcLoc.col && col < srcLoc.col + srcLoc.len\n        }\n\n    @Suppress(\"RedundantNullableReturnType\") // Can return undefined.\n    private fun getLine(lineNo: Int): String? = asm[lineNo - 1]\n\n    private fun SrcLoc.toAsmRange(): AsmRange =\n        AsmRange(\n            startLineNo = lineNo,\n            startCol = col,\n            endLineNo = lineNo,\n            endCol = col + len,\n        )\n\n    private sealed class Ir {\n        class Label(val label: Int) : Ir()\n        class Inst(val inst: Instruction, val paramIdx: Int) : Ir()\n    }\n\n    companion object {\n        private val KEYWORD_REGEX = Regex(\"\"\"^\\s*\\.[a-z]+${'$'}\"\"\")\n        private val KEYWORD_SUGGESTIONS: List<CompletionItem> =\n            listOf(\n                CompletionItem(\n                    label = \".code\",\n                    type = CompletionItemType.Keyword,\n                    detail = null,\n                    documentation = \"Start of a code segment\",\n                    insertText = \"code\",\n                ),\n                CompletionItem(\n                    label = \".data\",\n                    type = CompletionItemType.Keyword,\n                    detail = null,\n                    documentation = \"Start of a data segment\",\n                    insertText = \"data\",\n                ),\n                CompletionItem(\n                    label = \".string\",\n                    type = CompletionItemType.Keyword,\n                    detail = null,\n                    documentation = \"Start of a string data segment\",\n                    insertText = \"string\",\n                ),\n            )\n\n        private val INSTRUCTION_REGEX = Regex(\"\"\"^\\s*([a-z][a-z0-9_=<>!]*)?${'$'}\"\"\")\n        private val INSTRUCTION_SUGGESTIONS: List<CompletionItem> =\n            (OPCODES.asSequence() + OPCODES_F8.asSequence() + OPCODES_F9.asSequence())\n                .filterNotNull()\n                .map { opcode ->\n                    val sig = getSignature(opcode)\n                    CompletionItem(\n                        label = opcode.mnemonic,\n                        type = CompletionItemType.Opcode,\n                        detail = sig.label,\n                        documentation = sig.documentation,\n                        insertText = \"${opcode.mnemonic} \",\n                    )\n                }\n                .sortedBy { it.label }\n                .toList()\n\n        private fun getSignature(opcode: Opcode): Signature {\n            val signature = StringBuilder(opcode.mnemonic).append(\" \")\n            val params = mutableListOf<Parameter>()\n            var first = true\n\n            for (param in opcode.params) {\n                if (first) {\n                    first = false\n                } else {\n                    signature.append(\", \")\n                }\n\n                val labelStart = signature.length\n\n                signature.appendParam(param)\n\n                params.add(\n                    Parameter(\n                        labelStart,\n                        labelEnd = signature.length,\n                        documentation = param.doc,\n                    )\n                )\n            }\n\n            return Signature(\n                label = signature.toString(),\n                documentation = opcode.doc,\n                parameters = params,\n            )\n        }\n\n        private fun StringBuilder.appendParam(param: Param) {\n            if (param.read || param.write) {\n                if (param.read) append(\"in\")\n                if (param.write) append(\"out\")\n                append(\" \")\n            }\n\n            when (val type = param.type) {\n                AnyType.Instance -> append(\"Any\")\n                ByteType -> append(\"Byte\")\n                ShortType -> append(\"Short\")\n                IntType -> append(\"Int\")\n                FloatType -> append(\"Float\")\n                LabelType.Instance -> append(\"Label\")\n                ILabelType -> append(\"ILabel\")\n                DLabelType -> append(\"DLabel\")\n                SLabelType -> append(\"SLabel\")\n                ILabelVarType -> append(\"...ILabel\")\n                StringType -> append(\"String\")\n                is RegType -> {\n                    append(\"Reg\")\n\n                    type.registers?.let { registers ->\n                        append(\"<\")\n\n                        var first = true\n\n                        for (register in registers) {\n                            if (first) {\n                                first = false\n                            } else {\n                                append(\", \")\n                            }\n\n                            appendParam(register)\n                        }\n\n                        append(\">\")\n                    }\n                }\n                RegVarType -> append(\"...Reg\")\n                PointerType -> append(\"Pointer\")\n            }\n\n            param.name?.let {\n                append(\" \")\n                append(param.name)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return TimeSource.Monotonic.measureTime(block)\n}\n\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun TimeSource.measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    block()\n    return mark.elapsedNow()\n}\n\n\n/**\n * Data class representing a result of executing an action, along with the duration of elapsed time interval.\n *\n * @property value the result of the action.\n * @property duration the time elapsed to execute the action.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic data class TimedValue<T>(val value: T, val duration: Duration)\n\n/**\n * Executes the given function [block] and returns an instance of [TimedValue] class, containing both\n * the result of the function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return TimeSource.Monotonic.measureTimedValue(block)\n}\n\n/**\n * Executes the given [block] and returns an instance of [TimedValue] class, containing both\n * the result of function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> TimeSource.measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    val result = block()\n    return TimedValue(result, mark.elapsedNow())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage world.phantasmal.core\n\nexternal interface JsArray<T> {\n    val length: Int\n\n    fun push(vararg elements: T): Int\n\n    fun slice(start: Int = definedExternally): JsArray<T>\n    fun slice(start: Int, end: Int = definedExternally): JsArray<T>\n\n    fun some(callback: (element: T, index: Int) -> Boolean): Boolean\n\n    fun splice(start: Int, deleteCount: Int = definedExternally): JsArray<T>\n    fun splice(start: Int, deleteCount: Int, vararg items: T): JsArray<T>\n}\n\ninline operator fun <T> JsArray<T>.get(index: Int): T = asDynamic()[index].unsafeCast<T>()\n\ninline operator fun <T> JsArray<T>.set(index: Int, value: T) {\n    asDynamic()[index] = value\n}\n\ninline fun <T> jsArrayOf(vararg elements: T): JsArray<T> =\n    elements.unsafeCast<JsArray<T>>()\n\ninline fun <T> JsArray<T>.asArray(): Array<T> =\n    unsafeCast<Array<T>>()\n\ninline fun <T> Array<T>.asJsArray(): JsArray<T> =\n    unsafeCast<JsArray<T>>()\n\ninline fun <T> List<T>.toJsArray(): JsArray<T> =\n    toTypedArray().asJsArray()\n\n@Suppress(\"unused\")\nexternal interface JsPair<out A, out B>\n\ninline val <T> JsPair<T, *>.first: T get() = asDynamic()[0].unsafeCast<T>()\ninline val <T> JsPair<*, T>.second: T get() = asDynamic()[1].unsafeCast<T>()\n\ninline operator fun <T> JsPair<T, *>.component1(): T = first\ninline operator fun <T> JsPair<*, T>.component2(): T = second\n\n@Suppress(\"UNUSED_PARAMETER\")\ninline fun objectEntries(jsObject: dynamic): Array<JsPair<String, dynamic>> =\n    js(\"Object.entries(jsObject)\").unsafeCast<Array<JsPair<String, dynamic>>>()\n\nexternal interface JsSet<T> {\n    val size: Int\n\n    fun add(value: T): JsSet<T>\n    fun clear()\n    fun delete(value: T): Boolean\n    fun has(value: T): Boolean\n    fun forEach(callback: (value: T) -> Unit)\n}\n\ninline fun <T> emptyJsSet(): JsSet<T> =\n    js(\"new Set()\").unsafeCast<JsSet<T>>()\n\n@Suppress(\"UNUSED_PARAMETER\")\ninline fun <T> jsSetOf(vararg values: T): JsSet<T> =\n    js(\"new Set(values)\").unsafeCast<JsSet<T>>()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package world.phantasmal.web.assemblyWorker\n\nimport mu.KotlinLogging\nimport world.phantasmal.web.shared.Throttle\nimport world.phantasmal.web.shared.messages.*\nimport kotlin.time.measureTime\n\nclass AsmServer(\n    private val asmAnalyser: AsmAnalyser,\n    private val sendMessage: (ServerMessage) -> Unit,\n) {\n    private val messageQueue: MutableList<ClientMessage> = mutableListOf()\n    private val messageProcessingThrottle = Throttle(wait = 100)\n\n    fun receiveMessage(message: ClientMessage) {\n        messageQueue.add(message)\n        messageProcessingThrottle(::processMessages)\n    }\n\n    private fun processMessages() {\n        try {\n            // Split messages into ASM changes and other messages. Remove useless/duplicate\n            // notifications.\n            val asmChanges = mutableListOf<ClientNotification>()\n            val otherMessages = mutableListOf<ClientMessage>()\n\n            for (message in messageQueue) {\n                when (message) {\n                    is ClientNotification.SetAsm -> {\n                        // All previous ASM change messages can be discarded when the entire ASM has\n                        // changed.\n                        asmChanges.clear()\n                        asmChanges.add(message)\n                    }\n\n                    is ClientNotification.UpdateAsm ->\n                        asmChanges.add(message)\n\n                    else ->\n                        otherMessages.add(message)\n                }\n            }\n\n            messageQueue.clear()\n\n            // Process ASM changes first.\n            processAsmChanges(asmChanges)\n            otherMessages.forEach(::processMessage)\n        } catch (e: Throwable) {\n            logger.error(e) { \"Exception while processing messages.\" }\n            messageQueue.clear()\n        }\n    }\n\n    private fun processAsmChanges(messages: List<ClientNotification>) {\n        if (messages.isNotEmpty()) {\n            val time = measureTime {\n                val responses = try {\n                    for (message in messages) {\n                        when (message) {\n                            is ClientNotification.SetAsm ->\n                                asmAnalyser.setAsm(message.asm, message.inlineStackArgs)\n\n                            is ClientNotification.UpdateAsm ->\n                                asmAnalyser.updateAsm(message.changes)\n\n                            else ->\n                                // Should be processed by processMessage.\n                                logger.error { \"Unexpected ${message::class.simpleName}.\" }\n                        }\n                    }\n\n                    asmAnalyser.processAsm()\n                } catch (e: Throwable) {\n                    logger.error(e) { \"Exception while processing ASM changes.\" }\n                    emptyList<Response<*>>()\n                }\n\n                responses.forEach(sendMessage)\n            }\n\n            logger.trace {\n                \"Processed ${messages.size} assembly changes in ${time.inMilliseconds}ms.\"\n            }\n        }\n    }\n\n    private fun processMessage(message: ClientMessage) {\n        val time = measureTime {\n            try {\n                when (message) {\n                    is ClientNotification.SetAsm,\n                    is ClientNotification.UpdateAsm,\n                    ->\n                        // Should have been processed by processAsmChanges.\n                        logger.error { \"Unexpected ${message::class.simpleName}.\" }\n\n                    is Request -> processRequest(message)\n                }\n            } catch (e: Throwable) {\n                logger.error(e) { \"Exception while processing ${message::class.simpleName}.\" }\n            }\n        }\n\n        logger.trace { \"Processed ${message::class.simpleName} in ${time.inMilliseconds}ms.\" }\n    }\n\n    private fun processRequest(message: Request) {\n        val response = when (message) {\n            is Request.GetCompletions ->\n                asmAnalyser.getCompletions(message.id, message.lineNo, message.col)\n\n            is Request.GetSignatureHelp ->\n                asmAnalyser.getSignatureHelp(message.id, message.lineNo, message.col)\n\n            is Request.GetHover ->\n                asmAnalyser.getHover(message.id, message.lineNo, message.col)\n\n            is Request.GetDefinition ->\n                asmAnalyser.getDefinition(message.id, message.lineNo, message.col)\n\n            is Request.GetLabels ->\n                asmAnalyser.getLabels(message.id)\n\n            is Request.GetHighlights ->\n                asmAnalyser.getHighlights(message.id, message.lineNo, message.col)\n        }\n\n        sendMessage(response)\n    }\n\n    companion object {\n        private val logger = KotlinLogging.logger {}\n    }\n}\n","package world.phantasmal.web.assemblyWorker\n\nimport kotlinx.serialization.decodeFromString\nimport kotlinx.serialization.encodeToString\nimport mu.KotlinLoggingConfiguration\nimport mu.KotlinLoggingLevel\nimport world.phantasmal.web.shared.JSON_FORMAT\nimport world.phantasmal.web.shared.externals.self\nimport world.phantasmal.web.shared.logging.LogAppender\nimport world.phantasmal.web.shared.logging.LogFormatter\n\nfun main() {\n    KotlinLoggingConfiguration.FORMATTER = LogFormatter()\n    KotlinLoggingConfiguration.APPENDER = LogAppender()\n\n    if (self.location.hostname == \"localhost\") {\n        KotlinLoggingConfiguration.LOG_LEVEL = KotlinLoggingLevel.TRACE\n    }\n\n    val asmServer = AsmServer(\n        AsmAnalyser(),\n        sendMessage = { message ->\n            self.postMessage(JSON_FORMAT.encodeToString(message))\n        }\n    )\n\n    self.onmessage = { e ->\n        val json = e.data as String\n        asmServer.receiveMessage(JSON_FORMAT.decodeFromString(json))\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n",null,null,null,null,null,null,null,null,null,null,"package world.phantasmal.web.shared\n\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonBuilder\n\nval JSON_FORMAT = Json {\n    defaultConfig()\n}\n\nval JSON_FORMAT_PRETTY = Json {\n    defaultConfig()\n    prettyPrint = true\n}\n\nprivate fun JsonBuilder.defaultConfig() {\n    ignoreUnknownKeys = true\n    classDiscriminator = \"#type\"\n}\n","package world.phantasmal.web.shared.messages\n\nimport kotlinx.serialization.Serializable\nimport world.phantasmal.core.Severity\n\n/*\n * The protocol between the AsmAnalyser and the assembly web worker is loosely based on the language\n * server protocol. With the idea that at some point we might implement a full LSP server.\n *\n * There are 3 kinds of messages:\n * - Request: sent by the client expecting a response.\n * - Response: sent by server in response to a request.\n * - Notifications: sent by either the client or server. No response is required.\n */\n\n@Serializable\nsealed class ClientMessage\n\n@Serializable\nsealed class ClientNotification : ClientMessage() {\n    @Serializable\n    class SetAsm(\n        val asm: List<String>,\n        val inlineStackArgs: Boolean,\n    ) : ClientNotification()\n\n    @Serializable\n    class UpdateAsm(\n        val changes: List<AsmChange>,\n    ) : ClientNotification()\n}\n\n@Serializable\nsealed class Request : ClientMessage() {\n    /**\n     * Will be echoed in the response so the client can match responses to requests.\n     */\n    abstract val id: Int\n\n    @Serializable\n    class GetCompletions(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetSignatureHelp(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetHover(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetDefinition(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetLabels(override val id: Int) : Request()\n\n    @Serializable\n    class GetHighlights(override val id: Int, val lineNo: Int, val col: Int) : Request()\n}\n\n@Serializable\nsealed class ServerMessage\n\n@Serializable\nsealed class ServerNotification : ServerMessage() {\n    @Serializable\n    class MapDesignations(\n        val mapDesignations: Map<Int, Int>,\n    ) : ServerNotification()\n\n    @Serializable\n    class Problems(\n        val problems: List<AssemblyProblem>,\n    ) : ServerNotification()\n}\n\n@Serializable\nsealed class Response<T> : ServerMessage() {\n    /**\n     * ID of the related request.\n     */\n    abstract val id: Int\n\n    abstract val result: T\n\n    @Serializable\n    class GetCompletions(\n        override val id: Int,\n        override val result: List<CompletionItem>,\n    ) : Response<List<CompletionItem>>()\n\n    @Serializable\n    class GetSignatureHelp(\n        override val id: Int,\n        override val result: SignatureHelp?,\n    ) : Response<SignatureHelp?>()\n\n    @Serializable\n    class GetHover(\n        override val id: Int,\n        override val result: Hover?,\n    ) : Response<Hover?>()\n\n    @Serializable\n    class GetDefinition(\n        override val id: Int,\n        override val result: List<AsmRange>,\n    ) : Response<List<AsmRange>>()\n\n    @Serializable\n    class GetLabels(\n        override val id: Int,\n        override val result: List<Label>,\n    ) : Response<List<Label>>()\n\n    @Serializable\n    class GetHighlights(\n        override val id: Int,\n        override val result: List<AsmRange>,\n    ) : Response<List<AsmRange>>()\n}\n\n@Serializable\ndata class AsmRange(\n    /**\n     * Starting line of the range, inclusive.\n     */\n    val startLineNo: Int,\n    /**\n     * Starting column of the range, inclusive.\n     */\n    val startCol: Int,\n    /**\n     * Ending line of the range, exclusive.\n     */\n    val endLineNo: Int,\n    /**\n     * Ending column of the range, exclusive.\n     */\n    val endCol: Int,\n)\n\nenum class CompletionItemType {\n    Keyword, Opcode\n}\n\n@Serializable\nclass CompletionItem(\n    val label: String,\n    val type: CompletionItemType,\n    val detail: String?,\n    val documentation: String?,\n    val insertText: String,\n)\n\n@Serializable\nclass SignatureHelp(val signature: Signature, val activeParameter: Int)\n\n@Serializable\nclass Signature(val label: String, val documentation: String?, val parameters: List<Parameter>)\n\n@Serializable\nclass Parameter(\n    /**\n     * Start index of the parameter label within [Signature.label].\n     */\n    val labelStart: Int,\n    /**\n     * End index (exclusive) of the parameter label within [Signature.label].\n     */\n    val labelEnd: Int,\n    val documentation: String?,\n)\n\n@Serializable\nclass Hover(\n    /**\n     * List of markdown strings.\n     */\n    val contents: List<String>,\n)\n\n@Serializable\nclass AsmChange(\n    val range: AsmRange,\n    val newAsm: String,\n)\n\n@Serializable\nclass AssemblyProblem(\n    val severity: Severity,\n    val message: String,\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n)\n\n@Serializable\nclass Label(\n    val name: Int,\n    val range: AsmRange?,\n)\n","package world.phantasmal.web.shared\n\nimport world.phantasmal.web.shared.externals.self\n\n/**\n * Helper for limiting the amount of times a function is called within a given window.\n *\n * @param wait The number of milliseconds to throttle invocations to.\n * @param leading Invoke on the leading edge of the timeout window.\n * @param trailing Invoke on the trailing edge of the timeout window.\n */\nclass Throttle(\n    private val wait: Int,\n    private val leading: Boolean = true,\n    private val trailing: Boolean = true,\n) {\n    private var timeout: Int? = null\n    private var invokeOnTimeout = false\n    private var function: () -> Unit = {}\n\n    operator fun invoke(f: () -> Unit) {\n        function = f\n\n        if (timeout == null) {\n            if (leading) {\n                function()\n            } else if (trailing) {\n                invokeOnTimeout = true\n            }\n\n            timeout = self.setTimeout({\n                if (invokeOnTimeout) {\n                    function()\n                }\n\n                timeout = null\n                invokeOnTimeout = false\n            }, wait)\n        } else {\n            invokeOnTimeout = trailing\n        }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nimport mu.Appender\n\nclass LogAppender : Appender {\n    override fun trace(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.log(message.message, message.throwable)\n        } else {\n            console.log(message)\n        }\n    }\n\n    override fun debug(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.log(message.message, message.throwable)\n        } else {\n            console.log(message)\n        }\n    }\n\n    override fun info(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.info(message.message, message.throwable)\n        } else {\n            console.info(message)\n        }\n    }\n\n    override fun warn(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.warn(message.message, message.throwable)\n        } else {\n            console.warn(message)\n        }\n    }\n\n    override fun error(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.error(message.message, message.throwable)\n        } else {\n            console.error(message)\n        }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nimport mu.Formatter\nimport mu.KotlinLoggingLevel\nimport mu.Marker\nimport kotlin.js.Date\n\nclass LogFormatter : Formatter {\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        msg: () -> Any?,\n    ): String =\n        \"${time()} ${level.str()} $loggerName - ${msg.toStringSafe()}\"\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        t: Throwable?,\n        msg: () -> Any?,\n    ): MessageWithThrowable =\n        MessageWithThrowable(formatMessage(level, loggerName, msg), t)\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        marker: Marker?,\n        msg: () -> Any?,\n    ): String =\n        \"${time()} ${level.str()} $loggerName [${marker?.getName()}] - ${msg.toStringSafe()}\"\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        marker: Marker?,\n        t: Throwable?,\n        msg: () -> Any?,\n    ): MessageWithThrowable =\n        MessageWithThrowable(formatMessage(level, loggerName, marker, msg), t)\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun (() -> Any?).toStringSafe(): String {\n        return try {\n            invoke().toString()\n        } catch (e: Exception) {\n            \"Log message invocation failed: $e\"\n        }\n    }\n\n    private fun KotlinLoggingLevel.str(): String =\n        name.padEnd(MIN_LEVEL_LEN)\n\n    private fun time(): String {\n        val date = Date()\n        val h = date.getHours().toString().padStart(2, '0')\n        val m = date.getMinutes().toString().padStart(2, '0')\n        val s = date.getSeconds().toString().padStart(2, '0')\n        val ms = date.getMilliseconds().toString().padStart(3, '0')\n        return \"$h:$m:$s.$ms\"\n    }\n\n    companion object {\n        private val MIN_LEVEL_LEN: Int =\n            KotlinLoggingLevel.values().map { it.name.length }.maxOrNull()!!\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nclass MessageWithThrowable(\n    val message: Any?,\n    val throwable: Throwable?,\n)\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sourceRoot":""}