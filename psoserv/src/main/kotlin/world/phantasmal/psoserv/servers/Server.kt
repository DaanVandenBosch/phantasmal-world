package world.phantasmal.psoserv.servers

import mu.KLogger
import world.phantasmal.psolib.Endianness
import world.phantasmal.psolib.buffer.Buffer
import world.phantasmal.psoserv.encryption.Cipher
import world.phantasmal.psoserv.messages.Header
import world.phantasmal.psoserv.messages.Message
import world.phantasmal.psoserv.messages.messageString
import world.phantasmal.psoserv.roundToBlockSize
import java.net.*

private const val MAX_MSG_SIZE: Int = 32768

abstract class Server<MessageType : Message, StateType : ServerState<MessageType, StateType>>(
    private val logger: KLogger,
    private val address: InetAddress,
    private val port: Int,
) {
    private val serverSocket = ServerSocket(port, 50, address)
    private var connectionCounter = 0

    @Volatile
    private var running = true

    fun start() {
        logger.info { "Starting." }

        // Accept client connections on a dedicated thread.
        val thread = Thread(::acceptConnections)
        thread.name = this::class.simpleName
        thread.start()
    }

    fun stop() {
        logger.info { "Stopping." }

        // Signal to the connection thread that it should stop.
        running = false

        // Closing the server socket will generate a SocketException on the connection thread which
        // will then shut down.
        serverSocket.close()
    }

    private fun acceptConnections() {
        if (running) {
            logger.info { "Accepting connections." }

            while (running) {
                try {
                    val socket = serverSocket.accept()
                    logger.info { "New client connection from ${socket.inetAddress}." }
                    // Handle each client connection in its own thread.
                    // TODO: Shut down client threads when server is stopped.
                    val thread = Thread { clientConnected(socket) }
                    thread.name = "${this::class.simpleName} client ${connectionCounter++}"
                    thread.start()
                } catch (e: SocketTimeoutException) {
                    // Retry after timeout.
                    continue
                } catch (e: InterruptedException) {
                    logger.error(e) {
                        "Interrupted while trying to accept client connections on $address:$port, stopping."
                    }
                    break
                } catch (e: SocketException) {
                    // Don't log if we're not running anymore because that means this exception was
                    // probably generated by a socket.close() call.
                    if (running) {
                        logger.error(e) {
                            "Exception while trying to accept client connections on $address:$port, stopping."
                        }
                    }
                    break
                } catch (e: Throwable) {
                    logger.error(e) {
                        "Exception while trying to accept client connections on $address:$port."
                    }
                }
            }
        }

        logger.info { "Stopped." }
    }


    private fun clientConnected(socket: Socket) {
        try {
            val readBuffer = Buffer.withSize(MAX_MSG_SIZE, Endianness.Little)

            var read = 0
            var maxRead = MAX_MSG_SIZE
            var headerDecrypted = false

            val serverCipher = createCipher()
            val clientCipher = createCipher()

            val sender = ClientSender(logger, socket, serverCipher, clientCipher)

            var state: StateType = initializeState(sender)

            while (true) {
                val readNow = socket.getInputStream().read(readBuffer.byteArray, read, maxRead)

                if (readNow == -1) {
                    // Close the connection.
                    break
                }

                read += readNow
                maxRead = MAX_MSG_SIZE - read

                if (read >= clientCipher.blockSize) {
                    if (!headerDecrypted) {
                        clientCipher.decrypt(readBuffer, offset = 0, blocks = 1)
                        headerDecrypted = true
                    }

                    // Header size is always equal to cipher block size, so we can read it at this
                    // point.
                    val (code, size) = readHeader(readBuffer)

                    when {
                        size > MAX_MSG_SIZE -> {
                            logger.error {
                                val message = messageString(code, size)
                                "Receiving $message, too large: ${size}B."
                            }
                            break
                        }

                        read >= size -> {
                            val messageBuffer = readBuffer.copy(size = size)

                            read -= size
                            maxRead = MAX_MSG_SIZE - read
                            headerDecrypted = false

                            // Shift any remaining bytes to the front of the buffer.
                            if (read > 0) {
                                readBuffer.copyInto(readBuffer, offset = size, size = read)
                            }

                            clientCipher.decrypt(
                                messageBuffer,
                                offset = clientCipher.blockSize,
                                blocks = size / clientCipher.blockSize - 1,
                            )

                            val message = readMessage(messageBuffer)
                            logger.trace { "Received $message." }

                            state = state.process(message)

                            if (state is FinalServerState) {
                                // Give the client some time to disconnect.
                                Thread.sleep(100)

                                // Close the connection.
                                break
                            }
                        }

                        else -> {
                            maxRead = size - read
                        }
                    }
                }
            }
        } catch (e: Throwable) {
            logger.error(e) {
                "Error while processing client connection from ${socket.inetAddress}."
            }
        } finally {
            logger.info { "Closing client connection from ${socket.inetAddress}." }
            socket.close()
        }
    }

    protected abstract fun createCipher(): Cipher

    protected abstract fun initializeState(sender: ClientSender): StateType

    protected abstract fun readHeader(buffer: Buffer): Header

    protected abstract fun readMessage(buffer: Buffer): MessageType

    class ClientSender(
        private val logger: KLogger,
        private val socket: Socket,
        val serverCipher: Cipher,
        val clientCipher: Cipher,
    ) {
        fun send(message: Message, encrypt: Boolean = true) {
            logger.trace {
                "Sending $message${if (encrypt) "" else " (unencrypted)"}."
            }

            if (message.buffer.size != message.size) {
                logger.warn {
                    "Message size of $message is ${message.size}B, but wrote ${message.buffer.size} bytes."
                }
            }

            val buffer: Buffer

            if (encrypt) {
                // Pad buffer before encrypting.
                val initialSize = message.buffer.size
                buffer = message.buffer.copy(
                    size = roundToBlockSize(initialSize, serverCipher.blockSize)
                )
                serverCipher.encrypt(buffer)
            } else {
                buffer = message.buffer
            }

            socket.getOutputStream().write(buffer.byteArray, 0, buffer.size)
        }
    }
}
