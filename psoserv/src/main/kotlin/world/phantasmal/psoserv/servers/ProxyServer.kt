package world.phantasmal.psoserv.servers

import mu.KotlinLogging
import world.phantasmal.core.disposable.TrackedDisposable
import world.phantasmal.psolib.buffer.Buffer
import world.phantasmal.psoserv.encryption.Cipher
import world.phantasmal.psoserv.messages.BbMessage
import world.phantasmal.psoserv.messages.Header
import world.phantasmal.psoserv.messages.Message
import world.phantasmal.psoserv.messages.PcMessage
import java.net.*

class ProxyServer(
    private val proxyAddress: InetAddress,
    private val proxyPort: Int,
    private val serverAddress: InetAddress,
    private val serverPort: Int,
    private val readMessage: (Buffer) -> Message,
    private val createCipher: (key: ByteArray) -> Cipher,
    private val headerSize: Int,
    private val readHeader: (Buffer) -> Header,
    private val redirectMap: Map<Pair<Inet4Address, Int>, Pair<Inet4Address, Int>> = emptyMap(),
) : TrackedDisposable() {
    private val proxySocket = ServerSocket(proxyPort, 50, proxyAddress)

    @Volatile
    private var running = true
    private var connected = false

    init {
        LOGGER.info { "Initializing." }

        // Accept client connections on a dedicated thread.
        val thread = Thread(::acceptConnections)
        thread.name = this::class.simpleName
        thread.start()
    }

    override fun dispose() {
        LOGGER.info { "Stopping." }

        // Signal to the connection thread that it should stop.
        running = false

        // Closing the server socket will generate a SocketException on the connection thread which
        // will then shut down.
        proxySocket.close()

        super.dispose()
    }

    private fun acceptConnections() {
        if (running) {
            LOGGER.info { "Accepting connections." }

            while (running) {
                try {
                    val clientSocket = proxySocket.accept()
                    LOGGER.info {
                        "New client connection from ${clientSocket.inetAddress}:${clientSocket.port}."
                    }

                    val serverSocket = Socket(serverAddress, serverPort)
                    LOGGER.info {
                        "Connected to server ${serverSocket.inetAddress}:${serverSocket.port}."
                    }

                    connected = true

                    // Listen to server on this thread.
                    // Don't start listening to the client until encryption is initialized.
                    ServerHandler(serverSocket, clientSocket).listen()
                } catch (e: SocketTimeoutException) {
                    // Retry after timeout.
                    continue
                } catch (e: InterruptedException) {
                    LOGGER.error(e) {
                        "Interrupted while trying to accept client connections on $proxyAddress:$proxyPort, stopping."
                    }
                    break
                } catch (e: SocketException) {
                    // Don't log if we're not running anymore because that means this exception was
                    // probably generated by a socket.close() call.
                    if (running) {
                        LOGGER.error(e) {
                            "Exception while trying to accept client connections on $proxyAddress:$proxyPort, stopping."
                        }
                    }
                    break
                } catch (e: Throwable) {
                    LOGGER.error(e) {
                        "Exception while trying to accept client connections on $proxyAddress:$proxyPort."
                    }
                }
            }
        }

        LOGGER.info { "Stopped." }
    }

    private inner class ServerHandler(
        serverSocket: Socket,
        private val clientSocket: Socket,
    ) : SocketHandler<Message>(KotlinLogging.logger {}, serverSocket, headerSize) {

        private var clientHandler: ClientHandler? = null

        // The first message sent by the server is always unencrypted and initializes the
        // encryption. We don't start listening to the client until the encryption is
        // initialized.
        override var decryptCipher: Cipher? = null
        override var encryptCipher: Cipher? = null

        override fun readHeader(buffer: Buffer): Header =
            this@ProxyServer.readHeader(buffer)

        override fun readMessage(buffer: Buffer): Message =
            this@ProxyServer.readMessage(buffer)

        override fun processMessage(message: Message): ProcessResult {
            when (message) {
                is PcMessage.InitEncryption -> if (decryptCipher == null) {
                    decryptCipher = createCipher(message.serverKey)
                    encryptCipher = createCipher(message.serverKey)

                    val clientDecryptCipher = createCipher(message.clientKey)
                    val clientEncryptCipher = createCipher(message.clientKey)

                    logger.info {
                        "Encryption initialized, start listening to client."
                    }

                    // Start listening to client on another thread.
                    val clientListener = ClientHandler(
                        clientSocket,
                        this,
                        clientDecryptCipher,
                        clientEncryptCipher
                    )
                    this.clientHandler = clientListener
                    val thread = Thread(clientListener::listen)
                    thread.name = "${ProxyServer::class.simpleName} client"
                    thread.start()
                }

                is BbMessage.InitEncryption -> if (decryptCipher == null) {
                    decryptCipher = createCipher(message.serverKey)
                    encryptCipher = createCipher(message.serverKey)

                    val clientDecryptCipher = createCipher(message.clientKey)
                    val clientEncryptCipher = createCipher(message.clientKey)

                    logger.info {
                        "Encryption initialized, start listening to client."
                    }

                    // Start listening to client on another thread.
                    val clientListener = ClientHandler(
                        clientSocket,
                        this,
                        clientDecryptCipher,
                        clientEncryptCipher
                    )
                    this.clientHandler = clientListener
                    val thread = Thread(clientListener::listen)
                    thread.name = "${ProxyServer::class.simpleName} client"
                    thread.start()
                }

                is PcMessage.Redirect -> {
                    val oldAddress = InetAddress.getByAddress(message.ipAddress)

                    redirectMap[Pair(oldAddress, message.port)]?.let { (newAddress, newPort) ->
                        logger.debug {
                            "Rewriting redirect from $oldAddress:${message.port} to $newAddress:$newPort."
                        }

                        message.ipAddress = newAddress.address
                        message.port = newPort

                        return ProcessResult.Changed
                    }
                }

                is BbMessage.Redirect -> {
                    val oldAddress = InetAddress.getByAddress(message.ipAddress)

                    redirectMap[Pair(oldAddress, message.port)]?.let { (newAddress, newPort) ->
                        logger.debug {
                            "Rewriting redirect from $oldAddress:${message.port} to $newAddress:$newPort."
                        }

                        message.ipAddress = newAddress.address
                        message.port = newPort

                        return ProcessResult.Changed
                    }
                }
            }

            return ProcessResult.Ok
        }

        override fun processRawBytes(buffer: Buffer, offset: Int, size: Int) {
            clientHandler?.writeBytes(buffer, offset, size)
        }

        override fun socketClosed() {
            clientHandler?.stop()
            clientHandler = null
        }
    }

    private inner class ClientHandler(
        clientSocket: Socket,
        private val serverHandler: ServerHandler,
        override val decryptCipher: Cipher,
        override val encryptCipher: Cipher,
    ) : SocketHandler<Message>(KotlinLogging.logger {}, clientSocket, headerSize) {

        override fun readHeader(buffer: Buffer): Header =
            this@ProxyServer.readHeader(buffer)

        override fun readMessage(buffer: Buffer): Message =
            this@ProxyServer.readMessage(buffer)

        override fun processMessage(message: Message): ProcessResult = ProcessResult.Ok

        override fun processRawBytes(buffer: Buffer, offset: Int, size: Int) {
            serverHandler.writeBytes(buffer, offset, size)
        }

        override fun socketClosed() {
            serverHandler.stop()
        }
    }

    companion object {
        private val LOGGER = KotlinLogging.logger {}
    }
}
