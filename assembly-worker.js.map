{"version":3,"sources":["webpack://assembly-worker/webpack/universalModuleDefinition","webpack://assembly-worker/../src/jsMain/kotlin/mu/ConsoleOutputAppender.kt","webpack://assembly-worker/../src/jsMain/kotlin/mu/DefaultMessageFormatter.kt","webpack://assembly-worker/../src/commonMain/kotlin/mu/internal/MessageInvoker.kt","webpack://assembly-worker/../src/jsMain/kotlin/mu/KotlinLogging.kt","webpack://assembly-worker/../src/jsMain/kotlin/mu/KotlinLoggingConfiguration.kt","webpack://assembly-worker/../src/jsMain/kotlin/mu/KotlinLoggingLevel.kt","webpack://assembly-worker/../src/jsMain/kotlin/mu/internal/ErrorMessageProducer.kt","webpack://assembly-worker/../src/jsMain/kotlin/mu/internal/KLoggerJS.kt","webpack://assembly-worker/./kotlin-dce/wrapper.js","webpack://assembly-worker/./kotlin-dce/js/arrayUtils.js","webpack://assembly-worker/./kotlin-dce/js/callableReferenceUtils.js","webpack://assembly-worker/./kotlin-dce/js/conversions.js","webpack://assembly-worker/./kotlin-dce/js/core.js","webpack://assembly-worker/./kotlin-dce/js/misc.js","webpack://assembly-worker/./kotlin-dce/js/polyfills.js","webpack://assembly-worker/./kotlin-dce/js/markerFunctions.js","webpack://assembly-worker/./kotlin-dce/js/rtti.js","webpack://assembly-worker/./kotlin-dce/js/long.js","webpack://assembly-worker/./kotlin-dce/runtime/arrayUtils.kt","webpack://assembly-worker/./kotlin-dce/runtime/Enum.kt","webpack://assembly-worker/./kotlin-dce/primitiveCompanionObjects.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Arrays.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Ranges.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UByte.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UInt.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UShort.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/Ranges.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Collections.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Maps.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Sets.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/StringNumberConversions.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/time/Duration.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UnsignedUtils.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Sequences.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Collections.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_OneToManyTitlecaseMappings.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/char.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/string.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/Char.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Iterables.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Sequences.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/Preconditions.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Strings.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/Strings.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/Iterators.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/ProgressionIterators.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/CharCode.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/Progressions.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/Collections.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/Range.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/Unit.kt","webpack://assembly-worker/./kotlin-dce/builtin-sources/internal/progressionUtil.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/builtins.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/CoroutineImpl.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/Standard.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/Result.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/Continuation.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/exceptions.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/kotlin.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/numberConversions_js-v1.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_ArraysJs.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_CharCategories.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_ComparisonsJs.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_DigitChars.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_LetterChars.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_OtherLowercaseChars.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_TitlecaseMappings.kt","webpack://assembly-worker/./kotlin-dce/js/src/generated/_WhitespaceChars.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/AbstractMutableCollection.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/AbstractMutableList.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/AbstractMutableMap.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/AbstractMutableSet.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/ArrayList.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/ArraySorting.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/EqualityComparator.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/Comparator.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/HashMap.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/HashSet.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/InternalHashCodeMap.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/InternalStringMap.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/LinkedHashMap.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/LinkedHashSet.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/console.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/coroutines/SafeContinuationJs.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/exceptionUtils.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/math.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/numbers_js-v1.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/numbers.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/random/PlatformRandom.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/KClassImpl.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/collections/InternalMap.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/jsOperators.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/KTypeImpl.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/primitives.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/reflection.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/regexp.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/StringBuilderJs.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/numberConversions.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/regex.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/stringsCode.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/time/DurationUnit.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/time/MonoTimeSource.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/time/formatToDecimals.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/AbstractCollection.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/AbstractList.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/AbstractMap.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/AbstractSet.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/IndexedValue.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Iterators.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/MapWithDefault.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/MutableCollections.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/SequenceBuilder.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/ContinuationInterceptor.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/CoroutineContext.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/CoroutineContextImpl.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/coroutines/intrinsics/Intrinsics.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/random/Random.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/random/XorWowRandom.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/ranges/Ranges.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/Appendable.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/Indent.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/regex/MatchResult.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/time/DurationUnit.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/time/TimeSource.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/text/StringBuilder.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/time/TimeSources.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/time/measureTime.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/Lazy.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/Tuples.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/ULong.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/experimental/bitwiseOperations.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UIntRange.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UIterators.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/ULongRange.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UProgressionUtil.kt","webpack://assembly-worker/./kotlin-dce/unsigned/src/kotlin/UStrings.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Sets.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/reflection_js-v1.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/coroutines/cancellation/CancellationException.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/JsClass.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/KTypeHelpers.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/comparisons/Comparisons.kt","webpack://assembly-worker/./kotlin-dce/common/src/kotlin/MathH.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/text/utf8Encoding.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/DeepRecursive.kt","webpack://assembly-worker/../common/src/Delay.kt","webpack://assembly-worker/../common/src/EventLoop.common.kt","webpack://assembly-worker/../common/src/flow/SharedFlow.kt","webpack://assembly-worker/../common/src/internal/LockFreeTaskQueue.kt","webpack://assembly-worker/../js/src/JSDispatcher.kt","webpack://assembly-worker/../common/src/AbstractCoroutine.kt","webpack://assembly-worker/../common/src/CancellableContinuation.kt","webpack://assembly-worker/../common/src/CancellableContinuationImpl.kt","webpack://assembly-worker/../common/src/Builders.common.kt","webpack://assembly-worker/../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://assembly-worker/../common/src/CompletionState.kt","webpack://assembly-worker/../common/src/CoroutineDispatcher.kt","webpack://assembly-worker/../common/src/CoroutineExceptionHandler.kt","webpack://assembly-worker/../common/src/CompletableDeferred.kt","webpack://assembly-worker/../common/src/CoroutineName.kt","webpack://assembly-worker/../common/src/CoroutineScope.kt","webpack://assembly-worker/../common/src/CoroutineStart.kt","webpack://assembly-worker/../common/src/Job.kt","webpack://assembly-worker/../common/src/JobSupport.kt","webpack://assembly-worker/../js/src/internal/LinkedList.kt","webpack://assembly-worker/../common/src/MainCoroutineDispatcher.kt","webpack://assembly-worker/../common/src/NonCancellable.kt","webpack://assembly-worker/../common/src/Supervisor.kt","webpack://assembly-worker/../common/src/Timeout.kt","webpack://assembly-worker/../common/src/channels/AbstractChannel.kt","webpack://assembly-worker/../common/src/intrinsics/Cancellable.kt","webpack://assembly-worker/../common/src/sync/Semaphore.kt","webpack://assembly-worker/../common/src/flow/operators/Zip.kt","webpack://assembly-worker/../common/src/flow/terminal/Collect.kt","webpack://assembly-worker/../common/src/flow/terminal/Reduce.kt","webpack://assembly-worker/../common/src/flow/operators/Limit.kt","webpack://assembly-worker/../common/src/internal/Atomic.kt","webpack://assembly-worker/../common/src/internal/ConcurrentLinkedList.kt","webpack://assembly-worker/../common/src/internal/DispatchedContinuation.kt","webpack://assembly-worker/../common/src/internal/DispatchedTask.kt","webpack://assembly-worker/../common/src/internal/OnUndeliveredElement.kt","webpack://assembly-worker/../common/src/internal/Scopes.kt","webpack://assembly-worker/../common/src/internal/ThreadSafeHeap.kt","webpack://assembly-worker/../js/src/internal/Synchronized.kt","webpack://assembly-worker/../common/src/intrinsics/Undispatched.kt","webpack://assembly-worker/../common/src/selects/Select.kt","webpack://assembly-worker/../common/src/selects/SelectUnbiased.kt","webpack://assembly-worker/../js/src/CompletionHandler.kt","webpack://assembly-worker/../common/src/channels/Channels.common.kt","webpack://assembly-worker/../common/src/channels/ConflatedBroadcastChannel.kt","webpack://assembly-worker/../common/src/flow/Flow.kt","webpack://assembly-worker/../common/src/flow/internal/SafeCollector.common.kt","webpack://assembly-worker/../common/src/flow/internal/FlowExceptions.common.kt","webpack://assembly-worker/../common/src/flow/terminal/Count.kt","webpack://assembly-worker/../atomicfu/src/jsMain/kotlin/kotlinx/atomicfu/AtomicFU.kt","webpack://assembly-worker/../js/src/Runnable.kt","webpack://assembly-worker/../common/src/sync/Mutex.kt","webpack://assembly-worker/../js/src/CoroutineContext.kt","webpack://assembly-worker/../js/src/CoroutineExceptionHandlerImpl.kt","webpack://assembly-worker/../js/src/Debug.kt","webpack://assembly-worker/../js/src/Dispatchers.kt","webpack://assembly-worker/../js/src/EventLoop.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/jsTypeOf.kt","webpack://assembly-worker/../js/src/Exceptions.kt","webpack://assembly-worker/../js/src/Promise.kt","webpack://assembly-worker/../js/src/internal/Concurrent.kt","webpack://assembly-worker/../js/src/internal/CopyOnWriteList.kt","webpack://assembly-worker/../js/src/internal/LocalAtomics.kt","webpack://assembly-worker/../js/src/internal/ProbesSupport.kt","webpack://assembly-worker/../js/src/internal/StackTraceRecovery.kt","webpack://assembly-worker/../js/src/internal/SystemProps.kt","webpack://assembly-worker/../js/src/internal/ThreadContext.kt","webpack://assembly-worker/../js/src/internal/ThreadLocal.kt","webpack://assembly-worker/../common/src/flow/internal/FlowCoroutine.kt","webpack://assembly-worker/./kotlin-dce/js/src/kotlin/reflect/AssociatedObjects.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/builtins/BuiltinSerializers.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/descriptors/ContextAware.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptor.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/descriptors/SerialKinds.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/PluginGeneratedSerialDescriptor.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/encoding/AbstractDecoder.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/encoding/AbstractEncoder.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/AbstractPolymorphicSerializer.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/CollectionDescriptors.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/CollectionSerializers.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/Enums.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/InlineClassDescriptor.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/InlineClasses.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/NoOpEncoder.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/NullableSerializer.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/ObjectSerializer.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/util/HashCode.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/PrimitiveArraysSerializers.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/PluginHelperInterfaces.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/Primitives.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/Tagged.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/Tuples.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/modules/SerializersModule.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/PolymorphicSerializer.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/SealedSerializer.kt","webpack://assembly-worker/./kotlin-dce/src/kotlin/collections/Grouping.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/SerializationException.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/Serializers.kt","webpack://assembly-worker/../core/jsMain/src/kotlinx/serialization/internal/Platform.kt","webpack://assembly-worker/../core/jsMain/src/kotlinx/serialization/Serializers.kt","webpack://assembly-worker/./kotlin-dce/common/src/generated/_Maps.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/modules/SerializersModuleCollector.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/internal/JsonInternalDependencies.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonLexer.kt","webpack://assembly-worker/../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicDecoders.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/Composers.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonExceptions.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonNamesMap.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonTreeReader.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/Polymorphic.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonEncoder.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/PolymorphismValidator.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/SchemaCache.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonDecoder.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonEncoder.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/StringOps.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonDecoder.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/internal/WriteMode.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/Json.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/JsonConfiguration.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/JsonElement.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementSerializers.kt","webpack://assembly-worker/../formats/json/commonMain/src/kotlinx/serialization/json/JsonNames.kt","webpack://assembly-worker/../formats/json/jsMain/src/kotlinx/serialization/json/internal/createMapForCache.kt","webpack://assembly-worker/../formats/json/jsMain/src/kotlinx/serialization/json/internal/JsonStringBuilder.kt","webpack://assembly-worker/../formats/json/jsMain/src/kotlinx/serialization/json/JsonSchemaCache.kt","webpack://assembly-worker/../web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/AsmAnalyser.kt","webpack://assembly-worker/./kotlin/js/src/kotlin/collections.kt","webpack://assembly-worker/./kotlin/src/kotlin/collections/Collections.kt","webpack://assembly-worker/./kotlin/common/src/generated/_Collections.kt","webpack://assembly-worker/./kotlin/src/kotlin/text/Strings.kt","webpack://assembly-worker/./kotlin/js/src/kotlin/math.kt","webpack://assembly-worker/./kotlin/common/src/generated/_Sequences.kt","webpack://assembly-worker/./kotlin/src/kotlin/comparisons/Comparisons.kt","webpack://assembly-worker/./kotlin/src/kotlin/time/measureTime.kt","webpack://assembly-worker/./kotlin/js/src/kotlin/text/string.kt","webpack://assembly-worker/../core/src/jsMain/kotlin/world/phantasmal/core/Js.kt","webpack://assembly-worker/./kotlin/src/kotlin/util/Standard.kt","webpack://assembly-worker/../web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/AsmServer.kt","webpack://assembly-worker/../web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/Main.kt","webpack://assembly-worker/../core/commonMain/src/kotlinx/serialization/SerialFormat.kt","webpack://assembly-worker/../core/src/commonMain/kotlin/world/phantasmal/core/PwResult.kt","webpack://assembly-worker/../core/src/jsMain/kotlin/world/phantasmal/core/JsExtensions.kt","webpack://assembly-worker/../core/src/commonMain/kotlin/world/phantasmal/core/math/Math.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/dataFlowAnalysis/GetRegisterValue.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/dataFlowAnalysis/ValueSet.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/Endianness.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/Episode.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/AsmTokenization.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/Assembly.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/BytecodeIr.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/Opcode.kt","webpack://assembly-worker/../core/src/jsMain/kotlin/world/phantasmal/core/PrimitiveExtensions.kt","webpack://assembly-worker/../core/src/jsMain/kotlin/world/phantasmal/core/StandardExtensions.kt","webpack://assembly-worker/../core/src/jsMain/kotlin/world/phantasmal/core/Strings.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/dataFlowAnalysis/ControlFlowGraph.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/dataFlowAnalysis/GetMapDesignations.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/dataFlowAnalysis/GetStackValue.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/Areas.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/EntityProp.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/NpcType.kt","webpack://assembly-worker/../psolib/src/jsMain/kotlin/world/phantasmal/psolib/buffer/Buffer.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/buffer/Buffer.kt","webpack://assembly-worker/../psolib/build/generated-src/commonMain/kotlin/world/phantasmal/psolib/asm/Opcodes.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/asm/Disassembly.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/compression/prs/PrsDecompress.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/Afs.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/AreaRenderGeometry.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/Iff.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/ninja/Angle.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/ninja/Nj.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/ninja/Texture.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/ninja/Xj.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/Bin.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/Bytecode.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/Dat.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/NpcTypeExtensions.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/Qst.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/fileFormats/quest/Quest.kt","webpack://assembly-worker/../psolib/src/commonMain/kotlin/world/phantasmal/psolib/vm/VirtualMachine.kt","webpack://assembly-worker/../web/shared/src/commonMain/kotlin/world/phantasmal/web/shared/JsonFormat.kt","webpack://assembly-worker/../web/shared/src/commonMain/kotlin/world/phantasmal/web/shared/messages/Messages.kt","webpack://assembly-worker/../web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/Throttle.kt","webpack://assembly-worker/../web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/LogAppender.kt","webpack://assembly-worker/../web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/LogFormatter.kt","webpack://assembly-worker/../web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/MessageWithThrowable.kt","webpack://assembly-worker/webpack/bootstrap","webpack://assembly-worker/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","Kotlin","_","isBooleanArray","a","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","toString","String","fromCharCode","prototype","map","call","e","join","arrayEquals","b","length","i","n","equals","arrayHashCode","arr","result","hashCode","getCallableRef","f","callableName","name","toShort","toByte","toChar","numberToInt","Long","toInt","doubleToInt","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","obj","objType","getObjectHashCode","numberHashCode","Number","str","hash","charCodeAt","getStringHashCode","o","buf","bufFloat64","bufFloat32","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","Math","random","Object","defineProperty","throwMarkerError","Error","imul","isInheritanceFromInterface","ctor","iface","metadata","$metadata$","interfaces","superPrototype","getPrototypeOf","superConstructor","constructor","identityHashCode","low_","low","high_","high","IntCache_","fromInt","value","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","pow","size","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","floatToRawBits","floatFromBits","ensureNotNull","x","throwNPE","startsWith","searchString","position","lastIndexOf","endsWith","subjectString","undefined","lastIndex","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","y","exp","y1","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","fill","TypeError","O","len","relativeStart","k","end","relativeEnd","finalValue","normalizeOffset","offset","typedArraySlice","begin","subarray","arrays","TypedArray","slice","Function","self","array","callback","totalOrderComparator","sort","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","get","isType","object","proto","kind","OBJECT","klassMetadata","INTERFACE","isNumber","isChar","isComparable","type","Comparable","isCharSequence","CharSequence","ordinal","initValue","MIN_HIGH_SURROGATE","MAX_LOW_SURROGATE","fillArrayVal","init","element","index","NoSuchElementException","IntRange","destination","item","asCollection","emptySet","setOf","toCollection","emptySequence","checkIndexOverflow","iterator","hasNext","last","next","isEmpty","single","j","emptyList","listOf","optimizeReadOnlyList","optimizeReadOnlySet","separator","prefix","postfix","limit","truncated","transform","buffer","count","toUpperCase","uppercase","toLowerCase","titlecaseChar","to","first","step","EMPTY","minimumValue","maximumValue","range","start","endInclusive","FilteringSequence","predicate","it","TakeSequence","TransformingSequence","CharIterator","IntIterator","LongIterator","getProgressionLastElement","sortedList","NotImplementedError","nextByte","nextChar","nextShort","nextInt","nextLong","nextFloat","nextDouble","nextBoolean","CharProgressionIterator","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","c","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","context","current","v","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","cause","message","Exception","RuntimeException","src","dst","srcLen","dstLen","source","newSize","defaultValue","checkRadix","ArrayList","fromIndex","toIndex","resultLength","int","shift","base64","fromBase64","sixBit","bottom","top","middle","needle","binarySearchRange","ch","diff","toBase64","decodeVarLenBase64","decodedRangeStart","decodedRangeLength","decodedRangeCategory","code","lastTwoBits","threshold","distance","getLetterType","isOtherLowercase","uppercaseChar","toArray","copyToArrayImpl","collection","push","pair","list","copyToArray","comparator","collectionsSort","startIndex","endIndex","destinationOffset","rangeSize","set","subrange","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","initialCapacity","elements","_stableSortingIsSupported","comparison","getStableSortingIsSupported","mergeSort","median","left","leftIndex","rightIndex","right","leftValue","rightValue","target","checkIsMutable","remove","modified","_index","changed","times","hasPrevious","newValue","oldValue","entries","clear","key","from","iter","entry","modCount","splice","concat","pop","arrayCopy","value1","value2","internalMap","equality","InternalHashCodeMap","loadFactor","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","ClassCastException","NEGATIVE_INFINITY","toRawBits","bits","round","POSITIVE_INFINITY","isInfinite","hi26","INV_2_26","low27","INV_2_53","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","old","newEntry","build","println","outputStream","write","messageString","s","flush","console","cur","simpleName","jsClass","PrimitiveKClassImpl","classifier","isMarkedNullable","kClass","variance","prefixString","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","content","titlecaseCharImpl","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","isWhitespaceImpl","toLongOrNull","numberFormatError","isBlank","char","digitToIntImpl","prepend","pattern","options","RegExp","toFlags","match","IndexOutOfBoundsException","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","dstIndex","stringCsq","reset","exec","input","test","findNext","Regex","replace","replacement","lastStart","sb","foundMatch","collectionSizeOrDefault","nonGlobalOptions","requireNonNegativeLimit","matches","subSequence","sequence","literal","AbstractList","ignoreCase","JsMath","n1","n2","s1","s2","regionMatches","regex","regionMatchesImpl","thisOffset","otherOffset","sourceUnit","targetUnit","sourceCompareTarget","scale","isNode","HrTimeSource","MatchGroup","markNow","TimeMark","process","hrtime","AbstractDoubleTimeSource","startedAt","seconds","nanos","performance","now","decimals","rounded","toFixed","toPrecision","positive","positiveString","previous","nextIndex","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","ArithmeticException","values","contains","isVarargs","IndexingIterator","IndexedValue","pairs","putAll","emptyMap","filterInPlace","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","block","SequenceScope","asSequence","throwOnFailure","FlatteningSequence","GeneratorSequence","seedFunction","nextFunction","nextItem","nextState","itemIterator","nextItemIterator","SubSequence","safe","getOrThrow","acc","removed","interceptor","CombinedContext","baseKey","operation","initial","newLeft","Random","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","rnd","doubleFromParts","r1","r","nextDown","steps","remainder","vr","seed","boundsErrorMessage","t","v0","takeUpperBits","seed1","seed2","thisUpper","otherUpper","newIndent","lines","line","isWhitespace","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","digit","NumberFormatException","padChar","padStart","chars","indices","indexOfAny","charArrayOf","currentStartIndex","strings","findAnyOf","currentIndex","second","DelimitedRangesSequence","asList","delimiters","splitToSequence","lineSequence","MAX_NANOS","MAX_MILLIS","MAX_NANOS_IN_MILLIS","Duration","durationOfMillis","nextSearchIndex","groupValues","convertDurationUnit","toDuration","parseDuration","IllegalArgumentException","unit","durationOfNanos","convertDurationUnitOverflow","maxNsInUnit","valueInNs","roundToLong","durationOfMillisNormalized","hasSign","isTimeComponent","prevUnit","component","durationUnitByIsoChar","dotIndex","parseOverLongIsoComponent","whole","toDouble","strictIso","infinityString","INFINITE","afterFirst","allowSpaces","unitName","durationUnitByShortName","toLong","millis","normalNanos","normalMillis","nanosToMillis","millisToNanos","shortName","isoChar","normalValue","unitDiscriminator","durationOfNanosNormalized","otherNanos","thisMillis","otherMillis","resultMillis","otherNanoRemainder","remNanos","totalMillis","roundToInt","intScale","isPositive","coarserUnit","compareBits","action","hoursComponent","minutesComponent","secondsComponent","nanosecondsComponent","inWholeSeconds","inWholeHours","inWholeMinutes","inWholeNanoseconds","inWholeMilliseconds","absoluteValue","inWholeDays","days","hours","minutes","nanoseconds","components","hasDays","hasHours","hasMinutes","hasSeconds","fractional","fractionalSize","fracString","isoZeroes","nonZeroDigits","number","formatToExactDecimals","AdjustedTimeMark","duration","elapsedNow","mark","adjustment","read","initializer","isInitialized","InitializedLazyImpl","Pair","that","UByte","third","UInt","uintCompare","data","ulongCompare","uintDivide","ulongDivide","uintRemainder","ulongRemainder","UIntProgression","UIntRange","uintToDouble","UIntProgressionIterator","UIntIterator","ULong","nextUInt","nextULong","ULongProgression","ulongToDouble","ulongToString","ULongProgressionIterator","ULongIterator","ac","bc","UShort","uradix","beforeAdding","v1","v2","divisor","dividend","quotient","base","toMutableList","IndexingIterable","resultSize","throwCountOverflow","sequenceOf","collectionSizeOrNull","addAll","fillFrom","arrayCopyResize","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","captureStackTrace","instance","stack","UnsafeLazyImpl","original","delegate","NullPointerException","KTypeImpl","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","isLowerCaseImpl","toIntOrNull","thisLower","otherLower","getOrImplicitDefault","mapOf","optimizeReadOnlyMap","toSet","titlecaseImpl","replaceIndent","startFound","padEnd","delimiter","currentOffset","isLimited","toUByteOrNull","toUShortOrNull","toUIntOrNull","toULongOrNull","NodeJsOutput","BufferedOutputToConsoleLog","Comparator","sourceIterator","mapCapacity","findAssociatedObject","answer","compareValues","selector","BytecodeIr","param","arg","argSrcLoc","precise","pushInst","opcode","OP_ARG_PUSHR","firstOrNull","args","pushArg","labelArg","CompletionItem","sortedWith","filterNotNull","OPCODES","OPCODES_F8","OPCODES_F9","mnemonic","sig","label","documentation","ControlFlowGraph","inlineStackArgs","asm","changes","change","startLineNo","startCol","endLineNo","endCol","split","newAsm","linesChanged","newLines","lineNo","newLineParts","lineStart","lineEnd","newLinePart","startLine","endLine","startLineStart","endLineEnd","assemble","toList","assemblyResult","problems","AssemblyProblem","severity","uiMessage","col","notifications","instructionSegments","labels","getMapDesignations","designations","trim","text","filter","suggestions","startingWith","containing","requestId","signature","activeParam","inst","paramIdx","SignatureHelp","getOrNull","parameters","activeParameter","labelStart","labelEnd","contents","doc","Hover","coarse","flatMap","segments","segment","srcLoc","Label","results","ir","instructions","instLineNo","lastCol","argIdx","trailingArgSeparator","params","definitions","references","labelIdx","AsmRange","instruction","processParam","argSrcLocs","processImmediateArg","processStackArgSrcLoc","getStackValue","processStackArg","StringBuilder","Parameter","Signature","AnyType","ByteType","ShortType","IntType","FloatType","LabelType","ILabelType","DLabelType","SLabelType","ILabelVarType","StringType","registers","register","RegVarType","PointerType","Throttle","KotlinLogging","asmChanges","otherMessages","messages","processAsm","responses","id","response","JSON_FORMAT","postMessage","KotlinLoggingConfiguration","LogFormatter","LogAppender","location","hostname","AsmServer","AsmAnalyser","onmessage","json","joinToString","PwResultBuilder","logger","PwResult","problem","Problem","Success","Failure","close","PI","episode","LineTokenizer","SegmentSrcLoc","Segment","Arg","isLabel","HEX_INT_REGEX","hexStr","drop","FLOAT_REGEX","floatStr","toDoubleOrNull","isRegister","prevWasBackSpace","terminated","replaceAll","ident","nextToken","hasLabel","InstructionSegment","seg","Instruction","valid","InstructionSrcLoc","mnemonicSrcLoc","DataSegment","bytes","oldSize","StringSegment","intValue","mutableListOf","section","mnemonicToOpcode","strValue","prevToken","prevCol","prevLen","argCount","shouldBeArg","paramI","token","nextCol","nextLen","coarseCol","varargs","typeMatch","paramType","FloatArg","IntArg","StringArg","UnknownArg","ArgSrcLoc","SrcLoc","coarseLen","immediateArgs","srcLocs","typeStr","OP_ARG_PUSHB","OP_ARG_PUSHW","OP_ARG_PUSHL","OP_ARG_PUSHS","paramCount","errorLength","bitSize","minValue","maxValue","toByteArray","copy","sum","dcGcFormat","paramToArgs","listOfNotNull","pArgs","paramIndex","ValueType","RegRefType","getOpcode","UNKNOWN_OPCODE_MNEMONIC_REGEX","codeStr","codeToOpcode","opcodes","Opcode","bytecodeIr","ControlFlowGraphBuilder","createBasicBlocks","cfg","blocks","branchType","nextBlock","branchLabels","labelsToBlock","callers","caller","ret","linkReturningBlocks","linkBlocks","firstBlock","OP_RET","OP_JMP","OP_JMP_ON","OP_JMP_OFF","OP_JMP_E","OP_JMPI_E","OP_JMP_NE","OP_JMPI_NE","OP_UJMP_G","OP_UJMPI_G","OP_JMP_G","OP_JMPI_G","OP_UJMP_L","OP_UJMPI_L","OP_JMP_L","OP_JMPI_L","OP_UJMP_GE","OP_UJMPI_GE","OP_JMP_GE","OP_JMPI_GE","OP_UJMP_LE","OP_UJMPI_LE","OP_JMP_LE","OP_JMPI_LE","OP_SWITCH_JMP","OP_CALL","OP_VA_CALL","OP_SWITCH_CALL","BasicBlockImpl","instructionsToBlock","labelBlocks","linkReturningBlocksRecurse","encountered","toBlock","RegisterValueFinder","minOrNull","all","OP_SYNC","path","isNotEmpty","OP_LET","OP_LETI","OP_LETB","OP_LETW","OP_SYNC_LETI","OP_SET","OP_CLEAR","OP_REV","prevVals","OP_ADDI","OP_SUBI","OP_MULI","OP_DIVI","OP_IF_ZONE_CLEAR","OP_GET_DIFFLVL","OP_GET_SLOTNUMBER","OP_GET_RANDOM","maxOrNull","OP_STACK_PUSHM","OP_STACK_POPM","minReg","maxReg","argLen","regRef","empty","vaStartIdx","vaCallIdx","OP_VA_START","OP_ARG_PUSHA","OP_ARG_PUSHO","pos","getRegisterValue","multipleInstructions","fromValues","fromInstruction","idx","lastOrNull","Interval","scalar","addI","oldStart","oldEnd","newEnd","newStart","ValueSet","Area","order","avs","variants","AreaVariant","avId","area","uniqueName","rareType","lazy","FRIENDLY_NPC_PROPERTIES","EntityProp","arrayBuffer","DataView","endianness","byteLength","getUint8","getUint16","getUint32","getInt8","getInt16","getInt32","getFloat32","nullTerminated","codePoint","maxByteLength","setUint8","setUint16","setUint32","setInt8","setInt16","setInt32","setFloat32","btoa","newBuffer","coerceAtMost","Uint8Array","minNewSize","capacity","Buffer","initialSize","toTypedArray","atob","Assembler","time","checkCountOverflow","warnings","errors","func0Segment","OP_MAP_DESIGNATE","OP_MAP_DESIGNATE_EX","createCfg","areaId","variantIdRegister","variantId","mapDesignations","OP_BB_MAP_DESIGNATE","StackValueFinder","Param","RegType","repeat","createArea","ep1","ep2","ep4","VALUES","npcType","ultimateName","ignoreUnknownKeys","classDiscriminator","ClientMessage","ClientNotification","Request","ServerMessage","ServerNotification","Response","setTimeout","throwable","info","warn","error","level","loggerName","msg","MessageWithThrowable","marker","Json","defaultConfig","prettyPrint","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"mappings":"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b,OhHmDkE2c,GgHnDvDoB,EhHmDwEnB,KgHnDlEoB,EhHmD8EpB,OgHnDpF,EhHkF2C,IAAAF,GgHlFjCqB,EhHkF2CnB,KgHlFtCoB,EhHkFuDpB,KAAZ,GAbhB,IAAAF,GAAU,IAaTA,GgHlFpBqB,EhHkF8BnB,KgHlFzBoB,EhHkF0CpB,KAAZ,GAbNA,KgHrEnB5c,EhHqEmC4c,KAAX,GgHlExE,mBACI,MLwIsDK,GKxI7Cl1B,EAAIiY,GACb,ELuIsDid,GKvI7CpzB,EAAImW,GACb,OLqDmE6c,GKrDxDkB,ELqD0EnB,KKrDpEoB,ELqDgFpB,OKrDtF,EL+E6C,IAAAW,GK/EnCQ,EL+E8CnB,KAAK,SK/E9CoB,EL+E0DpB,OAb7B,IAAAW,GAAW,IAaVA,GK/EtBQ,EL+EiCnB,KAAK,SK/EjCoB,EL+E6CpB,OAblBA,KAAK,IKlE3B5c,ELkEsC4c,OK/DtF,mBAmBI,GAAAhf,EAAO,EADuE,OhHwBZ+e,GgHvBlD1e,EhHuBmE2e,KgHvB1DnkB,EhHuBsEmkB,OgHvB/E,EAAcnkB,EhHsDwB,IAAAikB,GgHtDfjkB,EhHsDyBmkB,KgHtDnB,GAAiBnkB,EAAKwF,EhH2WhC,IAAAye,GgH3WuC9e,IhHsDOgf,KAAZ,GgHrDrE,GAAAhf,EAAO,EAFuE,OhHwBZ+e,GgHtBlD1e,EhHsBmE2e,KgHtB1DnkB,EhHsBsEmkB,OgHtB/E,EAAcnkB,EhHwCuB,IAAAikB,GgHxCdjkB,EhHwCwBmkB,KgHxClB,GAAiB3e,EAAOxF,EhH0WlC,IAAAikB,GgH1WwC,GAAC9e,IhHwCGgf,KAAX,GgHvC5D,MAAa,GAAyB,iBAGlD,mBAmBI,GAAAhf,EAAA,WAAO,EAD2E,OLQfif,GKPnD5e,ELOqE2e,KKP5DnkB,ELOwEmkB,OKPjF,EAAcnkB,ELiC0B,IAAA8kB,GKjCjB9kB,ELiC4BmkB,KAAK,SKjC3B,GAAiBnkB,EAAKwF,ELkW7B,IAAAsf,GKlWoC3f,ILiCUgf,OKhCpF,GAAAhf,EAAA,WAAO,EAF2E,OLQfif,GKNnD5e,ELMqE2e,KKN5DnkB,ELMwEmkB,OKNjF,EAAcnkB,ELmByB,IAAA8kB,GKnBhB9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HEA,G,sBKIM,E,gBAAA,8BAAc,E,cACZ,Q,oBLpCsB,E,WAAP,M,WACvB,K,yBMhBR,G,YCiOoD,G,GPhNrC,Q,gCKqCP,O,wGG4LR,4E,gDAYuE,K,gMAA/D,iB,4JC/PR,+BAuBA,kB,iBAAA,eASwE,sB,EAA1B,oBAAO,qBAAmB,E,kDCuCvD,4B,2CCcT,6B,kCC9D+B,kBAAQ,kB,sEAE3C,6C,2BCqJ8C,Q,sCAjBd,oD,kCAGH,8BAAmB,UAAnB,O,CAMwC,6B,+CAIzE,eACW,E,mCAEE,EAAU,2B,OACX,IAAK,E,yCAKmC,wB,CAAC,mC,yL3IzFJ,SAAM,K,M2I4F5B,E,8HChJnB,oB,2CxBgEJ,G,WACI,gBAAO,E,oCwBoJsC,M,IAC1C,GAAc,gB,8BAEjB,eACA,IAzG6B,QA0G7B,EAAU,4B,kIAlGd,6B,OA8BA,IC9CJ,oBD8CI,8B,aA9BA,c,M9HpHI,E8HkJJ,+B,gBAhBiB,kC,SCvBb,KD+GuB,EC7GJ,G,2CAJvB,E,0FDiH2B,SCpGb,Q,mF7IlIC,sBAeX,WAAM,E,e8G0MF,c,qBAlJJ,Y,0BAXA,EAAU,YAWN,uBAA0B,EAAS,KAAvC,QAAI,sBAAJ,Q,uCAMA,I,kBAKO,K,MgB5CX,K,OhB6CY,E,UA0Bc,E,EgBvE1B,O,MhBgDY,GAAc,oBAAe,EAAf,+C,MAoIC,E,IAjIS,kB,gCAEpB,G,+HAGwB,E,qBgCrK5C,uB,aAEI,c,+DAaA,GAAO,wB,SAGX,kB,MAEQ,EADJ,G,kJCR8C,E,kDACZ,GAAR,IAAQ,E,CAAA,eAAR,IAAQ,oB,yCAKlC,mB,4DAQuB,QACvB,qBAAkD,a,mBAAlD,I,kBAAA,I,oBACA,sC,oECN4B,c,QAAQ,YAGhC,iB,CACA,I,QAGoB,IAAqB,kC,eCpB7C,QDuBI,YACI,MADJ,0BASY,E,YAAsB,G,OAAlC,E,eAyEsB,mB,+CZrE9B,cASI,cAAW,E,ecMP,c,kDAJJ,qB,kCAiEgB,Q,mCCyEZ,aAMA,E,+BAgCA,YAAQ,U,EAAA,oC,uCAuFK,Q,MAAgB,Y,iBAgDR,c,UAGrB,aAAO,IC9TI,6B,cTUX,Q,sCNmKwB,SAAO,EAAP,iBAEpB,Y,+IAYmC,Q,OAG3C,I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AAA,wB,IAAA,0B,IAAA,yB,IAAA,wB,IAAA,sB,IAAA,wB,IAAA,sB,IAAA,0B,IAAA,yB,IAAA,wB,IAAA,qB,IAAA,wB,IAAA,wB,IAAA,oB,IAAA,oB,IAAA,uB,IAAA,qB,IAAA,wB,IAAA,wB,IAAA,uB,IAAA,sB,IAAA,qB,IAAA,uB,IAAA,yB,IAAA,4B,IAAA,oB,IAAA,sB,IAAA,wB,IAAA,qB,IAAA,4B,IAAA,yB,IAAA,sB,IAAA,yB,IAAA,wB,IAAA,uB,IAAA,wB,IAAA,4B,IAAA,2B,IAAA,sB,IAAA,qB,IAAA,qB,IAAA,sB,IAAA,sB,IAAA,sB,IAAA,qB,IAAA,wB,IAAA,wB,IAAA,uB,IAAA,qB,IAAA,wB,IAAA,0B,IAAA,0B,IAAA,uB,IAAA,4B,IAAA,yB,IAAA,0B,IAAA,2B,IAAA,wB,IAAA,uB,IAAA,yB,IAAA,yB,IAAA,sB,IAAA,mB,IAAA,mB,IAAA,uB,IAAA,yB,IAAA,yB,IAAA,wB,IAAA,wB,IAAA,sB,IAAA,yB,IAAA,uB,IAAA,sB,IAAA,wB,IAAA,0B,IAAA,uB,IAAA,6B,IAAA,wB,IAAA,0B,IAAA,0B,IAAA,yB,IAAA,uB,IAAA,0B,IAAA,6B,IAAA,uB,IAAA,sB,IAAA,sB,IAAA,uB,IAAA,uB,IAAA,sB,IAAA,yB,IAAA,wB,IAAA,6B,IAAA,wB,IAAA,0B,IAAA,2B,IAAA,uB,IAAA,uB,IAAA,wB,IAAA,sB,IAAA,sB,IAAA,uB,IAAA,wB,IAAA,sB,IAAA,kB,IAAA,oB,IAAA,sB,IAAA,sB,IAAA,sB,IAAA,yB,IAAA,uB,IAAA,uB,IAAA,sB,IAAA,uB,IAAA,qB,IAAA,sB,IAAA,oB,IAAA,uB,IAAA,wB,IAAA,uB,IAAA,wB,IAAA,uB,IAAA,qB,IAAA,8B,IAAA,oB,IAAA,uB,IAAA,wB,IAAA,yB,IAAA,iB,IAAA,qB,IAAA,oB,IAAA,sB,IAAA,sB,IAAA,sB,IAAA,4B,IAAA,oB,IAAA,wB,IAAA,6B,IAAA,0B,IAAA,yB,IAAA,uB,QAAA,8E,sECKI,8C,IAAA,4C,+DAMA,uC,IACI,YACI,sBAAerB,GACf,oBAAQA,K,qEAIZ,W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","file":"assembly-worker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assembly-worker\"] = factory();\n\telse\n\t\troot[\"assembly-worker\"] = factory();\n})(this, function() {\nreturn ",null,null,null,null,null,null,null,null,"(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js.internal\n\n@JsName(\"DoubleCompanionObject\")\ninternal object DoubleCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Double = 4.9E-324\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Double = 1.7976931348623157E308\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Double = 1.0 / 0.0\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Double = -1.0 / 0.0\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Double = -(0.0 / 0.0)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"FloatCompanionObject\")\ninternal  object FloatCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Float = 1.4E-45F\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Float = 3.4028235E38F\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Float = 1.0F / 0.0F\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Float = -1.0F / 0.0F\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Float = -(0.0F / 0.0F)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"IntCompanionObject\")\ninternal  object IntCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Int = -2147483647 - 1\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Int = 2147483647\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"LongCompanionObject\")\ninternal  object LongCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Long = js(\"Kotlin.Long.MIN_VALUE\")\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Long = js(\"Kotlin.Long.MAX_VALUE\")\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"ShortCompanionObject\")\ninternal  object ShortCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Short = -32768\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Short = 32767\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\n@JsName(\"ByteCompanionObject\")\ninternal  object ByteCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Byte = -128\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Byte = 127\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 1\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 8\n}\n\n@JsName(\"CharCompanionObject\")\ninternal  object CharCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    public const val MIN_VALUE: Char = '\\u0000'\n\n    @JsName(\"MAX_VALUE\")\n    public const val MAX_VALUE: Char = '\\uFFFF'\n\n    @JsName(\"MIN_HIGH_SURROGATE\")\n    public const val MIN_HIGH_SURROGATE: Char = '\\uD800'\n\n    @JsName(\"MAX_HIGH_SURROGATE\")\n    public const val MAX_HIGH_SURROGATE: Char = '\\uDBFF'\n\n    @JsName(\"MIN_LOW_SURROGATE\")\n    public const val MIN_LOW_SURROGATE: Char = '\\uDC00'\n\n    @JsName(\"MAX_LOW_SURROGATE\")\n    public const val MAX_LOW_SURROGATE: Char = '\\uDFFF'\n\n    @JsName(\"MIN_SURROGATE\")\n    public const val MIN_SURROGATE: Char = MIN_HIGH_SURROGATE\n\n    @JsName(\"MAX_SURROGATE\")\n    public const val MAX_SURROGATE: Char = MAX_LOW_SURROGATE\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\ninternal  object StringCompanionObject {}\n\ninternal  object BooleanCompanionObject {}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.*\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * The type can store duration values up to 146 years with nanosecond precision,\n * and up to 146 million years with millisecond precision.\n *\n * To construct a duration, use either the extension function [toDuration] available on [Int], [Long], and [Double] numeric types,\n * or the `Duration` companion object functions [Duration.hours], [Duration.minutes], [Duration.seconds], and so on,\n * taking [Int], [Long], or [Double] numbers as parameters.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        // TODO: disable assertions in final version\n        if (isInNanos()) {\n            if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n        } else {\n            if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n            if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in any of the supported formats.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parse(value: String): Duration = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in ISO-8601 format.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parseIsoString(value: String): Duration = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid ISO duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in any of the supported formats.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parseOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in ISO-8601 format.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parseIsoStringOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.DAYS), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.HOURS), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.MINUTES), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately 292 years.\n     */\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately 292 million years.\n     */\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value\n     * expressed as a combination of numeric components, each in its own unit.\n     *\n     * Each component is a number followed by the unit abbreviated name: `d`, `h`, `m`, `s`:\n     * `5h`, `1d 12h`, `1h 0m 30.3340s`.\n     * The last component, usually seconds, can be a number with a fractional part.\n     *\n     * If the duration is less than a second, it is represented as a single number\n     * with one of sub-second units: `ms` (milliseconds), `us` (microseconds), or `ns` (nanoseconds):\n     * `140.884ms`, `500us`, `24ns`.\n     *\n     * A negative duration is prefixed with `-` sign and, if it consists of multiple components, surrounded with parentheses:\n     * `-12m` and `-(1h 30m)`.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * It's recommended to use [toIsoString] that uses more strict ISO-8601 format instead of this `toString`\n     * when you want to convert a duration to a string in cases of serialization, interchange, etc.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val isNegative = isNegative()\n            buildString {\n                if (isNegative) append('-')\n                absoluteValue.run {\n                    toComponents { _, hours, minutes, seconds, nanoseconds ->\n                        val days = inWholeDays\n                        val hasDays = days != 0L\n                        val hasHours = hours != 0\n                        val hasMinutes = minutes != 0\n                        val hasSeconds = seconds != 0 || nanoseconds != 0\n                        var components = 0\n                        if (hasDays) {\n                            append(days).append('d')\n                            components++\n                        }\n                        if (hasHours || (hasDays && (hasMinutes || hasSeconds))) {\n                            if (components++ > 0) append(' ')\n                            append(hours).append('h')\n                        }\n                        if (hasMinutes || (hasSeconds && (hasHours || hasDays))) {\n                            if (components++ > 0) append(' ')\n                            append(minutes).append('m')\n                        }\n                        if (hasSeconds) {\n                            if (components++ > 0) append(' ')\n                            when {\n                                seconds != 0 || hasDays || hasHours || hasMinutes ->\n                                    appendFractional(seconds, nanoseconds, 9, \"s\", isoZeroes = false)\n                                nanoseconds >= 1_000_000 ->\n                                    appendFractional(nanoseconds / 1_000_000, nanoseconds % 1_000_000, 6, \"ms\", isoZeroes = false)\n                                nanoseconds >= 1_000 ->\n                                    appendFractional(nanoseconds / 1_000, nanoseconds % 1_000, 3, \"us\", isoZeroes = false)\n                                else ->\n                                    append(nanoseconds).append(\"ns\")\n                            }\n                        }\n                        if (isNegative && components > 1) insert(1, '(').append(')')\n                    }\n                }\n            }\n        }\n    }\n\n    private fun StringBuilder.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean) {\n        append(whole)\n        if (fractional != 0) {\n            append('.')\n            val fracString = fractional.toString().padStart(fractionalSize, '0')\n            val nonZeroDigits = fracString.indexOfLast { it != '0' } + 1\n            when {\n                !isoZeroes && nonZeroDigits < 3 -> appendRange(fracString, 0, nonZeroDigits)\n                else -> appendRange(fracString, 0, ((nonZeroDigits + 2) / 3) * 3)\n            }\n        }\n        append(unit)\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * @param decimals the number of digits after decimal point to show. The value must be non-negative.\n     * No more than 12 decimals will be shown, even if a larger number is requested.\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return formatToExactDecimals(number, decimals.coerceAtMost(12)) + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        val absoluteValue = this@Duration.absoluteValue\n        absoluteValue.toComponents { _, minutes, seconds, nanoseconds ->\n            var hours = absoluteValue.inWholeHours\n            if (isInfinite()) {\n                // use large enough value instead of Long.MAX_VALUE\n                hours = 9_999_999_999_999\n            }\n            val hasHours = hours != 0L\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                appendFractional(seconds, nanoseconds, 9, \"S\", isoZeroes = true)\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.roundToLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).roundToLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n\n@ExperimentalTime\nprivate fun parseDuration(value: String, strictIso: Boolean): Duration {\n    var length = value.length\n    if (length == 0) throw IllegalArgumentException(\"The string is empty\")\n    var index = 0\n    var result = Duration.ZERO\n    val infinityString = \"Infinity\"\n    when (value[index]) {\n        '+', '-' -> index++\n    }\n    val hasSign = index > 0\n    val isNegative = hasSign && value.startsWith('-')\n    when {\n        length <= index ->\n            throw IllegalArgumentException(\"No components\")\n        value[index] == 'P' -> {\n            if (++index == length) throw IllegalArgumentException()\n            val nonDigitSymbols = \"+-.\"\n            var isTimeComponent = false\n            var prevUnit: DurationUnit? = null\n            while (index < length) {\n                if (value[index] == 'T') {\n                    if (isTimeComponent || ++index == length) throw IllegalArgumentException()\n                    isTimeComponent = true\n                    continue\n                }\n                val component = value.substringWhile(index) { it in '0'..'9' || it in nonDigitSymbols }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitChar = value.getOrElse(index) { throw IllegalArgumentException(\"Missing unit for value $component\") }\n                index++\n                val unit = durationUnitByIsoChar(unitChar, isTimeComponent)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (unit == DurationUnit.SECONDS && dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += parseOverLongIsoComponent(whole).toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                } else {\n                    result += parseOverLongIsoComponent(component).toDuration(unit)\n                }\n            }\n        }\n        strictIso ->\n            throw IllegalArgumentException()\n        value.regionMatches(index, infinityString, 0, length = maxOf(length - index, infinityString.length), ignoreCase = true) -> {\n            result = Duration.INFINITE\n        }\n        else -> {\n            // parse default string format\n            var prevUnit: DurationUnit? = null\n            var afterFirst = false\n            var allowSpaces = !hasSign\n            if (hasSign && value[index] == '(' && value.last() == ')') {\n                allowSpaces = true\n                if (++index == --length) throw IllegalArgumentException(\"No components\")\n            }\n            while (index < length) {\n                if (afterFirst && allowSpaces) {\n                    index = value.skipWhile(index) { it == ' ' }\n                }\n                afterFirst = true\n                val component = value.substringWhile(index) { it in '0'..'9' || it == '.' }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitName = value.substringWhile(index) { it in 'a'..'z' }\n                index += unitName.length\n                val unit = durationUnitByShortName(unitName)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += whole.toLong().toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                    if (index < length) throw IllegalArgumentException(\"Fractional component must be last\")\n                } else {\n                    result += component.toLong().toDuration(unit)\n                }\n            }\n        }\n    }\n    return if (isNegative) -result else result\n}\n\n\nprivate fun parseOverLongIsoComponent(value: String): Long {\n    val length = value.length\n    var startIndex = 0\n    if (length > 0 && value[0] in \"+-\") startIndex++\n    if ((length - startIndex) > 16 && (startIndex..value.lastIndex).all { value[it] in '0'..'9' }) {\n        // all chars are digits, but more than ceiling(log10(MAX_MILLIS / 1000)) of them\n        return if (value[0] == '-') Long.MIN_VALUE else Long.MAX_VALUE\n    }\n    // TODO: replace with just toLong after min JDK becomes 8\n    return if (value.startsWith(\"+\")) value.drop(1).toLong() else value.toLong()\n}\n\n\n\nprivate inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String =\n    substring(startIndex, skipWhile(startIndex, predicate))\n\nprivate inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int {\n    var i = startIndex\n    while (i < length && predicate(this[i])) i++\n    return i\n}\n\n\n\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\n@ExperimentalTime private fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\n@ExperimentalTime private fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\n@ExperimentalTime private fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\n@ExperimentalTime private fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\n@ExperimentalTime private fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence from the second time.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 10 mappings totally\ninternal fun Char.titlecaseImpl(): String {\n    val uppercase = uppercase()\n    if (uppercase.length > 1) {\n        return if (this == '\\u0149') uppercase else uppercase[0] + uppercase.substring(1).lowercase()\n    }\n    return titlecaseChar().toString()\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property Other_Lowercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(): Int {\n    return digitOf(this, 10).also {\n        if (it < 0) throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n    }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(): Int? {\n    return digitOf(this, 10).takeIf { it >= 0 }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n    return digitOf(this, radix).takeIf { it >= 0 }\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercase(): String\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.titlecaseChar(): Char\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.titlecase()` returns `\"\\u0046\\u0066\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no title case mapping, the result of [uppercase] is returned instead.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic fun Char.titlecase(): String = titlecaseImpl()\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n *\n * Two characters are considered the same ignoring case if at least one of the following is `true`:\n *   - The two characters are the same (as compared by the == operator)\n *   - Applying the method [uppercaseChar] to each character produces the same result\n *   - Applying the method [lowercaseChar] to each character produces the same result\n *\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    val thisUpper = this.uppercaseChar()\n    val otherUpper = other.uppercaseChar()\n\n    return thisUpper == otherUpper || thisUpper.lowercaseChar() == otherUpper.lowercaseChar()\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic expect val Char.category: CharCategory\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDefined(): Boolean\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetter(): Boolean\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetterOrDigit(): Boolean\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDigit(): Boolean\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isUpperCase(): Boolean\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property Other_Lowercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLowerCase(): Boolean\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isTitleCase(): Boolean\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isISOControl(): Boolean\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic expect fun Char.isWhitespace(): Boolean\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n/** Returns true when it's safe to convert this collection to a set without changing contains method behavior. */\nprivate fun <T> Collection<T>.safeToConvertToSet() = size > 2 && this is ArrayList\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperationWith(source: Iterable<T>): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection ->\n            when {\n                source is Collection && source.size < 2 -> this\n                else -> if (this.safeToConvertToSet()) toHashSet() else this\n            }\n        else -> toHashSet()\n    }\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperation(): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection -> if (this.safeToConvertToSet()) toHashSet() else this\n        else -> toHashSet()\n    }\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\ninternal fun requireNonNegativeLimit(limit: Int) =\n    require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    requireNonNegativeLimit(limit)\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence to a list of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@SinceKotlin(\"1.5\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.splitToSequence(regex: Regex, limit: Int = 0): Sequence<String> = regex.splitToSequence(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n *\n * If the program that calls this function is written in a way that only valid [code] is passed as the argument,\n * using the overload that takes a [UShort] argument is preferable (`Char(intValue.toUShort())`).\n * That overload doesn't check validity of the argument, and may improve program performance when the function is called routinely inside a loop.\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun Char(code: Int): Char {\n    if (code < Char.MIN_VALUE.code || code > Char.MAX_VALUE.code) {\n        throw IllegalArgumentException(\"Invalid Char code: $code\")\n    }\n    return code.toChar()\n}\n\n/**\n * Creates a Char with the specified [code].\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun Char(code: UShort): Char\n\n/**\n * Returns the code of this Char.\n *\n * Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.\n *\n * @sample samples.text.Chars.code\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline val Char.code: Int get() = this.toInt()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 1343 ranges totally\nprivate object Category {\n    val decodedRangeStart: IntArray\n    val decodedRangeCategory: IntArray\n    \n    init {\n        val toBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        val fromBase64 = IntArray(128)\n        for (i in toBase64.indices) {\n            fromBase64[toBase64[i].code] = i\n        }\n        \n        // rangeStartDiff.length = 1482\n        val rangeStartDiff = \"gBCFEDCKCDCaDDaDBhBCEEDDDDDEDXBHYBH5BRwBGDCHDCIDFHDCHFDCDEIRTEE7BGHDDJlCBbSEMOFGERwDEDDDDECEFCRBJhBFDCYFFCCzBvBjBBFC3BOhDBmBDGpBDDCtBBJIbEECLGDFCLDCgBBKVKEDiDDHCFECECKCEODBebC5CLBOKhBJDDDDWEBHFCFCPBZDEL1BVBSLPBgBB2BDBDICFBHKCCKCPDBHEDWBHEDDDDEDEDIBDGDCKCCGDDDCGECCWBFMDDCDEDDCHDDHKDDBKDBHFCWBFGFDBDDFEDBPDDKCHBGDCHEDWBFGFDCEDEDBHDDGDCKCGJEGDBFDDFDDDDDMEFDBFDCGBOKDFDFDCGFCXBQDDDDDBEGEDFDDKHBHDDGFCXBKBFCEFCFCHCHECCKDNCCHFCoBEDECFDDDDHDCCKJBGDCSDYBJEHBFDDEBIGKDCMuBFHEBGBIBKCkBFBFBXEIFJDFDGCKCEgBBDPEDGKKGECIBkBEOBDFFLBkBBIBEFFEClBrBCEBEGDBKGGDDDDDCHDENDCFEKDDlBDDFrBCDpKBECGEECpBBEChBBECGEECPB5BBECjCCDJUDQKG2CCGDsTCRBaCDrCDDIHNBEDLSDCJSCMLFCCM0BDHGFLBFDDKGKGEFDDBKGjBB1BHFChBDFmCKfDDDDDDCGDCFDKeCFLsBEaGKBDiBXDDD1BDGDEIGJEKGKGHBGCMF/BEBvBCEDDFHEKHKJJDDeDDGDKsBFEDCIEkBIICCDFKDDKeGCJHrBCDIIDBNBHEBEFDBFsB/BNBiBlB6BBF1EIiDJIGCGCIIIIGCGCIIIIOCIIIIIIDFEDDBFEDDDDEBDIFDDFEDBLFGCEEICFBJCDEDCLDKBFBKCCGDDKDDNDgBQNEBDMPFFDEDEBFFHECEBEEDFBEDDQjBCEDEFFCCJHBeEEfsIIEUCHCxCBeZoBGlCZLV8BuCW3FBJB2BIvDB4HOesBFCfKQgIjEW/BEgBCiIwBVCGnBCgBBpDvBBuBEDBHEFGCCjDCGEDCFCFlBDDF4BHCOBXJHBHBHBHBHBHBHBHBgBCECGHGEDIFBKCEDMEtBaB5CM2GaMEDDCKCGFCJEDFDDDC2CDDDB6CDCFrBB+CDEKgBkBMQfBKeIBPgBKnBPgKguGgC9vUDVB3jBD3BJoBGCsIBDQKCUuBDDKCcCCmCKCGIXJCNC/BBHGKDECEVFBEMCEEBqBDDGDFDXDCEBDGEG0BEICyBQCICKGSGDEBKcICXLCLBdDDBvBDECCDNCKECFCJKFBpBFEDCJDBICCKCEQBGDDByBEDCEFBYDCLEDDCKGCGCGJHBHBrBBEJDEwCjBIDCKGk9KMXExBEggCgoGuLCqDmBHMFFCKBNBFBIsDQRrLCQgCC2BoBMCCQGEGQDCQDDDDFDGDECEEFBnEEBFEDCKCDCaDDaDBFCKBtBCfDGCGCFEDDDDCECKDC\"\n        val diff = decodeVarLenBase64(rangeStartDiff, fromBase64, 1342)\n        val start = IntArray(diff.size + 1)\n        for (i in diff.indices) {\n            start[i + 1] = start[i] + diff[i]\n        }\n        decodedRangeStart = start\n        \n        // rangeCategory.length = 2033\n        val rangeCategory = \"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\"\n        decodedRangeCategory = decodeVarLenBase64(rangeCategory, fromBase64, 1343)\n    }\n}\n\nprivate fun categoryValueFrom(code: Int, ch: Int): Int {\n    return when {\n        code < 0x20 -> code\n        code < 0x400 -> if ((ch and 1) == 1) code shr 5 else code and 0x1f\n        else ->\n            when (ch % 3) {\n                2 -> code shr 10\n                1 -> (code shr 5) and 0x1f\n                else -> code and 0x1f\n            }\n    }\n}\n\n/**\n * Returns the Unicode general category of this character as an Int.\n */\ninternal fun Char.getCategoryValue(): Int {\n    val ch = this.code\n\n    val index = binarySearchRange(Category.decodedRangeStart, ch)\n    val start = Category.decodedRangeStart[index]\n    val code = Category.decodedRangeCategory[index]\n    val value = categoryValueFrom(code, ch - start)\n\n    return if (value == 17) CharCategory.UNASSIGNED.value else value\n}\n\ninternal fun decodeVarLenBase64(base64: String, fromBase64: IntArray, resultLength: Int): IntArray {\n    val result = IntArray(resultLength)\n    var index = 0\n    var int = 0\n    var shift = 0\n    for (char in base64) {\n        val sixBit = fromBase64[char.code]\n        int = int or ((sixBit and 0x1f) shl shift)\n        if (sixBit < 0x20) {\n            result[index++] = int\n            int = 0\n            shift = 0\n        } else {\n            shift += 5\n        }\n    }\n    return result\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 37 ranges totally\nprivate object Digit {\n    internal val rangeStart = intArrayOf(\n        0x0030, 0x0660, 0x06f0, 0x07c0, 0x0966, 0x09e6, 0x0a66, 0x0ae6, 0x0b66, 0x0be6, 0x0c66, 0x0ce6, 0x0d66, 0x0de6, 0x0e50, 0x0ed0, 0x0f20, 0x1040, 0x1090, 0x17e0, \n        0x1810, 0x1946, 0x19d0, 0x1a80, 0x1a90, 0x1b50, 0x1bb0, 0x1c40, 0x1c50, 0xa620, 0xa8d0, 0xa900, 0xa9d0, 0xa9f0, 0xaa50, 0xabf0, 0xff10, \n    )\n}\n\n/**\n * Returns the index of the largest element in [array] smaller or equal to the specified [needle],\n * or -1 if [needle] is smaller than the smallest element in [array].\n */\ninternal fun binarySearchRange(array: IntArray, needle: Int): Int {\n    var bottom = 0\n    var top = array.size - 1\n    var middle = -1\n    var value = 0\n    while (bottom <= top) {\n        middle = (bottom + top) / 2\n        value = array[middle]\n        if (needle > value)\n            bottom = middle + 1\n        else if (needle == value)\n            return middle\n        else\n            top = middle - 1\n    }\n    return middle - (if (needle < value) 1 else 0)\n}\n\n/**\n * Returns an integer from 0..9 indicating the digit this character represents,\n * or -1 if this character is not a digit.\n */\ninternal fun Char.digitToIntImpl(): Int {\n    val ch = this.code\n    val index = binarySearchRange(Digit.rangeStart, ch)\n    val diff = ch - Digit.rangeStart[index]\n    return if (diff < 10) diff else -1\n}\n\n/**\n * Returns `true` if this character is a digit.\n */\ninternal fun Char.isDigitImpl(): Boolean {\n    return digitToIntImpl() >= 0\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 222 ranges totally\nprivate object Letter {\n    val decodedRangeStart: IntArray\n    val decodedRangeLength: IntArray\n    val decodedRangeCategory: IntArray\n    \n    init {\n        val toBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        val fromBase64 = IntArray(128)\n        for (i in toBase64.indices) {\n            fromBase64[toBase64[i].code] = i\n        }\n        \n        // rangeStartDiff.length = 356\n        val rangeStartDiff = \"hCgBpCQGYHZH5BRpBPPPPPPRMP5BPPlCPP6BkEPPPPcPXPzBvBrB3BOiDoBHwD+E3DauCnFmBmB2D6E1BlBTiBmBlBP5BhBiBrBvBjBqBnBPRtBiCmCtBlB0BmB5BiB7BmBgEmChBZgCoEoGVpBSfRhBPqKQ2BwBYoFgB4CJuTiEvBuCuDrF5DgEgFlJ1DgFmBQtBsBRGsB+BPiBlD1EIjDPRPPPQPPPPPGQSQS/DxENVNU+B9zCwBwBPPCkDPNnBPqDYY1R8B7FkFgTgwGgwUwmBgKwBuBScmEP/BPPPPPPrBP8B7F1B/ErBqC6B7BiBmBfQsBUwCw/KwqIwLwETPcPjQgJxFgBlBsD\"\n        val diff = decodeVarLenBase64(rangeStartDiff, fromBase64, 222)\n        val start = IntArray(diff.size)\n        for (i in diff.indices) {\n            if (i == 0) start[i] = diff[i]\n            else start[i] = start[i - 1] + diff[i]\n        }\n        decodedRangeStart = start\n        \n        // rangeLength.length = 328\n        val rangeLength = \"aaMBXHYH5BRpBPPPPPPRMP5BPPlCPPzBDOOPPcPXPzBvBjB3BOhDmBBpB7DoDYxB+EiBP1DoExBkBQhBekBPmBgBhBctBiBMWOOXhCsBpBkBUV3Ba4BkB0DlCgBXgBtD4FSdBfPhBPpKP0BvBXjEQ2CGsT8DhBtCqDpFvD1D3E0IrD2EkBJrBDOBsB+BPiBlB1EIjDPPPPPPPPPPPGPPMNLsBNPNPKCvBvBPPCkDPBmBPhDXXgD4B6FzEgDguG9vUtkB9JcuBSckEP/BPPPPPPBPf4FrBjEhBpC3B5BKaWPrBOwCk/KsCuLqDHPbPxPsFtEaaqDL\"\n        decodedRangeLength = decodeVarLenBase64(rangeLength, fromBase64, 222)\n        \n        // rangeCategory.length = 959\n        val rangeCategory = \"GFjgggUHGGFFZZZmzpz5qB6s6020B60ptltB6smt2sB60mz22B1+vv+8BZZ5s2850BW5q1ymtB506smzBF3q1q1qB1q1q1+Bgii4wDTm74g3KiggxqM60q1q1Bq1o1q1BF1qlrqrBZ2q5wprBGFZWWZGHFsjiooLowgmOowjkwCkgoiIk7ligGogiioBkwkiYkzj2oNoi+sbkwj04DghhkQ8wgiYkgoioDsgnkwC4gikQ//v+85BkwvoIsgoyI4yguI0whiwEowri4CoghsJowgqYowgm4DkwgsY/nwnzPowhmYkg6wI8yggZswikwHgxgmIoxgqYkwgk4DkxgmIkgoioBsgssoBgzgyI8g9gL8g9kI0wgwJoxgkoC0wgioFkw/wI0w53iF4gioYowjmgBHGq1qkgwBF1q1q8qBHwghuIwghyKk0goQkwgoQk3goQHGFHkyg0pBgxj6IoinkxDswno7Ikwhz9Bo0gioB8z48Rwli0xN0mpjoX8w78pDwltoqKHFGGwwgsIHFH3q1q16BFHWFZ1q10q1B2qlwq1B1q10q1B2q1yq1B6q1gq1Biq1qhxBir1qp1Bqt1q1qB1g1q1+B//3q16B///q1qBH/qlqq9Bholqq9B1i00a1q10qD1op1HkwmigEigiy6Cptogq1Bixo1kDq7/j00B2qgoBWGFm1lz50B6s5q1+BGWhggzhwBFFhgk4//Bo2jigE8wguI8wguI8wgugUog1qoB4qjmIwwi2KgkYHHH4lBgiFWkgIWoghssMmz5smrBZ3q1y50B5sm7gzBtz1smzB5smz50BqzqtmzB5sgzqzBF2/9//5BowgoIwmnkzPkwgk4C8ys65BkgoqI0wgy6FghquZo2giY0ghiIsgh24B4ghsQ8QF/v1q1OFs0O8iCHHF1qggz/B8wg6Iznv+//B08QgohsjK0QGFk7hsQ4gB\"\n        decodedRangeCategory = decodeVarLenBase64(rangeCategory, fromBase64, 222)\n    }\n}\n\n/**\n * Returns `true` if this character is a letter.\n */\ninternal fun Char.isLetterImpl(): Boolean {\n    return getLetterType() != 0\n}\n\n/**\n * Returns `true` if this character is a lower case letter, or it has contributory property Other_Lowercase.\n */\ninternal fun Char.isLowerCaseImpl(): Boolean {\n    return getLetterType() == 1 || code.isOtherLowercase()\n}\n\n/**\n * Returns `true` if this character is an upper case letter, or it has contributory property Other_Uppercase.\n */\ninternal fun Char.isUpperCaseImpl(): Boolean {\n    return getLetterType() == 2 || code.isOtherUppercase()\n}\n\n/**\n * Returns\n *   - `1` if the character is a lower case letter,\n *   - `2` if the character is an upper case letter,\n *   - `3` if the character is a letter but not a lower or upper case letter,\n *   - `0` otherwise.\n */\nprivate fun Char.getLetterType(): Int {\n    val ch = this.code\n    val index = binarySearchRange(Letter.decodedRangeStart, ch)\n\n    val rangeStart = Letter.decodedRangeStart[index]\n    val rangeEnd = rangeStart + Letter.decodedRangeLength[index] - 1\n    val code = Letter.decodedRangeCategory[index]\n\n    if (ch > rangeEnd) {\n        return 0\n    }\n\n    val lastTwoBits = code and 0x3\n\n    if (lastTwoBits == 0) { // gap pattern\n        var shift = 2\n        var threshold = rangeStart\n        for (i in 0..1) {\n            threshold += (code shr shift) and 0x7f\n            if (threshold > ch) {\n                return 3\n            }\n            shift += 7\n            threshold += (code shr shift) and 0x7f\n            if (threshold > ch) {\n                return 0\n            }\n            shift += 7\n        }\n        return 3\n    }\n\n    if (code <= 0x7) {\n        return lastTwoBits\n    }\n\n    val distance = (ch - rangeStart)\n    val shift = if (code <= 0x1F) distance % 2 else distance\n    return (code shr (2 * shift)) and 0x3\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nprivate object OtherLowercase {\n    internal val otherLowerStart = intArrayOf(\n        0x00aa, 0x00ba, 0x02b0, 0x02c0, 0x02e0, 0x0345, 0x037a, 0x1d2c, 0x1d78, 0x1d9b, 0x2071, 0x207f, 0x2090, 0x2170, 0x24d0, 0x2c7c, 0xa69c, 0xa770, 0xa7f8, 0xab5c, \n    )\n    internal val otherLowerLength = intArrayOf(\n        1, 1, 9, 2, 5, 1, 1, 63, 1, 37, 1, 1, 13, 16, 26, 2, 2, 1, 2, 4, \n    )\n}\n\ninternal fun Int.isOtherLowercase(): Boolean {\n    val index = binarySearchRange(OtherLowercase.otherLowerStart, this)\n    return index >= 0 && this < OtherLowercase.otherLowerStart[index] + OtherLowercase.otherLowerLength[index]\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 4 ranges totally\ninternal fun Char.titlecaseCharImpl(): Char {\n    val code = this.code\n    // Letters repeating <Lu, Lt, Ll> sequence and code of the Lt is a multiple of 3, e.g. <, , >\n    if (code in 0x01c4..0x01cc || code in 0x01f1..0x01f3) {\n        return (3 * ((code + 1) / 3)).toChar()\n    }\n    // Lower case letters whose title case mapping equivalent is equal to the original letter\n    if (code in 0x10d0..0x10fa || code in 0x10fd..0x10ff) {\n        return this\n    }\n    return uppercaseChar()\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 9 ranges totally\n/**\n * Returns `true` if this character is a whitespace.\n */\ninternal fun Char.isWhitespaceImpl(): Boolean {\n    val ch = this.code\n    return ch in 0x0009..0x000d\n            || ch in 0x001c..0x0020\n            || ch == 0x00a0\n            || ch > 0x1000 && (\n                ch == 0x1680\n                || ch in 0x2000..0x200a\n                || ch == 0x2028\n                || ch == 0x2029\n                || ch == 0x202f\n                || ch == 0x205f\n                || ch == 0x3000\n            )\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/**\n * Returns the array if it's not `null`, or an empty array otherwise.\n * @sample samples.collections.Arrays.Usage.arrayOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n/**\n * Returns a *typed* array containing all of the elements of this collection.\n *\n * Allocates an array of runtime type `T` having its size equal to the size of this collection\n * and populates the array with the elements of this collection.\n * @sample samples.collections.Collections.Collections.collectionToTypedArray\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableList\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableListWith\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @JsName(\"toJSON\")\n    open fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        AbstractList.checkPositionIndex(index, size)\n\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n        final override fun remove(element: E): Boolean = removeEntry(element)\n        abstract fun removeEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    // TODO: should we implement them this way? Currently it's unspecified in JVM\n                    override fun equals(other: Any?): Boolean {\n                        if (this === other) return true\n                        if (other !is Collection<*>) return false\n                        return AbstractList.orderedEquals(this, other)\n                    }\n\n                    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual constructor(initialCapacity: Int = 0) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        if (array.size < size) {\n            return toArray() as Array<T>\n        }\n\n        (this.array as Array<T>).copyInto(array)\n\n        if (array.size > size) {\n            array[size] = null as T // null-terminate\n        }\n\n        return array\n    }\n\n    override fun toArray(): Array<Any?> {\n        return js(\"[]\").slice.call(array)\n    }\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    protected open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = JsMath.clz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal class KTypeImpl(\n    override val classifier: KClassifier,\n    override val arguments: List<KTypeProjection>,\n    override val isMarkedNullable: Boolean\n) : KType {\n    override fun equals(other: Any?): Boolean =\n        other is KTypeImpl &&\n                classifier == other.classifier && arguments == other.arguments && isMarkedNullable == other.isMarkedNullable\n\n    override fun hashCode(): Int =\n        (classifier.hashCode() * 31 + arguments.hashCode()) * 31 + isMarkedNullable.hashCode()\n\n    override fun toString(): String {\n        val kClass = (classifier as? KClass<*>)\n        val classifierName = when {\n            kClass == null -> classifier.toString()\n            kClass.simpleName != null -> kClass.simpleName\n            else -> \"(non-denotable type)\"\n        }\n\n        val args =\n            if (arguments.isEmpty()) \"\"\n            else arguments.joinToString(\", \", \"<\", \">\") { it.asString() }\n        val nullable = if (isMarkedNullable) \"?\" else \"\"\n\n        return classifierName + args + nullable\n    }\n\n    // TODO: this should be the implementation of KTypeProjection.toString, see KT-30071\n    private fun KTypeProjection.asString(): String {\n        if (variance == null) return \"*\"\n        return variance.prefixString() + type.toString()\n    }\n}\n\ninternal object DynamicKType : KType {\n    override val classifier: KClassifier? = null\n    override val arguments: List<KTypeProjection> = emptyList()\n    override val isMarkedNullable: Boolean = false\n    override fun toString(): String = \"dynamic\"\n}\n\ninternal fun KVariance.prefixString() =\n    when (this) {\n        KVariance.INVARIANT -> \"\"\n        KVariance.IN -> \"in \"\n        KVariance.OUT -> \"out \"\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [RegExp object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external class RegExp(pattern: String, flags: String? = definedExternally) {\n\n    public fun test(str: String): Boolean\n\n    public fun exec(str: String): RegExpMatch?\n\n    public override fun toString(): String\n\n    /**\n     * The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.\n     */\n    public var lastIndex: Int\n\n    public val global: Boolean\n    public val ignoreCase: Boolean\n    public val multiline: Boolean\n}\n\n/**\n * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the beginning of the input string.\n */\npublic fun RegExp.reset() {\n    lastIndex = 0\n}\n\n// TODO: Inherit from array or introduce asArray() extension\n/**\n * Represents the return value of [RegExp.exec].\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external interface RegExpMatch {\n    public val index: Int\n    public val input: String\n    public val length: Int\n}\n\n/**\n * Returns the entire text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis\n * at the given index.\n */\npublic inline operator fun RegExpMatch.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Converts the result of [RegExp.exec] to an array where the first element contains the entire matched text and each subsequent\n * element is the text matched by each capturing parenthesis.\n */\npublic inline fun RegExpMatch.asArray(): Array<out String?> = unsafeCast<Array<out String?>>()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n *\n * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull].\n */\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    char < '\\u0080' -> -1\n    char >= '\\uFF21' && char <= '\\uFF3A' -> char - '\\uFF21' + 10 // full-width latin capital letter\n    char >= '\\uFF41' && char <= '\\uFF5A' -> char - '\\uFF41' + 10 // full-width latin small letter\n    else -> char.digitToIntImpl()\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Provides enumeration values to use to set regular expression options.\n */\npublic actual enum class RegexOption(val value: String) {\n    /** Enables case-insensitive matching. */\n    IGNORE_CASE(\"i\"),\n    /** Enables multiline mode.\n     *\n     * In multiline mode the expressions `^` and `$` match just after or just before,\n     * respectively, a line terminator or the end of the input sequence. */\n    MULTILINE(\"m\")\n}\n\nprivate fun Iterable<RegexOption>.toFlags(prepend: String): String = joinToString(\"\", prefix = prepend) { it.value }\n\n\n/**\n * Represents the results from a single capturing group within a [MatchResult] of [Regex].\n *\n * @param value The value of captured group.\n */\npublic actual data class MatchGroup(actual val value: String)\n\n\n/**\n * Represents a compiled regular expression.\n * Provides functions to match strings in text with a pattern, replace the found occurrences and split text around matches.\n *\n * For pattern syntax reference see [MDN RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions)\n * and [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](https://www.w3schools.com/jsref/jsref_obj_regexp.asp).\n *\n * @constructor Creates a regular expression from the specified [pattern] string and the specified set of [options].\n */\npublic actual class Regex actual constructor(pattern: String, options: Set<RegexOption>) {\n\n    /** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n    public actual constructor(pattern: String, option: RegexOption) : this(pattern, setOf(option))\n\n    /** Creates a regular expression from the specified [pattern] string and the default options.  */\n    public actual constructor(pattern: String) : this(pattern, emptySet())\n\n\n    /** The pattern string of this regular expression. */\n    public actual val pattern: String = pattern\n    /** The set of options that were used to create this regular expression. */\n    public actual val options: Set<RegexOption> = options.toSet()\n    private val nativePattern: RegExp = RegExp(pattern, options.toFlags(\"gu\"))\n    private var nativeStickyPattern: RegExp? = null\n    private fun initStickyPattern(): RegExp =\n        nativeStickyPattern ?: RegExp(pattern, options.toFlags(\"yu\")).also { nativeStickyPattern = it }\n\n\n    /** Indicates whether the regular expression matches the entire [input]. */\n    public actual infix fun matches(input: CharSequence): Boolean {\n        nativePattern.reset()\n        val match = nativePattern.exec(input.toString())\n        return match != null && match.index == 0 && nativePattern.lastIndex == input.length\n    }\n\n    /** Indicates whether the regular expression can find at least one match in the specified [input]. */\n    public actual fun containsMatchIn(input: CharSequence): Boolean {\n        nativePattern.reset()\n        return nativePattern.test(input.toString())\n    }\n\n    @SinceKotlin(\"1.5\")\n    @ExperimentalStdlibApi\n    public actual fun matchesAt(input: CharSequence, index: Int): Boolean {\n        if (index < 0 || index > input.length) {\n            throw IndexOutOfBoundsException(\"index out of bounds: $index, input length: ${input.length}\")\n        }\n        val pattern = initStickyPattern()\n        pattern.lastIndex = index\n        return pattern.test(input.toString())\n    }\n\n    /**\n     * Returns the first match of a regular expression in the [input], beginning at the specified [startIndex].\n     *\n     * @param startIndex An index to start search with, by default 0. Must be not less than zero and not greater than `input.length()`\n     * @return An instance of [MatchResult] if match was found or `null` otherwise.\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     * @sample samples.text.Regexps.find\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun find(input: CharSequence, startIndex: Int = 0): MatchResult? {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return nativePattern.findNext(input.toString(), startIndex)\n    }\n\n    /**\n     * Returns a sequence of all occurrences of a regular expression within the [input] string, beginning at the specified [startIndex].\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     *\n     * @sample samples.text.Regexps.findAll\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence<MatchResult> {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return generateSequence({ find(input, startIndex) }, { match -> match.next() })\n    }\n\n    /**\n     * Attempts to match the entire [input] CharSequence against the pattern.\n     *\n     * @return An instance of [MatchResult] if the entire input matches or `null` otherwise.\n     */\n    public actual fun matchEntire(input: CharSequence): MatchResult? {\n        if (pattern.startsWith('^') && pattern.endsWith('$'))\n            return find(input)\n        else\n            return Regex(\"^${pattern.trimStart('^').trimEnd('$')}$\", options).find(input)\n    }\n\n    @SinceKotlin(\"1.5\")\n    @ExperimentalStdlibApi\n    public actual fun matchAt(input: CharSequence, index: Int): MatchResult? {\n        if (index < 0 || index > input.length) {\n            throw IndexOutOfBoundsException(\"index out of bounds: $index, input length: ${input.length}\")\n        }\n        return initStickyPattern().findNext(input.toString(), index)\n    }\n\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replace(input: CharSequence, replacement: String): String = input.toString().nativeReplace(nativePattern, replacement)\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with the result of\n     * the given function [transform] that takes [MatchResult] and returns a string to be used as a\n     * replacement for that match.\n     */\n    public actual inline fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String {\n        var match = find(input)\n        if (match == null) return input.toString()\n\n        var lastStart = 0\n        val length = input.length\n        val sb = StringBuilder(length)\n        do {\n            val foundMatch = match!!\n            sb.append(input, lastStart, foundMatch.range.start)\n            sb.append(transform(foundMatch))\n            lastStart = foundMatch.range.endInclusive + 1\n            match = foundMatch.next()\n        } while (lastStart < length && match != null)\n\n        if (lastStart < length) {\n            sb.append(input, lastStart, length)\n        }\n\n        return sb.toString()\n    }\n\n    /**\n     * Replaces the first occurrence of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replaceFirst(input: CharSequence, replacement: String): String {\n        val nonGlobalOptions = options.map { it.value }.joinToString(separator = \"\")\n        return input.toString().nativeReplace(RegExp(pattern, nonGlobalOptions), replacement)\n    }\n\n    /**\n     * Splits the [input] CharSequence to a list of strings around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun split(input: CharSequence, limit: Int = 0): List<String> {\n        requireNonNegativeLimit(limit)\n        val matches = findAll(input).let { if (limit == 0) it else it.take(limit - 1) }\n        val result = mutableListOf<String>()\n        var lastStart = 0\n\n        for (match in matches) {\n            result.add(input.subSequence(lastStart, match.range.start).toString())\n            lastStart = match.range.endInclusive + 1\n        }\n        result.add(input.subSequence(lastStart, input.length).toString())\n        return result\n    }\n\n    /**\n     * Splits the [input] CharSequence to a sequence of strings around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @SinceKotlin(\"1.5\")\n    @ExperimentalStdlibApi\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun splitToSequence(input: CharSequence, limit: Int = 0): Sequence<String> {\n        requireNonNegativeLimit(limit)\n\n        return sequence {\n            var match = find(input)\n            if (match == null || limit == 1) {\n                yield(input.toString())\n                return@sequence\n            }\n\n            var nextStart = 0\n            var splitCount = 0\n\n            do {\n                val foundMatch = match!!\n                yield(input.substring(nextStart, foundMatch.range.first))\n                nextStart = foundMatch.range.endInclusive + 1\n                match = foundMatch.next()\n            } while (++splitCount != limit - 1 && match != null)\n\n            yield(input.substring(nextStart, input.length))\n        }\n    }\n\n\n    /**\n     * Returns the string representation of this regular expression, namely the [pattern] of this regular expression.\n     *\n     * Note that another regular expression constructed from the same pattern string may have different [options]\n     * and may match strings differently.\n     */\n    public override fun toString(): String = nativePattern.toString()\n\n    actual companion object {\n        /**\n         * Returns a regular expression that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun fromLiteral(literal: String): Regex = Regex(escape(literal))\n\n        /**\n         * Returns a regular expression pattern string that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun escape(literal: String): String = literal.nativeReplace(patternEscape, \"\\\\$&\")\n\n        /**\n         * Returns a literal replacement expression for the specified [literal] string.\n         * No characters of that string will have special meaning when it is used as a replacement string in [Regex.replace] function.\n         */\n        public actual fun escapeReplacement(literal: String): String = literal.nativeReplace(replacementEscape, \"$$$$\")\n\n        private val patternEscape = RegExp(\"\"\"[\\\\^$*+?.()|[\\]{}]\"\"\", \"g\")\n        private val replacementEscape = RegExp(\"\"\"\\$\"\"\", \"g\")\n    }\n}\n\n/** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_sb3q2\\$\")\npublic fun Regex_0(pattern: String, option: RegexOption): Regex = Regex(pattern, setOf(option))\n\n/** Creates a regular expression from the specified [pattern] string and the default options.  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_61zpoe\\$\")\npublic fun Regex_1(pattern: String): Regex = Regex(pattern, emptySet())\n\n\n\n\nprivate fun RegExp.findNext(input: String, from: Int): MatchResult? {\n    this.lastIndex = from\n    val match = exec(input)\n    if (match == null) return null\n    val range = match.index..lastIndex - 1\n\n    return object : MatchResult {\n        override val range: IntRange = range\n        override val value: String\n            get() = match[0]!!\n\n        override val groups: MatchGroupCollection = object : MatchGroupCollection, AbstractCollection<MatchGroup?>() {\n            override val size: Int get() = match.length\n            override fun iterator(): Iterator<MatchGroup?> = indices.asSequence().map { this[it] }.iterator()\n            override fun get(index: Int): MatchGroup? = match[index]?.let { MatchGroup(it) }\n        }\n\n\n        private var groupValues_: List<String>? = null\n\n        override val groupValues: List<String>\n            get() {\n                if (groupValues_ == null) {\n                    groupValues_ = object : AbstractList<String>() {\n                        override val size: Int get() = match.length\n                        override fun get(index: Int): String = match[index] ?: \"\"\n                    }\n                }\n                return groupValues_!!\n            }\n\n        override fun next(): MatchResult? = this@findNext.findNext(input, if (range.isEmpty()) range.start + 1 else range.endInclusive + 1)\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\npublic fun String.matches(regex: String): Boolean {\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || (if (this is String) this else this.toString()).matches(\"^[\\\\s\\\\xA0]+$\")\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean =\n    when {\n        this == null -> other == null\n        !ignoreCase -> this == other\n        other == null -> false\n        else -> {\n            val thisLower = this.lowercase()\n            val otherLower = other.lowercase()\n            thisLower == otherLower || (thisLower.uppercase() == otherLower.uppercase())\n        }\n    }\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).uppercase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).lowercase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n * @sample samples.text.Strings.repeat\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n/**\n * Returns a new string obtained by replacing all occurrences of the [oldValue] substring in this string\n * with the specified [newValue] string.\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gui\" else \"gu\"), Regex.escapeReplacement(newValue))\n\n/**\n * Returns a new string with all occurrences of [oldChar] replaced with [newChar].\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gui\" else \"gu\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"ui\" else \"u\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"ui\" else \"u\"), newChar.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic actual enum class DurationUnit(internal val scale: Double) {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS(1e0),\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS(1e3),\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS(1e6),\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS(1e9),\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES(60e9),\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS(3600e9),\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS(86400e9);\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal actual fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> value * (sourceUnit.scale / targetUnit.scale)\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale)\n        else -> value\n    }\n}\n\n@SinceKotlin(\"1.5\")\n@ExperimentalTime\ninternal actual fun convertDurationUnitOverflow(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> value * (sourceUnit.scale / targetUnit.scale).toLong()\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale).toLong()\n        else -> value\n    }\n}\n\n@SinceKotlin(\"1.5\")\n@ExperimentalTime\ninternal actual fun convertDurationUnit(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> {\n            val scale = (sourceUnit.scale / targetUnit.scale).toLong()\n            val result = value * scale\n            when {\n                result / scale == value -> result\n                value > 0 -> Long.MAX_VALUE\n                else -> Long.MIN_VALUE\n            }\n        }\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale).toLong()\n        else -> value\n    }\n}\n\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport org.w3c.performance.GlobalPerformance\nimport org.w3c.performance.Performance\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal actual object MonotonicTimeSource : TimeSource {\n\n    private val actualSource: TimeSource = run {\n        val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n\n        if (isNode)\n            HrTimeSource(js(\"process\").unsafeCast<Process>())\n        else\n            js(\"self\").unsafeCast<GlobalPerformance?>()?.performance?.let(::PerformanceTimeSource)\n                ?: DateNowTimeSource\n\n    }\n\n    override fun markNow(): TimeMark = actualSource.markNow()\n}\n\ninternal external interface Process {\n    fun hrtime(time: Array<Double> = definedExternally): Array<Double>\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal class HrTimeSource(val process: Process) : TimeSource {\n\n    override fun markNow(): TimeMark = object : TimeMark() {\n        val startedAt = process.hrtime()\n        override fun elapsedNow(): Duration =\n            process.hrtime(startedAt).let { (seconds, nanos) -> Duration.seconds(seconds) + Duration.nanoseconds(nanos) }\n    }\n\n    override fun toString(): String = \"TimeSource(process.hrtime())\"\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal class PerformanceTimeSource(val performance: Performance) : AbstractDoubleTimeSource(unit = DurationUnit.MILLISECONDS) {\n    override fun read(): Double = performance.now()\n    override fun toString(): String = \"TimeSource(self.performance.now())\"\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal object DateNowTimeSource : AbstractDoubleTimeSource(unit = DurationUnit.MILLISECONDS) {\n    override fun read(): Double = kotlin.js.Date.now()\n    override fun toString(): String = \"TimeSource(Date.now())\"\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.js.json\nimport kotlin.math.*\n\ninternal actual fun formatToExactDecimals(value: Double, decimals: Int): String {\n    val rounded = if (decimals == 0) {\n        value\n    } else {\n        val pow = 10.0.pow(decimals)\n        JsMath.round(abs(value) * pow) / pow * sign(value)\n    }\n    return if (abs(rounded) < 1e21) {\n        // toFixed switches to scientific format after 1e21\n        rounded.asDynamic().toFixed(decimals).unsafeCast<String>()\n    } else {\n        // toPrecision outputs the specified number of digits, but only for positive numbers\n        val positive = abs(rounded)\n        val positiveString = positive.asDynamic().toPrecision(ceil(log10(positive)) + decimals).unsafeCast<String>()\n        if (rounded < 0) \"-$positiveString\" else positiveString\n    }\n}\n\ninternal actual fun formatUpToDecimals(value: Double, decimals: Int): String {\n    return value.asDynamic().toLocaleString(\"en-us\", json(\"maximumFractionDigits\" to decimals)).unsafeCast<String>()\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] that wraps each element produced by the original iterator\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(checkIndexOverflow(index++), iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'sequence { }' function instead.\", ReplaceWith(\"sequence(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildSequence(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(builderAction) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'iterator { }' function instead.\", ReplaceWith(\"iterator(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildIterator(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Iterator<T> = iterator(builderAction)\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\n@Deprecated(\"Use SequenceScope class instead.\", ReplaceWith(\"SequenceScope<T>\"), level = DeprecationLevel.ERROR)\npublic typealias SequenceBuilder<T> = SequenceScope<T>\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     *\n     * @sample samples.random.Randoms.nextBits\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextInt\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextLong\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + nextInt()\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     *\n     * @sample samples.random.Randoms.nextBoolean\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextDouble\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextFloat\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random(), Serializable {\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        private object Serialized : Serializable {\n            private const val serialVersionUID = 0L\n\n            private fun readResolve(): Any = Random\n        }\n\n        private fun writeReplace(): Any = Serialized\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray =\n            defaultRandom.nextBytes(array, fromIndex, toIndex)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom internal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random(), Serializable {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n\n    private companion object {\n        private const val serialVersionUID: Long = 0L\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2  of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2]  of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass()\n@file:kotlin.jvm.JvmName(\"DurationUnitKt\")\n\npackage kotlin.time\n\n\n/**\n * The list of possible time measurement units, in which a duration can be expressed.\n *\n * The smallest time unit is [NANOSECONDS] and the largest is [DAYS], which corresponds to exactly 24 [HOURS].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic expect enum class DurationUnit {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS,\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS,\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS,\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS,\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES,\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS,\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS;\n}\n\n/** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal expect fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double\n\n// overflown result is unspecified\n@SinceKotlin(\"1.5\")\n@ExperimentalTime\ninternal expect fun convertDurationUnitOverflow(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long\n\n// overflown result is coerced in the Long range boundaries\n@SinceKotlin(\"1.5\")\n@ExperimentalTime\ninternal expect fun convertDurationUnit(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long\n\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Suppress(\"REDUNDANT_ELSE_IN_WHEN\")\ninternal fun DurationUnit.shortName(): String = when (this) {\n    DurationUnit.NANOSECONDS -> \"ns\"\n    DurationUnit.MICROSECONDS -> \"us\"\n    DurationUnit.MILLISECONDS -> \"ms\"\n    DurationUnit.SECONDS -> \"s\"\n    DurationUnit.MINUTES -> \"m\"\n    DurationUnit.HOURS -> \"h\"\n    DurationUnit.DAYS -> \"d\"\n    else -> error(\"Unknown unit: $this\")\n}\n\n@SinceKotlin(\"1.5\")\n@ExperimentalTime\ninternal fun durationUnitByShortName(shortName: String): DurationUnit = when (shortName) {\n    \"ns\" -> DurationUnit.NANOSECONDS\n    \"us\" -> DurationUnit.MICROSECONDS\n    \"ms\" -> DurationUnit.MILLISECONDS\n    \"s\" -> DurationUnit.SECONDS\n    \"m\" -> DurationUnit.MINUTES\n    \"h\" -> DurationUnit.HOURS\n    \"d\" -> DurationUnit.DAYS\n    else -> throw IllegalArgumentException(\"Unknown duration unit short name: $shortName\")\n}\n\n@SinceKotlin(\"1.5\")\n@ExperimentalTime\ninternal fun durationUnitByIsoChar(isoChar: Char, isTimeComponent: Boolean): DurationUnit =\n    when {\n        !isTimeComponent -> {\n            when (isoChar) {\n                'D' -> DurationUnit.DAYS\n                else -> throw IllegalArgumentException(\"Invalid or unsupported duration ISO non-time unit: $isoChar\")\n            }\n        }\n        else -> {\n            when (isoChar) {\n                'H' -> DurationUnit.HOURS\n                'M' -> DurationUnit.MINUTES\n                'S' -> DurationUnit.SECONDS\n                else -> throw IllegalArgumentException(\"Invalid duration ISO time unit: $isoChar\")\n            }\n        }\n    }","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n/**\n * A source of time for measuring time intervals.\n *\n * The only operation provided by the time source is [markNow]. It returns a [TimeMark], which can be used to query the elapsed time later.\n *\n * @see [measureTime]\n * @see [measureTimedValue]\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic interface TimeSource {\n    /**\n     * Marks a point in time on this time source.\n     *\n     * The returned [TimeMark] instance encapsulates the captured time point and allows querying\n     * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point.\n     */\n    public fun markNow(): TimeMark\n\n    /**\n     * The most precise time source available in the platform.\n     *\n     * This time source returns its readings from a source of monotonic time when it is available in a target platform,\n     * and resorts to a non-monotonic time source otherwise.\n     */\n    public object Monotonic : TimeSource by MonotonicTimeSource {\n        override fun toString(): String = MonotonicTimeSource.toString()\n    }\n\n\n    public companion object {\n\n    }\n}\n\n/**\n * Represents a time point notched on a particular [TimeSource]. Remains bound to the time source it was taken from\n * and allows querying for the duration of time elapsed from that point (see the function [elapsedNow]).\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class TimeMark {\n    /**\n     * Returns the amount of time passed from this mark measured with the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     */\n    public abstract fun elapsedNow(): Duration\n\n    /**\n     * Returns a time mark on the same time source that is ahead of this time mark by the specified [duration].\n     *\n     * The returned time mark is more _late_ when the [duration] is positive, and more _early_ when the [duration] is negative.\n     */\n    public open operator fun plus(duration: Duration): TimeMark = AdjustedTimeMark(this, duration)\n\n    /**\n     * Returns a time mark on the same time source that is behind this time mark by the specified [duration].\n     *\n     * The returned time mark is more _early_ when the [duration] is positive, and more _late_ when the [duration] is negative.\n     */\n    public open operator fun minus(duration: Duration): TimeMark = plus(-duration)\n\n\n    /**\n     * Returns true if this time mark has passed according to the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes behind the current point of the time source.\n     */\n    public fun hasPassedNow(): Boolean = !elapsedNow().isNegative()\n\n    /**\n     * Returns false if this time mark has not passed according to the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     * If the time source is monotonic, it can change only from `true` to `false`, namely, when the time mark becomes behind the current point of the time source.\n     */\n    public fun hasNotPassedNow(): Boolean = elapsedNow().isNegative()\n}\n\n\n@ExperimentalTime\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Deprecated(\n    \"Subtracting one TimeMark from another is not a well defined operation because these time marks could have been obtained from the different time sources.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline operator fun TimeMark.minus(other: TimeMark): Duration = throw Error(\"Operation is disallowed.\")\n\n@ExperimentalTime\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Deprecated(\n    \"Comparing one TimeMark to another is not a well defined operation because these time marks could have been obtained from the different time sources.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline operator fun TimeMark.compareTo(other: TimeMark): Int = throw Error(\"Operation is disallowed.\")\n\n\n@ExperimentalTime\nprivate class AdjustedTimeMark(val mark: TimeMark, val adjustment: Duration) : TimeMark() {\n    override fun elapsedNow(): Duration = mark.elapsedNow() - adjustment\n\n    override fun plus(duration: Duration): TimeMark = AdjustedTimeMark(mark, adjustment + duration)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal expect object MonotonicTimeSource : TimeSource\n\n/**\n * An abstract class used to implement time sources that return their readings as [Long] values in the specified [unit].\n *\n * @property unit The unit in which this time source's readings are expressed.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class AbstractLongTimeSource(protected val unit: DurationUnit) : TimeSource {\n    /**\n     * This protected method should be overridden to return the current reading of the time source expressed as a [Long] number\n     * in the unit specified by the [unit] property.\n     */\n    protected abstract fun read(): Long\n\n    private class LongTimeMark(private val startedAt: Long, private val timeSource: AbstractLongTimeSource, private val offset: Duration) : TimeMark() {\n        override fun elapsedNow(): Duration = (timeSource.read() - startedAt).toDuration(timeSource.unit) - offset\n        override fun plus(duration: Duration): TimeMark = LongTimeMark(startedAt, timeSource, offset + duration)\n    }\n\n    override fun markNow(): TimeMark = LongTimeMark(read(), this, Duration.ZERO)\n}\n\n/**\n * An abstract class used to implement time sources that return their readings as [Double] values in the specified [unit].\n *\n * @property unit The unit in which this time source's readings are expressed.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class AbstractDoubleTimeSource(protected val unit: DurationUnit) : TimeSource {\n    /**\n     * This protected method should be overridden to return the current reading of the time source expressed as a [Double] number\n     * in the unit specified by the [unit] property.\n     */\n    protected abstract fun read(): Double\n\n    private class DoubleTimeMark(private val startedAt: Double, private val timeSource: AbstractDoubleTimeSource, private val offset: Duration) : TimeMark() {\n        override fun elapsedNow(): Duration = (timeSource.read() - startedAt).toDuration(timeSource.unit) - offset\n        override fun plus(duration: Duration): TimeMark = DoubleTimeMark(startedAt, timeSource, offset + duration)\n    }\n\n    override fun markNow(): TimeMark = DoubleTimeMark(read(), this, Duration.ZERO)\n}\n\n/**\n * A time source that has programmatically updatable readings. It is useful as a predictable source of time in tests.\n *\n * The current reading value can be advanced by the specified duration amount with the operator [plusAssign]:\n *\n * ```\n * val timeSource = TestTimeSource()\n * timeSource += 10.seconds\n * ```\n *\n * Implementation note: the current reading value is stored as a [Long] number of nanoseconds,\n * thus it's capable to represent a time range of approximately 292 years.\n * Should the reading value overflow as the result of [plusAssign] operation, an [IllegalStateException] is thrown.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic class TestTimeSource : AbstractLongTimeSource(unit = DurationUnit.NANOSECONDS) {\n    private var reading: Long = 0L\n\n    override fun read(): Long = reading\n\n    /**\n     * Advances the current reading value of this time source by the specified [duration].\n     *\n     * [duration] value is rounded down towards zero when converting it to a [Long] number of nanoseconds.\n     * For example, if the duration being added is `0.6.nanoseconds`, the reading doesn't advance because\n     * the duration value is rounded to zero nanoseconds.\n     *\n     * @throws IllegalStateException when the reading value overflows as the result of this operation.\n     */\n    public operator fun plusAssign(duration: Duration) {\n        val longDelta = duration.toLong(unit)\n        reading = if (longDelta != Long.MIN_VALUE && longDelta != Long.MAX_VALUE) {\n            // when delta fits in long, add it as long\n            val newReading = reading + longDelta\n            if (reading xor longDelta >= 0 && reading xor newReading < 0) overflow(duration)\n            newReading\n        } else {\n            val delta = duration.toDouble(unit)\n            // when delta is greater than long, add it as double\n            val newReading = reading + delta\n            if (newReading > Long.MAX_VALUE || newReading < Long.MIN_VALUE) overflow(duration)\n            newReading.toLong()\n        }\n    }\n\n    private fun overflow(duration: Duration) {\n        throw IllegalStateException(\"TestTimeSource will overflow if its reading ${reading}ns is advanced by $duration.\")\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return TimeSource.Monotonic.measureTime(block)\n}\n\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun TimeSource.measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    block()\n    return mark.elapsedNow()\n}\n\n\n/**\n * Data class representing a result of executing an action, along with the duration of elapsed time interval.\n *\n * @property value the result of the action.\n * @property duration the time elapsed to execute the action.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic data class TimedValue<T>(val value: T, val duration: Duration)\n\n/**\n * Executes the given function [block] and returns an instance of [TimedValue] class, containing both\n * the result of the function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return TimeSource.Monotonic.measureTimedValue(block)\n}\n\n/**\n * Executes the given [block] and returns an instance of [TimedValue] class, containing both\n * the result of function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> TimeSource.measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    val result = block()\n    return TimedValue(result, mark.elapsedNow())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = div(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toULong()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toULong()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.mod(other.toULong()).toUInt()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = rem(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic class UIntRange(start: UInt, endInclusive: UInt) : UIntProgression(start, endInclusive, 1), ClosedRange<UInt> {\n    override val start: UInt get() = first\n    override val endInclusive: UInt get() = last\n\n    override fun contains(value: UInt): Boolean = first <= value && value <= last\n\n    /** \n     * Checks if the range is empty.\n     \n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type UInt. */\n        public val EMPTY: UIntRange = UIntRange(UInt.MAX_VALUE, UInt.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class UIntProgression\ninternal constructor(\n    start: UInt,\n    endInclusive: UInt,\n    step: Int\n) : Iterable<UInt> {\n    init {\n        if (step == 0.toInt()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: UInt = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: UInt = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    final override fun iterator(): Iterator<UInt> = UIntProgressionIterator(first, last, step)\n\n    /** \n     * Checks if the progression is empty.\n     \n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step.toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates UIntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression = UIntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `UInt`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION_ERROR\")\nprivate class UIntProgressionIterator(first: UInt, last: UInt, step: Int) : UIntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toUInt() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextUInt(): UInt {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `UByte`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UByteIterator : Iterator<UByte> {\n    final override fun next() = nextUByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUByte(): UByte\n}\n\n/** An iterator over a sequence of values of type `UShort`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UShortIterator : Iterator<UShort> {\n    final override fun next() = nextUShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUShort(): UShort\n}\n\n/** An iterator over a sequence of values of type `UInt`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UIntIterator : Iterator<UInt> {\n    final override fun next() = nextUInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUInt(): UInt\n}\n\n/** An iterator over a sequence of values of type `ULong`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class ULongIterator : Iterator<ULong> {\n    final override fun next() = nextULong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextULong(): ULong\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic class ULongRange(start: ULong, endInclusive: ULong) : ULongProgression(start, endInclusive, 1), ClosedRange<ULong> {\n    override val start: ULong get() = first\n    override val endInclusive: ULong get() = last\n\n    override fun contains(value: ULong): Boolean = first <= value && value <= last\n\n    /** \n     * Checks if the range is empty.\n     \n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type ULong. */\n        public val EMPTY: ULongRange = ULongRange(ULong.MAX_VALUE, ULong.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class ULongProgression\ninternal constructor(\n    start: ULong,\n    endInclusive: ULong,\n    step: Long\n) : Iterable<ULong> {\n    init {\n        if (step == 0.toLong()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: ULong = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: ULong = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    final override fun iterator(): Iterator<ULong> = ULongProgressionIterator(first, last, step)\n\n    /** \n     * Checks if the progression is empty.\n     \n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt()) + (step xor (step ushr 32)).toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates ULongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression = ULongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `ULong`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION_ERROR\")\nprivate class ULongProgressionIterator(first: ULong, last: ULong, step: Long) : ULongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toULong() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextULong(): ULong {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// (a - b) mod c\nprivate fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\nprivate fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toUInt())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toUInt())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toULong())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toULong())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"UStringsKt\")  // string representation of unsigned numbers\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UByte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UShort.toString(radix: Int): String = this.toInt().toString(radix)\n\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UInt.toString(radix: Int): String = this.toLong().toString(radix)\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun ULong.toString(radix: Int): String = ulongToString(this.toLong(), checkRadix(radix))\n\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByte(): UByte = toUByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByte(radix: Int): UByte = toUByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShort(): UShort = toUShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShort(radix: Int): UShort = toUShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUInt(): UInt = toUIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUInt(radix: Int): UInt = toUIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULong(): ULong = toULongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULong(radix: Int): ULong = toULongOrNull(radix) ?: numberFormatError(this)\n\n\n\n\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByteOrNull(): UByte? = toUByteOrNull(radix = 10)\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByteOrNull(radix: Int): UByte? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UByte.MAX_VALUE) return null\n    return int.toUByte()\n}\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShortOrNull(): UShort? = toUShortOrNull(radix = 10)\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShortOrNull(radix: Int): UShort? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UShort.MAX_VALUE) return null\n    return int.toUShort()\n}\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUIntOrNull(): UInt? = toUIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUIntOrNull(radix: Int): UInt? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: UInt = UInt.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n    val limitForMaxRadix = 119304647u  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toUInt()\n    var result = 0u\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULongOrNull(): ULong? = toULongOrNull(radix = 10)\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULongOrNull(radix: Int): ULong? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: ULong = ULong.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n\n    val limitForMaxRadix = 512409557603043100uL  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toULong()\n    var result = 0uL\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.minus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] array.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Set<T>.minus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] collection.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Set<T>.minus(elements: Iterable<T>): Set<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toSet()\n    if (other is Set)\n        return this.filterNotTo(LinkedHashSet<T>()) { it in other }\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(other)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] sequence.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Set<T>.minus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.minusElement(element: T): Set<T> {\n    return minus(element)\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size + 1))\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] array,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size + elements.size))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] collection,\n * which aren't already in this set.\n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Iterable<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(elements.collectionSizeOrNull()?.let { this.size + it } ?: this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] sequence,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.plusElement(element: T): Set<T> {\n    return plus(element)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.reflect.KClass\n\n@PublishedApi\ninternal fun <T : Annotation> KClass<*>.findAssociatedObject(@Suppress(\"UNUSED_PARAMETER\") annotationClass: KClass<T>): Any? {\n    // This API is not supported in js-v1. Return `null` to be source-compatible with js-ir.\n    return null\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.cancellation\n\n@SinceKotlin(\"1.4\")\npublic actual open class CancellationException : IllegalStateException {\n    actual constructor() : super()\n    actual constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport getKClass\nimport kotlin.reflect.KClass\nimport kotlin.reflect.js.internal.KClassImpl\n\n/**\n * Represents the constructor of a class. Instances of `JsClass` can be passed to JavaScript APIs that expect a constructor reference.\n */\nexternal interface JsClass<T : Any> {\n    /**\n     * Returns the unqualified name of the class represented by this instance.\n     */\n    val name: String\n}\n\n/**\n * Obtains a constructor reference for the given `KClass`.\n */\nval <T : Any> KClass<T>.js: JsClass<T>\n    get() = (this as KClassImpl<T>).jClass\n\n/**\n * Obtains a `KClass` instance for the given constructor reference.\n */\nval <T : Any> JsClass<T>.kotlin: KClass<T>\n    get() = getKClass(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n// TODO: Remove once JsReflectionAPICallChecker supports more reflection types\n@file:Suppress(\"Unsupported\")\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"createKType\")\ninternal fun createKType(\n    classifier: KClassifier,\n    arguments: Array<KTypeProjection>,\n    isMarkedNullable: Boolean\n) =\n    KTypeImpl(classifier, arguments.asList(), isMarkedNullable)\n\n@JsName(\"createDynamicKType\")\ninternal fun createDynamicKType(): KType = DynamicKType\n\n@JsName(\"markKTypeNullable\")\ninternal fun markKTypeNullable(kType: KType) = KTypeImpl(kType.classifier!!, kType.arguments, true)\n\n@JsName(\"createKTypeParameter\")\ninternal fun createKTypeParameter(\n    name: String,\n    upperBounds: Array<KType>,\n    variance: String\n): KTypeParameter {\n    val kVariance = when (variance) {\n        \"in\" -> KVariance.IN\n        \"out\" -> KVariance.OUT\n        else -> KVariance.INVARIANT\n    }\n\n    return KTypeParameterImpl(name, upperBounds.asList(), kVariance, false)\n}\n\n@JsName(\"getStarKTypeProjection\")\ninternal fun getStarKTypeProjection(): KTypeProjection =\n    KTypeProjection.STAR\n\n@JsName(\"createCovariantKTypeProjection\")\ninternal fun createCovariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.covariant(type)\n\n@JsName(\"createInvariantKTypeProjection\")\ninternal fun createInvariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.invariant(type)\n\n@JsName(\"createContravariantKTypeProjection\")\ninternal fun createContravariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.contravariant(type)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MathKt\")\n\n\npackage kotlin.math\n\n\n\n// constants, can't use them from nativeMath as they are not constants there\n\n/** Ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n@SinceKotlin(\"1.2\")\npublic const val PI: Double = 3.141592653589793\n/** Base of the natural logarithms, approximately 2.71828. */\n@SinceKotlin(\"1.2\")\npublic const val E: Double = 2.718281828459045\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Double): Double\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Double): Double\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Double): Double\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Double): Double\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Double): Double\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Double): Double\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Double, x: Double): Double\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Double): Double\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Double): Double\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Double): Double\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Double, y: Double): Double\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Double): Double\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Double): Double\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Double): Double\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Double, base: Double): Double\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Double): Double\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Double): Double\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Double): Double\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Double): Double\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Double): Double\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Double): Double\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Double): Double\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Double, b: Double): Double\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Double, b: Double): Double\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(x: Double): Double\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(n: Int): Double\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.absoluteValue: Double\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.sign: Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Double): Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Int): Double\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.ulp: Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextUp(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextDown(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextTowards(to: Double): Double\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToInt(): Int\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToLong(): Long\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Float): Float\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Float): Float\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Float): Float\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Float): Float\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Float): Float\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Float): Float\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Float, x: Float): Float\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Float): Float\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Float): Float\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Float): Float\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Float, y: Float): Float\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Float): Float\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Float): Float\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Float): Float\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Float, base: Float): Float\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Float): Float\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Float): Float\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Float): Float\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Float): Float\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Float): Float\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Float): Float\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Float): Float\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Float, b: Float): Float\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Float, b: Float): Float\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(x: Float): Float\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(n: Int): Float\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.absoluteValue: Float\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.sign: Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Float): Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Int): Float\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToInt(): Int\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToLong(): Long\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Int): Int\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Int, b: Int): Int\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Int, b: Int): Int\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.absoluteValue: Int\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.sign: Int\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Long): Long\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Long, b: Long): Long\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Long, b: Long): Long\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.absoluteValue: Long\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.sign: Int\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.native.concurrent.SharedImmutable\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces [StackOverflowError] because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\n@ExperimentalStdlibApi\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\n@SharedImmutable\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\n@ExperimentalStdlibApi\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n",null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport findAssociatedObject\n\n/**\n * The experimental marker for associated objects API.\n *\n * Any usage of a declaration annotated with `@ExperimentalAssociatedObjects` must be accepted either by\n * annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalAssociatedObjects::class)`,\n * or by using the compiler argument `-Xopt-in=kotlin.reflect.ExperimentalAssociatedObjects`.\n */\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Retention(value = AnnotationRetention.BINARY)\npublic annotation class ExperimentalAssociatedObjects\n\n/**\n * Makes the annotated annotation class an associated object key.\n *\n * An associated object key annotation should have single [KClass] parameter.\n * When applied to a class with reference to an object declaration as an argument, it binds\n * the object to the class, making this binding discoverable at runtime using [findAssociatedObject].\n */\n@ExperimentalAssociatedObjects\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.ANNOTATION_CLASS)\npublic annotation class AssociatedObjectKey\n\n/**\n * If [T] is an @[AssociatedObjectKey]-annotated annotation class and [this] class is annotated with @[T] (`S::class`),\n * returns object `S`.\n *\n * Otherwise returns `null`.\n */\n@ExperimentalAssociatedObjects\npublic inline fun <reified T : Annotation> KClass<*>.findAssociatedObject(): Any? =\n    this.findAssociatedObject(T::class)",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.internal.InlineOnly\n\n\n/**\n * Returns a hash code value for the object or zero if the object is `null`.\n *\n * @see Any.hashCode\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun Any?.hashCode(): Int = this?.hashCode() ?: 0\n",null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"GroupingKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.collections\n\n/**\n * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.\n *\n * A [Grouping] structure serves as an intermediate step in group-and-fold operations:\n * they group elements by their keys and then fold each group with some aggregating operation.\n *\n * It is created by attaching `keySelector: (T) -> K` function to a source of elements.\n * To get an instance of [Grouping] use one of `groupingBy` extension functions:\n * - [Iterable.groupingBy]\n * - [Sequence.groupingBy]\n * - [Array.groupingBy]\n * - [CharSequence.groupingBy]\n *\n * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.\n */\n@SinceKotlin(\"1.1\")\npublic interface Grouping<T, out K> {\n    /** Returns an [Iterator] over the elements of the source of this grouping. */\n    fun sourceIterator(): Iterator<T>\n    /** Extracts the key of an [element]. */\n    fun keyOf(element: T): K\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation function is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * @return a [Map] associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadix\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.aggregate(\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): Map<K, R> {\n    return aggregateTo(mutableMapOf<K, R>(), operation)\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * If the [destination] map already has a value corresponding to some key,\n * then the elements being aggregated for that key are never considered as `first`.\n *\n * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadixTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(\n    destination: M,\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): M {\n    for (e in this.sourceIterator()) {\n        val key = keyOf(e)\n        val accumulator = destination[key]\n        destination[key] = operation(key, accumulator, e, accumulator == null && !destination.containsKey(key))\n    }\n    return destination\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * If the [destination] map already has a value corresponding to some key, that value is used as an initial value of\n * the accumulator for that group and the [initialValueSelector] function is not called for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in a new map.\n * An initial value of accumulator is the first element of the group.\n *\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowels\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K> Grouping<T, K>.reduce(\n    operation: (key: K, accumulator: S, element: T) -> S\n): Map<K, S> =\n    aggregate { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the first element of the group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group and the first element of that group is also\n * subjected to the [operation].\n\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being folded;\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowelsTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T, K>.reduceTo(\n    destination: M,\n    operation: (key: K, accumulator: S, element: T) -> S\n): M =\n    aggregateTo(destination) { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n\n/**\n * Groups elements from the [Grouping] source by key and counts elements in each group to the given [destination] map.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the counter for that group.\n *\n * @return the [destination] map associating the key of each group with the count of elements in the group.\n *\n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M): M =\n    foldTo(destination, 0) { acc, _ -> acc + 1 }\n\n/*\n/**\n * Groups elements from the [Grouping] source by key and sums values provided by the [valueSelector] function for elements in each group\n * to the given [destination] map.\n *\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the sum for that group.\n *\n * @return the [destination] map associating the key of each group with the sum of elements in the group.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachSumOfTo(destination: M, valueSelector: (T) -> Int): M =\n        foldTo(destination, 0) { acc, e -> acc + valueSelector(e)}\n*/\n\n\n/*\n// TODO: sum by long and by double overloads\n\npublic inline fun <T, K, M : MutableMap<in K, Long>> Grouping<T, K>.sumEachByLongTo(destination: M, valueSelector: (T) -> Long): M =\n        foldTo(destination, 0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByLong(valueSelector: (T) -> Long): Map<K, Long> =\n        fold(0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K, M : MutableMap<in K, Double>> Grouping<T, K>.sumEachByDoubleTo(destination: M, valueSelector: (T) -> Double): M =\n        foldTo(destination, 0.0) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByDouble(valueSelector: (T) -> Double): Map<K, Double> =\n        fold(0.0) { acc, e -> acc + valueSelector(e)}\n*/\n",null,null,null,null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOf(transform: (Map.Entry<K, V>) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the map was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOfOrNull(transform: (Map.Entry<K, V>) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"package world.phantasmal.web.assemblyWorker\n\nimport world.phantasmal.core.*\nimport world.phantasmal.psolib.asm.*\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.ValueSet\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.getMapDesignations\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.getStackValue\nimport world.phantasmal.web.shared.messages.*\nimport world.phantasmal.web.shared.messages.AssemblyProblem\nimport kotlin.math.max\nimport kotlin.math.min\nimport world.phantasmal.psolib.asm.AssemblyProblem as LibAssemblyProblem\n\nclass AsmAnalyser {\n    // User input.\n    private var inlineStackArgs: Boolean = true\n    private val asm: JsArray<String> = jsArrayOf()\n\n    // Output.\n    private var bytecodeIr = BytecodeIr(emptyList())\n    private var problems: List<AssemblyProblem>? = null\n\n    // Derived data.\n    private var _cfg: ControlFlowGraph? = null\n    private val cfg: ControlFlowGraph\n        get() {\n            if (_cfg == null) _cfg = ControlFlowGraph.create(bytecodeIr)\n            return _cfg!!\n        }\n\n    private var mapDesignations: Map<Int, Int>? = null\n\n    fun setAsm(asm: List<String>, inlineStackArgs: Boolean) {\n        this.inlineStackArgs = inlineStackArgs\n        this.asm.splice(0, this.asm.length, *asm.toTypedArray())\n        mapDesignations = null\n    }\n\n    fun updateAsm(changes: List<AsmChange>) {\n        for (change in changes) {\n            val (startLineNo, startCol, endLineNo, endCol) = change.range\n            val linesChanged = endLineNo - startLineNo + 1\n            val newLines = change.newAsm.split(\"\\n\").toJsArray()\n\n            when {\n                linesChanged == 1 -> {\n                    replaceLinePart(startLineNo, startCol, endCol, newLines)\n                }\n\n                newLines.length == 1 -> {\n                    replaceLinesAndMergeLineParts(\n                        startLineNo,\n                        endLineNo,\n                        startCol,\n                        endCol,\n                        newLines[0],\n                    )\n                }\n\n                else -> {\n                    // Keep the left part of the first changed line.\n                    replaceLinePartRight(startLineNo, startCol, newLines[0])\n\n                    // Keep the right part of the last changed line.\n                    replaceLinePartLeft(endLineNo, endCol, newLines[newLines.length - 1])\n\n                    // Replace all the lines in between.\n                    // It's important that we do this last.\n                    replaceLines(\n                        startLineNo + 1,\n                        endLineNo - 1,\n                        newLines.slice(1, newLines.length - 1),\n                    )\n                }\n            }\n        }\n    }\n\n    private fun replaceLinePart(\n        lineNo: Int,\n        startCol: Int,\n        endCol: Int,\n        newLineParts: JsArray<String>,\n    ) {\n        val line = asm[lineNo - 1]\n        // We keep the parts of the line that weren't affected by the edit.\n        val lineStart = line.substring(0, startCol - 1)\n        val lineEnd = line.substring(endCol - 1)\n\n        if (newLineParts.length == 1) {\n            asm[lineNo - 1] = lineStart + newLineParts[0] + lineEnd\n        } else {\n            asm.splice(\n                lineNo - 1,\n                1,\n                lineStart + newLineParts[0],\n                *newLineParts.slice(1, newLineParts.length - 1).asArray(),\n                newLineParts[newLineParts.length - 1] + lineEnd,\n            )\n        }\n    }\n\n    private fun replaceLinePartLeft(lineNo: Int, endCol: Int, newLinePart: String) {\n        asm[lineNo - 1] = newLinePart + asm[lineNo - 1].substring(endCol - 1)\n    }\n\n    private fun replaceLinePartRight(lineNo: Int, startCol: Int, newLinePart: String) {\n        asm[lineNo - 1] = asm[lineNo - 1].substring(0, startCol - 1) + newLinePart\n    }\n\n    private fun replaceLines(startLineNo: Int, endLineNo: Int, newLines: JsArray<String>) {\n        asm.splice(startLineNo - 1, endLineNo - startLineNo + 1, *newLines.asArray())\n    }\n\n    private fun replaceLinesAndMergeLineParts(\n        startLineNo: Int,\n        endLineNo: Int,\n        startCol: Int,\n        endCol: Int,\n        newLinePart: String,\n    ) {\n        val startLine = asm[startLineNo - 1]\n        val endLine = asm[endLineNo - 1]\n        // We keep the parts of the lines that weren't affected by the edit.\n        val startLineStart = startLine.substring(0, startCol - 1)\n        val endLineEnd = endLine.substring(endCol - 1)\n\n        asm.splice(\n            startLineNo - 1,\n            endLineNo - startLineNo + 1,\n            startLineStart + newLinePart + endLineEnd,\n        )\n    }\n\n    fun processAsm(): List<ServerNotification> {\n        _cfg = null\n\n        val notifications = mutableListOf<ServerNotification>()\n        val assemblyResult = assemble(asm.asArray().toList(), inlineStackArgs)\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val problems =\n            (assemblyResult.problems as List<LibAssemblyProblem>).map {\n                AssemblyProblem(it.severity, it.uiMessage, it.lineNo, it.col, it.len)\n            }\n\n        if (problems != this.problems) {\n            this.problems = problems\n            notifications.add(ServerNotification.Problems(problems))\n        }\n\n        if (assemblyResult is Success) {\n            bytecodeIr = assemblyResult.value\n\n            val instructionSegments = bytecodeIr.instructionSegments()\n\n            instructionSegments.find { 0 in it.labels }?.let { label0Segment ->\n                val designations = getMapDesignations(label0Segment) { cfg }\n\n                if (designations != mapDesignations) {\n                    mapDesignations = designations\n                    notifications.add(\n                        ServerNotification.MapDesignations(designations)\n                    )\n                }\n            }\n        }\n\n        return notifications\n    }\n\n    fun getCompletions(requestId: Int, lineNo: Int, col: Int): Response.GetCompletions {\n        val text = getLine(lineNo)?.take(col)?.trim()?.lowercase() ?: \"\"\n\n        val completions: List<CompletionItem> = when {\n            KEYWORD_REGEX.matches(text) -> KEYWORD_SUGGESTIONS\n\n            INSTRUCTION_REGEX.matches(text) -> {\n                val suggestions = INSTRUCTION_SUGGESTIONS.asSequence()\n                val startingWith = suggestions.filter { it.label.startsWith(text) }\n                val containing = suggestions.filter { it.label.contains(text) }\n\n                (startingWith + containing)\n                    .take(20)\n                    .toList()\n            }\n\n            else -> emptyList()\n        }\n\n        return Response.GetCompletions(requestId, completions)\n    }\n\n    fun getSignatureHelp(requestId: Int, lineNo: Int, col: Int): Response.GetSignatureHelp =\n        Response.GetSignatureHelp(requestId, signatureHelp(lineNo, col))\n\n    private fun signatureHelp(lineNo: Int, col: Int): SignatureHelp? {\n        var signature: Signature? = null\n        var activeParam = -1\n\n        getInstructionForSrcLoc(lineNo, col)?.let { result ->\n            signature = getSignature(result.inst.opcode)\n            activeParam = result.paramIdx\n        }\n\n        return signature?.let { sig ->\n            SignatureHelp(\n                signature = sig,\n                activeParameter = activeParam,\n            )\n        }\n    }\n\n    fun getHover(requestId: Int, lineNo: Int, col: Int): Response.GetHover {\n        val hover = signatureHelp(lineNo, col)?.let { help ->\n            val sig = help.signature\n            val param = sig.parameters.getOrNull(help.activeParameter)\n\n            val contents = mutableListOf<String>()\n\n            // Instruction signature. Parameter highlighted if possible.\n            contents.add(\n                if (param == null) {\n                    sig.label\n                } else {\n                    // TODO: Figure out how to underline the active parameter in addition to\n                    //  bolding it to make it match the look of the signature help.\n                    sig.label.substring(0, param.labelStart) +\n                            \"__\" +\n                            sig.label.substring(param.labelStart, param.labelEnd) +\n                            \"__\" +\n                            sig.label.substring(param.labelEnd)\n                }\n            )\n\n            // Put the parameter doc and the instruction doc in the same string to match the look of\n            // the signature help.\n            var doc = \"\"\n\n            // Parameter doc.\n            if (param?.documentation != null) {\n                doc += param.documentation\n\n                // TODO: Figure out how add an empty line here to make it match the look of the\n                //  signature help.\n                doc += \"\\n\\n\"\n            }\n\n            // Instruction doc.\n            sig.documentation?.let { doc += it }\n\n            if (doc.isNotEmpty()) {\n                contents.add(doc)\n            }\n\n            Hover(contents)\n        }\n\n        return Response.GetHover(requestId, hover)\n    }\n\n    fun getDefinition(requestId: Int, lineNo: Int, col: Int): Response.GetDefinition {\n        var result = emptyList<AsmRange>()\n\n        getInstructionForSrcLoc(lineNo, col)?.inst?.let { inst ->\n            visitLabelArguments(\n                inst,\n                accept = { argSrcLoc -> positionInside(lineNo, col, argSrcLoc.coarse) },\n                processImmediateArg = { label, _ ->\n                    result = getLabelDefinitionsAndReferences(label, references = false)\n                    VisitAction.Return\n                },\n                processStackArg = { labels, _, _ ->\n                    if (labels.size <= 5) {\n                        result = labels.flatMap {\n                            getLabelDefinitionsAndReferences(it, references = false)\n                        }\n                    }\n\n                    VisitAction.Return\n                },\n            )\n        }\n\n        return Response.GetDefinition(requestId, result)\n    }\n\n    fun getLabels(requestId: Int): Response.GetLabels {\n        val result = bytecodeIr.segments.asSequence()\n            .flatMap { segment ->\n                segment.labels.mapIndexed { labelIdx, label ->\n                    val range = segment.srcLoc.labels[labelIdx].toAsmRange()\n                    Label(name = label, range)\n                }\n            }\n            .toList()\n\n        return Response.GetLabels(requestId, result)\n    }\n\n    fun getHighlights(requestId: Int, lineNo: Int, col: Int): Response.GetHighlights {\n        val results = mutableListOf<AsmRange>()\n\n        when (val ir = getIrForSrcLoc(lineNo, col)) {\n            is Ir.Label -> {\n                results.addAll(getLabelDefinitionsAndReferences(ir.label))\n            }\n\n            is Ir.Inst -> {\n                val srcLoc = ir.inst.srcLoc?.mnemonic\n\n                if (ir.paramIdx == -1 ||\n                    // Also return this instruction if we're right past the mnemonic. E.g. at the\n                    // first whitespace character preceding the first argument.\n                    (srcLoc != null && col <= srcLoc.col + srcLoc.len)\n                ) {\n                    // Find all instructions with the same opcode.\n                    for (segment in bytecodeIr.segments) {\n                        if (segment is InstructionSegment) {\n                            for (inst in segment.instructions) {\n                                if (inst.opcode.code == ir.inst.opcode.code) {\n                                    inst.srcLoc?.mnemonic?.toAsmRange()?.let(results::add)\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    visitArgs(\n                        ir.inst,\n                        processParam = { VisitAction.Go },\n                        processImmediateArg = { param, arg, argSrcLoc ->\n                            if (positionInside(lineNo, col, argSrcLoc.coarse)) {\n                                (arg as? IntArg)?.let {\n                                    when (param.type) {\n                                        is LabelType -> {\n                                            results.addAll(\n                                                getLabelDefinitionsAndReferences(arg.value)\n                                            )\n                                        }\n                                        is RegRefType -> {\n                                            results.addAll(getRegisterReferences(arg.value))\n                                        }\n                                        else -> Unit\n                                    }\n                                }\n\n                                VisitAction.Return\n                            } else {\n                                VisitAction.Continue\n                            }\n                        },\n                        processStackArgSrcLoc = { _, argSrcLoc ->\n                            if (positionInside(lineNo, col, argSrcLoc.coarse)) {\n                                VisitAction.Go\n                            } else {\n                                VisitAction.Continue\n                            }\n                        },\n                        processStackArg = { param, _, pushInst, _ ->\n                            if (pushInst != null) {\n                                val pushArg = pushInst.args.firstOrNull()\n\n                                if (pushArg is IntArg) {\n                                    if (pushInst.opcode.code == OP_ARG_PUSHR.code ||\n                                        param.type is RegRefType\n                                    ) {\n                                        results.addAll(getRegisterReferences(pushArg.value))\n                                    } else if (param.type is LabelType) {\n                                        results.addAll(\n                                            getLabelDefinitionsAndReferences(pushArg.value)\n                                        )\n                                    }\n                                }\n                            }\n\n                            VisitAction.Return\n                        }\n                    )\n                }\n            }\n        }\n\n        return Response.GetHighlights(requestId, results)\n    }\n\n    private fun getInstructionForSrcLoc(lineNo: Int, col: Int): Ir.Inst? =\n        getIrForSrcLoc(lineNo, col) as? Ir.Inst\n\n    private fun getIrForSrcLoc(lineNo: Int, col: Int): Ir? {\n        for (segment in bytecodeIr.segments) {\n            for ((index, srcLoc) in segment.srcLoc.labels.withIndex()) {\n                if (srcLoc.lineNo == lineNo &&\n                    col >= srcLoc.col &&\n                    col < srcLoc.col + srcLoc.len\n                ) {\n                    return Ir.Label(segment.labels[index])\n                }\n            }\n\n            if (segment is InstructionSegment) {\n                // Loop over instructions in reverse order so stack popping instructions will be\n                // handled before the related stack pushing instructions when inlineStackArgs is on.\n                for (i in segment.instructions.lastIndex downTo 0) {\n                    val inst = segment.instructions[i]\n\n                    inst.srcLoc?.let { srcLoc ->\n                        var instLineNo = -1\n                        var lastCol = -1\n\n                        srcLoc.mnemonic?.let { mnemonicSrcLoc ->\n                            instLineNo = mnemonicSrcLoc.lineNo\n                            lastCol = mnemonicSrcLoc.col + mnemonicSrcLoc.len\n\n                            if (positionInside(lineNo, col, mnemonicSrcLoc)) {\n                                return Ir.Inst(inst, paramIdx = -1)\n                            }\n                        }\n\n                        for ((argIdx, argSrcLoc) in srcLoc.args.withIndex()) {\n                            instLineNo = argSrcLoc.coarse.lineNo\n                            lastCol = argSrcLoc.coarse.col + argSrcLoc.coarse.len\n\n                            if (positionInside(lineNo, col, argSrcLoc.coarse)) {\n                                return Ir.Inst(inst, argIdx)\n                            }\n                        }\n\n                        if (lineNo == instLineNo && col >= lastCol) {\n                            val argIdx = max(0, srcLoc.args.lastIndex) +\n                                    (if (srcLoc.trailingArgSeparator) 1 else 0)\n\n                            val paramIdx = min(argIdx, inst.opcode.params.lastIndex)\n\n                            return Ir.Inst(inst, paramIdx)\n                        }\n                    }\n                }\n            }\n        }\n\n        return null\n    }\n\n    private fun getRegisterReferences(register: Int): List<AsmRange> {\n        val results = mutableListOf<AsmRange>()\n\n        for (segment in bytecodeIr.segments) {\n            if (segment is InstructionSegment) {\n                for (inst in segment.instructions) {\n                    visitArgs(\n                        inst,\n                        processParam = { VisitAction.Go },\n                        processImmediateArg = { param, arg, argSrcLoc ->\n                            if (param.type is RegRefType &&\n                                arg is IntArg &&\n                                arg.value == register\n                            ) {\n                                results.add(argSrcLoc.precise.toAsmRange())\n                            }\n\n                            VisitAction.Go\n                        },\n                        processStackArgSrcLoc = { param, _ ->\n                            if (param.type is RegRefType) VisitAction.Go\n                            else VisitAction.Continue\n                        },\n                        processStackArg = { _, _, pushInst, argSrcLoc ->\n                            if (pushInst != null &&\n                                pushInst.opcode.code != OP_ARG_PUSHR.code\n                            ) {\n                                val pushArg = pushInst.args.firstOrNull()\n\n                                if (pushArg is IntArg && pushArg.value == register) {\n                                    results.add(argSrcLoc.precise.toAsmRange())\n                                }\n                            }\n\n                            VisitAction.Go\n                        }\n                    )\n                }\n            }\n        }\n\n        return results\n    }\n\n    /**\n     * Returns all definitions and all arguments that references the given [label].\n     */\n    private fun getLabelDefinitionsAndReferences(\n        label: Int,\n        definitions: Boolean = true,\n        references: Boolean = true,\n    ): List<AsmRange> {\n        val results = mutableListOf<AsmRange>()\n\n        for (segment in bytecodeIr.segments) {\n            // Add label definitions to the results.\n            if (definitions) {\n                val labelIdx = segment.labels.indexOf(label)\n\n                if (labelIdx != -1) {\n                    segment.srcLoc.labels.getOrNull(labelIdx)?.let { srcLoc ->\n                        results.add(\n                            AsmRange(\n                                startLineNo = srcLoc.lineNo,\n                                startCol = srcLoc.col,\n                                endLineNo = srcLoc.lineNo,\n                                // Exclude the trailing \":\" character.\n                                endCol = srcLoc.col + srcLoc.len - 1,\n                            )\n                        )\n                    }\n                }\n            }\n\n            // Find all instruction arguments that reference the label.\n            if (references) {\n                if (segment is InstructionSegment) {\n                    for (inst in segment.instructions) {\n                        visitLabelArguments(\n                            inst,\n                            accept = { true },\n                            processImmediateArg = { labelArg, argSrcLoc ->\n                                if (labelArg == label) {\n                                    results.add(argSrcLoc.precise.toAsmRange())\n                                }\n\n                                VisitAction.Go\n                            },\n                            processStackArg = { labelArg, pushInst, argSrcLoc ->\n                                // Filter out arg_pushr labels, because register values could be\n                                // used for anything.\n                                if (pushInst != null &&\n                                    pushInst.opcode.code != OP_ARG_PUSHR.code &&\n                                    labelArg.size == 1L &&\n                                    label in labelArg\n                                ) {\n                                    results.add(argSrcLoc.precise.toAsmRange())\n                                }\n\n                                VisitAction.Go\n                            },\n                        )\n                    }\n                }\n            }\n        }\n\n        return results\n    }\n\n    /**\n     * Visits all label arguments of [instruction] with their value.\n     */\n    private fun visitLabelArguments(\n        instruction: Instruction,\n        accept: (ArgSrcLoc) -> Boolean,\n        processImmediateArg: (label: Int, ArgSrcLoc) -> VisitAction,\n        processStackArg: (label: ValueSet, Instruction?, ArgSrcLoc) -> VisitAction,\n    ) {\n        visitArgs(\n            instruction,\n            processParam = { if (it.type is LabelType) VisitAction.Go else VisitAction.Continue },\n            processImmediateArg = { _, arg, srcLoc ->\n                if (accept(srcLoc) && arg is IntArg) {\n                    processImmediateArg(arg.value, srcLoc)\n                } else VisitAction.Continue\n            },\n            processStackArgSrcLoc = { _, srcLoc ->\n                if (accept(srcLoc)) VisitAction.Go\n                else VisitAction.Continue\n            },\n            processStackArg = { _, value, pushInst, srcLoc ->\n                processStackArg(value, pushInst, srcLoc)\n            }\n        )\n    }\n\n    private enum class VisitAction {\n        Go, Break, Continue, Return\n    }\n\n    /**\n     * Visits all arguments of [instruction], including stack arguments.\n     */\n    private fun visitArgs(\n        instruction: Instruction,\n        processParam: (Param) -> VisitAction,\n        processImmediateArg: (Param, Arg, ArgSrcLoc) -> VisitAction,\n        processStackArgSrcLoc: (Param, ArgSrcLoc) -> VisitAction,\n        processStackArg: (Param, ValueSet, Instruction?, ArgSrcLoc) -> VisitAction,\n    ) {\n        for ((paramIdx, param) in instruction.opcode.params.withIndex()) {\n            when (processParam(param)) {\n                VisitAction.Go -> Unit // Keep going.\n                VisitAction.Break -> break // Same as Stop.\n                VisitAction.Continue -> continue\n                VisitAction.Return -> return\n            }\n\n            if (instruction.opcode.stack !== StackInteraction.Pop) {\n                // Immediate arguments.\n                val args = instruction.getArgs(paramIdx)\n                val argSrcLocs = instruction.getArgSrcLocs(paramIdx)\n\n                for (i in 0 until min(args.size, argSrcLocs.size)) {\n                    val arg = args[i]\n                    val srcLoc = argSrcLocs[i]\n\n                    when (processImmediateArg(param, arg, srcLoc)) {\n                        VisitAction.Go -> Unit // Keep going.\n                        VisitAction.Break -> break\n                        VisitAction.Continue -> continue // Same as Down.\n                        VisitAction.Return -> return\n                    }\n                }\n            } else {\n                // Stack arguments.\n                val argSrcLocs = instruction.getArgSrcLocs(paramIdx)\n\n                // Never varargs.\n                for (srcLoc in argSrcLocs) {\n                    when (processStackArgSrcLoc(param, srcLoc)) {\n                        VisitAction.Go -> Unit // Keep going.\n                        VisitAction.Break -> break\n                        VisitAction.Continue -> continue\n                        VisitAction.Return -> return\n                    }\n\n                    val (labelValues, pushInstruction) = getStackValue(\n                        cfg,\n                        instruction,\n                        instruction.opcode.params.lastIndex - paramIdx,\n                    )\n\n                    when (processStackArg(param, labelValues, pushInstruction, srcLoc)) {\n                        VisitAction.Go -> Unit // Keep going.\n                        VisitAction.Break -> break\n                        VisitAction.Continue -> continue // Same as Down.\n                        VisitAction.Return -> return\n                    }\n                }\n            }\n        }\n    }\n\n    private fun positionInside(lineNo: Int, col: Int, srcLoc: SrcLoc?): Boolean =\n        if (srcLoc == null) {\n            false\n        } else {\n            lineNo == srcLoc.lineNo && col >= srcLoc.col && col < srcLoc.col + srcLoc.len\n        }\n\n    @Suppress(\"RedundantNullableReturnType\") // Can return undefined.\n    private fun getLine(lineNo: Int): String? = asm[lineNo - 1]\n\n    private fun SrcLoc.toAsmRange(): AsmRange =\n        AsmRange(\n            startLineNo = lineNo,\n            startCol = col,\n            endLineNo = lineNo,\n            endCol = col + len,\n        )\n\n    private sealed class Ir {\n        class Label(val label: Int) : Ir()\n        class Inst(val inst: Instruction, val paramIdx: Int) : Ir()\n    }\n\n    companion object {\n        private val KEYWORD_REGEX = Regex(\"\"\"^\\s*\\.[a-z]+${'$'}\"\"\")\n        private val KEYWORD_SUGGESTIONS: List<CompletionItem> =\n            listOf(\n                CompletionItem(\n                    label = \".code\",\n                    type = CompletionItemType.Keyword,\n                    detail = null,\n                    documentation = \"Start of a code segment\",\n                    insertText = \"code\",\n                ),\n                CompletionItem(\n                    label = \".data\",\n                    type = CompletionItemType.Keyword,\n                    detail = null,\n                    documentation = \"Start of a data segment\",\n                    insertText = \"data\",\n                ),\n                CompletionItem(\n                    label = \".string\",\n                    type = CompletionItemType.Keyword,\n                    detail = null,\n                    documentation = \"Start of a string data segment\",\n                    insertText = \"string\",\n                ),\n            )\n\n        private val INSTRUCTION_REGEX = Regex(\"\"\"^\\s*([a-z][a-z0-9_=<>!]*)?${'$'}\"\"\")\n        private val INSTRUCTION_SUGGESTIONS: List<CompletionItem> =\n            (OPCODES.asSequence() + OPCODES_F8.asSequence() + OPCODES_F9.asSequence())\n                .filterNotNull()\n                .map { opcode ->\n                    val sig = getSignature(opcode)\n                    CompletionItem(\n                        label = opcode.mnemonic,\n                        type = CompletionItemType.Opcode,\n                        detail = sig.label,\n                        documentation = sig.documentation,\n                        insertText = \"${opcode.mnemonic} \",\n                    )\n                }\n                .sortedBy { it.label }\n                .toList()\n\n        private fun getSignature(opcode: Opcode): Signature {\n            val signature = StringBuilder(opcode.mnemonic).append(\" \")\n            val params = mutableListOf<Parameter>()\n            var first = true\n\n            for (param in opcode.params) {\n                if (first) {\n                    first = false\n                } else {\n                    signature.append(\", \")\n                }\n\n                val labelStart = signature.length\n\n                signature.appendParam(param)\n\n                params.add(\n                    Parameter(\n                        labelStart,\n                        labelEnd = signature.length,\n                        documentation = param.doc,\n                    )\n                )\n            }\n\n            return Signature(\n                label = signature.toString(),\n                documentation = opcode.doc,\n                parameters = params,\n            )\n        }\n\n        private fun StringBuilder.appendParam(param: Param) {\n            if (param.read || param.write) {\n                if (param.read) append(\"in\")\n                if (param.write) append(\"out\")\n                append(\" \")\n            }\n\n            when (val type = param.type) {\n                AnyType.Instance -> append(\"Any\")\n                ByteType -> append(\"Byte\")\n                ShortType -> append(\"Short\")\n                IntType -> append(\"Int\")\n                FloatType -> append(\"Float\")\n                LabelType.Instance -> append(\"Label\")\n                ILabelType -> append(\"ILabel\")\n                DLabelType -> append(\"DLabel\")\n                SLabelType -> append(\"SLabel\")\n                ILabelVarType -> append(\"...ILabel\")\n                StringType -> append(\"String\")\n                is RegType -> {\n                    append(\"Reg\")\n\n                    type.registers?.let { registers ->\n                        append(\"<\")\n\n                        var first = true\n\n                        for (register in registers) {\n                            if (first) {\n                                first = false\n                            } else {\n                                append(\", \")\n                            }\n\n                            appendParam(register)\n                        }\n\n                        append(\">\")\n                    }\n                }\n                RegVarType -> append(\"...Reg\")\n                PointerType -> append(\"Pointer\")\n            }\n\n            param.name?.let {\n                append(\" \")\n                append(param.name)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/**\n * Returns the array if it's not `null`, or an empty array otherwise.\n * @sample samples.collections.Arrays.Usage.arrayOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n/**\n * Returns a *typed* array containing all of the elements of this collection.\n *\n * Allocates an array of runtime type `T` having its size equal to the size of this collection\n * and populates the array with the elements of this collection.\n * @sample samples.collections.Collections.Collections.collectionToTypedArray\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableList\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableListWith\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\ninternal fun requireNonNegativeLimit(limit: Int) =\n    require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    requireNonNegativeLimit(limit)\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence to a list of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@SinceKotlin(\"1.5\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.splitToSequence(regex: Regex, limit: Int = 0): Sequence<String> = regex.splitToSequence(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return TimeSource.Monotonic.measureTime(block)\n}\n\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun TimeSource.measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    block()\n    return mark.elapsedNow()\n}\n\n\n/**\n * Data class representing a result of executing an action, along with the duration of elapsed time interval.\n *\n * @property value the result of the action.\n * @property duration the time elapsed to execute the action.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic data class TimedValue<T>(val value: T, val duration: Duration)\n\n/**\n * Executes the given function [block] and returns an instance of [TimedValue] class, containing both\n * the result of the function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return TimeSource.Monotonic.measureTimedValue(block)\n}\n\n/**\n * Executes the given [block] and returns an instance of [TimedValue] class, containing both\n * the result of function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> TimeSource.measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    val result = block()\n    return TimedValue(result, mark.elapsedNow())\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage world.phantasmal.core\n\nimport org.w3c.dom.DOMRectReadOnly\nimport org.w3c.dom.Element\n\nexternal interface JsArray<T> {\n    val length: Int\n\n    fun push(vararg elements: T): Int\n\n    fun slice(start: Int = definedExternally): JsArray<T>\n    fun slice(start: Int, end: Int = definedExternally): JsArray<T>\n\n    fun some(callback: (element: T, index: Int) -> Boolean): Boolean\n\n    fun splice(start: Int, deleteCount: Int = definedExternally): JsArray<T>\n    fun splice(start: Int, deleteCount: Int, vararg items: T): JsArray<T>\n}\n\ninline operator fun <T> JsArray<T>.get(index: Int): T = asDynamic()[index].unsafeCast<T>()\n\ninline operator fun <T> JsArray<T>.set(index: Int, value: T) {\n    asDynamic()[index] = value\n}\n\ninline fun <T> jsArrayOf(vararg elements: T): JsArray<T> =\n    elements.unsafeCast<JsArray<T>>()\n\ninline fun <T> JsArray<T>.asArray(): Array<T> =\n    unsafeCast<Array<T>>()\n\ninline fun <T> Array<T>.asJsArray(): JsArray<T> =\n    unsafeCast<JsArray<T>>()\n\ninline fun <T> List<T>.toJsArray(): JsArray<T> =\n    toTypedArray().asJsArray()\n\n@Suppress(\"unused\")\nexternal interface JsPair<out A, out B>\n\ninline val <T> JsPair<T, *>.first: T get() = asDynamic()[0].unsafeCast<T>()\ninline val <T> JsPair<*, T>.second: T get() = asDynamic()[1].unsafeCast<T>()\n\ninline operator fun <T> JsPair<T, *>.component1(): T = first\ninline operator fun <T> JsPair<*, T>.component2(): T = second\n\n@JsName(\"Object\")\nexternal class JsObject {\n    companion object {\n        fun entries(jsObject: dynamic): Array<JsPair<String, dynamic>>\n    }\n}\n\nexternal class ResizeObserver(callback: (entries: Array<ResizeObserverEntry>) -> Unit) {\n    fun observe(target: Element)\n    fun unobserve(target: Element)\n    fun disconnect()\n}\n\nexternal interface ResizeObserverEntry {\n    val contentRect: DOMRectReadOnly\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package world.phantasmal.web.assemblyWorker\n\nimport mu.KotlinLogging\nimport world.phantasmal.web.shared.Throttle\nimport world.phantasmal.web.shared.messages.*\nimport kotlin.time.measureTime\n\nclass AsmServer(\n    private val asmAnalyser: AsmAnalyser,\n    private val sendMessage: (ServerMessage) -> Unit,\n) {\n    private val messageQueue: MutableList<ClientMessage> = mutableListOf()\n    private val messageProcessingThrottle = Throttle(wait = 100)\n\n    fun receiveMessage(message: ClientMessage) {\n        messageQueue.add(message)\n        messageProcessingThrottle(::processMessages)\n    }\n\n    private fun processMessages() {\n        try {\n            // Split messages into ASM changes and other messages. Remove useless/duplicate\n            // notifications.\n            val asmChanges = mutableListOf<ClientNotification>()\n            val otherMessages = mutableListOf<ClientMessage>()\n\n            for (message in messageQueue) {\n                when (message) {\n                    is ClientNotification.SetAsm -> {\n                        // All previous ASM change messages can be discarded when the entire ASM has\n                        // changed.\n                        asmChanges.clear()\n                        asmChanges.add(message)\n                    }\n\n                    is ClientNotification.UpdateAsm ->\n                        asmChanges.add(message)\n\n                    else ->\n                        otherMessages.add(message)\n                }\n            }\n\n            messageQueue.clear()\n\n            // Process ASM changes first.\n            processAsmChanges(asmChanges)\n            otherMessages.forEach(::processMessage)\n        } catch (e: Throwable) {\n            logger.error(e) { \"Exception while processing messages.\" }\n            messageQueue.clear()\n        }\n    }\n\n    private fun processAsmChanges(messages: List<ClientNotification>) {\n        if (messages.isNotEmpty()) {\n            val time = measureTime {\n                val responses = try {\n                    for (message in messages) {\n                        when (message) {\n                            is ClientNotification.SetAsm ->\n                                asmAnalyser.setAsm(message.asm, message.inlineStackArgs)\n\n                            is ClientNotification.UpdateAsm ->\n                                asmAnalyser.updateAsm(message.changes)\n\n                            else ->\n                                // Should be processed by processMessage.\n                                logger.error { \"Unexpected ${message::class.simpleName}.\" }\n                        }\n                    }\n\n                    asmAnalyser.processAsm()\n                } catch (e: Throwable) {\n                    logger.error(e) { \"Exception while processing ASM changes.\" }\n                    emptyList<Response<*>>()\n                }\n\n                responses.forEach(sendMessage)\n            }\n\n            logger.trace {\n                \"Processed ${messages.size} assembly changes in ${time.inWholeMilliseconds}ms.\"\n            }\n        }\n    }\n\n    private fun processMessage(message: ClientMessage) {\n        val time = measureTime {\n            try {\n                when (message) {\n                    is ClientNotification.SetAsm,\n                    is ClientNotification.UpdateAsm,\n                    ->\n                        // Should have been processed by processAsmChanges.\n                        logger.error { \"Unexpected ${message::class.simpleName}.\" }\n\n                    is Request -> processRequest(message)\n                }\n            } catch (e: Throwable) {\n                logger.error(e) { \"Exception while processing ${message::class.simpleName}.\" }\n            }\n        }\n\n        logger.trace { \"Processed ${message::class.simpleName} in ${time.inWholeMilliseconds}ms.\" }\n    }\n\n    private fun processRequest(message: Request) {\n        val response = when (message) {\n            is Request.GetCompletions ->\n                asmAnalyser.getCompletions(message.id, message.lineNo, message.col)\n\n            is Request.GetSignatureHelp ->\n                asmAnalyser.getSignatureHelp(message.id, message.lineNo, message.col)\n\n            is Request.GetHover ->\n                asmAnalyser.getHover(message.id, message.lineNo, message.col)\n\n            is Request.GetDefinition ->\n                asmAnalyser.getDefinition(message.id, message.lineNo, message.col)\n\n            is Request.GetLabels ->\n                asmAnalyser.getLabels(message.id)\n\n            is Request.GetHighlights ->\n                asmAnalyser.getHighlights(message.id, message.lineNo, message.col)\n        }\n\n        sendMessage(response)\n    }\n\n    companion object {\n        private val logger = KotlinLogging.logger {}\n    }\n}\n","package world.phantasmal.web.assemblyWorker\n\nimport kotlinx.serialization.decodeFromString\nimport kotlinx.serialization.encodeToString\nimport mu.KotlinLoggingConfiguration\nimport mu.KotlinLoggingLevel\nimport world.phantasmal.web.shared.JSON_FORMAT\nimport world.phantasmal.web.shared.externals.self\nimport world.phantasmal.web.shared.logging.LogAppender\nimport world.phantasmal.web.shared.logging.LogFormatter\n\nfun main() {\n    KotlinLoggingConfiguration.FORMATTER = LogFormatter()\n    KotlinLoggingConfiguration.APPENDER = LogAppender()\n\n    if (self.location.hostname == \"localhost\") {\n        KotlinLoggingConfiguration.LOG_LEVEL = KotlinLoggingLevel.TRACE\n    }\n\n    val asmServer = AsmServer(\n        AsmAnalyser(),\n        sendMessage = { message ->\n            self.postMessage(JSON_FORMAT.encodeToString(message))\n        }\n    )\n\n    self.onmessage = { e ->\n        val json = e.data as String\n        asmServer.receiveMessage(JSON_FORMAT.decodeFromString(json))\n    }\n}\n",null,"package world.phantasmal.core\n\nimport mu.KLogger\n\nsealed class PwResult<out T>(val problems: List<Problem>) {\n    fun getOrNull(): T? = when (this) {\n        is Success -> value\n        is Failure -> null\n    }\n\n    fun unwrap(): T = when (this) {\n        is Success -> value\n        is Failure -> error(problems.joinToString(\"\\n\") { \"[${it.severity}] ${it.uiMessage}\" })\n    }\n\n    companion object {\n        fun <T> build(logger: KLogger): PwResultBuilder<T> =\n            PwResultBuilder(logger)\n    }\n}\n\nclass Success<T>(val value: T, problems: List<Problem> = emptyList()) : PwResult<T>(problems)\n\nclass Failure(problems: List<Problem>) : PwResult<Nothing>(problems)\n\nopen class Problem(\n    val severity: Severity,\n    /**\n     * Readable message meant for users.\n     */\n    val uiMessage: String,\n    /**\n     * Message meant for developers.\n     */\n    val message: String? = null,\n    val cause: Throwable? = null,\n)\n\nenum class Severity {\n    Trace,\n    Debug,\n    Info,\n    Warning,\n    Error,\n}\n\n/**\n * Useful for building up a [PwResult] and logging problems at the same time.\n */\nclass PwResultBuilder<T>(private val logger: KLogger) {\n    private val problems: MutableList<Problem> = mutableListOf()\n\n    /**\n     * Add a problem to the problems list and log it with [logger].\n     */\n    fun addProblem(\n        problem: Problem,\n    ): PwResultBuilder<T> {\n        when (problem.severity) {\n            Severity.Trace -> logger.trace(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Debug -> logger.debug(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Info -> logger.info(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Warning -> logger.warn(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Error -> logger.error(problem.cause) { problem.message ?: problem.uiMessage }\n        }\n\n        problems.add(problem)\n        return this\n    }\n\n    /**\n     * Add a problem to the problems list and log it with [logger].\n     */\n    fun addProblem(\n        severity: Severity,\n        uiMessage: String,\n        message: String? = null,\n        cause: Throwable? = null,\n    ): PwResultBuilder<T> =\n        addProblem(Problem(severity, uiMessage, message, cause))\n\n    /**\n     * Add the given result's problems.\n     */\n    fun addResult(result: PwResult<*>): PwResultBuilder<T> {\n        problems.addAll(result.problems)\n        return this\n    }\n\n    fun success(value: T): Success<T> =\n        Success(value, problems)\n\n    fun failure(): Failure =\n        Failure(problems)\n}\n","package world.phantasmal.core\n\nimport kotlinx.coroutines.await\nimport world.phantasmal.core.externals.browser.WritableStream\n\nsuspend inline fun <S : WritableStream, R> S.use(block: (S) -> R): R {\n    try {\n        return block(this)\n    } finally {\n        close().await()\n    }\n}\n","package world.phantasmal.core.math\n\nimport kotlin.math.PI\n\nprivate const val TO_DEG = 180 / PI\nprivate const val TO_RAD = PI / 180\n\n/**\n * Converts radians to degrees.\n */\nfun radToDeg(rad: Double): Double = rad * TO_DEG\n\n/**\n * Converts degrees to radians.\n */\nfun degToRad(deg: Double): Double = deg * TO_RAD\n\nfun clamp(value: Int, min: Int, max: Int): Int =\n    when {\n        value < min -> min\n        value > max -> max\n        else -> value\n    }\n","package world.phantasmal.psolib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.asm.*\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * Computes the possible values of a register right before a specific instruction.\n */\nfun getRegisterValue(cfg: ControlFlowGraph, instruction: Instruction, register: Int): ValueSet {\n    require(register in 0..255) {\n        \"register should be between 0 and 255, inclusive but was $register.\"\n    }\n\n    val block = cfg.getBlockForInstruction(instruction)\n\n    return RegisterValueFinder().find(\n        mutableSetOf(),\n        block,\n        block.indexOfInstruction(instruction),\n        register\n    )\n}\n\nprivate class RegisterValueFinder {\n    private var iterations = 0\n\n    // TODO: Deal with incorrect argument types.\n    fun find(\n        path: MutableSet<BasicBlock>,\n        block: BasicBlock,\n        end: Int,\n        register: Int,\n    ): ValueSet {\n        if (++iterations > 100) {\n            logger.warn { \"Too many iterations.\" }\n            return ValueSet.all()\n        }\n\n        for (i in end - 1 downTo block.start) {\n            val instruction = block.segment.instructions[i]\n            val args = instruction.args\n\n            when (instruction.opcode.code) {\n                OP_SYNC.code -> {\n                    // After a sync call, concurrent code could have modified the register. We don't\n                    // check whether concurrent code *ever* writes to the register to possibly\n                    // continue the analysis.\n                    return ValueSet.all()\n                }\n\n                OP_VA_CALL.code -> {\n                    val value = vaCall(path, block, i, register)\n                    if (value.isNotEmpty()) return value\n                }\n\n                OP_LET.code -> {\n                    if (args[0].value == register) {\n                        return find(LinkedHashSet(path), block, i, (args[1] as IntArg).value)\n                    }\n                }\n\n                OP_LETI.code,\n                OP_LETB.code,\n                OP_LETW.code,\n                OP_SYNC_LETI.code,\n                -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of((args[1] as IntArg).value)\n                    }\n                }\n\n                OP_SET.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(1)\n                    }\n                }\n\n                OP_CLEAR.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(0)\n                    }\n                }\n\n                OP_REV.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n\n                        return if (prevVals.size == 1L && prevVals[0] == 0) {\n                            ValueSet.of(1)\n                        } else if (0 in prevVals) {\n                            ValueSet.ofInterval(0, 1)\n                        } else {\n                            ValueSet.of(0)\n                        }\n                    }\n                }\n\n                OP_ADDI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals += (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_SUBI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals -= (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_MULI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals *= (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_DIVI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals /= (args[1] as IntArg).value\n                        return prevVals\n                    }\n                }\n\n                OP_IF_ZONE_CLEAR.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 1)\n                    }\n                }\n\n                OP_GET_DIFFLVL.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 2)\n                    }\n                }\n\n                OP_GET_SLOTNUMBER.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 3)\n                    }\n                }\n\n                OP_GET_RANDOM.code -> {\n                    if (args[1].value == register) {\n                        // TODO: undefined values.\n                        val min = find(\n                            LinkedHashSet(path),\n                            block,\n                            i,\n                            (args[0] as IntArg).value\n                        ).minOrNull()!!\n\n                        val max = max(\n                            find(\n                                LinkedHashSet(path),\n                                block,\n                                i,\n                                (args[0] as IntArg).value + 1\n                            ).maxOrNull()!!,\n                            min + 1,\n                        )\n\n                        return ValueSet.ofInterval(min, max - 1)\n                    }\n                }\n\n                OP_STACK_PUSHM.code,\n                OP_STACK_POPM.code,\n                -> {\n                    val minReg = (args[0] as IntArg).value\n                    val maxReg = (args[0] as IntArg).value + (args[1] as IntArg).value\n\n                    if (register in minReg until maxReg) {\n                        return ValueSet.all()\n                    }\n                }\n\n                else -> {\n                    // Assume any other opcodes that write to the register can produce any value.\n                    val params = instruction.opcode.params\n                    val argLen = min(args.size, params.size)\n\n                    for (j in 0 until argLen) {\n                        val param = params[j]\n\n                        if (param.type is RegType && param.type.registers != null) {\n                            val regRef = (args[j] as IntArg).value\n\n                            for ((k, regParam) in param.type.registers.withIndex()) {\n                                if (regParam.write && regRef + k == register) {\n                                    return ValueSet.all()\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        val values = ValueSet.empty()\n        path.add(block)\n\n        for (from in block.from) {\n            // Bail out from loops.\n            if (from in path) {\n                return ValueSet.all()\n            }\n\n            values.union(find(LinkedHashSet(path), from, from.end, register))\n        }\n\n        // If values is empty at this point, we know nothing ever sets the register's value from\n        // this thread or handler. Concurrent code could have modified it, we don't yet try to\n        // exclude this possibility so we just return all values.\n        if (values.isEmpty()) {\n            return ValueSet.all()\n        }\n\n        return values\n    }\n\n    /**\n     * After a va_start instruction, 0 or more arg_push instructions can be used. When va_call is\n     * executed the values on the stack will become the values of registers r1..r7 (inclusive) in\n     * the order that they were pushed.\n     *\n     * E.g.:\n     *\n     * va_start\n     * arg_pushl 10\n     * arg_pushl 20\n     * va_call 777\n     * va_end\n     *\n     * This means call 777 with r1 = 10 and r2 = 20.\n     */\n    private fun vaCall(\n        path: MutableSet<BasicBlock>,\n        block: BasicBlock,\n        vaCallIdx: Int,\n        register: Int,\n    ): ValueSet {\n        if (register !in 1..7) return ValueSet.empty()\n\n        var vaStartIdx = -1\n        val stack = mutableListOf<Instruction>()\n\n        for (i in block.start until vaCallIdx) {\n            val instruction = block.segment.instructions[i]\n            val opcode = instruction.opcode\n\n            if (opcode.code == OP_VA_START.code) {\n                vaStartIdx = i\n            } else if (vaStartIdx != -1) {\n                when (opcode.code) {\n                    OP_ARG_PUSHR.code,\n                    OP_ARG_PUSHL.code,\n                    OP_ARG_PUSHB.code,\n                    OP_ARG_PUSHW.code,\n                    OP_ARG_PUSHA.code,\n                    OP_ARG_PUSHO.code,\n                    OP_ARG_PUSHS.code,\n                    -> stack.add(instruction)\n                }\n            }\n        }\n\n        return if (register in 1..stack.size) {\n            val instruction = stack[register - 1]\n            val arg = instruction.args.first()\n\n            when (instruction.opcode.code) {\n                OP_ARG_PUSHR.code ->\n                    find(LinkedHashSet(path), block, vaStartIdx, (arg as IntArg).value)\n\n                OP_ARG_PUSHL.code,\n                OP_ARG_PUSHB.code,\n                OP_ARG_PUSHW.code,\n                -> ValueSet.of((arg as IntArg).value)\n\n                // TODO: Deal with strings.\n                else -> ValueSet.all() // String or pointer\n            }\n        } else {\n            ValueSet.of(0)\n        }\n    }\n}\n","package world.phantasmal.psolib.asm.dataFlowAnalysis\n\nimport kotlin.math.max\nimport kotlin.math.min\n\n/**\n * Represents a sorted set of integers.\n */\nclass ValueSet private constructor(private val intervals: MutableList<Interval>) : Iterable<Int> {\n    val size: Long\n        get() = intervals.fold(0L) { acc, i -> acc + i.end - i.start + 1L }\n\n    operator fun get(i: Int): Int? {\n        var idx = i\n\n        for ((start, end) in intervals) {\n            val size = end - start + 1\n\n            if (idx < size) {\n                return start + idx\n            } else {\n                idx -= size\n            }\n        }\n\n        return null\n    }\n\n    fun isEmpty(): Boolean =\n        intervals.isEmpty()\n\n    fun isNotEmpty(): Boolean =\n        intervals.isNotEmpty()\n\n    fun minOrNull(): Int? =\n        intervals.firstOrNull()?.start\n\n    fun maxOrNull(): Int? =\n        intervals.lastOrNull()?.end\n\n    operator fun contains(value: Int): Boolean {\n        for (int in intervals) {\n            if (value in int) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    /**\n     * Sets this ValueSet to the given integer.\n     */\n    fun setValue(value: Int): ValueSet {\n        intervals.clear()\n        intervals.add(Interval(value, value))\n        return this\n    }\n\n    /**\n     * Sets this ValueSet to the values in the given interval.\n     *\n     * @param start lower bound, inclusive\n     * @param end upper bound, inclusive\n     */\n    fun setInterval(start: Int, end: Int): ValueSet {\n        require(end >= start) {\n            \"Interval upper bound should be greater than or equal to lower bound, got [${start}, ${end}].\"\n        }\n\n        intervals.clear()\n        intervals.add(Interval(start, end))\n        return this\n    }\n\n    /**\n     * Scalar addition.\n     */\n    operator fun plusAssign(scalar: Int) {\n        if (scalar >= 0) {\n            var i = 0\n            var addI = 0\n\n            while (i < intervals.size) {\n                val int = intervals[i]\n                val oldStart = int.start\n                val oldEnd = int.end\n                int.start += scalar\n                int.end += scalar\n\n                if (int.start < oldStart) {\n                    // Integer overflow of both start and end.\n                    intervals.removeAt(i)\n                    intervals.add(addI++, int)\n                } else if (int.end < oldEnd) {\n                    // Integer overflow of end.\n                    val newEnd = int.end\n                    int.end = Int.MAX_VALUE\n\n                    if (newEnd + 1 == intervals.first().start) {\n                        intervals.first().start = Int.MIN_VALUE\n                    } else {\n                        intervals.add(0, Interval(Int.MIN_VALUE, newEnd))\n                        addI++\n                        // Increment i twice because we left this interval and inserted a new one.\n                        i++\n                    }\n                }\n\n                i++\n            }\n        } else {\n            var i = intervals.lastIndex\n            var addI = 0\n\n            while (i >= 0) {\n                val int = intervals[i]\n                val oldStart = int.start\n                val oldEnd = int.end\n                int.start += scalar\n                int.end += scalar\n\n                if (int.end > oldEnd) {\n                    // Integer underflow of both start and end.\n                    intervals.removeAt(i)\n                    intervals.add(intervals.size - addI++, int)\n                } else if (int.start > oldStart) {\n                    // Integer underflow of start.\n                    val newStart = int.start\n                    int.start = Int.MIN_VALUE\n\n                    if (newStart - 1 == intervals.last().end) {\n                        intervals.last().end = Int.MAX_VALUE\n                    } else {\n                        intervals.add(Interval(newStart, Int.MAX_VALUE))\n                        addI++\n                    }\n                }\n\n                i--\n            }\n        }\n    }\n\n    /**\n     * Scalar subtraction.\n     */\n    operator fun minusAssign(scalar: Int) {\n        plusAssign(-scalar)\n    }\n\n    /**\n     * Doesn't take into account integer overflow.\n     */\n    operator fun timesAssign(s: Int) {\n        for (int in intervals) {\n            int.start *= s\n            int.end *= s\n        }\n    }\n\n    /**\n     * Integer division.\n     */\n    operator fun divAssign(s: Int) {\n        for (int in intervals) {\n            int.start /= s\n            int.end /= s\n        }\n    }\n\n    fun union(other: ValueSet): ValueSet {\n        var i = 0\n\n        outer@ for (b in other.intervals) {\n            while (i < intervals.size) {\n                val a = intervals[i]\n\n                if (b.end < a.start - 1L) {\n                    // b lies entirely before a, insert it right before a.\n                    intervals.add(i, b.copy())\n                    i++\n                    continue@outer\n                } else if (b.start <= a.end + 1L) {\n                    // a and b overlap or form a continuous interval (e.g. [1, 2] and [3, 4]).\n                    a.start = min(a.start, b.start)\n\n                    // Merge all intervals that overlap with b.\n                    val j = i + 1\n\n                    while (j < intervals.size) {\n                        if (b.end >= intervals[j].start - 1L) {\n                            a.end = intervals[j].end\n                            intervals.removeAt(j)\n                        } else {\n                            break\n                        }\n                    }\n\n                    a.end = max(a.end, b.end)\n                    i++\n                    continue@outer\n                } else {\n                    // b lies entirely after a, check next a.\n                    i++\n                }\n            }\n\n            // b lies after every a, add it to the end of our intervals.\n            intervals.add(b.copy())\n        }\n\n        return this\n    }\n\n    override fun iterator(): Iterator<Int> =\n        object : Iterator<Int> {\n            private var intIdx = 0\n            private var nextValue: Int? = minOrNull()\n\n            override fun hasNext(): Boolean =\n                nextValue != null\n\n            override fun next(): Int {\n                val v = nextValue ?: throw NoSuchElementException()\n\n                nextValue =\n                    if (v < intervals[intIdx].end) {\n                        v + 1\n                    } else {\n                        intIdx++\n\n                        if (intIdx < intervals.size) {\n                            intervals[intIdx].start\n                        } else {\n                            null\n                        }\n                    }\n\n                return v\n            }\n        }\n\n    companion object {\n        /**\n         * Returns an empty [ValueSet].\n         */\n        fun empty(): ValueSet = ValueSet(mutableListOf())\n\n        /**\n         * Returns a [ValueSet] containing all possible Int values.\n         */\n        fun all(): ValueSet = ofInterval(Int.MIN_VALUE, Int.MAX_VALUE)\n\n        /**\n         * Returns a [ValueSet] with a single initial [value].\n         */\n        fun of(value: Int): ValueSet = ValueSet(mutableListOf(Interval(value, value)))\n\n        /**\n         * Returns a [ValueSet] with all values between [start] and [end], inclusively.\n         */\n        fun ofInterval(start: Int, end: Int): ValueSet =\n            ValueSet(mutableListOf(Interval(start, end)))\n    }\n}\n\n/**\n * Closed interval [start, end].\n */\nprivate data class Interval(var start: Int, var end: Int) {\n    operator fun contains(value: Int): Boolean =\n        value in start..end\n}\n","package world.phantasmal.psolib\n\nenum class Endianness {\n    Little,\n    Big\n}\n","package world.phantasmal.psolib\n\nenum class Episode {\n    I,\n    II,\n    IV;\n\n    fun toInt(): Int = when(this) {\n        I -> 1\n        II -> 2\n        IV -> 4\n    }\n\n    companion object {\n        fun fromInt(episode: Int) = when (episode) {\n            1 -> I\n            2 -> II\n            4 -> IV\n            else -> error(\"$episode is invalid.\")\n        }\n    }\n}\n","package world.phantasmal.psolib.asm\n\nimport world.phantasmal.core.fastIsWhitespace\nimport world.phantasmal.core.fastReplace\nimport world.phantasmal.core.getCodePointAt\nimport world.phantasmal.core.isDigit\n\nprivate val HEX_INT_REGEX = Regex(\"\"\"^0[xX][0-9a-fA-F]+$\"\"\")\nprivate val FLOAT_REGEX = Regex(\"\"\"^-?\\d+(\\.\\d+)?(e-?\\d+)?$\"\"\")\n\nenum class Token {\n    Int32,\n    Float32,\n    InvalidNumber,\n    Register,\n    Label,\n    CodeSection,\n    DataSection,\n    StrSection,\n    InvalidSection,\n    Str,\n    UnterminatedStr,\n    Ident,\n    InvalidIdent,\n    ArgSeparator,\n}\n\nclass LineTokenizer {\n    private var line = \"\"\n    private var index = 0\n    private var startIndex = 0\n\n    var value: Any? = null\n        private set\n\n    var type: Token? = null\n        private set\n\n    val col: Int get() = startIndex + 1\n    val len: Int get() = index - startIndex\n\n    fun tokenize(line: String) {\n        this.line = line\n        index = 0\n        startIndex = 0\n    }\n\n    val intValue: Int\n        get() {\n            require(type === Token.Int32 || type === Token.Register || type === Token.Label)\n            return value as Int\n        }\n\n    val floatValue: Float\n        get() {\n            require(type === Token.Float32)\n            return value as Float\n        }\n\n    val strValue: String\n        get() {\n            require(\n                type === Token.Str ||\n                        type === Token.UnterminatedStr ||\n                        type === Token.Ident ||\n                        type === Token.InvalidIdent\n            )\n            return value as String\n        }\n\n    fun nextToken(): Boolean {\n        type = null\n        value = null\n\n        while (hasNext()) {\n            startIndex = index\n            val char = peek()\n\n            if (char == '/') {\n                skip()\n\n                if (peek() == '/') {\n                    // It's a comment.\n                    break\n                } else {\n                    back()\n                }\n            }\n\n            if (char.fastIsWhitespace()) {\n                skip()\n                continue\n            }\n\n            if (char == '-' || char.isDigit()) {\n                tokenizeNumberOrLabel()\n            } else if (char == ',') {\n                type = Token.ArgSeparator\n                skip()\n            } else if (char == '.') {\n                tokenizeSection()\n            } else if (char == '\"') {\n                tokenizeString()\n            } else if (char == 'r') {\n                tokenizeRegisterOrIdent()\n            } else {\n                tokenizeIdent()\n            }\n\n            break\n        }\n\n        return if (type == null) {\n            startIndex = line.length\n            index = line.length\n            false\n        } else {\n            true\n        }\n    }\n\n    private fun hasNext(): Boolean = index < line.length\n\n    private fun next(): Char = line[index++]\n\n    private fun peek(): Char = line[index]\n\n    private fun skip() {\n        index++\n    }\n\n    private fun back() {\n        index--\n    }\n\n    private fun slice(from: Int = 0, to: Int = 0): String =\n        line.substring(startIndex + from, index - to)\n\n    private fun eatRestOfToken() {\n        while (hasNext()) {\n            val char = next()\n\n            if (char == ',' || char.fastIsWhitespace()) {\n                back()\n                break\n            }\n        }\n    }\n\n    private fun tokenizeNumberOrLabel() {\n        val firstChar = next()\n        var isLabel = false\n\n        while (hasNext()) {\n            val char = peek()\n\n            if (char == '.' || char == 'e') {\n                tokenizeFloat()\n                return\n            } else if (firstChar == '0' && (char == 'x' || char == 'X')) {\n                tokenizeHexNumber()\n                return\n            } else if (char == ':') {\n                isLabel = true\n                break\n            } else if (char == ',' || char.fastIsWhitespace()) {\n                break\n            } else {\n                skip()\n            }\n        }\n\n        value = slice().toIntOrNull()\n\n        if (isLabel) {\n            skip()\n        }\n\n        type = when {\n            value == null -> Token.InvalidNumber\n            isLabel -> Token.Label\n            else -> Token.Int32\n        }\n    }\n\n    private fun tokenizeHexNumber() {\n        eatRestOfToken()\n        val hexStr = slice()\n\n        if (HEX_INT_REGEX.matches(hexStr)) {\n            value = hexStr.drop(2).toIntOrNull(16)\n\n            if (value != null) {\n                type = Token.Int32\n                return\n            }\n        }\n\n        type = Token.InvalidNumber\n    }\n\n    private fun tokenizeFloat() {\n        eatRestOfToken()\n        val floatStr = slice()\n\n        if (FLOAT_REGEX.matches(floatStr)) {\n            value = floatStr.toFloatOrNull()\n\n            if (value != null) {\n                type = Token.Float32\n                return\n            }\n        }\n\n        type = Token.InvalidNumber\n    }\n\n    private fun tokenizeRegisterOrIdent() {\n        skip()\n        var isRegister = false\n\n        while (hasNext()) {\n            val char = peek()\n\n            if (char.isDigit()) {\n                isRegister = true\n                skip()\n            } else {\n                break\n            }\n        }\n\n        if (isRegister) {\n            value = slice(from = 1).toInt()\n            type = Token.Register\n        } else {\n            back()\n            tokenizeIdent()\n        }\n    }\n\n    private fun tokenizeSection() {\n        while (hasNext()) {\n            if (peek().fastIsWhitespace()) {\n                break\n            } else {\n                skip()\n            }\n        }\n\n        type = when (slice()) {\n            \".code\" -> Token.CodeSection\n            \".data\" -> Token.DataSection\n            \".string\" -> Token.StrSection\n            else -> Token.InvalidSection\n        }\n    }\n\n    private fun tokenizeString() {\n        skip()\n        var prevWasBackSpace = false\n        var terminated = false\n\n        loop@ // Use label as workaround for https://youtrack.jetbrains.com/issue/KT-43943.\n        while (hasNext()) {\n            when (peek()) {\n                '\\\\' -> {\n                    prevWasBackSpace = true\n                }\n                '\"' -> {\n                    if (!prevWasBackSpace) {\n                        skip()\n                        terminated = true\n                        break@loop\n                    }\n\n                    prevWasBackSpace = false\n                }\n                else -> {\n                    prevWasBackSpace = false\n                }\n            }\n\n            skip()\n        }\n\n        value = slice(from = 1, to = if (terminated) 1 else 0)\n            .fastReplace(\"\\\\\\\"\", \"\\\"\")\n            .fastReplace(\"\\\\n\", \"\\n\")\n\n        type = if (terminated) {\n            Token.Str\n        } else {\n            Token.UnterminatedStr\n        }\n    }\n\n    private fun tokenizeIdent() {\n        while (hasNext()) {\n            val char = peek()\n\n            if (char == ',' || char.fastIsWhitespace()) {\n                break\n            } else if (char == '/') {\n                skip()\n\n                if (peek() == '/') {\n                    back()\n                    break\n                }\n            } else {\n                skip()\n            }\n        }\n\n        val ident = slice()\n        value = ident\n\n        if (ident.getCodePointAt(0) !in 'a'.code..'z'.code) {\n            type = Token.InvalidIdent\n            return\n        }\n\n        for (i in 1 until ident.length) {\n            when (ident.getCodePointAt(i)) {\n                in '0'.code..'9'.code,\n                in 'a'.code..'z'.code,\n                '_'.code,\n                '='.code,\n                '<'.code,\n                '>'.code,\n                '!'.code,\n                -> {\n                    // Valid character.\n                }\n                else -> {\n                    type = Token.InvalidIdent\n                    return\n                }\n            }\n        }\n\n        type = Token.Ident\n    }\n}\n","package world.phantasmal.psolib.asm\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.Problem\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.psolib.buffer.Buffer\nimport kotlin.time.measureTimedValue\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AssemblyProblem(\n    severity: Severity,\n    uiMessage: String,\n    message: String? = null,\n    cause: Throwable? = null,\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n) : Problem(severity, uiMessage, message, cause)\n\nfun assemble(\n    asm: List<String>,\n    inlineStackArgs: Boolean = true,\n): PwResult<BytecodeIr> {\n    logger.trace {\n        \"Assembling ${asm.size} lines with ${\n            if (inlineStackArgs) \"inline stack arguments\" else \"stack push instructions\"\n        }.\"\n    }\n\n    val (result, time) = measureTimedValue { Assembler(asm, inlineStackArgs).assemble() }\n\n    logger.trace {\n        val warnings = result.problems.count { it.severity == Severity.Warning }\n        val errors = result.problems.count { it.severity == Severity.Error }\n\n        \"Assembly finished in ${time.inWholeMilliseconds}ms with $warnings warnings and $errors errors.\"\n    }\n\n    return result\n}\n\nprivate class Assembler(private val asm: List<String>, private val inlineStackArgs: Boolean) {\n    private var lineNo = 1\n    private val tokenizer = LineTokenizer()\n    private var ir: MutableList<Segment> = mutableListOf()\n\n    /**\n     * The current segment.\n     */\n    private var segment: Segment? = null\n\n    /**\n     * Encountered labels.\n     */\n    private val labels: MutableSet<Int> = mutableSetOf()\n    private var section: SegmentType = SegmentType.Instructions\n    private var firstSectionMarker = true\n    private var prevLineHadLabel = false\n\n    private val result = PwResult.build<BytecodeIr>(logger)\n\n    fun assemble(): PwResult<BytecodeIr> {\n        // Tokenize and assemble line by line.\n        for (line in asm) {\n            tokenizer.tokenize(line)\n            tokenizer.nextToken()\n\n            if (tokenizer.type != null) {\n                var hasLabel = false\n\n                // Token type checks are ordered from most frequent to least frequent for increased\n                // perf.\n                when (tokenizer.type) {\n                    Token.Ident -> {\n                        if (section === SegmentType.Instructions) {\n                            parseInstruction()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.Label -> {\n                        parseLabel()\n                        hasLabel = true\n                    }\n                    Token.CodeSection -> {\n                        parseCodeSection()\n                    }\n                    Token.DataSection -> {\n                        parseDataSection()\n                    }\n                    Token.StrSection -> {\n                        parseStrSection()\n                    }\n                    Token.Int32 -> {\n                        if (section === SegmentType.Data) {\n                            parseBytes()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.Str -> {\n                        if (section === SegmentType.String) {\n                            parseString()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.InvalidSection -> {\n                        addError(\"Invalid section type.\")\n                    }\n                    Token.InvalidIdent -> {\n                        addError(\"Invalid identifier.\")\n                    }\n                    else -> {\n                        addUnexpectedTokenError()\n                    }\n                }\n\n                prevLineHadLabel = hasLabel\n            }\n\n            lineNo++\n        }\n\n        return result.success(BytecodeIr(ir))\n    }\n\n    private fun addInstruction(\n        opcode: Opcode,\n        args: List<Arg>,\n        mnemonicSrcLoc: SrcLoc?,\n        valid: Boolean,\n        argSrcLocs: List<ArgSrcLoc>,\n        trailingArgSeparator: Boolean,\n    ) {\n        when (val seg = segment) {\n            null -> {\n                // Unreachable code, technically valid.\n                segment = InstructionSegment(\n                    labels = mutableListOf(),\n                    instructions = mutableListOf(),\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is InstructionSegment -> {\n                seg.instructions.add(\n                    Instruction(\n                        opcode,\n                        args,\n                        valid,\n                        InstructionSrcLoc(\n                            mnemonic = mnemonicSrcLoc,\n                            args = argSrcLocs,\n                            trailingArgSeparator,\n                        ),\n                    )\n                )\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected instructions segment.\" }\n            }\n        }\n    }\n\n    private fun addBytes(bytes: ByteArray) {\n        when (val seg = segment) {\n            null -> {\n                // Unaddressable data, technically valid.\n                segment = DataSegment(\n                    labels = mutableListOf(),\n                    data = Buffer.fromByteArray(bytes),\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is DataSegment -> {\n                val oldSize = seg.data.size\n                seg.data.size += bytes.size\n\n                for (i in bytes.indices) {\n                    seg.data.setByte(i + oldSize, bytes[i])\n                }\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected data segment.\" }\n            }\n        }\n    }\n\n    private fun addString(str: String) {\n        when (val seg = segment) {\n            null -> {\n                // Unaddressable data, technically valid.\n                segment = StringSegment(\n                    labels = mutableListOf(),\n                    value = str,\n                    bytecodeSize = null,\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is StringSegment -> {\n                seg.value += str\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected string segment.\" }\n            }\n        }\n    }\n\n    private fun addError(col: Int, len: Int, uiMessage: String, message: String? = null) {\n        result.addProblem(\n            AssemblyProblem(\n                Severity.Error,\n                uiMessage,\n                message ?: \"$uiMessage At $lineNo:$col.\",\n                lineNo = lineNo,\n                col = col,\n                len = len\n            )\n        )\n    }\n\n    private fun addError(uiMessage: String, message: String? = null) {\n        addError(tokenizer.col, tokenizer.len, uiMessage, message)\n    }\n\n    private fun addUnexpectedTokenError() {\n        addError(\n            \"Unexpected token.\",\n            \"Unexpected ${tokenizer.type?.name} at $lineNo:${tokenizer.col}.\",\n        )\n    }\n\n    private fun addWarning(uiMessage: String) {\n        result.addProblem(\n            AssemblyProblem(\n                Severity.Warning,\n                uiMessage,\n                lineNo = lineNo,\n                col = tokenizer.col,\n                len = tokenizer.len,\n            )\n        )\n    }\n\n    private fun parseLabel() {\n        val label = tokenizer.intValue\n\n        if (!labels.add(label)) {\n            addError(\"Duplicate label.\")\n        }\n\n        val srcLoc = srcLocFromTokenizer()\n\n        if (prevLineHadLabel) {\n            val segment = ir.last()\n            segment.labels.add(label)\n            segment.srcLoc.labels.add(srcLoc)\n        }\n\n        tokenizer.nextToken()\n\n        when (section) {\n            SegmentType.Instructions -> {\n                if (!prevLineHadLabel) {\n                    segment = InstructionSegment(\n                        labels = mutableListOf(label),\n                        instructions = mutableListOf(),\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Ident) {\n                    parseInstruction()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected opcode mnemonic.\")\n                }\n            }\n\n            SegmentType.Data -> {\n                if (!prevLineHadLabel) {\n                    segment = DataSegment(\n                        labels = mutableListOf(label),\n                        data = Buffer.withCapacity(0),\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Int32) {\n                    parseBytes()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected bytes.\")\n                }\n            }\n\n            SegmentType.String -> {\n                if (!prevLineHadLabel) {\n                    segment = StringSegment(\n                        labels = mutableListOf(label),\n                        value = \"\",\n                        bytecodeSize = null,\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Str) {\n                    parseString()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected a string.\")\n                }\n            }\n        }\n    }\n\n    private fun parseCodeSection() {\n        parseSection(SegmentType.Instructions)\n    }\n\n    private fun parseDataSection() {\n        parseSection(SegmentType.Data)\n    }\n\n    private fun parseStrSection() {\n        parseSection(SegmentType.String)\n    }\n\n    private fun parseSection(section: SegmentType) {\n        if (this.section == section && !firstSectionMarker) {\n            addWarning(\"Unnecessary section marker.\")\n        }\n\n        this.section = section\n        firstSectionMarker = false\n\n        if (tokenizer.nextToken()) {\n            addUnexpectedTokenError()\n        }\n    }\n\n    private fun parseInstruction() {\n        val opcode = mnemonicToOpcode(tokenizer.strValue)\n        val mnemonicSrcLoc = srcLocFromTokenizer()\n\n        if (opcode == null) {\n            addError(\"Unknown opcode.\")\n        } else {\n            if (opcode.stack !== StackInteraction.Pop) {\n                // Arguments should be inlined immediately after the opcode.\n                parseArgs(\n                    opcode,\n                    mnemonicSrcLoc,\n                    stack = false,\n                )\n            } else {\n                // Arguments should be passed to the opcode via the stack.\n                parseArgs(\n                    opcode,\n                    mnemonicSrcLoc,\n                    stack = true,\n                )\n            }\n        }\n    }\n\n    private fun parseArgs(opcode: Opcode, mnemonicSrcLoc: SrcLoc, stack: Boolean) {\n        val immediateArgs = mutableListOf<Arg>()\n        val srcLocs = mutableListOf<ArgSrcLoc>()\n        var argCount = 0\n        var valid = true\n        var shouldBeArg = true\n        var paramI = 0\n        var prevToken: Token?\n        var prevCol: Int\n        var prevLen: Int\n        var token = tokenizer.type\n        var col = tokenizer.col\n        var len = tokenizer.len\n\n        tokenizer.nextToken()\n\n        while (true) {\n            // Previous token data.\n            prevToken = token\n            prevCol = col\n            prevLen = len\n\n            // Current token data.\n            token = tokenizer.type\n            col = tokenizer.col\n            len = tokenizer.len\n            val value = tokenizer.value\n\n            if (token == null) {\n                break\n            }\n\n            // Next token data.\n            tokenizer.nextToken()\n            val nextToken = tokenizer.type\n            val nextCol = tokenizer.col\n            val nextLen = tokenizer.len\n\n            val param = opcode.params.getOrNull(paramI)\n            val paramType = param?.type\n\n            // Coarse source position, including surrounding whitespace.\n            val coarseCol = prevCol + prevLen\n            val coarseLen = when (nextToken) {\n                Token.ArgSeparator -> nextCol + nextLen - coarseCol\n                null -> nextCol - coarseCol + 1\n                else -> nextCol - coarseCol\n            }\n\n            if (token === Token.ArgSeparator) {\n                if (shouldBeArg) {\n                    addError(\"Expected an argument.\")\n                } else if (param == null || !param.varargs) {\n                    paramI++\n                }\n\n                shouldBeArg = true\n            } else {\n                if (!shouldBeArg) {\n                    addError(coarseCol, col - coarseCol, \"Expected a comma.\")\n                }\n\n                shouldBeArg = false\n\n                argCount++\n\n                // Try to match token type to parameter type.\n                var typeMatch: Boolean\n\n                // If arg is nonnull, types match and argument is syntactically valid.\n                val arg: Arg = when (token) {\n                    Token.Int32 -> {\n                        value as Int\n\n                        when (paramType) {\n                            ByteType -> {\n                                typeMatch = true\n                                checkIntValue(col, len, value, 1)\n                            }\n                            ShortType,\n                            is LabelType,\n                            -> {\n                                typeMatch = true\n                                checkIntValue(col, len, value, 2)\n                            }\n                            IntType -> {\n                                typeMatch = true\n                                checkIntValue(col, len, value, 4)\n                            }\n                            FloatType -> {\n                                typeMatch = true\n                                FloatArg(value.toFloat())\n                            }\n                            else -> {\n                                typeMatch = false\n                                IntArg(value)\n                            }\n                        }\n                    }\n\n                    Token.Float32 -> {\n                        typeMatch = paramType === FloatType\n                        FloatArg(value as Float)\n                    }\n\n                    Token.Register -> {\n                        typeMatch = stack ||\n                                paramType === RegVarType ||\n                                paramType is RegType\n\n                        value as Int\n\n                        if (value > 255) {\n                            addError(col, len, \"Invalid register reference, expected r0-r255.\")\n                        }\n\n                        IntArg(value)\n                    }\n\n                    Token.Str -> {\n                        typeMatch = paramType === StringType\n                        StringArg(value as String)\n                    }\n\n                    else -> {\n                        typeMatch = false\n                        UnknownArg(value)\n                    }\n                }\n\n                val srcLoc = ArgSrcLoc(\n                    precise = SrcLoc(lineNo, col, len),\n                    coarse = SrcLoc(lineNo, coarseCol, coarseLen),\n                )\n\n                if (!stack) {\n                    immediateArgs.add(arg)\n                }\n\n                srcLocs.add(srcLoc)\n\n                if (!typeMatch) {\n                    valid = false\n\n                    // Don't add a type errors for surplus arguments.\n                    if (param != null) {\n                        val typeStr = when (param.type) {\n                            ByteType -> \"an 8-bit integer\"\n                            ShortType -> \"a 16-bit integer\"\n                            IntType -> \"a 32-bit integer\"\n                            FloatType -> \"a float\"\n\n                            ILabelType,\n                            ILabelVarType,\n                            -> \"an instruction label\"\n\n                            DLabelType -> \"a data label\"\n                            SLabelType -> \"a string label\"\n\n                            is LabelType -> \"a label\"\n\n                            StringType -> \"a string\"\n\n                            RegVarType,\n                            is RegType,\n                            -> \"a register reference\"\n\n                            PointerType -> \"a pointer\" // No known opcodes directly take a pointer.\n\n                            AnyType.Instance -> \"an argument\" // Should never happen.\n                        }\n\n                        addError(col, len, \"Expected ${typeStr}.\")\n                    }\n                }\n\n                // Inject stack push instructions if necessary. Don't inject push instruction if\n                // there's no parameter for the argument (i.e. too many arguments).\n                if (stack && paramType != null) {\n                    // If the token is a register, push it as a register, otherwise coerce type.\n                    if (token === Token.Register) {\n                        if (paramType is RegType) {\n                            addInstruction(\n                                OP_ARG_PUSHB,\n                                listOf(arg),\n                                mnemonicSrcLoc = null,\n                                valid = true,\n                                listOf(srcLoc),\n                                trailingArgSeparator = false,\n                            )\n                        } else {\n                            addInstruction(\n                                OP_ARG_PUSHR,\n                                listOf(arg),\n                                mnemonicSrcLoc = null,\n                                valid = true,\n                                listOf(srcLoc),\n                                trailingArgSeparator = false,\n                            )\n                        }\n                    } else {\n                        when (paramType) {\n                            ByteType,\n                            is RegType,\n                            -> {\n                                addInstruction(\n                                    OP_ARG_PUSHB,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            ShortType,\n                            is LabelType,\n                            -> {\n                                addInstruction(\n                                    OP_ARG_PUSHW,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            IntType -> {\n                                addInstruction(\n                                    OP_ARG_PUSHL,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            // Floats are pushed as ints.\n                            FloatType -> {\n                                addInstruction(\n                                    OP_ARG_PUSHL,\n                                    listOf(IntArg((arg as FloatArg).value.toRawBits())),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            StringType -> {\n                                addInstruction(\n                                    OP_ARG_PUSHS,\n                                    listOf(arg),\n                                    mnemonicSrcLoc = null,\n                                    valid = true,\n                                    listOf(srcLoc),\n                                    trailingArgSeparator = false,\n                                )\n                            }\n\n                            else -> {\n                                logger.error {\n                                    \"Line $lineNo: Type ${paramType::class} not implemented.\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        val paramCount =\n            if (!inlineStackArgs && opcode.stack === StackInteraction.Pop) 0\n            else opcode.params.size\n\n        val trailingArgSeparator = prevToken === Token.ArgSeparator\n\n        // Length from the start of the mnemonic until the end of the last token.\n        val errorLength = prevCol + prevLen - mnemonicSrcLoc.col\n\n        if (opcode.varargs) {\n            // Argument count should be equal to or greater than the amount of parameters for variadic\n            // opcodes.\n            if (argCount < paramCount) {\n                valid = false\n                addError(\n                    mnemonicSrcLoc.col,\n                    errorLength,\n                    \"Expected at least $paramCount argument${\n                        if (paramCount == 1) \"\" else \"s\"\n                    }, got $argCount.\",\n                )\n            }\n        } else {\n            // Argument count should match parameter count exactly for non-variadic opcodes.\n            if (argCount != paramCount) {\n                valid = false\n                addError(\n                    mnemonicSrcLoc.col,\n                    errorLength,\n                    \"Expected $paramCount argument${\n                        if (paramCount == 1) \"\" else \"s\"\n                    }, got $argCount.\",\n                )\n            }\n        }\n\n        // Trailing argument separators are not allowed.\n        if (trailingArgSeparator) {\n            addError(prevCol, prevLen, \"Unexpected comma.\")\n        }\n\n        addInstruction(opcode, immediateArgs, mnemonicSrcLoc, valid, srcLocs, trailingArgSeparator)\n    }\n\n    private fun checkIntValue(col: Int, len: Int, value: Int, size: Int): Arg {\n        // Fast-path 32-bit ints for improved JS perf. Otherwise maxValue would have to be a Long\n        // or UInt, which incurs a perf hit in JS.\n        if (size != 4) {\n            val bitSize = 8 * size\n            // Minimum of the signed version of this integer type.\n            val minValue = -(1 shl (bitSize - 1))\n            // Maximum of the unsigned version of this integer type.\n            val maxValue = (1 shl (bitSize)) - 1\n\n            when {\n                value < minValue -> {\n                    addError(col, len, \"${bitSize}-Bit integer can't be less than ${minValue}.\")\n                }\n                value > maxValue -> {\n                    addError(col, len, \"${bitSize}-Bit integer can't be greater than ${maxValue}.\")\n                }\n            }\n        }\n\n        return IntArg(value)\n    }\n\n    private fun parseBytes() {\n        val bytes = mutableListOf<Byte>()\n\n        while (tokenizer.type === Token.Int32) {\n            val value = tokenizer.intValue\n\n            if (value < 0) {\n                addError(\"Unsigned 8-bit integer can't be less than 0.\")\n            } else if (value > 255) {\n                addError(\"Unsigned 8-bit integer can't be greater than 255.\")\n            }\n\n            bytes.add(value.toByte())\n\n            tokenizer.nextToken()\n        }\n\n        if (tokenizer.type != null) {\n            addError(\"Expected an unsigned 8-bit integer.\")\n        }\n\n        addBytes(bytes.toByteArray())\n    }\n\n    private fun parseString() {\n        addString(tokenizer.strValue.replace(\"\\n\", \"<cr>\"))\n\n        if (tokenizer.nextToken()) {\n            addUnexpectedTokenError()\n        }\n    }\n\n    private fun srcLocFromTokenizer(): SrcLoc = SrcLoc(lineNo, tokenizer.col, tokenizer.len)\n}\n","package world.phantasmal.psolib.asm\n\nimport world.phantasmal.core.unsafe.unsafeAssertNotNull\nimport world.phantasmal.psolib.buffer.Buffer\nimport kotlin.math.ceil\n\n/**\n * Intermediate representation of PSO bytecode. Used by most ASM/bytecode analysis code.\n */\nclass BytecodeIr(\n    val segments: List<Segment>,\n) {\n    fun instructionSegments(): List<InstructionSegment> =\n        segments.filterIsInstance<InstructionSegment>()\n\n    fun copy(): BytecodeIr =\n        BytecodeIr(segments.map { it.copy() })\n}\n\nenum class SegmentType {\n    Instructions,\n    Data,\n    String,\n}\n\n/**\n * Segment of bytecode. A segment starts with an instruction, data block or string that is\n * referenced by one or more labels. The segment ends right before the next instruction, data block\n * or string that is referenced by a label.\n */\nsealed class Segment(\n    val type: SegmentType,\n    val labels: MutableList<Int>,\n    val srcLoc: SegmentSrcLoc,\n) {\n    abstract fun size(dcGcFormat: Boolean): Int\n    abstract fun copy(): Segment\n}\n\nclass InstructionSegment(\n    labels: MutableList<Int>,\n    val instructions: MutableList<Instruction>,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.Instructions, labels, srcLoc) {\n    override fun size(dcGcFormat: Boolean): Int =\n        instructions.sumOf { it.getSize(dcGcFormat) }\n\n    override fun copy(): InstructionSegment =\n        InstructionSegment(\n            ArrayList(labels),\n            instructions.mapTo(ArrayList(instructions.size)) { it.copy() },\n            srcLoc.copy(),\n        )\n}\n\nclass DataSegment(\n    labels: MutableList<Int>,\n    val data: Buffer,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.Data, labels, srcLoc) {\n    override fun size(dcGcFormat: Boolean): Int =\n        data.size\n\n    override fun copy(): DataSegment =\n        DataSegment(ArrayList(labels), data.copy(), srcLoc.copy())\n}\n\nclass StringSegment(\n    labels: MutableList<Int>,\n    value: String,\n    /**\n     * Normally string segments have a byte length that is a multiple of 4, but some bytecode is\n     * malformed so we store the initial size in the bytecode.\n     */\n    private var bytecodeSize: Int?,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.String, labels, srcLoc) {\n    var value: String = value\n        set(value) {\n            bytecodeSize = null\n            field = value\n        }\n\n    override fun size(dcGcFormat: Boolean): Int =\n        // String segments should be multiples of 4 bytes.\n        bytecodeSize\n            ?: if (dcGcFormat) {\n                4 * ceil((value.length + 1) / 4.0).toInt()\n            } else {\n                4 * ceil((value.length + 1) / 2.0).toInt()\n            }\n\n    override fun copy(): StringSegment =\n        StringSegment(ArrayList(labels), value, bytecodeSize, srcLoc.copy())\n}\n\n/**\n * Opcode invocation.\n */\nclass Instruction(\n    val opcode: Opcode,\n    /**\n     * Immediate arguments for the opcode.\n     */\n    val args: List<Arg>,\n    val valid: Boolean,\n    val srcLoc: InstructionSrcLoc?,\n) {\n    /**\n     * Maps each parameter by index to its immediate arguments.\n     */\n    // Avoid using lazy to keep GC pressure low.\n    private var paramToArgs: List<List<Arg>>? = null\n\n    /**\n     * Returns the immediate arguments for the parameter at the given index.\n     */\n    fun getArgs(paramIndex: Int): List<Arg> {\n        if (paramToArgs == null) {\n            val paramToArgs: MutableList<List<Arg>> = mutableListOf()\n            this.paramToArgs = paramToArgs\n\n            if (opcode.stack !== StackInteraction.Pop) {\n                for (i in opcode.params.indices) {\n                    val param = opcode.params[i]\n\n                    // Variable length arguments are always last, so we can just gobble up all\n                    // arguments from this point.\n                    val pArgs = if (param.varargs) {\n                        check(i == opcode.params.lastIndex)\n                        args.drop(i)\n                    } else {\n                        listOfNotNull(args.getOrNull(i))\n                    }\n\n                    paramToArgs.add(pArgs)\n                }\n            }\n        }\n\n        return unsafeAssertNotNull(paramToArgs)[paramIndex]\n    }\n\n    /**\n     * Returns the source locations of the (immediate or stack) arguments for the parameter at the\n     * given index.\n     */\n    fun getArgSrcLocs(paramIndex: Int): List<ArgSrcLoc> {\n        val argSrcLocs = srcLoc?.args\n            ?: return emptyList()\n\n        return if (opcode.params[paramIndex].varargs) {\n            // Variadic parameters are always last, so we can just gobble up all SrcLocs from\n            // paramIndex onward.\n            argSrcLocs.drop(paramIndex)\n        } else {\n            listOfNotNull(argSrcLocs.getOrNull(paramIndex))\n        }\n    }\n\n    /**\n     * Returns the byte size of the entire instruction, i.e. the sum of the opcode size and all\n     * argument sizes.\n     */\n    fun getSize(dcGcFormat: Boolean): Int {\n        var size = opcode.size\n\n        if (opcode.stack === StackInteraction.Pop) return size\n\n        for (i in opcode.params.indices) {\n            val type = opcode.params[i].type\n            val args = getArgs(i)\n\n            size += when (type) {\n                ByteType -> 1\n\n                // Ensure this case is before the LabelType case because ILabelVarType extends\n                // LabelType.\n                ILabelVarType -> 1 + 2 * args.size\n\n                ShortType -> 2\n\n                IntType,\n                FloatType,\n                -> 4\n\n                StringType -> {\n                    if (dcGcFormat) {\n                        (args[0] as StringArg).value.length + 1\n                    } else {\n                        2 * (args[0] as StringArg).value.length + 2\n                    }\n                }\n\n                RegVarType -> 1 + args.size\n\n                // Check RegRefType and LabelType last, because \"is\" checks are very slow in JS.\n\n                is RegType -> 1\n\n                is LabelType -> 2\n\n                else -> error(\"Parameter type ${type::class} not implemented.\")\n            }\n        }\n\n        return size\n    }\n\n    fun copy(): Instruction =\n        Instruction(opcode, args, valid, srcLoc).also { it.paramToArgs = paramToArgs }\n}\n\n/**\n * Instruction argument.\n */\nsealed class Arg {\n    abstract val value: Any?\n\n    abstract fun coerceInt(): Int\n    abstract fun coerceFloat(): Float\n    abstract fun coerceString(): String\n}\n\ndata class IntArg(override val value: Int) : Arg() {\n    override fun coerceInt(): Int = value\n    override fun coerceFloat(): Float = Float.fromBits(value)\n    override fun coerceString(): String = value.toString()\n}\n\ndata class FloatArg(override val value: Float) : Arg() {\n    override fun coerceInt(): Int = value.toRawBits()\n    override fun coerceFloat(): Float = value\n    override fun coerceString(): String = value.toString()\n}\n\ndata class StringArg(override val value: String) : Arg() {\n    override fun coerceInt(): Int = 0\n    override fun coerceFloat(): Float = 0f\n    override fun coerceString(): String = value\n}\n\ndata class UnknownArg(override val value: Any?) : Arg() {\n    override fun coerceInt(): Int = 0\n    override fun coerceFloat(): Float = 0f\n    override fun coerceString(): String = \"\"\n}\n\n/**\n * Position and length of related source assembly code.\n */\nclass SrcLoc(\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n)\n\n/**\n * Locations of the instruction parts in the source assembly code.\n */\nclass InstructionSrcLoc(\n    val mnemonic: SrcLoc?,\n    /**\n     * Immediate or stack argument locations.\n     */\n    val args: List<ArgSrcLoc> = emptyList(),\n    /**\n     * Does the instruction end with a comma? This can be the case when a user has partially typed\n     * an instruction.\n     */\n    val trailingArgSeparator: Boolean,\n)\n\n/**\n * Location of an instruction argument in the source assembly code.\n */\nclass ArgSrcLoc(\n    /**\n     * The precise location of this argument.\n     */\n    val precise: SrcLoc,\n    /**\n     * The location of this argument, its surrounding whitespace and the following comma if there is\n     * one.\n     */\n    val coarse: SrcLoc,\n)\n\n/**\n * Locations of a segment's labels in the source assembly code.\n */\nclass SegmentSrcLoc(val labels: MutableList<SrcLoc> = mutableListOf()) {\n    fun copy(): SegmentSrcLoc =\n        SegmentSrcLoc(ArrayList(labels))\n}\n","package world.phantasmal.psolib.asm\n\nimport world.phantasmal.core.unsafe.UnsafeMap\n\nprivate val MNEMONIC_TO_OPCODES: UnsafeMap<String, Opcode> by lazy {\n    val map = UnsafeMap<String, Opcode>()\n\n    OPCODES.forEach { if (it != null) map.set(it.mnemonic, it) }\n    OPCODES_F8.forEach { if (it != null) map.set(it.mnemonic, it) }\n    OPCODES_F9.forEach { if (it != null) map.set(it.mnemonic, it) }\n\n    map\n}\nprivate val UNKNOWN_OPCODE_MNEMONIC_REGEX = Regex(\"\"\"^unknown_((f8|f9)?[0-9a-f]{2})$\"\"\")\n\n/**\n * Abstract super type of all types.\n */\nsealed class AnyType {\n    object Instance : AnyType()\n}\n\n/**\n * Purely abstract super type of all value types.\n */\nsealed class ValueType : AnyType()\n\n/**\n * 8-Bit integer.\n */\nobject ByteType : ValueType()\n\n/**\n * 16-Bit integer.\n */\nobject ShortType : ValueType()\n\n/**\n * 32-Bit integer.\n */\nobject IntType : ValueType()\n\n/**\n * 32-Bit floating point number.\n */\nobject FloatType : ValueType()\n\n/**\n * Abstract super type of all label types.\n */\nsealed class LabelType : ValueType() {\n    object Instance : LabelType()\n}\n\n/**\n * Named reference to an instruction.\n */\nobject ILabelType : LabelType()\n\n/**\n * Named reference to a data segment.\n */\nobject DLabelType : LabelType()\n\n/**\n * Named reference to a string segment.\n */\nobject SLabelType : LabelType()\n\n/**\n * Arbitrary amount of instruction labels (variadic arguments).\n */\nobject ILabelVarType : LabelType()\n\n/**\n * String of arbitrary size.\n */\nobject StringType : ValueType()\n\n/**\n * Purely abstract super type of all register reference types.\n */\nsealed class RegRefType : AnyType()\n\n/**\n * Register reference. If [registers] is null, references one or more consecutive registers of any\n * type (only stack_pushm and stack_popm use this). If [registers] is not null, references a fixed\n * amount of consecutive registers of specific types. [Param.type] can't be a variadic type.\n */\nclass RegType(val registers: List<Param>?) : RegRefType()\n\n/**\n * Arbitrary amount of register references (variadic arguments).\n */\nobject RegVarType : RegRefType()\n\n/**\n * Raw memory pointer.\n */\nobject PointerType : AnyType()\n\nclass Param(\n    val type: AnyType,\n    val name: String?,\n    /**\n     * Documentation string.\n     */\n    val doc: String?,\n    /**\n     * Whether or not the instruction reads this parameter. Only set when type is a register\n     * reference.\n     */\n    val read: Boolean,\n    /**\n     * Whether or not the instruction writes this parameter. Only set when type is a register\n     * reference.\n     */\n    val write: Boolean,\n) {\n    /**\n     * Whether or not this parameter takes a variable number of arguments.\n     */\n    val varargs: Boolean = type === ILabelVarType || type === RegVarType\n}\n\nenum class StackInteraction {\n    Push,\n    Pop,\n}\n\n/**\n * Opcode for script byte code. Invoked by instructions.\n * Don't directly instantiate this class, use the global constants and lookup functions.\n */\nclass Opcode internal constructor(\n    /**\n     * 1- Or 2-byte big-endian representation of this opcode as used in byte code.\n     */\n    val code: Int,\n    /**\n     * String representation of this opcode as used in assembly.\n     */\n    val mnemonic: String,\n    /**\n     * Documentation string.\n     */\n    val doc: String?,\n    /**\n     * Parameters passed in directly or via the stack, depending on the value of [stack].\n     */\n    val params: List<Param>,\n    /**\n     * Stack interaction.\n     */\n    val stack: StackInteraction?,\n    /**\n     * Whether or not the last parameter of this opcode takes a variable number of arguments.\n     */\n    val varargs: Boolean,\n    /**\n     * Whether or not the working of this opcode is known.\n     */\n    val known: Boolean,\n) {\n    /**\n     * Byte size of the opcode, either 1 or 2.\n     */\n    val size: Int = if (code < 0xFF) 1 else 2\n\n    override fun equals(other: Any?): Boolean = this === other\n\n    override fun hashCode(): Int = code\n\n    override fun toString(): String = mnemonic\n}\n\nfun codeToOpcode(code: Int): Opcode =\n    when {\n        code <= 0xFF -> getOpcode(code, code, OPCODES)\n        code <= 0xF8FF -> getOpcode(code, code and 0xFF, OPCODES_F8)\n        else -> getOpcode(code, code and 0xFF, OPCODES_F9)\n    }\n\nfun mnemonicToOpcode(mnemonic: String): Opcode? {\n    var opcode = MNEMONIC_TO_OPCODES.get(mnemonic)\n\n    if (opcode == null) {\n        UNKNOWN_OPCODE_MNEMONIC_REGEX.matchEntire(mnemonic)?.destructured?.let { (codeStr) ->\n            val code = codeStr.toInt(16)\n            opcode = codeToOpcode(code)\n            MNEMONIC_TO_OPCODES.set(mnemonic, opcode!!)\n        }\n    }\n\n    return opcode\n}\n\nprivate fun getOpcode(code: Int, index: Int, opcodes: Array<Opcode?>): Opcode {\n    var opcode = opcodes[index]\n\n    if (opcode == null) {\n        opcode = Opcode(\n            code,\n            mnemonic = \"unknown_${code.toString(16)}\",\n            doc = null,\n            params = emptyList(),\n            stack = null,\n            varargs = false,\n            known = false,\n        )\n        opcodes[index] = opcode\n    }\n\n    return opcode\n}\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun Char.fastIsWhitespace(): Boolean =\n    asDynamic() == 0x20 || (asDynamic() >= 0x09 && asDynamic() <= 0x0D)\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun Char.isDigit(): Boolean =\n    asDynamic() >= 0x30 && asDynamic() <= 0x39\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun String.fastReplace(oldValue: String, newValue: String): String =\n    asDynamic().replaceAll(oldValue, newValue).unsafeCast<String>()\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun String.getCodePointAt(index: Int): Int =\n    asDynamic().charCodeAt(index).unsafeCast<Int>()\n","package world.phantasmal.psolib.asm.dataFlowAnalysis\n\nimport world.phantasmal.psolib.asm.*\n\n// See https://en.wikipedia.org/wiki/Control-flow_graph.\n\nenum class BranchType {\n    /**\n     * Only encountered when the last segment of a script has no jump or return.\n     */\n    None,\n\n    /**\n     * ret.\n     */\n    Return,\n\n    /**\n     * jmp.\n     */\n    Jump,\n\n    /**\n     * Every other jump instruction.\n     */\n    ConditionalJump,\n\n    /**\n     * call, switch_call or va_call.\n     */\n    Call,\n}\n\n/**\n * Instruction sequence into which control flow only enters at the start and only leaves at the end.\n * No code jumps/returns/calls into the middle of a basic block or branches out of a basic block\n * from the middle.\n */\ninterface BasicBlock {\n    /**\n     * The instruction segment that this block is a part of.\n     */\n    val segment: InstructionSegment\n\n    /**\n     * Index of this block's first instruction.\n     */\n    val start: Int\n\n    /**\n     * Index of the instruction right after this block's last instruction.\n     */\n    val end: Int\n\n    /**\n     * The way control flow leaves this block.\n     */\n    val branchType: BranchType\n\n    /**\n     * Either jumps or calls when non-empty, depending on [branchType].\n     */\n    val branchLabels: List<Int>\n\n    /**\n     * The blocks which branch to this block.\n     */\n    val from: List<BasicBlock>\n\n    /**\n     * The blocks this block branches to.\n     */\n    val to: List<BasicBlock>\n\n    fun indexOfInstruction(instruction: Instruction): Int\n}\n\n/**\n * Graph representing the flow of control through the [BasicBlock]s of a script.\n */\nclass ControlFlowGraph internal constructor(\n    val blocks: List<BasicBlock>,\n    private val instructionToBlock: Map<Instruction, BasicBlock>,\n) {\n    fun getBlockForInstruction(instruction: Instruction): BasicBlock {\n        val block = instructionToBlock[instruction]\n        requireNotNull(block) { \"Instruction is not part of the control-flow graph.\" }\n        return block\n    }\n\n    companion object {\n        fun create(bytecodeIr: BytecodeIr): ControlFlowGraph =\n            create(bytecodeIr.instructionSegments())\n\n        fun create(segments: List<InstructionSegment>): ControlFlowGraph {\n            val cfg = ControlFlowGraphBuilder()\n\n            // Mapping of labels to basic blocks.\n            for (segment in segments) {\n                createBasicBlocks(cfg, segment)\n            }\n\n            linkBlocks(cfg)\n            return cfg.build()\n        }\n    }\n}\n\nprivate class ControlFlowGraphBuilder {\n    val blocks: MutableList<BasicBlockImpl> = mutableListOf()\n    val instructionsToBlock: MutableMap<Instruction, BasicBlockImpl> = mutableMapOf()\n    val labelsToBlock: MutableMap<Int, BasicBlockImpl> = mutableMapOf()\n\n    fun build(): ControlFlowGraph =\n        ControlFlowGraph(blocks, instructionsToBlock)\n}\n\nprivate class BasicBlockImpl(\n    override val segment: InstructionSegment,\n    override val start: Int,\n    override val end: Int,\n    override val branchType: BranchType,\n    override val branchLabels: List<Int>,\n) : BasicBlock {\n    override val from: MutableList<BasicBlockImpl> = mutableListOf()\n    override val to: MutableList<BasicBlockImpl> = mutableListOf()\n\n    override fun indexOfInstruction(instruction: Instruction): Int {\n        var index = -1\n\n        for (i in start until end) {\n            if (instruction == segment.instructions[i]) {\n                index = i\n                break\n            }\n        }\n\n        return index\n    }\n\n    fun linkTo(other: BasicBlockImpl) {\n        if (other !in to) {\n            to.add(other)\n            other.from.add(this)\n        }\n    }\n}\n\nprivate fun createBasicBlocks(cfg: ControlFlowGraphBuilder, segment: InstructionSegment) {\n    val len = segment.instructions.size\n    var start = 0\n    var firstBlock = true\n\n    for (i in 0 until len) {\n        val inst = segment.instructions[i]\n\n        var branchType: BranchType\n        var branchLabels: List<Int>\n\n        when (inst.opcode.code) {\n            // Return.\n            OP_RET.code -> {\n                branchType = BranchType.Return\n                branchLabels = emptyList()\n            }\n\n            // Unconditional jump.\n            OP_JMP.code -> {\n                branchType = BranchType.Jump\n                branchLabels = listOfNotNull((inst.args[0] as? IntArg)?.value)\n            }\n\n            // Conditional jumps.\n            OP_JMP_ON.code,\n            OP_JMP_OFF.code,\n            -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = listOfNotNull((inst.args[0] as? IntArg)?.value)\n            }\n            OP_JMP_E.code,\n            OP_JMPI_E.code,\n            OP_JMP_NE.code,\n            OP_JMPI_NE.code,\n            OP_UJMP_G.code,\n            OP_UJMPI_G.code,\n            OP_JMP_G.code,\n            OP_JMPI_G.code,\n            OP_UJMP_L.code,\n            OP_UJMPI_L.code,\n            OP_JMP_L.code,\n            OP_JMPI_L.code,\n            OP_UJMP_GE.code,\n            OP_UJMPI_GE.code,\n            OP_JMP_GE.code,\n            OP_JMPI_GE.code,\n            OP_UJMP_LE.code,\n            OP_UJMPI_LE.code,\n            OP_JMP_LE.code,\n            OP_JMPI_LE.code,\n            -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = listOfNotNull((inst.args[2] as? IntArg)?.value)\n            }\n            OP_SWITCH_JMP.code -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = inst.args.drop(1).mapNotNull { (it as? IntArg)?.value }\n            }\n\n            // Calls.\n            OP_CALL.code,\n            OP_VA_CALL.code,\n            -> {\n                branchType = BranchType.Call\n                branchLabels = listOfNotNull((inst.args[0] as? IntArg)?.value)\n            }\n            OP_SWITCH_CALL.code -> {\n                branchType = BranchType.Call\n                branchLabels = inst.args.drop(1).mapNotNull { (it as? IntArg)?.value }\n            }\n\n            // All other opcodes.\n            else -> {\n                if (i == len - 1) {\n                    // This is the last block of the segment.\n                    branchType = BranchType.None\n                    branchLabels = emptyList()\n                } else {\n                    // Non-branching instruction, part of the current block.\n                    continue\n                }\n            }\n        }\n\n        val block = BasicBlockImpl(segment, start, i + 1, branchType, branchLabels)\n\n        for (j in block.start until block.end) {\n            cfg.instructionsToBlock[block.segment.instructions[j]] = block\n        }\n\n        cfg.blocks.add(block)\n\n        if (firstBlock) {\n            for (label in segment.labels) {\n                cfg.labelsToBlock[label] = block\n            }\n\n            firstBlock = false\n        }\n\n        start = i + 1\n    }\n}\n\nprivate fun linkBlocks(cfg: ControlFlowGraphBuilder) {\n    // Pairs of calling block and block to which callees should return to.\n    val callers = mutableListOf<Pair<BasicBlockImpl, BasicBlockImpl>>()\n\n    for ((i, block) in cfg.blocks.withIndex()) {\n        val nextBlock = cfg.blocks.getOrNull(i + 1)\n\n        when (block.branchType) {\n            BranchType.Return ->\n                continue\n\n            BranchType.Call ->\n                nextBlock?.let { callers.add(block to nextBlock) }\n\n            BranchType.None,\n            BranchType.ConditionalJump,\n            -> nextBlock?.let(block::linkTo)\n\n            BranchType.Jump -> {\n                // Ignore.\n            }\n        }\n\n        for (label in block.branchLabels) {\n            cfg.labelsToBlock[label]?.let { toBlock ->\n                block.linkTo(toBlock)\n            }\n        }\n    }\n\n    for ((caller, ret) in callers) {\n        linkReturningBlocks(cfg.labelsToBlock, ret, caller)\n    }\n}\n\n/**\n * Links returning blocks to their callers.\n *\n * @param labelBlocks Mapping of labels to basic blocks.\n * @param ret Basic block the caller should return to.\n * @param caller Calling basic block.\n */\nprivate fun linkReturningBlocks(\n    labelBlocks: Map<Int, BasicBlockImpl>,\n    ret: BasicBlockImpl,\n    caller: BasicBlockImpl,\n) {\n    for (label in caller.branchLabels) {\n        labelBlocks[label]?.let { callee ->\n            if (callee.branchType === BranchType.Return) {\n                callee.linkTo(ret)\n            } else {\n                linkReturningBlocksRecurse(mutableSetOf(), ret, callee)\n            }\n        }\n    }\n}\n\n/**\n * @param encountered For avoiding infinite loops.\n * @param ret\n * @param block\n */\nprivate fun linkReturningBlocksRecurse(\n    encountered: MutableSet<BasicBlockImpl>,\n    ret: BasicBlockImpl,\n    block: BasicBlockImpl,\n) {\n    if (block in encountered) {\n        return\n    } else {\n        encountered.add(block)\n    }\n\n    for (toBlock in block.to) {\n        if (toBlock.branchType === BranchType.Return) {\n            toBlock.linkTo(ret)\n        } else {\n            linkReturningBlocksRecurse(encountered, ret, toBlock)\n        }\n    }\n}\n","package world.phantasmal.psolib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.asm.*\n\nprivate val logger = KotlinLogging.logger {}\n\nfun getMapDesignations(\n    func0Segment: InstructionSegment,\n    createCfg: () -> ControlFlowGraph,\n): MutableMap<Int, Int> {\n    val mapDesignations = mutableMapOf<Int, Int>()\n    var cfg: ControlFlowGraph? = null\n\n    for (inst in func0Segment.instructions) {\n        when (inst.opcode.code) {\n            OP_MAP_DESIGNATE.code,\n            OP_MAP_DESIGNATE_EX.code,\n            -> {\n                if (cfg == null) {\n                    cfg = createCfg()\n                }\n\n                val areaId = getRegisterValue(cfg, inst, (inst.args[0] as IntArg).value)\n\n                if (areaId.size > 1) {\n                    logger.warn {\n                        \"Couldn't determine area ID for ${inst.opcode.mnemonic} instruction.\"\n                    }\n                    continue\n                }\n\n                val variantIdRegister =\n                    (inst.args[0] as IntArg).value + (if (inst.opcode == OP_MAP_DESIGNATE) 2 else 3)\n                val variantId = getRegisterValue(cfg, inst, variantIdRegister)\n\n                if (variantId.size > 1) {\n                    logger.warn {\n                        \"Couldn't determine area variant ID for ${inst.opcode.mnemonic} instruction.\"\n                    }\n                    continue\n                }\n\n                mapDesignations[areaId[0]!!] = variantId[0]!!\n            }\n\n            OP_BB_MAP_DESIGNATE.code -> {\n                mapDesignations[(inst.args[0] as IntArg).value] = (inst.args[2] as IntArg).value\n            }\n        }\n    }\n\n    return mapDesignations\n}\n","package world.phantasmal.psolib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.asm.*\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * Computes the possible values of a stack element at the nth position from the top, right before a\n * specific instruction. If the stack element's value can be traced back to a single push\n * instruction, that instruction is also returned.\n */\nfun getStackValue(\n    cfg: ControlFlowGraph,\n    instruction: Instruction,\n    position: Int,\n): Pair<ValueSet, Instruction?> {\n    val block = cfg.getBlockForInstruction(instruction)\n\n    return StackValueFinder().find(\n        mutableSetOf(),\n        cfg,\n        block,\n        block.indexOfInstruction(instruction),\n        position,\n    )\n}\n\nprivate class StackValueFinder {\n    private var iterations = 0\n\n    fun find(\n        path: MutableSet<BasicBlock>,\n        cfg: ControlFlowGraph,\n        block: BasicBlock,\n        end: Int,\n        position: Int,\n    ): Pair<ValueSet, Instruction?> {\n        if (++iterations > 100) {\n            logger.warn { \"Too many iterations.\" }\n            return Pair(ValueSet.all(), null)\n        }\n\n        var pos = position\n\n        for (i in end - 1 downTo block.start) {\n            val instruction = block.segment.instructions[i]\n\n            if (instruction.opcode.stack == StackInteraction.Pop) {\n                pos += instruction.opcode.params.size\n                continue\n            }\n\n            val args = instruction.args\n\n            when (instruction.opcode.code) {\n                OP_ARG_PUSHR.code -> {\n                    if (pos == 0) {\n                        val arg = args[0]\n\n                        return if (arg is IntArg) {\n                            Pair(getRegisterValue(cfg, instruction, arg.value), instruction)\n                        } else {\n                            Pair(ValueSet.all(), instruction)\n                        }\n                    } else {\n                        pos--\n                    }\n                }\n\n                OP_ARG_PUSHL.code,\n                OP_ARG_PUSHB.code,\n                OP_ARG_PUSHW.code,\n                -> {\n                    if (pos == 0) {\n                        val arg = args[0]\n\n                        return if (arg is IntArg) {\n                            Pair(ValueSet.of(arg.value), instruction)\n                        } else {\n                            Pair(ValueSet.all(), instruction)\n                        }\n                    } else {\n                        pos--\n                    }\n                }\n\n                OP_ARG_PUSHA.code,\n                OP_ARG_PUSHO.code,\n                OP_ARG_PUSHS.code,\n                -> {\n                    if (pos == 0) {\n                        return Pair(ValueSet.all(), instruction)\n                    } else {\n                        pos--\n                    }\n                }\n            }\n        }\n\n        val values = ValueSet.empty()\n        var instruction: Instruction? = null\n        var multipleInstructions = false\n        path.add(block)\n\n        for (from in block.from) {\n            // Bail out from loops.\n            if (from in path) {\n                return Pair(ValueSet.all(), null)\n            }\n\n            val (fromValues, fromInstruction) = find(LinkedHashSet(path), cfg, from, from.end, pos)\n            values.union(fromValues)\n\n            if (!multipleInstructions) {\n                if (instruction == null) {\n                    instruction = fromInstruction\n                } else if (instruction != fromInstruction) {\n                    instruction = null\n                    multipleInstructions = true\n                }\n            }\n        }\n\n        return Pair(values, instruction)\n    }\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport world.phantasmal.psolib.Episode\n\nclass Area(\n    val id: Int,\n    val name: String,\n    val order: Int,\n    val areaVariants: List<AreaVariant>,\n)\n\nclass AreaVariant(\n    val id: Int,\n    val area: Area,\n)\n\nfun getAreasForEpisode(episode: Episode): List<Area> =\n    AREAS.getValue(episode)\n\nprivate val AREAS by lazy {\n    var order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep1 = listOf(\n        createArea(0, \"Pioneer II\", order++, 1),\n        createArea(1, \"Forest 1\", order++, 1),\n        createArea(2, \"Forest 2\", order++, 1),\n        createArea(11, \"Under the Dome\", order++, 1),\n        createArea(3, \"Cave 1\", order++, 6),\n        createArea(4, \"Cave 2\", order++, 5),\n        createArea(5, \"Cave 3\", order++, 6),\n        createArea(12, \"Underground Channel\", order++, 1),\n        createArea(6, \"Mine 1\", order++, 6),\n        createArea(7, \"Mine 2\", order++, 6),\n        createArea(13, \"Monitor Room\", order++, 1),\n        createArea(8, \"Ruins 1\", order++, 5),\n        createArea(9, \"Ruins 2\", order++, 5),\n        createArea(10, \"Ruins 3\", order++, 5),\n        createArea(14, \"Dark Falz\", order++, 1),\n        // TODO:\n        // createArea(15, \"BA Ruins\", order++, 3),\n        // createArea(16, \"BA Spaceship\", order++, 3),\n        // createArea(17, \"Lobby\", order++, 15),\n    )\n\n    order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep2 = listOf(\n        createArea(0, \"Lab\", order++, 1),\n        createArea(1, \"VR Temple Alpha\", order++, 3),\n        createArea(2, \"VR Temple Beta\", order++, 3),\n        createArea(14, \"VR Temple Final\", order++, 1),\n        createArea(3, \"VR Spaceship Alpha\", order++, 3),\n        createArea(4, \"VR Spaceship Beta\", order++, 3),\n        createArea(15, \"VR Spaceship Final\", order++, 1),\n        createArea(5, \"Central Control Area\", order++, 1),\n        createArea(6, \"Jungle Area East\", order++, 1),\n        createArea(7, \"Jungle Area North\", order++, 1),\n        createArea(8, \"Mountain Area\", order++, 3),\n        createArea(9, \"Seaside Area\", order++, 1),\n        createArea(12, \"Cliffs of Gal Da Val\", order++, 1),\n        createArea(10, \"Seabed Upper Levels\", order++, 3),\n        createArea(11, \"Seabed Lower Levels\", order++, 3),\n        createArea(13, \"Test Subject Disposal Area\", order++, 1),\n        createArea(16, \"Seaside Area at Night\", order++, 2),\n        createArea(17, \"Control Tower\", order++, 5),\n    )\n\n    order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep4 = listOf(\n        createArea(0, \"Pioneer II\", order++, 1),\n        createArea(1, \"Crater Route 1\", order++, 1),\n        createArea(2, \"Crater Route 2\", order++, 1),\n        createArea(3, \"Crater Route 3\", order++, 1),\n        createArea(4, \"Crater Route 4\", order++, 1),\n        createArea(5, \"Crater Interior\", order++, 1),\n        createArea(6, \"Subterranean Desert 1\", order++, 3),\n        createArea(7, \"Subterranean Desert 2\", order++, 3),\n        createArea(8, \"Subterranean Desert 3\", order++, 3),\n        createArea(9, \"Meteor Impact Site\", order++, 1),\n    )\n\n    mapOf(\n        Episode.I to ep1,\n        Episode.II to ep2,\n        Episode.IV to ep4,\n    )\n}\n\nprivate fun createArea(id: Int, name: String, order: Int, variants: Int): Area {\n    val avs = mutableListOf<AreaVariant>()\n    val area = Area(id, name, order, avs)\n\n    for (avId in 0 until variants) {\n        avs.add(AreaVariant(avId, area))\n    }\n\n    return area\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\n/**\n * Represents an entity type-specific property for accessing ambiguous parts of the entity data.\n */\nclass EntityProp(\n    val name: String,\n    val offset: Int,\n    val type: EntityPropType,\n)\n\nenum class EntityPropType {\n    I32,\n    F32,\n\n    /**\n     * Signed 32-bit integer that represents an angle. 0x10000 is 360.\n     */\n    Angle,\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport world.phantasmal.psolib.Episode\n\nprivate val FRIENDLY_NPC_PROPERTIES = listOf(\n    EntityProp(name = \"Movement distance\", offset = 44, type = EntityPropType.F32),\n    EntityProp(name = \"Hide register\", offset = 52, type = EntityPropType.F32),\n    EntityProp(name = \"Character ID\", offset = 56, type = EntityPropType.F32),\n    EntityProp(name = \"Script label\", offset = 60, type = EntityPropType.F32),\n    EntityProp(name = \"Movement flag\", offset = 64, type = EntityPropType.I32)\n)\n\nenum class NpcType(\n    override val uniqueName: String,\n    override val simpleName: String = uniqueName,\n    val ultimateName: String = simpleName,\n    val episode: Episode? = null,\n    val enemy: Boolean = false,\n    rareType: (() -> NpcType)? = null,\n    /**\n     * IDs of the areas this NPC can be found in.\n     */\n    val areaIds: List<Int>,\n    /**\n     * Type ID used by the game.\n     */\n    val typeId: Int? = null,\n    /**\n     * Skin value used by the game.\n     */\n    val skin: Int? = null,\n    /**\n     * Boolean specifying whether an NPC is the regular or special variant.\n     * Sometimes signifies a variant (e.g. Barbarous Wolf), sometimes a rare variant (e.g. Pouilly\n     * Slime).\n     */\n    val special: Boolean? = null,\n    /**\n     * NPC-specific properties.\n     */\n    override val properties: List<EntityProp> = emptyList(),\n) : EntityType {\n    //\n    // Unknown NPCs\n    //\n\n    Unknown(\n        uniqueName = \"Unknown\",\n        areaIds = listOf(),\n    ),\n\n    //\n    // Friendly NPCs\n    //\n\n    FemaleFat(\n        uniqueName = \"Female Fat\",\n        areaIds = listOf(0),\n        typeId = 4,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    FemaleMacho(\n        uniqueName = \"Female Macho\",\n        areaIds = listOf(0),\n        typeId = 5,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    FemaleTall(\n        uniqueName = \"Female Tall\",\n        areaIds = listOf(0),\n        typeId = 7,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleDwarf(\n        uniqueName = \"Male Dwarf\",\n        areaIds = listOf(0),\n        typeId = 10,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleFat(\n        uniqueName = \"Male Fat\",\n        areaIds = listOf(0),\n        typeId = 11,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleMacho(\n        uniqueName = \"Male Macho\",\n        areaIds = listOf(0),\n        typeId = 12,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleOld(\n        uniqueName = \"Male Old\",\n        areaIds = listOf(0),\n        typeId = 13,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    BlueSoldier(\n        uniqueName = \"Blue Soldier\",\n        areaIds = listOf(0),\n        typeId = 25,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    RedSoldier(\n        uniqueName = \"Red Soldier\",\n        areaIds = listOf(0),\n        typeId = 26,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Principal(\n        uniqueName = \"Principal\",\n        areaIds = listOf(0),\n        typeId = 27,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Tekker(\n        uniqueName = \"Tekker\",\n        areaIds = listOf(0),\n        typeId = 28,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    GuildLady(\n        uniqueName = \"Guild Lady\",\n        areaIds = listOf(0),\n        typeId = 29,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Scientist(\n        uniqueName = \"Scientist\",\n        areaIds = listOf(0),\n        typeId = 30,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Nurse(\n        uniqueName = \"Nurse\",\n        areaIds = listOf(0),\n        typeId = 31,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Irene(\n        uniqueName = \"Irene\",\n        areaIds = listOf(0),\n        typeId = 32,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    ItemShop(\n        uniqueName = \"Item Shop\",\n        areaIds = listOf(0),\n        typeId = 241,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Nurse2(\n        uniqueName = \"Nurse (Ep. II)\",\n        simpleName = \"Nurse\",\n        episode = Episode.II,\n        areaIds = listOf(0),\n        typeId = 254,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n\n    //\n    // Enemy NPCs\n    //\n\n    // Episode I Forest\n\n    Hildebear(\n        uniqueName = \"Hildebear\",\n        ultimateName = \"Hildelt\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { Hildeblue },\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 0,\n        special = false,\n    ),\n    Hildeblue(\n        uniqueName = \"Hildeblue\",\n        ultimateName = \"Hildetorr\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 1,\n        special = false,\n    ),\n    RagRappy(\n        uniqueName = \"Rag Rappy\",\n        ultimateName = \"El Rappy\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { AlRappy },\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    AlRappy(\n        uniqueName = \"Al Rappy\",\n        ultimateName = \"Pal Rappy\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    Monest(\n        uniqueName = \"Monest\",\n        ultimateName = \"Mothvist\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 66,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"State\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Start number\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Total number\", offset = 52, type = EntityPropType.F32)\n        ),\n    ),\n    Mothmant(\n        uniqueName = \"Mothmant\",\n        ultimateName = \"Mothvert\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    SavageWolf(\n        uniqueName = \"Savage Wolf\",\n        ultimateName = \"Gulgus\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 67,\n        skin = 0,\n        special = false,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    BarbarousWolf(\n        uniqueName = \"Barbarous Wolf\",\n        ultimateName = \"Gulgus-Gue\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 67,\n        skin = 0,\n        special = true,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    Booma(\n        uniqueName = \"Booma\",\n        ultimateName = \"Bartle\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Gobooma(\n        uniqueName = \"Gobooma\",\n        ultimateName = \"Barble\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Gigobooma(\n        uniqueName = \"Gigobooma\",\n        ultimateName = \"Tollaw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Dragon(\n        uniqueName = \"Dragon\",\n        ultimateName = \"Sil Dragon\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(11),\n        typeId = 192,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Caves\n\n    GrassAssassin(\n        uniqueName = \"Grass Assassin\",\n        ultimateName = \"Crimson Assassin\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 96,\n        skin = 0,\n        special = false,\n    ),\n    PoisonLily(\n        uniqueName = \"Poison Lily\",\n        ultimateName = \"Ob Lily\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { NarLily },\n        areaIds = listOf(3, 4, 5),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    NarLily(\n        uniqueName = \"Nar Lily\",\n        ultimateName = \"Mil Lily\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 97,\n        skin = 1,\n        special = true,\n    ),\n    NanoDragon(\n        uniqueName = \"Nano Dragon\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 98,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spawn flag\", offset = 64, type = EntityPropType.I32)\n        ),\n    ),\n    EvilShark(\n        uniqueName = \"Evil Shark\",\n        ultimateName = \"Vulmer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    PalShark(\n        uniqueName = \"Pal Shark\",\n        ultimateName = \"Govulmer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    GuilShark(\n        uniqueName = \"Guil Shark\",\n        ultimateName = \"Melqueek\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    PofuillySlime(\n        uniqueName = \"Pofuilly Slime\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { PouillySlime },\n        areaIds = listOf(3, 4, 5),\n        typeId = 100,\n        skin = 0,\n        special = false,\n    ),\n    PouillySlime(\n        uniqueName = \"Pouilly Slime\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 100,\n        skin = 0,\n        special = true,\n    ),\n    PanArms(\n        uniqueName = \"Pan Arms\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 101,\n        skin = 0,\n        special = false,\n    ),\n    Migium(\n        uniqueName = \"Migium\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Hidoom(\n        uniqueName = \"Hidoom\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    DeRolLe(\n        uniqueName = \"De Rol Le\",\n        ultimateName = \"Dal Ra Lie\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(12),\n        typeId = 193,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Mines\n\n    Dubchic(\n        uniqueName = \"Dubchic\",\n        ultimateName = \"Dubchich\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 128,\n        skin = 0,\n        special = false,\n    ),\n    Gilchic(\n        uniqueName = \"Gilchic\",\n        ultimateName = \"Gilchich\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 128,\n        skin = 1,\n        special = false,\n    ),\n    Garanz(\n        uniqueName = \"Garanz\",\n        ultimateName = \"Baranz\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 129,\n        skin = 0,\n        special = false,\n    ),\n    SinowBeat(\n        uniqueName = \"Sinow Beat\",\n        ultimateName = \"Sinow Blue\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 130,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Invisible\", offset = 44, type = EntityPropType.F32)\n        ),\n    ),\n    SinowGold(\n        uniqueName = \"Sinow Gold\",\n        ultimateName = \"Sinow Red\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 130,\n        skin = 0,\n        special = true,\n        properties = listOf(\n            EntityProp(name = \"Invisible\", offset = 44, type = EntityPropType.F32)\n        ),\n    ),\n    Canadine(\n        uniqueName = \"Canadine\",\n        ultimateName = \"Canabin\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 131,\n        skin = 0,\n        special = false,\n    ),\n    Canane(\n        uniqueName = \"Canane\",\n        ultimateName = \"Canune\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 132,\n        skin = 0,\n        special = false,\n    ),\n    Dubswitch(\n        uniqueName = \"Dubswitch\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 133,\n        skin = 0,\n        special = false,\n    ),\n    VolOptPart1(\n        uniqueName = \"Vol Opt (Part 1)\",\n        simpleName = \"Vol Opt\",\n        ultimateName = \"Vol Opt ver.2\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 194,\n        skin = 0,\n        special = false,\n    ),\n    VolOptPart2(\n        uniqueName = \"Vol Opt (Part 2)\",\n        simpleName = \"Vol Opt\",\n        ultimateName = \"Vol Opt ver.2\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 197,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Ruins\n\n    Delsaber(\n        uniqueName = \"Delsaber\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 160,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Jump distance\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Block HP\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    ChaosSorcerer(\n        uniqueName = \"Chaos Sorcerer\",\n        ultimateName = \"Gran Sorcerer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 161,\n        skin = 0,\n        special = false,\n    ),\n    DarkGunner(\n        uniqueName = \"Dark Gunner\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 162,\n        skin = 0,\n        special = false,\n    ),\n    DeathGunner(\n        uniqueName = \"Death Gunner\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    ChaosBringer(\n        uniqueName = \"Chaos Bringer\",\n        ultimateName = \"Dark Bringer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 164,\n        skin = 0,\n        special = false,\n    ),\n    DarkBelra(\n        uniqueName = \"Dark Belra\",\n        ultimateName = \"Indi Belra\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 165,\n        skin = 0,\n        special = false,\n    ),\n    Dimenian(\n        uniqueName = \"Dimenian\",\n        ultimateName = \"Arlan\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    LaDimenian(\n        uniqueName = \"La Dimenian\",\n        ultimateName = \"Merlan\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    SoDimenian(\n        uniqueName = \"So Dimenian\",\n        ultimateName = \"Del-D\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Bulclaw(\n        uniqueName = \"Bulclaw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 167,\n        skin = 0,\n        special = false,\n    ),\n    Bulk(\n        uniqueName = \"Bulk\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Claw(\n        uniqueName = \"Claw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 168,\n        skin = 0,\n        special = false,\n    ),\n    DarkFalz(\n        uniqueName = \"Dark Falz\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(14),\n        typeId = 200,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II VR Temple\n\n    Hildebear2(\n        uniqueName = \"Hildebear (Ep. II)\",\n        simpleName = \"Hildebear\",\n        ultimateName = \"Hildelt\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { Hildeblue2 },\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 0,\n        special = false,\n    ),\n    Hildeblue2(\n        uniqueName = \"Hildeblue (Ep. II)\",\n        simpleName = \"Hildeblue\",\n        ultimateName = \"Hildetorr\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 1,\n        special = false,\n    ),\n    RagRappy2(\n        uniqueName = \"Rag Rappy (Ep. II)\",\n        simpleName = \"Rag Rappy\",\n        ultimateName = \"El Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { LoveRappy },\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    LoveRappy(\n        uniqueName = \"Love Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    StRappy(\n        uniqueName = \"St. Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    HalloRappy(\n        uniqueName = \"Hallo Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    EggRappy(\n        uniqueName = \"Egg Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Monest2(\n        uniqueName = \"Monest (Ep. II)\",\n        simpleName = \"Monest\",\n        ultimateName = \"Mothvist\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 66,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"State\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Start number\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Total number\", offset = 52, type = EntityPropType.F32)\n        ),\n    ),\n    Mothmant2(\n        uniqueName = \"Mothmant\",\n        ultimateName = \"Mothvert\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    PoisonLily2(\n        uniqueName = \"Poison Lily (Ep. II)\",\n        simpleName = \"Poison Lily\",\n        ultimateName = \"Ob Lily\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { NarLily2 },\n        areaIds = listOf(1, 2),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    NarLily2(\n        uniqueName = \"Nar Lily (Ep. II)\",\n        simpleName = \"Nar Lily\",\n        ultimateName = \"Mil Lily\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 97,\n        skin = 1,\n        special = false,\n    ),\n    GrassAssassin2(\n        uniqueName = \"Grass Assassin (Ep. II)\",\n        simpleName = \"Grass Assassin\",\n        ultimateName = \"Crimson Assassin\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 96,\n        skin = 0,\n        special = false,\n    ),\n    Dimenian2(\n        uniqueName = \"Dimenian (Ep. II)\",\n        simpleName = \"Dimenian\",\n        ultimateName = \"Arlan\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    LaDimenian2(\n        uniqueName = \"La Dimenian (Ep. II)\",\n        simpleName = \"La Dimenian\",\n        ultimateName = \"Merlan\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    SoDimenian2(\n        uniqueName = \"So Dimenian (Ep. II)\",\n        simpleName = \"So Dimenian\",\n        ultimateName = \"Del-D\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    DarkBelra2(\n        uniqueName = \"Dark Belra (Ep. II)\",\n        simpleName = \"Dark Belra\",\n        ultimateName = \"Indi Belra\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 165,\n        skin = 0,\n        special = false,\n    ),\n    BarbaRay(\n        uniqueName = \"Barba Ray\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(14),\n        typeId = 203,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II VR Spaceship\n\n    SavageWolf2(\n        uniqueName = \"Savage Wolf (Ep. II)\",\n        simpleName = \"Savage Wolf\",\n        ultimateName = \"Gulgus\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 67,\n        skin = 0,\n        special = false,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    BarbarousWolf2(\n        uniqueName = \"Barbarous Wolf (Ep. II)\",\n        simpleName = \"Barbarous Wolf\",\n        ultimateName = \"Gulgus-Gue\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 67,\n        skin = 0,\n        special = true,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    PanArms2(\n        uniqueName = \"Pan Arms (Ep. II)\",\n        simpleName = \"Pan Arms\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 101,\n        skin = 0,\n        special = false,\n    ),\n    Migium2(\n        uniqueName = \"Migium (Ep. II)\",\n        simpleName = \"Migium\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Hidoom2(\n        uniqueName = \"Hidoom (Ep. II)\",\n        simpleName = \"Hidoom\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Dubchic2(\n        uniqueName = \"Dubchic (Ep. II)\",\n        simpleName = \"Dubchic\",\n        ultimateName = \"Dubchich\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 128,\n        skin = 0,\n        special = false,\n    ),\n    Gilchic2(\n        uniqueName = \"Gilchic (Ep. II)\",\n        simpleName = \"Gilchic\",\n        ultimateName = \"Gilchich\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 128,\n        skin = 1,\n        special = false,\n    ),\n    Garanz2(\n        uniqueName = \"Garanz (Ep. II)\",\n        simpleName = \"Garanz\",\n        ultimateName = \"Baranz\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 129,\n        skin = 0,\n        special = false,\n    ),\n    Dubswitch2(\n        uniqueName = \"Dubswitch (Ep. II)\",\n        simpleName = \"Dubswitch\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 133,\n        skin = 0,\n        special = false,\n    ),\n    Delsaber2(\n        uniqueName = \"Delsaber (Ep. II)\",\n        simpleName = \"Delsaber\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 160,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Jump distance\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Block HP\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    ChaosSorcerer2(\n        uniqueName = \"Chaos Sorcerer (Ep. II)\",\n        simpleName = \"Chaos Sorcerer\",\n        ultimateName = \"Gran Sorcerer\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 161,\n        skin = 0,\n        special = false,\n    ),\n    GolDragon(\n        uniqueName = \"Gol Dragon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(15),\n        typeId = 204,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II Central Control Area\n\n    SinowBerill(\n        uniqueName = \"Sinow Berill\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 212,\n        skin = 0,\n        special = false,\n    ),\n    SinowSpigell(\n        uniqueName = \"Sinow Spigell\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 212,\n        skin = 1,\n        special = false,\n    ),\n    Merillia(\n        uniqueName = \"Merillia\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 213,\n        skin = 0,\n        special = false,\n    ),\n    Meriltas(\n        uniqueName = \"Meriltas\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 213,\n        skin = 1,\n        special = false,\n    ),\n    Mericarol(\n        uniqueName = \"Mericarol\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 0,\n        special = false,\n    ),\n    Mericus(\n        uniqueName = \"Mericus\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 1,\n        special = false,\n    ),\n    Merikle(\n        uniqueName = \"Merikle\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 2,\n        special = false,\n    ),\n    UlGibbon(\n        uniqueName = \"Ul Gibbon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 215,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spot appear\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Jump appear\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Back jump\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Run tech\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Back tech\", offset = 60, type = EntityPropType.F32)\n        ),\n    ),\n    ZolGibbon(\n        uniqueName = \"Zol Gibbon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 215,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spot appear\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Jump appear\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Back jump\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Run tech\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Back tech\", offset = 60, type = EntityPropType.F32)\n        ),\n    ),\n    Gibbles(\n        uniqueName = \"Gibbles\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 216,\n        skin = 0,\n        special = false,\n    ),\n    Gee(\n        uniqueName = \"Gee\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 217,\n        skin = 0,\n        special = false,\n    ),\n    GiGue(\n        uniqueName = \"Gi Gue\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 218,\n        skin = 0,\n        special = false,\n    ),\n    IllGill(\n        uniqueName = \"Ill Gill\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 225,\n        skin = 0,\n        special = false,\n    ),\n    DelLily(\n        uniqueName = \"Del Lily\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    Epsilon(\n        uniqueName = \"Epsilon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 224,\n        skin = 0,\n        special = false,\n    ),\n    GalGryphon(\n        uniqueName = \"Gal Gryphon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(12),\n        typeId = 192,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II Seabed\n\n    Deldepth(\n        uniqueName = \"Deldepth\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 219,\n        skin = 0,\n        special = false,\n    ),\n    Delbiter(\n        uniqueName = \"Delbiter\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11, 17),\n        typeId = 220,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Howl percent\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Confuse percent\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Confuse distance\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Laser percent\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Charge percent\", offset = 60, type = EntityPropType.F32),\n            EntityProp(name = \"Type\", offset = 64, type = EntityPropType.I32)\n        ),\n    ),\n    Dolmolm(\n        uniqueName = \"Dolmolm\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 221,\n        skin = 0,\n        special = false,\n    ),\n    Dolmdarl(\n        uniqueName = \"Dolmdarl\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 221,\n        skin = 1,\n        special = false,\n    ),\n    Morfos(\n        uniqueName = \"Morfos\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 222,\n        skin = 0,\n        special = false,\n    ),\n    Recobox(\n        uniqueName = \"Recobox\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11, 17),\n        typeId = 223,\n        skin = 0,\n        special = false,\n    ),\n    Recon(\n        uniqueName = \"Recon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    SinowZoa(\n        uniqueName = \"Sinow Zoa\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 224,\n        skin = 0,\n        special = false,\n    ),\n    SinowZele(\n        uniqueName = \"Sinow Zele\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 224,\n        skin = 1,\n        special = false,\n    ),\n    OlgaFlow(\n        uniqueName = \"Olga Flow\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 202,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode IV\n\n    SandRappy(\n        uniqueName = \"Sand Rappy\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { DelRappy },\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    DelRappy(\n        uniqueName = \"Del Rappy\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    Astark(\n        uniqueName = \"Astark\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 272,\n        skin = 0,\n        special = false,\n    ),\n    SatelliteLizard(\n        uniqueName = \"Satellite Lizard\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 273,\n        skin = 0,\n        special = false,\n    ),\n    Yowie(\n        uniqueName = \"Yowie\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 273,\n        skin = 0,\n        special = true,\n    ),\n    MerissaA(\n        uniqueName = \"Merissa A\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { MerissaAA },\n        areaIds = listOf(6, 7, 8),\n        typeId = 274,\n        skin = 0,\n        special = false,\n    ),\n    MerissaAA(\n        uniqueName = \"Merissa AA\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 274,\n        skin = 1,\n        special = false,\n    ),\n    Girtablulu(\n        uniqueName = \"Girtablulu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 275,\n        skin = 0,\n        special = false,\n    ),\n    Zu(\n        uniqueName = \"Zu\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Pazuzu },\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 276,\n        skin = 0,\n        special = false,\n    ),\n    Pazuzu(\n        uniqueName = \"Pazuzu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 276,\n        skin = 1,\n        special = false,\n    ),\n    Boota(\n        uniqueName = \"Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 0,\n        special = false,\n    ),\n    ZeBoota(\n        uniqueName = \"Ze Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 1,\n        special = false,\n    ),\n    BaBoota(\n        uniqueName = \"Ba Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 2,\n        special = false,\n    ),\n    Dorphon(\n        uniqueName = \"Dorphon\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { DorphonEclair },\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 278,\n        skin = 0,\n        special = false,\n    ),\n    DorphonEclair(\n        uniqueName = \"Dorphon Eclair\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 278,\n        skin = 1,\n        special = false,\n    ),\n    Goran(\n        uniqueName = \"Goran\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 0,\n        special = false,\n    ),\n    PyroGoran(\n        uniqueName = \"Pyro Goran\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 1,\n        special = false,\n    ),\n    GoranDetonator(\n        uniqueName = \"Goran Detonator\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 2,\n        special = false,\n    ),\n    SaintMilion(\n        uniqueName = \"Saint-Milion\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Kondrieu },\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 0,\n        special = false,\n    ),\n    Shambertin(\n        uniqueName = \"Shambertin\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Kondrieu },\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 1,\n        special = false,\n    ),\n    Kondrieu(\n        uniqueName = \"Kondrieu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 0,\n        special = true,\n    );\n\n    /**\n     * The type of this NPC's rare variant if it has one.\n     */\n    val rareType: NpcType? by lazy { rareType?.invoke() }\n\n    companion object {\n        /**\n         * Use this instead of [values] to avoid unnecessary copying.\n         */\n        val VALUES: Array<NpcType> = values()\n    }\n}\n","package world.phantasmal.psolib.buffer\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.DataView\nimport org.khronos.webgl.Int8Array\nimport org.khronos.webgl.Uint8Array\nimport org.w3c.dom.WindowOrWorkerGlobalScope\nimport world.phantasmal.psolib.Endianness\nimport kotlin.math.min\n\nexternal val self: WindowOrWorkerGlobalScope\n\nactual class Buffer private constructor(\n    arrayBuffer: ArrayBuffer,\n    size: Int,\n    endianness: Endianness,\n) {\n    var arrayBuffer = arrayBuffer\n        private set\n\n    private var dataView = DataView(arrayBuffer)\n    private var littleEndian = endianness == Endianness.Little\n\n    actual var size: Int = size\n        set(value) {\n            ensureCapacity(value)\n            field = value\n        }\n\n    actual var endianness: Endianness\n        get() = if (littleEndian) Endianness.Little else Endianness.Big\n        set(value) {\n            littleEndian = value == Endianness.Little\n        }\n\n    actual val capacity: Int\n        get() = arrayBuffer.byteLength\n\n    actual fun getUByte(offset: Int): UByte {\n        checkOffset(offset, 1)\n        return dataView.getUint8(offset).toUByte()\n    }\n\n    actual fun getUShort(offset: Int): UShort {\n        checkOffset(offset, 2)\n        return dataView.getUint16(offset, littleEndian).toUShort()\n    }\n\n    actual fun getUInt(offset: Int): UInt {\n        checkOffset(offset, 4)\n        return dataView.getUint32(offset, littleEndian).toUInt()\n    }\n\n    actual fun getByte(offset: Int): Byte {\n        checkOffset(offset, 1)\n        return dataView.getInt8(offset)\n    }\n\n    actual fun getShort(offset: Int): Short {\n        checkOffset(offset, 2)\n        return dataView.getInt16(offset, littleEndian)\n    }\n\n    actual fun getInt(offset: Int): Int {\n        checkOffset(offset, 4)\n        return dataView.getInt32(offset, littleEndian)\n    }\n\n    actual fun getFloat(offset: Int): Float {\n        checkOffset(offset, 4)\n        return dataView.getFloat32(offset, littleEndian)\n    }\n\n    actual fun getStringAscii(\n        offset: Int,\n        maxByteLength: Int,\n        nullTerminated: Boolean,\n    ): String =\n        buildString {\n            for (i in 0 until maxByteLength) {\n                val codePoint = (getByte(offset + i).toInt() and 0xFF).toChar()\n\n                if (nullTerminated && codePoint == '\\u0000') {\n                    break\n                }\n\n                append(codePoint)\n            }\n        }\n\n    actual fun getStringUtf16(\n        offset: Int,\n        maxByteLength: Int,\n        nullTerminated: Boolean,\n    ): String =\n        buildString {\n            val len = maxByteLength / 2\n\n            for (i in 0 until len) {\n                val codePoint = getShort(offset + i * 2).toInt().toChar()\n\n                if (nullTerminated && codePoint == '0') {\n                    break\n                }\n\n                append(codePoint)\n            }\n        }\n\n    actual fun slice(offset: Int, size: Int): Buffer {\n        checkOffset(offset, size)\n        return fromArrayBuffer(\n            arrayBuffer.slice(offset, (offset + size)),\n            endianness\n        )\n    }\n\n    actual fun setUByte(offset: Int, value: UByte): Buffer {\n        checkOffset(offset, 1)\n        dataView.setUint8(offset, value.toByte())\n        return this\n    }\n\n    actual fun setUShort(offset: Int, value: UShort): Buffer {\n        checkOffset(offset, 2)\n        dataView.setUint16(offset, value.toShort(), littleEndian)\n        return this\n    }\n\n    actual fun setUInt(offset: Int, value: UInt): Buffer {\n        checkOffset(offset, 4)\n        dataView.setUint32(offset, value.toInt(), littleEndian)\n        return this\n    }\n\n    actual fun setByte(offset: Int, value: Byte): Buffer {\n        checkOffset(offset, 1)\n        dataView.setInt8(offset, value)\n        return this\n    }\n\n    actual fun setShort(offset: Int, value: Short): Buffer {\n        checkOffset(offset, 2)\n        dataView.setInt16(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setInt(offset: Int, value: Int): Buffer {\n        checkOffset(offset, 4)\n        dataView.setInt32(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setFloat(offset: Int, value: Float): Buffer {\n        checkOffset(offset, 4)\n        dataView.setFloat32(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setStringAscii(offset: Int, str: String, byteLength: Int): Buffer {\n        checkOffset(offset, byteLength)\n\n        for (i in 0 until min(str.length, byteLength)) {\n            val codePoint = str[i].code.toByte()\n            dataView.setInt8(offset + i, codePoint)\n        }\n\n        for (i in str.length until byteLength) {\n            dataView.setInt8(offset + i, 0)\n        }\n\n        return this\n    }\n\n    actual fun setStringUtf16(offset: Int, str: String, byteLength: Int): Buffer {\n        checkOffset(offset, byteLength)\n\n        for (i in 0 until min(str.length, byteLength / 2)) {\n            val codePoint = str[i].code.toShort()\n            dataView.setInt16(offset + 2 * i, codePoint)\n        }\n\n        for (i in 2 * str.length until byteLength) {\n            dataView.setInt8(offset + i, 0)\n        }\n\n        return this\n    }\n\n    actual fun zero(): Buffer =\n        fillByte(0)\n\n    actual fun fillByte(value: Byte): Buffer {\n        (Int8Array(arrayBuffer, 0, size).asDynamic()).fill(value)\n        return this\n    }\n\n    actual fun toBase64(): String {\n        var str = \"\"\n\n        for (i in 0 until size) {\n            str += (getByte(i).toInt() and 0xff).toChar()\n        }\n\n        return self.btoa(str)\n    }\n\n    actual fun copy(offset: Int, size: Int): Buffer {\n        val newBuffer = withSize(size, endianness)\n        copyInto(newBuffer, destinationOffset = 0, offset, size.coerceAtMost(this.size - offset))\n        return newBuffer\n    }\n\n    actual fun copyInto(destination: Buffer, destinationOffset: Int, offset: Int, size: Int) {\n        require(offset >= 0 && offset <= this.size) {\n            \"Offset $offset is out of bounds.\"\n        }\n        require(destinationOffset >= 0 && destinationOffset <= this.size) {\n            \"Destination offset $destinationOffset is out of bounds.\"\n        }\n        require(\n            size >= 0 &&\n                    destinationOffset + size <= destination.size &&\n                    offset + size <= this.size\n        ) {\n            \"Size $size is out of bounds.\"\n        }\n\n        Uint8Array(destination.arrayBuffer, destinationOffset)\n            .set(Uint8Array(arrayBuffer, offset, size))\n    }\n\n    /**\n     * Checks whether we can read [size] bytes at [offset].\n     */\n    private fun checkOffset(offset: Int, size: Int) {\n        require(offset >= 0 && offset + size <= this.size) {\n            \"Offset $offset is out of bounds.\"\n        }\n    }\n\n    /**\n     * Reallocates the underlying ArrayBuffer if necessary.\n     */\n    private fun ensureCapacity(minNewSize: Int) {\n        if (minNewSize > capacity) {\n            var newSize = if (capacity == 0) minNewSize else capacity\n\n            do {\n                newSize *= 2\n            } while (newSize < minNewSize)\n\n            val newBuffer = ArrayBuffer(newSize)\n            Uint8Array(newBuffer).set(Uint8Array(arrayBuffer, 0, size))\n            arrayBuffer = newBuffer\n            dataView = DataView(arrayBuffer)\n        }\n    }\n\n    actual companion object {\n        actual fun withCapacity(\n            initialCapacity: Int,\n            endianness: Endianness,\n        ): Buffer =\n            Buffer(ArrayBuffer(initialCapacity), size = 0, endianness)\n\n        actual fun withSize(initialSize: Int, endianness: Endianness): Buffer =\n            Buffer(ArrayBuffer(initialSize), initialSize, endianness)\n\n        actual fun fromByteArray(array: ByteArray, endianness: Endianness): Buffer {\n            val arrayBuffer = ArrayBuffer(array.size)\n            Int8Array(arrayBuffer).set(array.toTypedArray())\n            return Buffer(arrayBuffer, array.size, endianness)\n        }\n\n        fun fromArrayBuffer(arrayBuffer: ArrayBuffer, endianness: Endianness): Buffer =\n            Buffer(arrayBuffer, arrayBuffer.byteLength, endianness)\n\n        actual fun fromBase64(data: String, endianness: Endianness): Buffer {\n            val str = self.atob(data)\n            val buf = withSize(str.length, endianness)\n\n            for (i in 0 until buf.size) {\n                buf.setByte(i, str[i].code.toByte())\n            }\n\n            return buf\n        }\n    }\n}\n","package world.phantasmal.psolib.buffer\n\nimport world.phantasmal.psolib.Endianness\n\n/**\n * Resizable, continuous block of bytes which is reallocated when necessary.\n */\nexpect class Buffer {\n    var size: Int\n\n    /**\n     * Byte order mode.\n     */\n    var endianness: Endianness\n\n    val capacity: Int\n\n    /**\n     * Reads an unsigned 8-bit integer at the given offset.\n     */\n    fun getUByte(offset: Int): UByte\n\n    /**\n     * Reads an unsigned 16-bit integer at the given offset.\n     */\n    fun getUShort(offset: Int): UShort\n\n    /**\n     * Reads an unsigned 32-bit integer at the given offset.\n     */\n    fun getUInt(offset: Int): UInt\n\n    /**\n     * Reads a signed 8-bit integer at the given offset.\n     */\n    fun getByte(offset: Int): Byte\n\n    /**\n     * Reads a signed 16-bit integer at the given offset.\n     */\n    fun getShort(offset: Int): Short\n\n    /**\n     * Reads a signed 32-bit integer at the given offset.\n     */\n    fun getInt(offset: Int): Int\n\n    /**\n     * Reads a 32-bit floating point number at the given offset.\n     */\n    fun getFloat(offset: Int): Float\n\n    /**\n     * Reads an ASCII-encoded string at the given offset.\n     */\n    fun getStringAscii(offset: Int, maxByteLength: Int, nullTerminated: Boolean): String\n\n    /**\n     * Reads a UTF-16-encoded string at the given offset.\n     */\n    fun getStringUtf16(offset: Int, maxByteLength: Int, nullTerminated: Boolean): String\n\n    /**\n     * Returns a copy of this buffer at the given offset with the given size.\n     */\n    fun slice(offset: Int, size: Int): Buffer\n\n    /**\n     * Writes an unsigned 8-bit integer at the given offset.\n     */\n    fun setUByte(offset: Int, value: UByte): Buffer\n\n    /**\n     * Writes an unsigned 16-bit integer at the given offset.\n     */\n    fun setUShort(offset: Int, value: UShort): Buffer\n\n    /**\n     * Writes an unsigned 32-bit integer at the given offset.\n     */\n    fun setUInt(offset: Int, value: UInt): Buffer\n\n    /**\n     * Writes a signed 8-bit integer at the given offset.\n     */\n    fun setByte(offset: Int, value: Byte): Buffer\n\n    /**\n     * Writes a signed 16-bit integer at the given offset.\n     */\n    fun setShort(offset: Int, value: Short): Buffer\n\n    /**\n     * Writes a signed 32-bit integer at the given offset.\n     */\n    fun setInt(offset: Int, value: Int): Buffer\n\n    /**\n     * Writes a 32-bit floating point number at the given offset.\n     */\n    fun setFloat(offset: Int, value: Float): Buffer\n\n    /**\n     * Writes an ASCII-encoded string at the given offset. If [str] is shorter than [byteLength],\n     * nul bytes will be inserted until [byteLength] bytes have been written.\n     */\n    fun setStringAscii(offset: Int, str: String, byteLength: Int): Buffer\n\n    /**\n     * Writes a UTF-16-encoded string at the given offset. If less than [byteLength] bytes can be\n     * written this way, nul bytes will be inserted until [byteLength] bytes have been written.\n     */\n    fun setStringUtf16(offset: Int, str: String, byteLength: Int): Buffer\n\n    /**\n     * Writes 0 bytes to the entire buffer.\n     */\n    fun zero(): Buffer\n\n    /**\n     * Writes [value] to every byte in the buffer.\n     */\n    fun fillByte(value: Byte): Buffer\n\n    fun toBase64(): String\n\n    /**\n     * Returns a copy of this buffer. The copy's capacity will equal its size. If [size] is greater\n     * than this buffer's size, the remaining bytes will be zeroed out.\n     */\n    fun copy(offset: Int = 0, size: Int = this.size): Buffer\n\n    fun copyInto(\n        destination: Buffer,\n        destinationOffset: Int = 0,\n        offset: Int = 0,\n        size: Int = this.size,\n    )\n\n    companion object {\n        /**\n         * Returns a new buffer the given initial capacity and size 0.\n         */\n        fun withCapacity(initialCapacity: Int, endianness: Endianness = Endianness.Little): Buffer\n\n        /**\n         * Returns a new buffer with an initial size and capacity of [initialSize].\n         */\n        fun withSize(initialSize: Int, endianness: Endianness = Endianness.Little): Buffer\n\n        fun fromByteArray(array: ByteArray, endianness: Endianness = Endianness.Little): Buffer\n\n        fun fromBase64(data: String, endianness: Endianness = Endianness.Little): Buffer\n    }\n}\n","@file:Suppress(\"unused\", \"BooleanLiteralArgument\")\n\npackage world.phantasmal.psolib.asm\n\nval OPCODES: Array<Opcode?> = Array(256) { null }\nval OPCODES_F8: Array<Opcode?> = Array(256) { null }\nval OPCODES_F9: Array<Opcode?> = Array(256) { null }\n\nval OP_NOP = Opcode(\n    code = 0x00,\n    mnemonic = \"nop\",\n    doc = \"No operation, does nothing.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x00] = it }\n\nval OP_RET = Opcode(\n    code = 0x01,\n    mnemonic = \"ret\",\n    doc = \"Returns control to caller.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x01] = it }\n\nval OP_SYNC = Opcode(\n    code = 0x02,\n    mnemonic = \"sync\",\n    doc = \"Yields control for the rest of the current frame. Execution will continue the following frame.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x02] = it }\n\nval OP_EXIT = Opcode(\n    code = 0x03,\n    mnemonic = \"exit\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x03] = it }\n\nval OP_THREAD = Opcode(\n    code = 0x04,\n    mnemonic = \"thread\",\n    doc = \"Starts a new thread. Thread execution will start at the given label.\\nOften used to check a register every frame. Make sure to yield control with sync when looping.\",\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x04] = it }\n\nval OP_VA_START = Opcode(\n    code = 0x05,\n    mnemonic = \"va_start\",\n    doc = \"Initializes a variable argument list.\\nMake sure to call va_end after va_start and va_call.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x05] = it }\n\nval OP_VA_END = Opcode(\n    code = 0x06,\n    mnemonic = \"va_end\",\n    doc = \"Restores the registers overwritten by arg_push* instructions.\\nCalled after va_call.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x06] = it }\n\nval OP_VA_CALL = Opcode(\n    code = 0x07,\n    mnemonic = \"va_call\",\n    doc = \"Calls the variable argument function at the given label.\\nCalled after initializing the argument list with va_start and pushing arguments onto the stack with arg_push* instructions. Make sure to call va_end afterwards.\",\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x07] = it }\n\nval OP_LET = Opcode(\n    code = 0x08,\n    mnemonic = \"let\",\n    doc = \"Sets a register to a given register's value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x08] = it }\n\nval OP_LETI = Opcode(\n    code = 0x09,\n    mnemonic = \"leti\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x09] = it }\n\nval OP_LETB = Opcode(\n    code = 0x0A,\n    mnemonic = \"letb\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ByteType, null, null, false, true),\n        )), null, null, false, false),\n        Param(ByteType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0A] = it }\n\nval OP_LETW = Opcode(\n    code = 0x0B,\n    mnemonic = \"letw\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ShortType, null, null, false, true),\n        )), null, null, false, false),\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0B] = it }\n\nval OP_LETA = Opcode(\n    code = 0x0C,\n    mnemonic = \"leta\",\n    doc = \"Sets a register to the memory address of a given register. Not used by Sega.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(PointerType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0C] = it }\n\nval OP_LETO = Opcode(\n    code = 0x0D,\n    mnemonic = \"leto\",\n    doc = \"Sets a register to the memory address of the given label. Not used by Sega.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(PointerType, null, null, false, true),\n        )), null, null, false, false),\n        Param(LabelType.Instance, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0D] = it }\n\nval OP_SET = Opcode(\n    code = 0x10,\n    mnemonic = \"set\",\n    doc = \"Sets a register to 1.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x10] = it }\n\nval OP_CLEAR = Opcode(\n    code = 0x11,\n    mnemonic = \"clear\",\n    doc = \"Sets a register to 0.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x11] = it }\n\nval OP_REV = Opcode(\n    code = 0x12,\n    mnemonic = \"rev\",\n    doc = \"Sets a register to 1 if its current value is 0, otherwise sets it to 0.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x12] = it }\n\nval OP_GSET = Opcode(\n    code = 0x13,\n    mnemonic = \"gset\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x13] = it }\n\nval OP_GCLEAR = Opcode(\n    code = 0x14,\n    mnemonic = \"gclear\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x14] = it }\n\nval OP_GREV = Opcode(\n    code = 0x15,\n    mnemonic = \"grev\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x15] = it }\n\nval OP_GLET = Opcode(\n    code = 0x16,\n    mnemonic = \"glet\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x16] = it }\n\nval OP_GGET = Opcode(\n    code = 0x17,\n    mnemonic = \"gget\",\n    doc = \"Sets a register to value of the given flag.\",\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(ShortType, \"flag\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x17] = it }\n\nval OP_ADD = Opcode(\n    code = 0x18,\n    mnemonic = \"add\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x18] = it }\n\nval OP_ADDI = Opcode(\n    code = 0x19,\n    mnemonic = \"addi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x19] = it }\n\nval OP_SUB = Opcode(\n    code = 0x1A,\n    mnemonic = \"sub\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1A] = it }\n\nval OP_SUBI = Opcode(\n    code = 0x1B,\n    mnemonic = \"subi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1B] = it }\n\nval OP_MUL = Opcode(\n    code = 0x1C,\n    mnemonic = \"mul\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1C] = it }\n\nval OP_MULI = Opcode(\n    code = 0x1D,\n    mnemonic = \"muli\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1D] = it }\n\nval OP_DIV = Opcode(\n    code = 0x1E,\n    mnemonic = \"div\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1E] = it }\n\nval OP_DIVI = Opcode(\n    code = 0x1F,\n    mnemonic = \"divi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1F] = it }\n\nval OP_AND = Opcode(\n    code = 0x20,\n    mnemonic = \"and\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x20] = it }\n\nval OP_ANDI = Opcode(\n    code = 0x21,\n    mnemonic = \"andi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x21] = it }\n\nval OP_OR = Opcode(\n    code = 0x22,\n    mnemonic = \"or\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x22] = it }\n\nval OP_ORI = Opcode(\n    code = 0x23,\n    mnemonic = \"ori\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x23] = it }\n\nval OP_XOR = Opcode(\n    code = 0x24,\n    mnemonic = \"xor\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x24] = it }\n\nval OP_XORI = Opcode(\n    code = 0x25,\n    mnemonic = \"xori\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x25] = it }\n\nval OP_MOD = Opcode(\n    code = 0x26,\n    mnemonic = \"mod\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x26] = it }\n\nval OP_MODI = Opcode(\n    code = 0x27,\n    mnemonic = \"modi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x27] = it }\n\nval OP_JMP = Opcode(\n    code = 0x28,\n    mnemonic = \"jmp\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x28] = it }\n\nval OP_CALL = Opcode(\n    code = 0x29,\n    mnemonic = \"call\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x29] = it }\n\nval OP_JMP_ON = Opcode(\n    code = 0x2A,\n    mnemonic = \"jmp_on\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n        Param(RegVarType, null, null, true, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x2A] = it }\n\nval OP_JMP_OFF = Opcode(\n    code = 0x2B,\n    mnemonic = \"jmp_off\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n        Param(RegVarType, null, null, true, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x2B] = it }\n\nval OP_JMP_E = Opcode(\n    code = 0x2C,\n    mnemonic = \"jmp_=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2C] = it }\n\nval OP_JMPI_E = Opcode(\n    code = 0x2D,\n    mnemonic = \"jmpi_=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2D] = it }\n\nval OP_JMP_NE = Opcode(\n    code = 0x2E,\n    mnemonic = \"jmp_!=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2E] = it }\n\nval OP_JMPI_NE = Opcode(\n    code = 0x2F,\n    mnemonic = \"jmpi_!=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2F] = it }\n\nval OP_UJMP_G = Opcode(\n    code = 0x30,\n    mnemonic = \"ujmp_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x30] = it }\n\nval OP_UJMPI_G = Opcode(\n    code = 0x31,\n    mnemonic = \"ujmpi_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x31] = it }\n\nval OP_JMP_G = Opcode(\n    code = 0x32,\n    mnemonic = \"jmp_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x32] = it }\n\nval OP_JMPI_G = Opcode(\n    code = 0x33,\n    mnemonic = \"jmpi_>\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x33] = it }\n\nval OP_UJMP_L = Opcode(\n    code = 0x34,\n    mnemonic = \"ujmp_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x34] = it }\n\nval OP_UJMPI_L = Opcode(\n    code = 0x35,\n    mnemonic = \"ujmpi_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x35] = it }\n\nval OP_JMP_L = Opcode(\n    code = 0x36,\n    mnemonic = \"jmp_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x36] = it }\n\nval OP_JMPI_L = Opcode(\n    code = 0x37,\n    mnemonic = \"jmpi_<\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x37] = it }\n\nval OP_UJMP_GE = Opcode(\n    code = 0x38,\n    mnemonic = \"ujmp_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x38] = it }\n\nval OP_UJMPI_GE = Opcode(\n    code = 0x39,\n    mnemonic = \"ujmpi_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x39] = it }\n\nval OP_JMP_GE = Opcode(\n    code = 0x3A,\n    mnemonic = \"jmp_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3A] = it }\n\nval OP_JMPI_GE = Opcode(\n    code = 0x3B,\n    mnemonic = \"jmpi_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3B] = it }\n\nval OP_UJMP_LE = Opcode(\n    code = 0x3C,\n    mnemonic = \"ujmp_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3C] = it }\n\nval OP_UJMPI_LE = Opcode(\n    code = 0x3D,\n    mnemonic = \"ujmpi_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3D] = it }\n\nval OP_JMP_LE = Opcode(\n    code = 0x3E,\n    mnemonic = \"jmp_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3E] = it }\n\nval OP_JMPI_LE = Opcode(\n    code = 0x3F,\n    mnemonic = \"jmpi_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3F] = it }\n\nval OP_SWITCH_JMP = Opcode(\n    code = 0x40,\n    mnemonic = \"switch_jmp\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelVarType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x40] = it }\n\nval OP_SWITCH_CALL = Opcode(\n    code = 0x41,\n    mnemonic = \"switch_call\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(ILabelVarType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x41] = it }\n\nval OP_STACK_PUSH = Opcode(\n    code = 0x42,\n    mnemonic = \"stack_push\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x42] = it }\n\nval OP_STACK_POP = Opcode(\n    code = 0x43,\n    mnemonic = \"stack_pop\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x43] = it }\n\nval OP_STACK_PUSHM = Opcode(\n    code = 0x44,\n    mnemonic = \"stack_pushm\",\n    doc = \"Pushes the values of an arbitrary amount of registers onto the stack.\",\n    params = listOf(\n        Param(RegType(null), null, null, true, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x44] = it }\n\nval OP_STACK_POPM = Opcode(\n    code = 0x45,\n    mnemonic = \"stack_popm\",\n    doc = \"Pops an arbitrary amount of values from the stack and writes them to registers.\",\n    params = listOf(\n        Param(RegType(null), null, null, false, true),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x45] = it }\n\nval OP_ARG_PUSHR = Opcode(\n    code = 0x48,\n    mnemonic = \"arg_pushr\",\n    doc = \"Pushes the value of the given register onto the stack.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x48] = it }\n\nval OP_ARG_PUSHL = Opcode(\n    code = 0x49,\n    mnemonic = \"arg_pushl\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x49] = it }\n\nval OP_ARG_PUSHB = Opcode(\n    code = 0x4A,\n    mnemonic = \"arg_pushb\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(ByteType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4A] = it }\n\nval OP_ARG_PUSHW = Opcode(\n    code = 0x4B,\n    mnemonic = \"arg_pushw\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4B] = it }\n\nval OP_ARG_PUSHA = Opcode(\n    code = 0x4C,\n    mnemonic = \"arg_pusha\",\n    doc = \"Pushes the memory address of the given register onto the stack. Not used by Sega.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4C] = it }\n\nval OP_ARG_PUSHO = Opcode(\n    code = 0x4D,\n    mnemonic = \"arg_pusho\",\n    doc = \"Pushes the memory address of the given label onto the stack. Not used by Sega.\",\n    params = listOf(\n        Param(LabelType.Instance, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4D] = it }\n\nval OP_ARG_PUSHS = Opcode(\n    code = 0x4E,\n    mnemonic = \"arg_pushs\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4E] = it }\n\nval OP_UNKNOWN_4F = Opcode(\n    code = 0x4F,\n    mnemonic = \"unknown_4f\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0x4F] = it }\n\nval OP_MESSAGE = Opcode(\n    code = 0x50,\n    mnemonic = \"message\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x50] = it }\n\nval OP_LIST = Opcode(\n    code = 0x51,\n    mnemonic = \"list\",\n    doc = \"Used to display a list of items and retrieve the item selected by the player.\\nList items should be seperated by newlines. The selected item's index will be written to the given register.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ByteType, null, null, false, true),\n        )), null, null, false, false),\n        Param(StringType, \"list\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x51] = it }\n\nval OP_FADEIN = Opcode(\n    code = 0x52,\n    mnemonic = \"fadein\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x52] = it }\n\nval OP_FADEOUT = Opcode(\n    code = 0x53,\n    mnemonic = \"fadeout\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x53] = it }\n\nval OP_SE = Opcode(\n    code = 0x54,\n    mnemonic = \"se\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x54] = it }\n\nval OP_BGM = Opcode(\n    code = 0x55,\n    mnemonic = \"bgm\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x55] = it }\n\nval OP_ENABLE = Opcode(\n    code = 0x58,\n    mnemonic = \"enable\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x58] = it }\n\nval OP_DISABLE = Opcode(\n    code = 0x59,\n    mnemonic = \"disable\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x59] = it }\n\nval OP_WINDOW_MSG = Opcode(\n    code = 0x5A,\n    mnemonic = \"window_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5A] = it }\n\nval OP_ADD_MSG = Opcode(\n    code = 0x5B,\n    mnemonic = \"add_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5B] = it }\n\nval OP_MESEND = Opcode(\n    code = 0x5C,\n    mnemonic = \"mesend\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5C] = it }\n\nval OP_GETTIME = Opcode(\n    code = 0x5D,\n    mnemonic = \"gettime\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5D] = it }\n\nval OP_WINEND = Opcode(\n    code = 0x5E,\n    mnemonic = \"winend\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5E] = it }\n\nval OP_NPC_CRT_V3 = Opcode(\n    code = 0x60,\n    mnemonic = \"npc_crt_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x60] = it }\n\nval OP_NPC_STOP = Opcode(\n    code = 0x61,\n    mnemonic = \"npc_stop\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x61] = it }\n\nval OP_NPC_PLAY = Opcode(\n    code = 0x62,\n    mnemonic = \"npc_play\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x62] = it }\n\nval OP_NPC_KILL = Opcode(\n    code = 0x63,\n    mnemonic = \"npc_kill\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x63] = it }\n\nval OP_NPC_NONT = Opcode(\n    code = 0x64,\n    mnemonic = \"npc_nont\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x64] = it }\n\nval OP_NPC_TALK = Opcode(\n    code = 0x65,\n    mnemonic = \"npc_talk\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x65] = it }\n\nval OP_NPC_CRP_V3 = Opcode(\n    code = 0x66,\n    mnemonic = \"npc_crp_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x66] = it }\n\nval OP_CREATE_PIPE = Opcode(\n    code = 0x68,\n    mnemonic = \"create_pipe\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x68] = it }\n\nval OP_P_HPSTAT_V3 = Opcode(\n    code = 0x69,\n    mnemonic = \"p_hpstat_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x69] = it }\n\nval OP_P_DEAD_V3 = Opcode(\n    code = 0x6A,\n    mnemonic = \"p_dead_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6A] = it }\n\nval OP_P_DISABLEWARP = Opcode(\n    code = 0x6B,\n    mnemonic = \"p_disablewarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6B] = it }\n\nval OP_P_ENABLEWARP = Opcode(\n    code = 0x6C,\n    mnemonic = \"p_enablewarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6C] = it }\n\nval OP_P_MOVE_V3 = Opcode(\n    code = 0x6D,\n    mnemonic = \"p_move_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6D] = it }\n\nval OP_P_LOOK = Opcode(\n    code = 0x6E,\n    mnemonic = \"p_look\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6E] = it }\n\nval OP_P_ACTION_DISABLE = Opcode(\n    code = 0x70,\n    mnemonic = \"p_action_disable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x70] = it }\n\nval OP_P_ACTION_ENABLE = Opcode(\n    code = 0x71,\n    mnemonic = \"p_action_enable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x71] = it }\n\nval OP_DISABLE_MOVEMENT1 = Opcode(\n    code = 0x72,\n    mnemonic = \"disable_movement1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x72] = it }\n\nval OP_ENABLE_MOVEMENT1 = Opcode(\n    code = 0x73,\n    mnemonic = \"enable_movement1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x73] = it }\n\nval OP_P_NONCOL = Opcode(\n    code = 0x74,\n    mnemonic = \"p_noncol\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x74] = it }\n\nval OP_P_COL = Opcode(\n    code = 0x75,\n    mnemonic = \"p_col\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x75] = it }\n\nval OP_P_SETPOS = Opcode(\n    code = 0x76,\n    mnemonic = \"p_setpos\",\n    doc = \"Sets a player's position.\",\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n            Param(IntType, \"y_rot\", null, true, false),\n        )), null, \"Coordinates and rotation around y-axis.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x76] = it }\n\nval OP_P_RETURN_GUILD = Opcode(\n    code = 0x77,\n    mnemonic = \"p_return_guild\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x77] = it }\n\nval OP_P_TALK_GUILD = Opcode(\n    code = 0x78,\n    mnemonic = \"p_talk_guild\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x78] = it }\n\nval OP_NPC_TALK_PL_V3 = Opcode(\n    code = 0x79,\n    mnemonic = \"npc_talk_pl_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x79] = it }\n\nval OP_NPC_TALK_KILL = Opcode(\n    code = 0x7A,\n    mnemonic = \"npc_talk_kill\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7A] = it }\n\nval OP_NPC_CRTPK_V3 = Opcode(\n    code = 0x7B,\n    mnemonic = \"npc_crtpk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7B] = it }\n\nval OP_NPC_CRPPK_V3 = Opcode(\n    code = 0x7C,\n    mnemonic = \"npc_crppk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7C] = it }\n\nval OP_NPC_CRPTALK_V3 = Opcode(\n    code = 0x7D,\n    mnemonic = \"npc_crptalk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7D] = it }\n\nval OP_P_LOOK_AT_V1 = Opcode(\n    code = 0x7E,\n    mnemonic = \"p_look_at_v1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7E] = it }\n\nval OP_NPC_CRP_ID_V3 = Opcode(\n    code = 0x7F,\n    mnemonic = \"npc_crp_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7F] = it }\n\nval OP_CAM_QUAKE = Opcode(\n    code = 0x80,\n    mnemonic = \"cam_quake\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x80] = it }\n\nval OP_CAM_ADJ = Opcode(\n    code = 0x81,\n    mnemonic = \"cam_adj\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x81] = it }\n\nval OP_CAM_ZMIN = Opcode(\n    code = 0x82,\n    mnemonic = \"cam_zmin\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x82] = it }\n\nval OP_CAM_ZMOUT = Opcode(\n    code = 0x83,\n    mnemonic = \"cam_zmout\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x83] = it }\n\nval OP_CAM_PAN_V3 = Opcode(\n    code = 0x84,\n    mnemonic = \"cam_pan_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x84] = it }\n\nval OP_GAME_LEV_SUPER = Opcode(\n    code = 0x85,\n    mnemonic = \"game_lev_super\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x85] = it }\n\nval OP_GAME_LEV_RESET = Opcode(\n    code = 0x86,\n    mnemonic = \"game_lev_reset\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x86] = it }\n\nval OP_POS_PIPE_V3 = Opcode(\n    code = 0x87,\n    mnemonic = \"pos_pipe_v3\",\n    doc = \"Create a telepipe at a specific position for the given player slot that takes players back to Pioneer 2 or the Lab.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x87] = it }\n\nval OP_IF_ZONE_CLEAR = Opcode(\n    code = 0x88,\n    mnemonic = \"if_zone_clear\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x88] = it }\n\nval OP_CHK_ENE_NUM = Opcode(\n    code = 0x89,\n    mnemonic = \"chk_ene_num\",\n    doc = \"Retrieves the amount of enemies killed during the quest.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x89] = it }\n\nval OP_UNHIDE_OBJ = Opcode(\n    code = 0x8A,\n    mnemonic = \"unhide_obj\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8A] = it }\n\nval OP_UNHIDE_ENE = Opcode(\n    code = 0x8B,\n    mnemonic = \"unhide_ene\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8B] = it }\n\nval OP_AT_COORDS_CALL = Opcode(\n    code = 0x8C,\n    mnemonic = \"at_coords_call\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8C] = it }\n\nval OP_AT_COORDS_TALK = Opcode(\n    code = 0x8D,\n    mnemonic = \"at_coords_talk\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8D] = it }\n\nval OP_COL_NPCIN = Opcode(\n    code = 0x8E,\n    mnemonic = \"col_npcin\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(ILabelType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8E] = it }\n\nval OP_COL_NPCINR = Opcode(\n    code = 0x8F,\n    mnemonic = \"col_npcinr\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8F] = it }\n\nval OP_SWITCH_ON = Opcode(\n    code = 0x90,\n    mnemonic = \"switch_on\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x90] = it }\n\nval OP_SWITCH_OFF = Opcode(\n    code = 0x91,\n    mnemonic = \"switch_off\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x91] = it }\n\nval OP_PLAYBGM_EPI = Opcode(\n    code = 0x92,\n    mnemonic = \"playbgm_epi\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x92] = it }\n\nval OP_SET_MAINWARP = Opcode(\n    code = 0x93,\n    mnemonic = \"set_mainwarp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x93] = it }\n\nval OP_SET_OBJ_PARAM = Opcode(\n    code = 0x94,\n    mnemonic = \"set_obj_param\",\n    doc = \"Creates a targetable object.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n            Param(IntType, \"radius\", null, true, false),\n            Param(ILabelType, \"func\", null, true, false),\n            Param(IntType, \"cursor_y\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, \"Object handle.\", false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x94] = it }\n\nval OP_SET_FLOOR_HANDLER = Opcode(\n    code = 0x95,\n    mnemonic = \"set_floor_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, \"Floor number.\", false, false),\n        Param(ILabelType, null, \"Handler function label.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x95] = it }\n\nval OP_CLR_FLOOR_HANDLER = Opcode(\n    code = 0x96,\n    mnemonic = \"clr_floor_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, \"Floor number.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x96] = it }\n\nval OP_COL_PLINAW = Opcode(\n    code = 0x97,\n    mnemonic = \"col_plinaw\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x97] = it }\n\nval OP_HUD_HIDE = Opcode(\n    code = 0x98,\n    mnemonic = \"hud_hide\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x98] = it }\n\nval OP_HUD_SHOW = Opcode(\n    code = 0x99,\n    mnemonic = \"hud_show\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x99] = it }\n\nval OP_CINE_ENABLE = Opcode(\n    code = 0x9A,\n    mnemonic = \"cine_enable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x9A] = it }\n\nval OP_CINE_DISABLE = Opcode(\n    code = 0x9B,\n    mnemonic = \"cine_disable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x9B] = it }\n\nval OP_SET_QT_FAILURE = Opcode(\n    code = 0xA1,\n    mnemonic = \"set_qt_failure\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA1] = it }\n\nval OP_SET_QT_SUCCESS = Opcode(\n    code = 0xA2,\n    mnemonic = \"set_qt_success\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA2] = it }\n\nval OP_CLR_QT_FAILURE = Opcode(\n    code = 0xA3,\n    mnemonic = \"clr_qt_failure\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA3] = it }\n\nval OP_CLR_QT_SUCCESS = Opcode(\n    code = 0xA4,\n    mnemonic = \"clr_qt_success\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA4] = it }\n\nval OP_SET_QT_CANCEL = Opcode(\n    code = 0xA5,\n    mnemonic = \"set_qt_cancel\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA5] = it }\n\nval OP_CLR_QT_CANCEL = Opcode(\n    code = 0xA6,\n    mnemonic = \"clr_qt_cancel\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA6] = it }\n\nval OP_PL_WALK_V3 = Opcode(\n    code = 0xA8,\n    mnemonic = \"pl_walk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA8] = it }\n\nval OP_PL_ADD_MESETA = Opcode(\n    code = 0xB0,\n    mnemonic = \"pl_add_meseta\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB0] = it }\n\nval OP_THREAD_STG = Opcode(\n    code = 0xB1,\n    mnemonic = \"thread_stg\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB1] = it }\n\nval OP_DEL_OBJ_PARAM = Opcode(\n    code = 0xB2,\n    mnemonic = \"del_obj_param\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, \"Object handle.\", false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB2] = it }\n\nval OP_ITEM_CREATE = Opcode(\n    code = 0xB3,\n    mnemonic = \"item_create\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB3] = it }\n\nval OP_ITEM_CREATE2 = Opcode(\n    code = 0xB4,\n    mnemonic = \"item_create2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB4] = it }\n\nval OP_ITEM_DELETE = Opcode(\n    code = 0xB5,\n    mnemonic = \"item_delete\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB5] = it }\n\nval OP_ITEM_DELETE2 = Opcode(\n    code = 0xB6,\n    mnemonic = \"item_delete2\",\n    doc = \"Deletes an item from the player's inventory.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB6] = it }\n\nval OP_ITEM_CHECK = Opcode(\n    code = 0xB7,\n    mnemonic = \"item_check\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB7] = it }\n\nval OP_SETEVT = Opcode(\n    code = 0xB8,\n    mnemonic = \"setevt\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB8] = it }\n\nval OP_GET_DIFFLVL = Opcode(\n    code = 0xB9,\n    mnemonic = \"get_difflvl\",\n    doc = \"Sets the given register to the current difficulty. 0 For normal, 1 for hard and 2 for both very hard and ultimate.\\nUse get_difficulty_level2 if you want to differentiate between very hard and ultimate.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB9] = it }\n\nval OP_SET_QT_EXIT = Opcode(\n    code = 0xBA,\n    mnemonic = \"set_qt_exit\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xBA] = it }\n\nval OP_CLR_QT_EXIT = Opcode(\n    code = 0xBB,\n    mnemonic = \"clr_qt_exit\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xBB] = it }\n\nval OP_PARTICLE_V3 = Opcode(\n    code = 0xC0,\n    mnemonic = \"particle_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC0] = it }\n\nval OP_NPC_TEXT = Opcode(\n    code = 0xC1,\n    mnemonic = \"npc_text\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC1] = it }\n\nval OP_NPC_CHKWARP = Opcode(\n    code = 0xC2,\n    mnemonic = \"npc_chkwarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC2] = it }\n\nval OP_PL_PKOFF = Opcode(\n    code = 0xC3,\n    mnemonic = \"pl_pkoff\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC3] = it }\n\nval OP_MAP_DESIGNATE = Opcode(\n    code = 0xC4,\n    mnemonic = \"map_designate\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC4] = it }\n\nval OP_MASTERKEY_ON = Opcode(\n    code = 0xC5,\n    mnemonic = \"masterkey_on\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC5] = it }\n\nval OP_MASTERKEY_OFF = Opcode(\n    code = 0xC6,\n    mnemonic = \"masterkey_off\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC6] = it }\n\nval OP_WINDOW_TIME = Opcode(\n    code = 0xC7,\n    mnemonic = \"window_time\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC7] = it }\n\nval OP_WINEND_TIME = Opcode(\n    code = 0xC8,\n    mnemonic = \"winend_time\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC8] = it }\n\nval OP_WINSET_TIME = Opcode(\n    code = 0xC9,\n    mnemonic = \"winset_time\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC9] = it }\n\nval OP_GETMTIME = Opcode(\n    code = 0xCA,\n    mnemonic = \"getmtime\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCA] = it }\n\nval OP_SET_QUEST_BOARD_HANDLER = Opcode(\n    code = 0xCB,\n    mnemonic = \"set_quest_board_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCB] = it }\n\nval OP_CLEAR_QUEST_BOARD_HANDLER = Opcode(\n    code = 0xCC,\n    mnemonic = \"clear_quest_board_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCC] = it }\n\nval OP_PARTICLE_ID_V3 = Opcode(\n    code = 0xCD,\n    mnemonic = \"particle_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCD] = it }\n\nval OP_NPC_CRPTALK_ID_V3 = Opcode(\n    code = 0xCE,\n    mnemonic = \"npc_crptalk_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCE] = it }\n\nval OP_NPC_LANG_CLEAN = Opcode(\n    code = 0xCF,\n    mnemonic = \"npc_lang_clean\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCF] = it }\n\nval OP_PL_PKON = Opcode(\n    code = 0xD0,\n    mnemonic = \"pl_pkon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD0] = it }\n\nval OP_PL_CHK_ITEM2 = Opcode(\n    code = 0xD1,\n    mnemonic = \"pl_chk_item2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD1] = it }\n\nval OP_ENABLE_MAINMENU = Opcode(\n    code = 0xD2,\n    mnemonic = \"enable_mainmenu\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD2] = it }\n\nval OP_DISABLE_MAINMENU = Opcode(\n    code = 0xD3,\n    mnemonic = \"disable_mainmenu\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD3] = it }\n\nval OP_START_BATTLEBGM = Opcode(\n    code = 0xD4,\n    mnemonic = \"start_battlebgm\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD4] = it }\n\nval OP_END_BATTLEBGM = Opcode(\n    code = 0xD5,\n    mnemonic = \"end_battlebgm\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD5] = it }\n\nval OP_DISP_MSG_QB = Opcode(\n    code = 0xD6,\n    mnemonic = \"disp_msg_qb\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD6] = it }\n\nval OP_CLOSE_MSG_QB = Opcode(\n    code = 0xD7,\n    mnemonic = \"close_msg_qb\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD7] = it }\n\nval OP_SET_EVENTFLAG_V3 = Opcode(\n    code = 0xD8,\n    mnemonic = \"set_eventflag_v3\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD8] = it }\n\nval OP_SYNC_LETI = Opcode(\n    code = 0xD9,\n    mnemonic = \"sync_leti\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD9] = it }\n\nval OP_SET_RETURNHUNTER = Opcode(\n    code = 0xDA,\n    mnemonic = \"set_returnhunter\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDA] = it }\n\nval OP_SET_RETURNCITY = Opcode(\n    code = 0xDB,\n    mnemonic = \"set_returncity\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDB] = it }\n\nval OP_LOAD_PVR = Opcode(\n    code = 0xDC,\n    mnemonic = \"load_pvr\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDC] = it }\n\nval OP_LOAD_MIDI = Opcode(\n    code = 0xDD,\n    mnemonic = \"load_midi\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDD] = it }\n\nval OP_UNKNOWN_DE = Opcode(\n    code = 0xDE,\n    mnemonic = \"unknown_de\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDE] = it }\n\nval OP_NPC_PARAM_V3 = Opcode(\n    code = 0xDF,\n    mnemonic = \"npc_param_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDF] = it }\n\nval OP_PAD_DRAGON = Opcode(\n    code = 0xE0,\n    mnemonic = \"pad_dragon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE0] = it }\n\nval OP_CLEAR_MAINWARP = Opcode(\n    code = 0xE1,\n    mnemonic = \"clear_mainwarp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE1] = it }\n\nval OP_PCAM_PARAM_V3 = Opcode(\n    code = 0xE2,\n    mnemonic = \"pcam_param_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE2] = it }\n\nval OP_START_SETEVT_V3 = Opcode(\n    code = 0xE3,\n    mnemonic = \"start_setevt_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE3] = it }\n\nval OP_WARP_ON = Opcode(\n    code = 0xE4,\n    mnemonic = \"warp_on\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE4] = it }\n\nval OP_WARP_OFF = Opcode(\n    code = 0xE5,\n    mnemonic = \"warp_off\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE5] = it }\n\nval OP_GET_SLOTNUMBER = Opcode(\n    code = 0xE6,\n    mnemonic = \"get_slotnumber\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE6] = it }\n\nval OP_GET_SERVERNUMBER = Opcode(\n    code = 0xE7,\n    mnemonic = \"get_servernumber\",\n    doc = \"Returns the index of the player who is the leader of the party.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE7] = it }\n\nval OP_SET_EVENTFLAG2 = Opcode(\n    code = 0xE8,\n    mnemonic = \"set_eventflag2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE8] = it }\n\nval OP_RES = Opcode(\n    code = 0xE9,\n    mnemonic = \"res\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE9] = it }\n\nval OP_UNKNOWN_EA = Opcode(\n    code = 0xEA,\n    mnemonic = \"unknown_ea\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0xEA] = it }\n\nval OP_ENABLE_BGMCTRL = Opcode(\n    code = 0xEB,\n    mnemonic = \"enable_bgmctrl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEB] = it }\n\nval OP_SW_SEND = Opcode(\n    code = 0xEC,\n    mnemonic = \"sw_send\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEC] = it }\n\nval OP_CREATE_BGMCTRL = Opcode(\n    code = 0xED,\n    mnemonic = \"create_bgmctrl\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xED] = it }\n\nval OP_PL_ADD_MESETA2 = Opcode(\n    code = 0xEE,\n    mnemonic = \"pl_add_meseta2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEE] = it }\n\nval OP_SYNC_REGISTER = Opcode(\n    code = 0xEF,\n    mnemonic = \"sync_register\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEF] = it }\n\nval OP_SEND_REGWORK = Opcode(\n    code = 0xF0,\n    mnemonic = \"send_regwork\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF0] = it }\n\nval OP_LETI_FIXED_CAMERA_V3 = Opcode(\n    code = 0xF1,\n    mnemonic = \"leti_fixed_camera_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF1] = it }\n\nval OP_DEFAULT_CAMERA_POS1 = Opcode(\n    code = 0xF2,\n    mnemonic = \"default_camera_pos1\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF2] = it }\n\nval OP_GET_GC_NUMBER = Opcode(\n    code = 0xFA,\n    mnemonic = \"get_gc_number\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xFA] = it }\n\nval OP_UNKNOWN_FB = Opcode(\n    code = 0xFB,\n    mnemonic = \"unknown_fb\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0xFB] = it }\n\nval OP_SET_CHAT_CALLBACK = Opcode(\n    code = 0xF801,\n    mnemonic = \"set_chat_callback\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x01] = it }\n\nval OP_GET_DIFFICULTY_LEVEL2 = Opcode(\n    code = 0xF808,\n    mnemonic = \"get_difficulty_level2\",\n    doc = \"Sets the given register to the current difficulty. 0 For normal, 1 for hard, 2 for very hard and 3 for ultimate.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x08] = it }\n\nval OP_GET_NUMBER_OF_PLAYER1 = Opcode(\n    code = 0xF809,\n    mnemonic = \"get_number_of_player1\",\n    doc = \"Set the given register to the current number of players. Either 1, 2, 3 or 4.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x09] = it }\n\nval OP_GET_COORD_OF_PLAYER = Opcode(\n    code = 0xF80A,\n    mnemonic = \"get_coord_of_player\",\n    doc = \"Retrieves a player's position.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"x\", null, true, false),\n            Param(IntType, \"y\", null, true, false),\n            Param(IntType, \"z\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0A] = it }\n\nval OP_ENABLE_MAP = Opcode(\n    code = 0xF80B,\n    mnemonic = \"enable_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0B] = it }\n\nval OP_DISABLE_MAP = Opcode(\n    code = 0xF80C,\n    mnemonic = \"disable_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0C] = it }\n\nval OP_MAP_DESIGNATE_EX = Opcode(\n    code = 0xF80D,\n    mnemonic = \"map_designate_ex\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0D] = it }\n\nval OP_UNKNOWN_F80E = Opcode(\n    code = 0xF80E,\n    mnemonic = \"unknown_f80e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x0E] = it }\n\nval OP_UNKNOWN_F80F = Opcode(\n    code = 0xF80F,\n    mnemonic = \"unknown_f80f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x0F] = it }\n\nval OP_BA_INITIAL_FLOOR = Opcode(\n    code = 0xF810,\n    mnemonic = \"ba_initial_floor\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x10] = it }\n\nval OP_SET_BA_RULES = Opcode(\n    code = 0xF811,\n    mnemonic = \"set_ba_rules\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x11] = it }\n\nval OP_UNKNOWN_F812 = Opcode(\n    code = 0xF812,\n    mnemonic = \"unknown_f812\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x12] = it }\n\nval OP_UNKNOWN_F813 = Opcode(\n    code = 0xF813,\n    mnemonic = \"unknown_f813\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x13] = it }\n\nval OP_UNKNOWN_F814 = Opcode(\n    code = 0xF814,\n    mnemonic = \"unknown_f814\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x14] = it }\n\nval OP_UNKNOWN_F815 = Opcode(\n    code = 0xF815,\n    mnemonic = \"unknown_f815\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x15] = it }\n\nval OP_UNKNOWN_F816 = Opcode(\n    code = 0xF816,\n    mnemonic = \"unknown_f816\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x16] = it }\n\nval OP_UNKNOWN_F817 = Opcode(\n    code = 0xF817,\n    mnemonic = \"unknown_f817\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x17] = it }\n\nval OP_UNKNOWN_F818 = Opcode(\n    code = 0xF818,\n    mnemonic = \"unknown_f818\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x18] = it }\n\nval OP_UNKNOWN_F819 = Opcode(\n    code = 0xF819,\n    mnemonic = \"unknown_f819\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x19] = it }\n\nval OP_UNKNOWN_F81A = Opcode(\n    code = 0xF81A,\n    mnemonic = \"unknown_f81a\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x1A] = it }\n\nval OP_UNKNOWN_F81B = Opcode(\n    code = 0xF81B,\n    mnemonic = \"unknown_f81b\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x1B] = it }\n\nval OP_BA_DISP_MSG = Opcode(\n    code = 0xF81C,\n    mnemonic = \"ba_disp_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1C] = it }\n\nval OP_DEATH_LVL_UP = Opcode(\n    code = 0xF81D,\n    mnemonic = \"death_lvl_up\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1D] = it }\n\nval OP_DEATH_TECH_LVL_UP = Opcode(\n    code = 0xF81E,\n    mnemonic = \"death_tech_lvl_up\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1E] = it }\n\nval OP_CMODE_STAGE = Opcode(\n    code = 0xF820,\n    mnemonic = \"cmode_stage\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x20] = it }\n\nval OP_UNKNOWN_F823 = Opcode(\n    code = 0xF823,\n    mnemonic = \"unknown_f823\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x23] = it }\n\nval OP_UNKNOWN_F824 = Opcode(\n    code = 0xF824,\n    mnemonic = \"unknown_f824\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x24] = it }\n\nval OP_EXP_MULTIPLICATION = Opcode(\n    code = 0xF825,\n    mnemonic = \"exp_multiplication\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x25] = it }\n\nval OP_EXP_DIVISION = Opcode(\n    code = 0xF826,\n    mnemonic = \"exp_division\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x26] = it }\n\nval OP_GET_USER_IS_DEAD = Opcode(\n    code = 0xF827,\n    mnemonic = \"get_user_is_dead\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x27] = it }\n\nval OP_GO_FLOOR = Opcode(\n    code = 0xF828,\n    mnemonic = \"go_floor\",\n    doc = \"Sends a player to the given floor.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"floor_id\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x28] = it }\n\nval OP_GET_NUM_KILLS = Opcode(\n    code = 0xF829,\n    mnemonic = \"get_num_kills\",\n    doc = \"Returns the number of enemies a player has killed during the quest.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"num_kills\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x29] = it }\n\nval OP_UNLOCK_DOOR2 = Opcode(\n    code = 0xF82B,\n    mnemonic = \"unlock_door2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2B] = it }\n\nval OP_LOCK_DOOR2 = Opcode(\n    code = 0xF82C,\n    mnemonic = \"lock_door2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2C] = it }\n\nval OP_IF_SWITCH_NOT_PRESSED = Opcode(\n    code = 0xF82D,\n    mnemonic = \"if_switch_not_pressed\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2D] = it }\n\nval OP_IF_SWITCH_PRESSED = Opcode(\n    code = 0xF82E,\n    mnemonic = \"if_switch_pressed\",\n    doc = \"Returns 1 if the switch is pressed, 0 otherwise.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"floor_id\", null, true, false),\n            Param(IntType, \"switch_id\", null, true, false),\n            Param(IntType, \"is_set\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2E] = it }\n\nval OP_UNKNOWN_F82F = Opcode(\n    code = 0xF82F,\n    mnemonic = \"unknown_f82f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x2F] = it }\n\nval OP_CONTROL_DRAGON = Opcode(\n    code = 0xF830,\n    mnemonic = \"control_dragon\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x30] = it }\n\nval OP_RELEASE_DRAGON = Opcode(\n    code = 0xF831,\n    mnemonic = \"release_dragon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x31] = it }\n\nval OP_SHRINK = Opcode(\n    code = 0xF838,\n    mnemonic = \"shrink\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x38] = it }\n\nval OP_UNSHRINK = Opcode(\n    code = 0xF839,\n    mnemonic = \"unshrink\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x39] = it }\n\nval OP_DISPLAY_CLOCK2 = Opcode(\n    code = 0xF83C,\n    mnemonic = \"display_clock2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x3C] = it }\n\nval OP_UNKNOWN_F83D = Opcode(\n    code = 0xF83D,\n    mnemonic = \"unknown_f83d\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x3D] = it }\n\nval OP_DELETE_AREA_TITLE = Opcode(\n    code = 0xF83E,\n    mnemonic = \"delete_area_title\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x3E] = it }\n\nval OP_LOAD_NPC_DATA = Opcode(\n    code = 0xF840,\n    mnemonic = \"load_npc_data\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x40] = it }\n\nval OP_GET_NPC_DATA = Opcode(\n    code = 0xF841,\n    mnemonic = \"get_npc_data\",\n    doc = null,\n    params = listOf(\n        Param(DLabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x41] = it }\n\nval OP_GIVE_DAMAGE_SCORE = Opcode(\n    code = 0xF848,\n    mnemonic = \"give_damage_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x48] = it }\n\nval OP_TAKE_DAMAGE_SCORE = Opcode(\n    code = 0xF849,\n    mnemonic = \"take_damage_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x49] = it }\n\nval OP_UNK_SCORE_F84A = Opcode(\n    code = 0xF84A,\n    mnemonic = \"unk_score_f84a\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4A] = it }\n\nval OP_UNK_SCORE_F84B = Opcode(\n    code = 0xF84B,\n    mnemonic = \"unk_score_f84b\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4B] = it }\n\nval OP_KILL_SCORE = Opcode(\n    code = 0xF84C,\n    mnemonic = \"kill_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4C] = it }\n\nval OP_DEATH_SCORE = Opcode(\n    code = 0xF84D,\n    mnemonic = \"death_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4D] = it }\n\nval OP_UNK_SCORE_F84E = Opcode(\n    code = 0xF84E,\n    mnemonic = \"unk_score_f84e\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4E] = it }\n\nval OP_ENEMY_DEATH_SCORE = Opcode(\n    code = 0xF84F,\n    mnemonic = \"enemy_death_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4F] = it }\n\nval OP_MESETA_SCORE = Opcode(\n    code = 0xF850,\n    mnemonic = \"meseta_score\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x50] = it }\n\nval OP_UNKNOWN_F851 = Opcode(\n    code = 0xF851,\n    mnemonic = \"unknown_f851\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x51] = it }\n\nval OP_UNKNOWN_F852 = Opcode(\n    code = 0xF852,\n    mnemonic = \"unknown_f852\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x52] = it }\n\nval OP_REVERSE_WARPS = Opcode(\n    code = 0xF853,\n    mnemonic = \"reverse_warps\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x53] = it }\n\nval OP_UNREVERSE_WARPS = Opcode(\n    code = 0xF854,\n    mnemonic = \"unreverse_warps\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x54] = it }\n\nval OP_SET_ULT_MAP = Opcode(\n    code = 0xF855,\n    mnemonic = \"set_ult_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x55] = it }\n\nval OP_UNSET_ULT_MAP = Opcode(\n    code = 0xF856,\n    mnemonic = \"unset_ult_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x56] = it }\n\nval OP_SET_AREA_TITLE = Opcode(\n    code = 0xF857,\n    mnemonic = \"set_area_title\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x57] = it }\n\nval OP_EQUIP_ITEM = Opcode(\n    code = 0xF85A,\n    mnemonic = \"equip_item\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x5A] = it }\n\nval OP_UNEQUIP_ITEM = Opcode(\n    code = 0xF85B,\n    mnemonic = \"unequip_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x5B] = it }\n\nval OP_UNKNOWN_F85E = Opcode(\n    code = 0xF85E,\n    mnemonic = \"unknown_f85e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x5E] = it }\n\nval OP_UNKNOWN_F85F = Opcode(\n    code = 0xF85F,\n    mnemonic = \"unknown_f85f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x5F] = it }\n\nval OP_UNKNOWN_F860 = Opcode(\n    code = 0xF860,\n    mnemonic = \"unknown_f860\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x60] = it }\n\nval OP_UNKNOWN_F861 = Opcode(\n    code = 0xF861,\n    mnemonic = \"unknown_f861\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x61] = it }\n\nval OP_CMODE_RANK = Opcode(\n    code = 0xF864,\n    mnemonic = \"cmode_rank\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x64] = it }\n\nval OP_AWARD_ITEM_NAME = Opcode(\n    code = 0xF865,\n    mnemonic = \"award_item_name\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x65] = it }\n\nval OP_AWARD_ITEM_SELECT = Opcode(\n    code = 0xF866,\n    mnemonic = \"award_item_select\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x66] = it }\n\nval OP_AWARD_ITEM_GIVE_TO = Opcode(\n    code = 0xF867,\n    mnemonic = \"award_item_give_to\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x67] = it }\n\nval OP_UNKNOWN_F868 = Opcode(\n    code = 0xF868,\n    mnemonic = \"unknown_f868\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x68] = it }\n\nval OP_UNKNOWN_F869 = Opcode(\n    code = 0xF869,\n    mnemonic = \"unknown_f869\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x69] = it }\n\nval OP_ITEM_CREATE_CMODE = Opcode(\n    code = 0xF86A,\n    mnemonic = \"item_create_cmode\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6A] = it }\n\nval OP_UNKNOWN_F86B = Opcode(\n    code = 0xF86B,\n    mnemonic = \"unknown_f86b\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x6B] = it }\n\nval OP_AWARD_ITEM_OK = Opcode(\n    code = 0xF86C,\n    mnemonic = \"award_item_ok\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6C] = it }\n\nval OP_BA_SET_LIVES = Opcode(\n    code = 0xF86F,\n    mnemonic = \"ba_set_lives\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6F] = it }\n\nval OP_BA_SET_TECH_LVL = Opcode(\n    code = 0xF870,\n    mnemonic = \"ba_set_tech_lvl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x70] = it }\n\nval OP_BA_SET_LVL = Opcode(\n    code = 0xF871,\n    mnemonic = \"ba_set_lvl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x71] = it }\n\nval OP_BA_SET_TIME_LIMIT = Opcode(\n    code = 0xF872,\n    mnemonic = \"ba_set_time_limit\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x72] = it }\n\nval OP_BOSS_IS_DEAD = Opcode(\n    code = 0xF873,\n    mnemonic = \"boss_is_dead\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x73] = it }\n\nval OP_ENABLE_TECHS = Opcode(\n    code = 0xF877,\n    mnemonic = \"enable_techs\",\n    doc = \"Enables technique use for the given player.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x77] = it }\n\nval OP_DISABLE_TECHS = Opcode(\n    code = 0xF878,\n    mnemonic = \"disable_techs\",\n    doc = \"Disables technique use for the given player.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x78] = it }\n\nval OP_GET_GENDER = Opcode(\n    code = 0xF879,\n    mnemonic = \"get_gender\",\n    doc = \"Retrieves the player's gender. 0 If male, 1 if female.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"gender\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x79] = it }\n\nval OP_GET_CHARA_CLASS = Opcode(\n    code = 0xF87A,\n    mnemonic = \"get_chara_class\",\n    doc = \"Retrieves the player's race and character class. race will be 0 if human, 1 if newman and 2 if cast. class will be 0 if hunter, 1 if ranger and 2 if force.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"race\", null, false, true),\n            Param(IntType, \"class\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7A] = it }\n\nval OP_TAKE_SLOT_MESETA = Opcode(\n    code = 0xF87B,\n    mnemonic = \"take_slot_meseta\",\n    doc = \"Takes an amount of meseta from a player's inventory. Returns 1 if the meseta was taken, 0 otherwise.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n            Param(IntType, \"amount\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"taken\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7B] = it }\n\nval OP_READ_GUILDCARD_FLAG = Opcode(\n    code = 0xF87F,\n    mnemonic = \"read_guildcard_flag\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7F] = it }\n\nval OP_UNKNOWN_F880 = Opcode(\n    code = 0xF880,\n    mnemonic = \"unknown_f880\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x80] = it }\n\nval OP_GET_PL_NAME = Opcode(\n    code = 0xF881,\n    mnemonic = \"get_pl_name\",\n    doc = \"Sets the value of <pl_name> to the given player's name.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x81] = it }\n\nval OP_GET_PL_JOB = Opcode(\n    code = 0xF882,\n    mnemonic = \"get_pl_job\",\n    doc = \"Sets the value of <pl_job> to the given player's job (Hunter/Ranger/Force).\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x82] = it }\n\nval OP_UNKNOWN_F883 = Opcode(\n    code = 0xF883,\n    mnemonic = \"unknown_f883\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x83] = it }\n\nval OP_GET_PLAYER_STATUS = Opcode(\n    code = 0xF88A,\n    mnemonic = \"get_player_status\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8A] = it }\n\nval OP_SEND_MAIL = Opcode(\n    code = 0xF88B,\n    mnemonic = \"send_mail\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8B] = it }\n\nval OP_ONLINE_CHECK = Opcode(\n    code = 0xF88C,\n    mnemonic = \"online_check\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8C] = it }\n\nval OP_CHL_SET_TIMERECORD = Opcode(\n    code = 0xF88D,\n    mnemonic = \"chl_set_timerecord\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8D] = it }\n\nval OP_CHL_GET_TIMERECORD = Opcode(\n    code = 0xF88E,\n    mnemonic = \"chl_get_timerecord\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8E] = it }\n\nval OP_UNKNOWN_F88F = Opcode(\n    code = 0xF88F,\n    mnemonic = \"unknown_f88f\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x8F] = it }\n\nval OP_LOAD_ENEMY_DATA = Opcode(\n    code = 0xF891,\n    mnemonic = \"load_enemy_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x91] = it }\n\nval OP_GET_PHYSICAL_DATA = Opcode(\n    code = 0xF892,\n    mnemonic = \"get_physical_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x92] = it }\n\nval OP_GET_ATTACK_DATA = Opcode(\n    code = 0xF893,\n    mnemonic = \"get_attack_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x93] = it }\n\nval OP_GET_RESIST_DATA = Opcode(\n    code = 0xF894,\n    mnemonic = \"get_resist_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x94] = it }\n\nval OP_GET_MOVEMENT_DATA = Opcode(\n    code = 0xF895,\n    mnemonic = \"get_movement_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x95] = it }\n\nval OP_SHIFT_LEFT = Opcode(\n    code = 0xF898,\n    mnemonic = \"shift_left\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x98] = it }\n\nval OP_SHIFT_RIGHT = Opcode(\n    code = 0xF899,\n    mnemonic = \"shift_right\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x99] = it }\n\nval OP_GET_RANDOM = Opcode(\n    code = 0xF89A,\n    mnemonic = \"get_random\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9A] = it }\n\nval OP_RESET_MAP = Opcode(\n    code = 0xF89B,\n    mnemonic = \"reset_map\",\n    doc = \"Sets all registers to 0 and resets the quest.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9B] = it }\n\nval OP_DISP_CHL_RETRY_MENU = Opcode(\n    code = 0xF89C,\n    mnemonic = \"disp_chl_retry_menu\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9C] = it }\n\nval OP_CHL_REVERSER = Opcode(\n    code = 0xF89D,\n    mnemonic = \"chl_reverser\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9D] = it }\n\nval OP_UNKNOWN_F89E = Opcode(\n    code = 0xF89E,\n    mnemonic = \"unknown_f89e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x9E] = it }\n\nval OP_UNKNOWN_F89F = Opcode(\n    code = 0xF89F,\n    mnemonic = \"unknown_f89f\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x9F] = it }\n\nval OP_UNKNOWN_F8A8 = Opcode(\n    code = 0xF8A8,\n    mnemonic = \"unknown_f8a8\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xA8] = it }\n\nval OP_UNKNOWN_F8A9 = Opcode(\n    code = 0xF8A9,\n    mnemonic = \"unknown_f8a9\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xA9] = it }\n\nval OP_GET_NUMBER_OF_PLAYER2 = Opcode(\n    code = 0xF8AD,\n    mnemonic = \"get_number_of_player2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xAD] = it }\n\nval OP_READ1 = Opcode(\n    code = 0xF8B0,\n    mnemonic = \"read1\",\n    doc = \"Reads a 1-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ByteType, null, null, false, true),\n        )), null, \"Register to store the result to.\", false, false),\n        Param(IntType, null, \"Address to read from.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB0] = it }\n\nval OP_READ2 = Opcode(\n    code = 0xF8B1,\n    mnemonic = \"read2\",\n    doc = \"Reads a 2-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(ShortType, null, null, false, true),\n        )), null, \"Register to store the result to.\", false, false),\n        Param(IntType, null, \"Address to read from.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB1] = it }\n\nval OP_READ4 = Opcode(\n    code = 0xF8B2,\n    mnemonic = \"read4\",\n    doc = \"Reads a 4-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, \"Register to store the result to.\", false, false),\n        Param(IntType, null, \"Address to read from.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB2] = it }\n\nval OP_WRITE1 = Opcode(\n    code = 0xF8B3,\n    mnemonic = \"write1\",\n    doc = \"Writes a 1-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, null, \"Address to write to.\", false, false),\n        Param(ByteType, null, \"Value to be written.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB3] = it }\n\nval OP_WRITE2 = Opcode(\n    code = 0xF8B4,\n    mnemonic = \"write2\",\n    doc = \"Writes a 2-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, null, \"Address to write to.\", false, false),\n        Param(ShortType, null, \"Value to be written.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB4] = it }\n\nval OP_WRITE4 = Opcode(\n    code = 0xF8B5,\n    mnemonic = \"write4\",\n    doc = \"Writes a 4-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, null, \"Address to write to.\", false, false),\n        Param(IntType, null, \"Value to be written.\", false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB5] = it }\n\nval OP_CHL_RECOVERY = Opcode(\n    code = 0xF8B9,\n    mnemonic = \"chl_recovery\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB9] = it }\n\nval OP_SET_EPISODE = Opcode(\n    code = 0xF8BC,\n    mnemonic = \"set_episode\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xBC] = it }\n\nval OP_FILE_DL_REQ = Opcode(\n    code = 0xF8C0,\n    mnemonic = \"file_dl_req\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC0] = it }\n\nval OP_GET_DL_STATUS = Opcode(\n    code = 0xF8C1,\n    mnemonic = \"get_dl_status\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC1] = it }\n\nval OP_GBA_UNKNOWN4 = Opcode(\n    code = 0xF8C2,\n    mnemonic = \"gba_unknown4\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC2] = it }\n\nval OP_GET_GBA_STATE = Opcode(\n    code = 0xF8C3,\n    mnemonic = \"get_gba_state\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC3] = it }\n\nval OP_UNKNOWN_F8C4 = Opcode(\n    code = 0xF8C4,\n    mnemonic = \"unknown_f8c4\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xC4] = it }\n\nval OP_UNKNOWN_F8C5 = Opcode(\n    code = 0xF8C5,\n    mnemonic = \"unknown_f8c5\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xC5] = it }\n\nval OP_QEXIT = Opcode(\n    code = 0xF8C6,\n    mnemonic = \"qexit\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC6] = it }\n\nval OP_USE_ANIMATION = Opcode(\n    code = 0xF8C7,\n    mnemonic = \"use_animation\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"animation\", null, true, false),\n            Param(IntType, \"duration\", null, true, false),\n        )), null, \"Animation ID and duration in number of frames.\", false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC7] = it }\n\nval OP_STOP_ANIMATION = Opcode(\n    code = 0xF8C8,\n    mnemonic = \"stop_animation\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC8] = it }\n\nval OP_RUN_TO_COORD = Opcode(\n    code = 0xF8C9,\n    mnemonic = \"run_to_coord\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC9] = it }\n\nval OP_SET_SLOT_INVINCIBLE = Opcode(\n    code = 0xF8CA,\n    mnemonic = \"set_slot_invincible\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCA] = it }\n\nval OP_UNKNOWN_F8CB = Opcode(\n    code = 0xF8CB,\n    mnemonic = \"unknown_f8cb\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xCB] = it }\n\nval OP_SET_SLOT_POISON = Opcode(\n    code = 0xF8CC,\n    mnemonic = \"set_slot_poison\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCC] = it }\n\nval OP_SET_SLOT_PARALYZE = Opcode(\n    code = 0xF8CD,\n    mnemonic = \"set_slot_paralyze\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCD] = it }\n\nval OP_SET_SLOT_SHOCK = Opcode(\n    code = 0xF8CE,\n    mnemonic = \"set_slot_shock\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCE] = it }\n\nval OP_SET_SLOT_FREEZE = Opcode(\n    code = 0xF8CF,\n    mnemonic = \"set_slot_freeze\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCF] = it }\n\nval OP_SET_SLOT_SLOW = Opcode(\n    code = 0xF8D0,\n    mnemonic = \"set_slot_slow\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD0] = it }\n\nval OP_SET_SLOT_CONFUSE = Opcode(\n    code = 0xF8D1,\n    mnemonic = \"set_slot_confuse\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD1] = it }\n\nval OP_SET_SLOT_SHIFTA = Opcode(\n    code = 0xF8D2,\n    mnemonic = \"set_slot_shifta\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD2] = it }\n\nval OP_SET_SLOT_DEBAND = Opcode(\n    code = 0xF8D3,\n    mnemonic = \"set_slot_deband\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD3] = it }\n\nval OP_SET_SLOT_JELLEN = Opcode(\n    code = 0xF8D4,\n    mnemonic = \"set_slot_jellen\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD4] = it }\n\nval OP_SET_SLOT_ZALURE = Opcode(\n    code = 0xF8D5,\n    mnemonic = \"set_slot_zalure\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD5] = it }\n\nval OP_FLETI_FIXED_CAMERA = Opcode(\n    code = 0xF8D6,\n    mnemonic = \"fleti_fixed_camera\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD6] = it }\n\nval OP_FLETI_LOCKED_CAMERA = Opcode(\n    code = 0xF8D7,\n    mnemonic = \"fleti_locked_camera\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD7] = it }\n\nval OP_DEFAULT_CAMERA_POS2 = Opcode(\n    code = 0xF8D8,\n    mnemonic = \"default_camera_pos2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD8] = it }\n\nval OP_SET_MOTION_BLUR = Opcode(\n    code = 0xF8D9,\n    mnemonic = \"set_motion_blur\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD9] = it }\n\nval OP_SET_SCREEN_BW = Opcode(\n    code = 0xF8DA,\n    mnemonic = \"set_screen_bw\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDA] = it }\n\nval OP_UNKNOWN_F8DB = Opcode(\n    code = 0xF8DB,\n    mnemonic = \"unknown_f8db\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xDB] = it }\n\nval OP_NPC_ACTION_STRING = Opcode(\n    code = 0xF8DC,\n    mnemonic = \"npc_action_string\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(SLabelType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDC] = it }\n\nval OP_GET_PAD_COND = Opcode(\n    code = 0xF8DD,\n    mnemonic = \"get_pad_cond\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDD] = it }\n\nval OP_GET_BUTTON_COND = Opcode(\n    code = 0xF8DE,\n    mnemonic = \"get_button_cond\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDE] = it }\n\nval OP_FREEZE_ENEMIES = Opcode(\n    code = 0xF8DF,\n    mnemonic = \"freeze_enemies\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDF] = it }\n\nval OP_UNFREEZE_ENEMIES = Opcode(\n    code = 0xF8E0,\n    mnemonic = \"unfreeze_enemies\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE0] = it }\n\nval OP_FREEZE_EVERYTHING = Opcode(\n    code = 0xF8E1,\n    mnemonic = \"freeze_everything\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE1] = it }\n\nval OP_UNFREEZE_EVERYTHING = Opcode(\n    code = 0xF8E2,\n    mnemonic = \"unfreeze_everything\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE2] = it }\n\nval OP_RESTORE_HP = Opcode(\n    code = 0xF8E3,\n    mnemonic = \"restore_hp\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE3] = it }\n\nval OP_RESTORE_TP = Opcode(\n    code = 0xF8E4,\n    mnemonic = \"restore_tp\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE4] = it }\n\nval OP_CLOSE_CHAT_BUBBLE = Opcode(\n    code = 0xF8E5,\n    mnemonic = \"close_chat_bubble\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE5] = it }\n\nval OP_MOVE_COORDS_OBJECT = Opcode(\n    code = 0xF8E6,\n    mnemonic = \"move_coords_object\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE6] = it }\n\nval OP_AT_COORDS_CALL_EX = Opcode(\n    code = 0xF8E7,\n    mnemonic = \"at_coords_call_ex\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE7] = it }\n\nval OP_UNKNOWN_F8E8 = Opcode(\n    code = 0xF8E8,\n    mnemonic = \"unknown_f8e8\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xE8] = it }\n\nval OP_UNKNOWN_F8E9 = Opcode(\n    code = 0xF8E9,\n    mnemonic = \"unknown_f8e9\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xE9] = it }\n\nval OP_UNKNOWN_F8EA = Opcode(\n    code = 0xF8EA,\n    mnemonic = \"unknown_f8ea\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEA] = it }\n\nval OP_UNKNOWN_F8EB = Opcode(\n    code = 0xF8EB,\n    mnemonic = \"unknown_f8eb\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEB] = it }\n\nval OP_UNKNOWN_F8EC = Opcode(\n    code = 0xF8EC,\n    mnemonic = \"unknown_f8ec\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEC] = it }\n\nval OP_ANIMATION_CHECK = Opcode(\n    code = 0xF8ED,\n    mnemonic = \"animation_check\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xED] = it }\n\nval OP_CALL_IMAGE_DATA = Opcode(\n    code = 0xF8EE,\n    mnemonic = \"call_image_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(ShortType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xEE] = it }\n\nval OP_TURN_OFF_BGM_P2 = Opcode(\n    code = 0xF8F0,\n    mnemonic = \"turn_off_bgm_p2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF0] = it }\n\nval OP_TURN_ON_BGM_P2 = Opcode(\n    code = 0xF8F1,\n    mnemonic = \"turn_on_bgm_p2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF1] = it }\n\nval OP_LOAD_UNK_DATA = Opcode(\n    code = 0xF8F2,\n    mnemonic = \"load_unk_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(DLabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF2] = it }\n\nval OP_PARTICLE2 = Opcode(\n    code = 0xF8F3,\n    mnemonic = \"particle2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF3] = it }\n\nval OP_DEC2FLOAT = Opcode(\n    code = 0xF901,\n    mnemonic = \"dec2float\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x01] = it }\n\nval OP_FLOAT2DEC = Opcode(\n    code = 0xF902,\n    mnemonic = \"float2dec\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x02] = it }\n\nval OP_FLET = Opcode(\n    code = 0xF903,\n    mnemonic = \"flet\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x03] = it }\n\nval OP_FLETI = Opcode(\n    code = 0xF904,\n    mnemonic = \"fleti\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x04] = it }\n\nval OP_FADD = Opcode(\n    code = 0xF908,\n    mnemonic = \"fadd\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x08] = it }\n\nval OP_FADDI = Opcode(\n    code = 0xF909,\n    mnemonic = \"faddi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x09] = it }\n\nval OP_FSUB = Opcode(\n    code = 0xF90A,\n    mnemonic = \"fsub\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0A] = it }\n\nval OP_FSUBI = Opcode(\n    code = 0xF90B,\n    mnemonic = \"fsubi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0B] = it }\n\nval OP_FMUL = Opcode(\n    code = 0xF90C,\n    mnemonic = \"fmul\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0C] = it }\n\nval OP_FMULI = Opcode(\n    code = 0xF90D,\n    mnemonic = \"fmuli\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0D] = it }\n\nval OP_FDIV = Opcode(\n    code = 0xF90E,\n    mnemonic = \"fdiv\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(FloatType, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0E] = it }\n\nval OP_FDIVI = Opcode(\n    code = 0xF90F,\n    mnemonic = \"fdivi\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(FloatType, null, null, false, true),\n        )), null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0F] = it }\n\nval OP_GET_UNKNOWN_COUNT = Opcode(\n    code = 0xF910,\n    mnemonic = \"get_unknown_count\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x10] = it }\n\nval OP_GET_STACKABLE_ITEM_COUNT = Opcode(\n    code = 0xF911,\n    mnemonic = \"get_stackable_item_count\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, \"slot\", null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n            Param(IntType, null, null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x11] = it }\n\nval OP_FREEZE_AND_HIDE_EQUIP = Opcode(\n    code = 0xF912,\n    mnemonic = \"freeze_and_hide_equip\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x12] = it }\n\nval OP_THAW_AND_SHOW_EQUIP = Opcode(\n    code = 0xF913,\n    mnemonic = \"thaw_and_show_equip\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x13] = it }\n\nval OP_SET_PALETTEX_CALLBACK = Opcode(\n    code = 0xF914,\n    mnemonic = \"set_palettex_callback\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x14] = it }\n\nval OP_ACTIVATE_PALETTEX = Opcode(\n    code = 0xF915,\n    mnemonic = \"activate_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x15] = it }\n\nval OP_ENABLE_PALETTEX = Opcode(\n    code = 0xF916,\n    mnemonic = \"enable_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x16] = it }\n\nval OP_RESTORE_PALETTEX = Opcode(\n    code = 0xF917,\n    mnemonic = \"restore_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x17] = it }\n\nval OP_DISABLE_PALETTEX = Opcode(\n    code = 0xF918,\n    mnemonic = \"disable_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x18] = it }\n\nval OP_GET_PALETTEX_ACTIVATED = Opcode(\n    code = 0xF919,\n    mnemonic = \"get_palettex_activated\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x19] = it }\n\nval OP_GET_UNKNOWN_PALETTEX_STATUS = Opcode(\n    code = 0xF91A,\n    mnemonic = \"get_unknown_palettex_status\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1A] = it }\n\nval OP_DISABLE_MOVEMENT2 = Opcode(\n    code = 0xF91B,\n    mnemonic = \"disable_movement2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1B] = it }\n\nval OP_ENABLE_MOVEMENT2 = Opcode(\n    code = 0xF91C,\n    mnemonic = \"enable_movement2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1C] = it }\n\nval OP_GET_TIME_PLAYED = Opcode(\n    code = 0xF91D,\n    mnemonic = \"get_time_played\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1D] = it }\n\nval OP_GET_GUILDCARD_TOTAL = Opcode(\n    code = 0xF91E,\n    mnemonic = \"get_guildcard_total\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1E] = it }\n\nval OP_GET_SLOT_MESETA = Opcode(\n    code = 0xF91F,\n    mnemonic = \"get_slot_meseta\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1F] = it }\n\nval OP_GET_PLAYER_LEVEL = Opcode(\n    code = 0xF920,\n    mnemonic = \"get_player_level\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x20] = it }\n\nval OP_GET_SECTION_ID = Opcode(\n    code = 0xF921,\n    mnemonic = \"get_section_id\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x21] = it }\n\nval OP_GET_PLAYER_HP = Opcode(\n    code = 0xF922,\n    mnemonic = \"get_player_hp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, \"max_hp\", null, false, true),\n            Param(IntType, \"hp\", null, false, true),\n            Param(IntType, \"max_tp\", null, false, true),\n            Param(IntType, \"tp\", null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x22] = it }\n\nval OP_GET_FLOOR_NUMBER = Opcode(\n    code = 0xF923,\n    mnemonic = \"get_floor_number\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x23] = it }\n\nval OP_GET_COORD_PLAYER_DETECT = Opcode(\n    code = 0xF924,\n    mnemonic = \"get_coord_player_detect\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, \"slot\", null, true, false),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, true, false),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x24] = it }\n\nval OP_READ_GLOBAL_FLAG = Opcode(\n    code = 0xF925,\n    mnemonic = \"read_global_flag\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x25] = it }\n\nval OP_WRITE_GLOBAL_FLAG = Opcode(\n    code = 0xF926,\n    mnemonic = \"write_global_flag\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x26] = it }\n\nval OP_UNKNOWN_F927 = Opcode(\n    code = 0xF927,\n    mnemonic = \"unknown_f927\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x27] = it }\n\nval OP_FLOOR_PLAYER_DETECT = Opcode(\n    code = 0xF928,\n    mnemonic = \"floor_player_detect\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n            Param(IntType, null, null, false, true),\n            Param(IntType, null, null, false, true),\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x28] = it }\n\nval OP_READ_DISK_FILE = Opcode(\n    code = 0xF929,\n    mnemonic = \"read_disk_file\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x29] = it }\n\nval OP_OPEN_PACK_SELECT = Opcode(\n    code = 0xF92A,\n    mnemonic = \"open_pack_select\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2A] = it }\n\nval OP_ITEM_SELECT = Opcode(\n    code = 0xF92B,\n    mnemonic = \"item_select\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2B] = it }\n\nval OP_GET_ITEM_ID = Opcode(\n    code = 0xF92C,\n    mnemonic = \"get_item_id\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2C] = it }\n\nval OP_COLOR_CHANGE = Opcode(\n    code = 0xF92D,\n    mnemonic = \"color_change\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2D] = it }\n\nval OP_SEND_STATISTIC = Opcode(\n    code = 0xF92E,\n    mnemonic = \"send_statistic\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2E] = it }\n\nval OP_UNKNOWN_F92F = Opcode(\n    code = 0xF92F,\n    mnemonic = \"unknown_f92f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x2F] = it }\n\nval OP_CHAT_BOX = Opcode(\n    code = 0xF930,\n    mnemonic = \"chat_box\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x30] = it }\n\nval OP_CHAT_BUBBLE = Opcode(\n    code = 0xF931,\n    mnemonic = \"chat_bubble\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x31] = it }\n\nval OP_UNKNOWN_F933 = Opcode(\n    code = 0xF933,\n    mnemonic = \"unknown_f933\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x33] = it }\n\nval OP_SCROLL_TEXT = Opcode(\n    code = 0xF934,\n    mnemonic = \"scroll_text\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x34] = it }\n\nval OP_GBA_UNKNOWN1 = Opcode(\n    code = 0xF935,\n    mnemonic = \"gba_unknown1\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x35] = it }\n\nval OP_GBA_UNKNOWN2 = Opcode(\n    code = 0xF936,\n    mnemonic = \"gba_unknown2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x36] = it }\n\nval OP_GBA_UNKNOWN3 = Opcode(\n    code = 0xF937,\n    mnemonic = \"gba_unknown3\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x37] = it }\n\nval OP_ADD_DAMAGE_TO = Opcode(\n    code = 0xF938,\n    mnemonic = \"add_damage_to\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x38] = it }\n\nval OP_ITEM_DELETE3 = Opcode(\n    code = 0xF939,\n    mnemonic = \"item_delete3\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x39] = it }\n\nval OP_GET_ITEM_INFO = Opcode(\n    code = 0xF93A,\n    mnemonic = \"get_item_info\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3A] = it }\n\nval OP_ITEM_PACKING1 = Opcode(\n    code = 0xF93B,\n    mnemonic = \"item_packing1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3B] = it }\n\nval OP_ITEM_PACKING2 = Opcode(\n    code = 0xF93C,\n    mnemonic = \"item_packing2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3C] = it }\n\nval OP_GET_LANG_SETTING = Opcode(\n    code = 0xF93D,\n    mnemonic = \"get_lang_setting\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(AnyType.Instance, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3D] = it }\n\nval OP_PREPARE_STATISTIC = Opcode(\n    code = 0xF93E,\n    mnemonic = \"prepare_statistic\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3E] = it }\n\nval OP_KEYWORD_DETECT = Opcode(\n    code = 0xF93F,\n    mnemonic = \"keyword_detect\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3F] = it }\n\nval OP_KEYWORD = Opcode(\n    code = 0xF940,\n    mnemonic = \"keyword\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, \"slot\", null, false, false),\n        Param(StringType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x40] = it }\n\nval OP_GET_GUILDCARD_NUM = Opcode(\n    code = 0xF941,\n    mnemonic = \"get_guildcard_num\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x41] = it }\n\nval OP_GET_WRAP_STATUS = Opcode(\n    code = 0xF944,\n    mnemonic = \"get_wrap_status\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"slot\", null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x44] = it }\n\nval OP_INITIAL_FLOOR = Opcode(\n    code = 0xF945,\n    mnemonic = \"initial_floor\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x45] = it }\n\nval OP_SIN = Opcode(\n    code = 0xF946,\n    mnemonic = \"sin\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x46] = it }\n\nval OP_COS = Opcode(\n    code = 0xF947,\n    mnemonic = \"cos\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x47] = it }\n\nval OP_BOSS_IS_DEAD2 = Opcode(\n    code = 0xF94A,\n    mnemonic = \"boss_is_dead2\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x4A] = it }\n\nval OP_UNKNOWN_F94B = Opcode(\n    code = 0xF94B,\n    mnemonic = \"unknown_f94b\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x4B] = it }\n\nval OP_UNKNOWN_F94C = Opcode(\n    code = 0xF94C,\n    mnemonic = \"unknown_f94c\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x4C] = it }\n\nval OP_IS_THERE_CARDBATTLE = Opcode(\n    code = 0xF94D,\n    mnemonic = \"is_there_cardbattle\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x4D] = it }\n\nval OP_BB_P2_MENU = Opcode(\n    code = 0xF950,\n    mnemonic = \"bb_p2_menu\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x50] = it }\n\nval OP_BB_MAP_DESIGNATE = Opcode(\n    code = 0xF951,\n    mnemonic = \"bb_map_designate\",\n    doc = null,\n    params = listOf(\n        Param(ByteType, null, null, false, false),\n        Param(ShortType, null, null, false, false),\n        Param(ByteType, null, null, false, false),\n        Param(ByteType, null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x51] = it }\n\nval OP_BB_GET_NUMBER_IN_PACK = Opcode(\n    code = 0xF952,\n    mnemonic = \"bb_get_number_in_pack\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x52] = it }\n\nval OP_BB_SWAP_ITEM = Opcode(\n    code = 0xF953,\n    mnemonic = \"bb_swap_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x53] = it }\n\nval OP_BB_CHECK_WRAP = Opcode(\n    code = 0xF954,\n    mnemonic = \"bb_check_wrap\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x54] = it }\n\nval OP_BB_EXCHANGE_PD_ITEM = Opcode(\n    code = 0xF955,\n    mnemonic = \"bb_exchange_pd_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x55] = it }\n\nval OP_BB_EXCHANGE_PD_SRANK = Opcode(\n    code = 0xF956,\n    mnemonic = \"bb_exchange_pd_srank\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x56] = it }\n\nval OP_BB_EXCHANGE_PD_SPECIAL = Opcode(\n    code = 0xF957,\n    mnemonic = \"bb_exchange_pd_special\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x57] = it }\n\nval OP_BB_EXCHANGE_PD_PERCENT = Opcode(\n    code = 0xF958,\n    mnemonic = \"bb_exchange_pd_percent\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x58] = it }\n\nval OP_UNKNOWN_F959 = Opcode(\n    code = 0xF959,\n    mnemonic = \"unknown_f959\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x59] = it }\n\nval OP_BB_EXCHANGE_SLT = Opcode(\n    code = 0xF95C,\n    mnemonic = \"bb_exchange_slt\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5C] = it }\n\nval OP_BB_EXCHANGE_PC = Opcode(\n    code = 0xF95D,\n    mnemonic = \"bb_exchange_pc\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5D] = it }\n\nval OP_BB_BOX_CREATE_BP = Opcode(\n    code = 0xF95E,\n    mnemonic = \"bb_box_create_bp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n        Param(FloatType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5E] = it }\n\nval OP_BB_EXCHANGE_PT = Opcode(\n    code = 0xF95F,\n    mnemonic = \"bb_exchange_pt\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n        Param(IntType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n        Param(ILabelType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5F] = it }\n\nval OP_UNKNOWN_F960 = Opcode(\n    code = 0xF960,\n    mnemonic = \"unknown_f960\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null, false, false),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x60] = it }\n\nval OP_UNKNOWN_F961 = Opcode(\n    code = 0xF961,\n    mnemonic = \"unknown_f961\",\n    doc = null,\n    params = listOf(\n        Param(RegType(listOf(\n            Param(IntType, null, null, false, true),\n        )), null, null, false, false),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x61] = it }\n","package world.phantasmal.psolib.asm\n\nimport mu.KotlinLogging\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val INDENT_WIDTH = 4\nprivate val INDENT = \" \".repeat(INDENT_WIDTH)\n\n/**\n * @param inlineStackArgs If true, will output stack arguments inline instead of outputting stack\n * management instructions (argpush variants).\n */\nfun disassemble(bytecodeIr: BytecodeIr, inlineStackArgs: Boolean = true): List<String> {\n    logger.trace {\n        \"Disassembling ${bytecodeIr.segments.size} segments with ${\n            if (inlineStackArgs) \"inline stack arguments\" else \"stack push instructions\"\n        }.\"\n    }\n\n    val lines = mutableListOf<String>()\n    val stack = mutableListOf<ArgWithType>()\n    var sectionType: SegmentType? = null\n\n    for (segment in bytecodeIr.segments) {\n        // Section marker (.code, .data or .string).\n        if (sectionType != segment.type) {\n            sectionType = segment.type\n\n            if (lines.isNotEmpty()) {\n                lines.add(\"\")\n            }\n\n            val sectionMarker = when (segment) {\n                is InstructionSegment -> \".code\"\n                is DataSegment -> \".data\"\n                is StringSegment -> \".string\"\n            }\n\n            lines.add(sectionMarker)\n            lines.add(\"\")\n        }\n\n        // Labels.\n        for (label in segment.labels) {\n            lines.add(\"$label:\")\n        }\n\n        // Code or data lines.\n        when (segment) {\n            is InstructionSegment -> {\n                var inVaList = false\n\n                segment.instructions.forEachIndexed { i, instruction ->\n                    val opcode = instruction.opcode\n\n                    if (opcode.code == OP_VA_START.code) {\n                        inVaList = true\n                    } else if (opcode.code == OP_VA_END.code) {\n                        inVaList = false\n                    }\n\n                    if (inlineStackArgs &&\n                        !inVaList &&\n                        opcode.stack == StackInteraction.Push &&\n                        canInlinePushedArg(segment, i)\n                    ) {\n                        stack.addAll(addTypeToArgs(opcode.params, instruction.args))\n                    } else {\n                        val sb = StringBuilder(INDENT)\n                        sb.append(opcode.mnemonic)\n\n                        if (opcode.stack == StackInteraction.Pop) {\n                            if (inlineStackArgs) {\n                                sb.appendArgs(\n                                    opcode.params,\n                                    stack.takeLast(opcode.params.size),\n                                    stack = true,\n                                )\n                            }\n                        } else {\n                            sb.appendArgs(\n                                opcode.params,\n                                addTypeToArgs(opcode.params, instruction.args),\n                                stack = false\n                            )\n                        }\n\n                        if (opcode.stack != StackInteraction.Push) {\n                            stack.clear()\n                        }\n\n                        lines.add(sb.toString())\n                    }\n                }\n            }\n\n            is DataSegment -> {\n                val sb = StringBuilder(INDENT)\n\n                for (i in 0 until segment.data.size) {\n                    sb.append(\"0x\")\n                    sb.append(segment.data.getUByte(i).toString(16).padStart(2, '0'))\n\n                    when {\n                        // Last line.\n                        i == segment.data.size - 1 -> {\n                            lines.add(sb.toString())\n                        }\n                        // Start a new line after every 16 bytes.\n                        i % 16 == 15 -> {\n                            lines.add(sb.toString())\n                            sb.setLength(0)\n                            sb.append(INDENT)\n                        }\n                        // Add a space between each byte.\n                        else -> {\n                            sb.append(\" \")\n                        }\n                    }\n                }\n            }\n\n            is StringSegment -> {\n                lines.add(StringBuilder(INDENT).appendStringSegment(segment.value).toString())\n            }\n        }\n    }\n\n    // Ensure newline at the end.\n    lines.add(\"\")\n\n    logger.trace { \"Disassembly finished, line count: ${lines.size}.\" }\n\n    return lines\n}\n\nprivate data class ArgWithType(val arg: Arg, val type: AnyType)\n\nprivate fun canInlinePushedArg(segment: InstructionSegment, index: Int): Boolean {\n    var pushedArgCount = 0\n\n    for (i in index until segment.instructions.size) {\n        val opcode = segment.instructions[i].opcode\n\n        when (opcode.stack) {\n            StackInteraction.Push -> pushedArgCount++\n\n            StackInteraction.Pop -> {\n                var paramCount = 0\n                var varArgs = false\n\n                for (param in opcode.params) {\n                    when (param.type) {\n                        is ILabelVarType -> varArgs = true\n                        is RegVarType -> varArgs = true\n                        else -> paramCount++\n                    }\n                }\n\n                return pushedArgCount <= paramCount || (pushedArgCount > paramCount && varArgs)\n            }\n\n            null -> return false\n        }\n    }\n\n    return false\n}\n\nprivate fun addTypeToArgs(params: List<Param>, args: List<Arg>): List<ArgWithType> {\n    val argsWithType = mutableListOf<ArgWithType>()\n\n    for (i in 0 until min(params.size, args.size)) {\n        argsWithType.add(ArgWithType(args[i], params[i].type))\n    }\n\n    // Deal with varargs.\n    val lastParam = params.lastOrNull()\n\n    if (lastParam?.varargs == true) {\n        for (i in argsWithType.size until args.size) {\n            argsWithType.add(ArgWithType(args[i], lastParam.type))\n        }\n    }\n\n    return argsWithType\n}\n\nprivate fun StringBuilder.appendArgs(params: List<Param>, args: List<ArgWithType>, stack: Boolean) {\n    var i = 0\n\n    while (i < params.size) {\n        val paramType = params[i].type\n\n        if (i == 0) {\n            append(\" \")\n        } else {\n            append(\", \")\n        }\n\n        if (i < args.size) {\n            val (arg, argType) = args[i]\n\n            if (argType is RegType) {\n                append(\"r\")\n                append(arg.value)\n            } else {\n                when (paramType) {\n                    FloatType -> {\n                        // Floats are pushed onto the stack as integers with arg_pushl.\n                        if (stack) {\n                            append(Float.fromBits((arg as IntArg).value))\n                        } else {\n                            append(arg.value)\n                        }\n                    }\n\n                    ILabelVarType -> {\n                        while (i < args.size) {\n                            append(args[i].arg.value)\n                            if (i < args.lastIndex) append(\", \")\n                            i++\n                        }\n                    }\n\n                    RegVarType -> {\n                        while (i < args.size) {\n                            append(\"r\")\n                            append(args[i].arg.value)\n                            if (i < args.lastIndex) append(\", \")\n                            i++\n                        }\n                    }\n\n                    is RegType -> {\n                        append(\"r\")\n                        append(arg.value)\n                    }\n\n                    StringType -> {\n                        appendStringArg((arg as StringArg).value)\n                    }\n\n                    else -> {\n                        append(arg.value)\n                    }\n                }\n            }\n        }\n\n        i++\n    }\n}\n\nprivate fun StringBuilder.appendStringArg(value: String): StringBuilder {\n    append(\"\\\"\")\n\n    for (char in value) {\n        when (char) {\n            '\\r' -> append(\"\\\\r\")\n            '\\n' -> append(\"\\\\n\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            else -> append(char)\n        }\n    }\n\n    append(\"\\\"\")\n    return this\n}\n\nprivate fun StringBuilder.appendStringSegment(value: String): StringBuilder {\n    append(\"\\\"\")\n\n    var i = 0\n\n    while (i < value.length) {\n        when (val char = value[i]) {\n            // Replace <cr> with \\n.\n            '<' -> {\n                if (i + 3 < value.length &&\n                    value[i + 1] == 'c' &&\n                    value[i + 2] == 'r' &&\n                    value[i + 3] == '>'\n                ) {\n                    append(\"\\\\n\")\n                    i += 3\n                } else {\n                    append(char)\n                }\n            }\n            '\\r' -> append(\"\\\\r\")\n            '\\n' -> append(\"\\\\n\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            else -> append(char)\n        }\n\n        i++\n    }\n\n    append(\"\\\"\")\n    return this\n}\n","package world.phantasmal.psolib.compression.prs\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.cursor.WritableCursor\nimport world.phantasmal.psolib.cursor.cursor\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n// This code uses signed types for better KJS performance. In KJS unsigned types are always boxed.\n\nfun prsDecompress(cursor: Cursor): PwResult<Cursor> =\n    PrsDecompressor(cursor).decompress()\n\nprivate class PrsDecompressor(private val src: Cursor) {\n    private val dst: WritableCursor =\n        Buffer.withCapacity(6 * src.size, src.endianness).cursor()\n    private var flags = 0\n    private var flagBitsLeft = 0\n\n    fun decompress(): PwResult<Cursor> {\n        try {\n            while (true) {\n                if (readFlagBit() == 1) {\n                    // Single byte copy.\n                    copyByte()\n                } else {\n                    // Multi byte copy.\n                    if (readFlagBit() == 0) {\n                        // Short copy.\n                        val size = 2 + ((readFlagBit() shl 1) or readFlagBit())\n                        val offset = readUByte() - 256\n\n                        offsetCopy(offset, size)\n                    } else {\n                        // Long copy or end of file.\n                        var offset = readUShort()\n\n                        // Two zero bytes implies that this is the end of the file.\n                        if (offset == 0) {\n                            break\n                        }\n\n                        // Do we need to read a size byte, or is it encoded in what we already have?\n                        var size = offset and 0b111\n                        offset = offset ushr 3\n\n                        if (size == 0) {\n                            size = readUByte()\n                            size += 1\n                        } else {\n                            size += 2\n                        }\n\n                        offset -= 8192\n\n                        offsetCopy(offset, size)\n                    }\n                }\n            }\n\n            return Success(dst.seekStart(0))\n        } catch (e: Exception) {\n            return PwResult.build<Cursor>(logger)\n                .addProblem(Severity.Error, \"PRS-compressed stream is corrupt.\", cause = e)\n                .failure()\n        }\n    }\n\n    private fun readFlagBit(): Int {\n        // Fetch a new flag byte when the previous byte has been processed.\n        if (flagBitsLeft == 0) {\n            flags = readUByte()\n            flagBitsLeft = 8\n        }\n\n        val bit = flags and 1\n        flags = flags ushr 1\n        flagBitsLeft -= 1\n        return bit\n    }\n\n    private fun copyByte() {\n        dst.writeByte(src.byte())\n    }\n\n    private fun readUByte(): Int = src.byte().toInt() and 0xFF\n\n    private fun readUShort(): Int = src.short().toInt() and 0xFFFF\n\n    private fun offsetCopy(offset: Int, size: Int) {\n        require(offset in -8192..0) {\n            \"offset was ${offset}, should be between -8192 and 0.\"\n        }\n\n        require(size in 1..256) {\n            \"size was ${size}, should be between 1 and 256.\"\n        }\n\n        // Size can be larger than -offset, in that case we copy -offset bytes size/-offset times.\n        val bufSize = min(-offset, size)\n\n        dst.seek(offset)\n        val buf = dst.take(bufSize)\n        dst.seek(-offset - bufSize)\n\n        repeat(size / bufSize) {\n            dst.writeCursor(buf)\n            buf.seekStart(0)\n        }\n\n        dst.writeCursor(buf.take(size % bufSize))\n    }\n}\n","package world.phantasmal.psolib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.Cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val AFS = 0x00534641\n\n/**\n * Returns the files contained in the given AFS archive. AFS is a simple archive format used by SEGA\n * for e.g. player character textures.\n */\nfun parseAfs(cursor: Cursor): PwResult<List<Buffer>> {\n    val result = PwResult.build<List<Buffer>>(logger)\n\n    if (cursor.bytesLeft < 8) {\n        return result\n            .addProblem(\n                Severity.Error,\n                \"AFS archive is corrupted.\",\n                \"Expected at least 8 bytes for the header, got ${cursor.bytesLeft} bytes.\",\n            )\n            .failure()\n    }\n\n    val magic = cursor.int()\n\n    if (magic != AFS) {\n        return result\n            .addProblem(Severity.Error, \"AFS archive is corrupted.\", \"Magic bytes not present.\")\n            .failure()\n    }\n\n    val fileCount = cursor.short()\n\n    // Skip two unused bytes (are these just part of the file count field?).\n    cursor.seek(2)\n\n    val files = mutableListOf<Buffer>()\n\n    for (i in 1..fileCount) {\n        if (cursor.bytesLeft < 8) {\n            result.addProblem(\n                Severity.Warning,\n                \"AFS file entry $i is invalid.\",\n                \"Couldn't read file entry $i, only ${cursor.bytesLeft} bytes left.\",\n            )\n\n            break\n        }\n\n        val offset = cursor.int()\n        val size = cursor.int()\n\n        when {\n            offset > cursor.size -> {\n                result.addProblem(\n                    Severity.Warning,\n                    \"AFS file entry $i is invalid.\",\n                    \"Invalid file offset $offset for entry $i.\",\n                )\n            }\n\n            offset + size > cursor.size -> {\n                result.addProblem(\n                    Severity.Warning,\n                    \"AFS file entry $i is invalid.\",\n                    \"File size $size (offset: $offset) of entry $i too large.\",\n                )\n            }\n\n            else -> {\n                val startPos = cursor.position\n                cursor.seekStart(offset)\n                files.add(cursor.buffer(size))\n                cursor.seekStart(startPos)\n            }\n        }\n    }\n\n    return result.success(files)\n}\n","package world.phantasmal.psolib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.isBitSet\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.fileFormats.ninja.*\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AreaGeometry(\n    val sections: List<AreaSection>,\n)\n\nclass AreaSection(\n    val id: Int,\n    val position: Vec3,\n    val rotation: Vec3,\n    val radius: Float,\n    val objects: List<AreaObject.Simple>,\n    val animatedObjects: List<AreaObject.Animated>,\n)\n\nsealed class AreaObject {\n    abstract val offset: Int\n    abstract val xjObject: XjObject\n    abstract val flags: Int\n\n    class Simple(\n        override val offset: Int,\n        override val xjObject: XjObject,\n        override val flags: Int,\n    ) : AreaObject()\n\n    class Animated(\n        override val offset: Int,\n        override val xjObject: XjObject,\n        val njMotion: NjMotion,\n        val speed: Float,\n        override val flags: Int,\n    ) : AreaObject()\n}\n\nfun parseAreaRenderGeometry(cursor: Cursor): AreaGeometry {\n    val dataOffset = parseRel(cursor, parseIndex = false).dataOffset\n\n    cursor.seekStart(dataOffset)\n    val format = cursor.stringAscii(maxByteLength = 4, nullTerminated = true, dropRemaining = true)\n\n    if (format != \"fmt2\") {\n        logger.warn { \"\"\"Expected format to be \"fmt2\" but was \"$format\".\"\"\" }\n    }\n\n    cursor.seek(4)\n    val sectionsCount = cursor.int()\n    cursor.seek(4)\n    val sectionsOffset = cursor.int()\n\n    val sections = mutableListOf<AreaSection>()\n\n    // Cache keys are offsets.\n    val simpleAreaObjectCache = mutableMapOf<Int, List<AreaObject.Simple>>()\n    val animatedAreaObjectCache = mutableMapOf<Int, List<AreaObject.Animated>>()\n    val njMotionCache = mutableMapOf<Int, NjMotion>()\n\n    for (i in 0 until sectionsCount) {\n        cursor.seekStart(sectionsOffset + 52 * i)\n\n        val sectionId = cursor.int()\n        val sectionPosition = cursor.vec3Float()\n        val sectionRotation = Vec3(\n            angleToRad(cursor.int()),\n            angleToRad(cursor.int()),\n            angleToRad(cursor.int()),\n        )\n\n        val radius = cursor.float()\n\n        val simpleAreaObjectsOffset = cursor.int()\n        val animatedAreaObjectsOffset = cursor.int()\n        val simpleAreaObjectsCount = cursor.int()\n        val animatedAreaObjectsCount = cursor.int()\n        // Ignore the last 4 bytes.\n\n//        println(\"section $sectionId (index $i), simple geom at $simpleGeometryTableOffset, animated geom at $animatedGeometryTableOffset\")\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val simpleObjects = simpleAreaObjectCache.getOrPut(simpleAreaObjectsOffset) {\n            parseAreaObjects(\n                cursor,\n                njMotionCache,\n                simpleAreaObjectsOffset,\n                simpleAreaObjectsCount,\n                animated = false,\n            ) as List<AreaObject.Simple>\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val animatedObjects = animatedAreaObjectCache.getOrPut(animatedAreaObjectsOffset) {\n            parseAreaObjects(\n                cursor,\n                njMotionCache,\n                animatedAreaObjectsOffset,\n                animatedAreaObjectsCount,\n                animated = true,\n            ) as List<AreaObject.Animated>\n        }\n\n        sections.add(AreaSection(\n            sectionId,\n            sectionPosition,\n            sectionRotation,\n            radius,\n            simpleObjects,\n            animatedObjects,\n        ))\n    }\n\n    return AreaGeometry(sections)\n}\n\nprivate fun parseAreaObjects(\n    cursor: Cursor,\n    njMotionCache: MutableMap<Int, NjMotion>,\n    offset: Int,\n    count: Int,\n    animated: Boolean,\n): List<AreaObject> {\n    val objectSize = if (animated) 32 else 16\n    val objects = mutableListOf<AreaObject>()\n\n    for (i in 0 until count) {\n        val objectOffset = offset + objectSize * i\n        cursor.seekStart(objectOffset)\n\n        var xjObjectOffset = cursor.int()\n        val speed: Float?\n        val njMotionOffset: Int?\n\n        if (animated) {\n            njMotionOffset = cursor.int()\n            cursor.seek(8)\n            speed = cursor.float()\n        } else {\n            speed = null\n            njMotionOffset = null\n        }\n\n        cursor.seek(8) // Skip slide texture ID offset and swap texture ID offset.\n\n        val flags = cursor.int()\n\n        if (flags.isBitSet(2)) {\n            xjObjectOffset = cursor.seekStart(xjObjectOffset).int()\n        }\n\n        cursor.seekStart(xjObjectOffset)\n        val xjObjects = parseXjObject(cursor)\n\n        if (xjObjects.size > 1) {\n            logger.warn {\n                \"Expected exactly one xjObject at ${xjObjectOffset}, got ${xjObjects.size}.\"\n            }\n        }\n\n        val xjObject = xjObjects.first()\n\n        val njMotion = njMotionOffset?.let {\n            njMotionCache.getOrPut(njMotionOffset) {\n                cursor.seekStart(njMotionOffset)\n                parseMotion(cursor, v2Format = false)\n            }\n        }\n\n        objects.add(\n            if (animated) {\n                AreaObject.Animated(objectOffset, xjObject, njMotion!!, speed!!, flags)\n            } else {\n                AreaObject.Simple(objectOffset, xjObject, flags)\n            }\n        )\n    }\n\n    return objects\n}\n","package world.phantasmal.psolib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.psolib.cursor.Cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nclass IffChunk(val type: Int, val data: Cursor)\n\nclass IffChunkHeader(val type: Int, val size: Int)\n\n/**\n * PSO uses a little endian variant of the IFF format.\n * IFF files contain chunks preceded by an 8-byte header.\n * The header consists of 4 ASCII characters for the \"Type ID\" and a 32-bit integer specifying the chunk size.\n */\nfun parseIff(cursor: Cursor, silent: Boolean = false): PwResult<List<IffChunk>> =\n    parse(cursor, silent) { chunkCursor, type, size -> IffChunk(type, chunkCursor.take(size)) }\n\n/**\n * Parses just the chunk headers.\n */\nfun parseIffHeaders(cursor: Cursor, silent: Boolean = false): PwResult<List<IffChunkHeader>> =\n    parse(cursor, silent) { _, type, size -> IffChunkHeader(type, size) }\n\nprivate fun <T> parse(\n    cursor: Cursor,\n    silent: Boolean,\n    getChunk: (Cursor, type: Int, size: Int) -> T,\n): PwResult<List<T>> {\n    val result = PwResult.build<List<T>>(logger)\n    val chunks = mutableListOf<T>()\n    var corrupted = false\n\n    while (cursor.bytesLeft >= 8) {\n        val type = cursor.int()\n        val sizePos = cursor.position\n        val size = cursor.int()\n\n        if (size > cursor.bytesLeft) {\n            corrupted = true\n\n            if (!silent) {\n                result.addProblem(\n                    if (chunks.isEmpty()) Severity.Error else Severity.Warning,\n                    \"IFF file corrupted.\",\n                    \"Size $size was too large (only ${cursor.bytesLeft} bytes left) at position $sizePos.\"\n                )\n            }\n\n            break\n        }\n\n        chunks.add(getChunk(cursor, type, size))\n    }\n\n    return if (corrupted && chunks.isEmpty()) {\n        result.failure()\n    } else {\n        result.success(chunks)\n    }\n}\n","package world.phantasmal.psolib.fileFormats.ninja\n\nimport kotlin.math.PI\nimport kotlin.math.round\n\nprivate const val ANGLE_TO_RAD = ((2 * PI) / 0x10000).toFloat()\nprivate const val RAD_TO_ANGLE = (0x10000 / (2 * PI)).toFloat()\n\nfun angleToRad(angle: Int): Float {\n    return angle * ANGLE_TO_RAD\n}\n\nfun radToAngle(rad: Float): Int {\n    return round(rad * RAD_TO_ANGLE).toInt()\n}\n","package world.phantasmal.psolib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.isBitSet\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.fileFormats.Vec2\nimport world.phantasmal.psolib.fileFormats.Vec3\nimport world.phantasmal.psolib.fileFormats.vec3Float\nimport kotlin.math.abs\n\n// TODO:\n//  - colors\n//  - bump maps\n\nprivate val logger = KotlinLogging.logger {}\n\n// TODO: Simplify parser by not parsing chunks into vertices and meshes. Do the chunk to vertex/mesh\n//       conversion at a higher level.\nfun parseNjModel(cursor: Cursor, cachedChunks: MutableMap<Int, List<NjChunk>>): NjModel {\n    val vlistOffset = cursor.int() // Vertex list\n    val plistOffset = cursor.int() // Triangle strip index list\n    val collisionSphereCenter = cursor.vec3Float()\n    val collisionSphereRadius = cursor.float()\n    val vertices: MutableList<NjVertex?> = mutableListOf()\n    val meshes: MutableList<NjTriangleStrip> = mutableListOf()\n\n    if (vlistOffset != 0) {\n        cursor.seekStart(vlistOffset)\n\n        for (chunk in parseChunks(cursor)) {\n            if (chunk is NjChunk.Vertex) {\n                for (vertex in chunk.vertices) {\n                    while (vertices.size <= vertex.index) {\n                        vertices.add(null)\n                    }\n\n                    vertices[vertex.index] = NjVertex(\n                        vertex.position,\n                        vertex.normal,\n                        vertex.boneWeight,\n                        vertex.boneWeightStatus,\n                        vertex.calcContinue,\n                    )\n                }\n            }\n        }\n    }\n\n    if (plistOffset > 0) {\n        cursor.seekStart(plistOffset)\n\n        PolygonChunkProcessor(cachedChunks, meshes).process(parseChunks(cursor))\n    }\n\n    return NjModel(\n        vertices,\n        meshes,\n        collisionSphereCenter,\n        collisionSphereRadius,\n    )\n}\n\nprivate class PolygonChunkProcessor(\n    private val cachedChunks: MutableMap<Int, List<NjChunk>>,\n    private val meshes: MutableList<NjTriangleStrip>,\n) {\n    private var textureId: Int? = null\n    private var srcAlpha: Int? = null\n    private var dstAlpha: Int? = null\n\n    /**\n     * When [cacheList] is non-null we are caching chunks.\n     */\n    private var cacheList: MutableList<NjChunk>? = null\n\n    fun process(chunks: List<NjChunk>) {\n        for (chunk in chunks) {\n            if (cacheList == null) {\n                when (chunk) {\n                    is NjChunk.BlendAlpha -> {\n                        srcAlpha = chunk.srcAlpha\n                        dstAlpha = chunk.dstAlpha\n                    }\n\n                    is NjChunk.CachePolygonList -> {\n                        cacheList = mutableListOf()\n                        cachedChunks[chunk.cacheIndex] = cacheList!!\n                    }\n\n                    is NjChunk.DrawPolygonList -> {\n                        val cached = cachedChunks[chunk.cacheIndex]\n\n                        if (cached == null) {\n                            logger.debug {\n                                \"Draw Polygon List chunk pointed to nonexistent cache index ${chunk.cacheIndex}.\"\n                            }\n                        } else {\n                            process(cached)\n                        }\n                    }\n\n                    is NjChunk.Tiny -> {\n                        textureId = chunk.textureId\n                    }\n\n                    is NjChunk.Material -> {\n                        srcAlpha = chunk.srcAlpha\n                        dstAlpha = chunk.dstAlpha\n                    }\n\n                    is NjChunk.Strip -> {\n                        for (strip in chunk.triangleStrips) {\n                            strip.textureId = textureId\n                            strip.srcAlpha = srcAlpha\n                            strip.dstAlpha = dstAlpha\n                        }\n\n                        meshes.addAll(chunk.triangleStrips)\n                    }\n\n                    else -> {\n                        // Ignore\n                    }\n                }\n            } else {\n                cacheList!!.add(chunk)\n            }\n        }\n    }\n}\n\nprivate fun parseChunks(cursor: Cursor): List<NjChunk> {\n    val chunks: MutableList<NjChunk> = mutableListOf()\n\n    do {\n        val chunkStartPosition = cursor.position\n        val typeId = cursor.uByte().toInt()\n        val flags = cursor.uByte().toInt()\n        val chunkDataPosition = cursor.position\n        var size = 0\n        val chunk: NjChunk\n\n        when (typeId) {\n            0 -> {\n                chunk = NjChunk.Null\n            }\n            1 -> {\n                chunk = NjChunk.BlendAlpha(\n                    srcAlpha = (flags ushr 3) and 0b111,\n                    dstAlpha = flags and 0b111,\n                )\n            }\n            2 -> {\n                chunk = NjChunk.MipmapDAdjust(\n                    adjust = flags and 0b1111,\n                )\n            }\n            3 -> {\n                chunk = NjChunk.SpecularExponent(\n                    specular = flags and 0b11111,\n                )\n            }\n            4 -> {\n                chunk = NjChunk.CachePolygonList(\n                    cacheIndex = flags,\n                )\n            }\n            5 -> {\n                chunk = NjChunk.DrawPolygonList(\n                    cacheIndex = flags,\n                )\n            }\n            in 8..9 -> {\n                size = 2\n                val textureBitsAndId = cursor.uShort().toInt()\n\n                chunk = NjChunk.Tiny(\n                    typeId,\n                    flipU = flags.isBitSet(7),\n                    flipV = flags.isBitSet(6),\n                    clampU = flags.isBitSet(5),\n                    clampV = flags.isBitSet(4),\n                    mipmapDAdjust = flags.toUInt() and 0b1111u,\n                    filterMode = textureBitsAndId ushr 14,\n                    superSample = (textureBitsAndId and 0x40) != 0,\n                    textureId = textureBitsAndId and 0x1FFF,\n                )\n            }\n            in 17..31 -> {\n                val bodySize = 2 * cursor.short()\n                size = 2 + bodySize\n\n                var diffuse: NjArgb? = null\n                var ambient: NjArgb? = null\n                var specular: NjErgb? = null\n\n                if (typeId == 24) {\n                    // Skip bump map data.\n                    cursor.seek(bodySize)\n                } else {\n                    if (typeId.isBitSet(0)) {\n                        diffuse = NjArgb(\n                            b = cursor.uByte().toFloat() / 255f,\n                            g = cursor.uByte().toFloat() / 255f,\n                            r = cursor.uByte().toFloat() / 255f,\n                            a = cursor.uByte().toFloat() / 255f,\n                        )\n                    }\n\n                    if (typeId.isBitSet(1)) {\n                        ambient = NjArgb(\n                            b = cursor.uByte().toFloat() / 255f,\n                            g = cursor.uByte().toFloat() / 255f,\n                            r = cursor.uByte().toFloat() / 255f,\n                            a = cursor.uByte().toFloat() / 255f,\n                        )\n                    }\n\n                    if (typeId.isBitSet(2)) {\n                        specular = NjErgb(\n                            b = cursor.uByte(),\n                            g = cursor.uByte(),\n                            r = cursor.uByte(),\n                            e = cursor.uByte(),\n                        )\n                    }\n                }\n\n                chunk = NjChunk.Material(\n                    typeId,\n                    srcAlpha = (flags ushr 3) and 0b111,\n                    dstAlpha = flags and 0b111,\n                    diffuse,\n                    ambient,\n                    specular,\n                )\n            }\n            in 32..50 -> {\n                size = 2 + 4 * cursor.short()\n                chunk = NjChunk.Vertex(\n                    typeId,\n                    vertices = parseVertexChunk(cursor, typeId, flags),\n                )\n            }\n            in 56..58 -> {\n                size = 2 + 2 * cursor.short()\n                chunk = NjChunk.Volume(\n                    typeId,\n                )\n\n                // Skip volume information.\n                cursor.seek(2 * cursor.short())\n            }\n            in 64..75 -> {\n                size = 2 + 2 * cursor.short()\n                chunk = NjChunk.Strip(\n                    typeId,\n                    triangleStrips = parseTriangleStripChunk(cursor, typeId, flags),\n                )\n            }\n            255 -> {\n                chunk = NjChunk.End\n            }\n            else -> {\n                val bodySize = 2 * cursor.short()\n                size = 2 + bodySize\n                chunk = NjChunk.Unknown(\n                    typeId,\n                )\n                // Skip unknown data.\n                cursor.seek(bodySize)\n                logger.warn { \"Unknown chunk type $typeId at offset ${chunkStartPosition}.\" }\n            }\n        }\n\n        chunks.add(chunk)\n\n        val bytesRead = cursor.position - chunkDataPosition\n\n        check(bytesRead <= size) {\n            \"Expected to read at most $size bytes, actually read $bytesRead.\"\n        }\n\n        cursor.seekStart(chunkDataPosition + size)\n    } while (chunk != NjChunk.End)\n\n    return chunks\n}\n\nprivate fun parseVertexChunk(\n    cursor: Cursor,\n    chunkTypeId: Int,\n    flags: Int,\n): List<NjChunkVertex> {\n    val boneWeightStatus = flags and 0b11\n    val calcContinue = (flags and 0x80) != 0\n\n    val index = cursor.uShort()\n    val vertexCount = cursor.uShort()\n\n    val vertices: MutableList<NjChunkVertex> = mutableListOf()\n\n    for (i in (0u).toUShort() until vertexCount) {\n        var vertexIndex = index + i\n        val position = cursor.vec3Float()\n        var normal: Vec3? = null\n        var boneWeight: Float? = null\n\n        when (chunkTypeId) {\n            32 -> {\n                // NJD_CV_SH\n                cursor.seek(4) // Always 1.0\n            }\n            33 -> {\n                // NJD_CV_VN_SH\n                cursor.seek(4) // Always 1.0\n                normal = cursor.vec3Float()\n                cursor.seek(4) // Always 0.0\n            }\n            34 -> {\n                // NJD_CV\n                // Nothing to do.\n            }\n            in 35..40 -> {\n                if (chunkTypeId == 37) {\n                    // NJD_CV_NF\n                    // NinjaFlags32\n                    vertexIndex = index + cursor.uShort()\n                    boneWeight = cursor.uShort().toFloat() / 255f\n                } else {\n                    // NJD_CV_D8\n                    // NJD_CV_UF\n                    // NJD_CV_S5\n                    // NJD_CV_S4\n                    // NJD_CV_IN\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            41 -> {\n                // NJD_CV_VN\n                normal = cursor.vec3Float()\n            }\n            in 42..47 -> {\n                normal = cursor.vec3Float()\n\n                if (chunkTypeId == 44) {\n                    // NJD_CV_VN_NF\n                    // NinjaFlags32\n                    vertexIndex = index + cursor.uShort()\n                    boneWeight = cursor.uShort().toFloat() / 255f\n                } else {\n                    // NJD_CV_VN_D8\n                    // NJD_CV_VN_UF\n                    // NJD_CV_VN_S5\n                    // NJD_CV_VN_S4\n                    // NJD_CV_VN_IN\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            in 48..50 -> {\n                // NJD_CV_VNX\n                // 32-Bit vertex normal in format: reserved(2)|x(10)|y(10)|z(10)\n                val n = cursor.uInt()\n                normal = Vec3(\n                    ((n shr 20) and 0x3FFu).toFloat() / 0x3FF,\n                    ((n shr 10) and 0x3FFu).toFloat() / 0x3FF,\n                    (n and 0x3FFu).toFloat() / 0x3FF,\n                )\n\n                if (chunkTypeId >= 49) {\n                    // NJD_CV_VNX_D8\n                    // NJD_CV_VNX_UF\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            else -> error(\"Unexpected chunk type ID ${chunkTypeId}.\")\n        }\n\n        vertices.add(NjChunkVertex(\n            vertexIndex.toInt(),\n            position,\n            normal,\n            boneWeight,\n            boneWeightStatus,\n            calcContinue,\n        ))\n    }\n\n    return vertices\n}\n\nprivate fun parseTriangleStripChunk(\n    cursor: Cursor,\n    chunkTypeId: Int,\n    flags: Int,\n): List<NjTriangleStrip> {\n    val ignoreLight = flags.isBitSet(0)\n    val ignoreSpecular = flags.isBitSet(1)\n    val ignoreAmbient = flags.isBitSet(2)\n    val useAlpha = flags.isBitSet(3)\n    val doubleSide = flags.isBitSet(4)\n    val flatShading = flags.isBitSet(5)\n    val environmentMapping = flags.isBitSet(6)\n\n    val userOffsetAndStripCount = cursor.short().toInt()\n    val userFlagsSize = 2 * (userOffsetAndStripCount ushr 14)\n    val stripCount = userOffsetAndStripCount and 0x3FFF\n\n    var hasTexCoords = false\n    var hasColor = false\n    var hasNormal = false\n    var hasDoubleTexCoords = false\n\n    when (chunkTypeId) {\n        64 -> {\n        }\n        65, 66 -> {\n            hasTexCoords = true\n        }\n        67 -> {\n            hasNormal = true\n        }\n        68, 69 -> {\n            hasTexCoords = true\n            hasNormal = true\n        }\n        70 -> {\n            hasColor = true\n        }\n        71, 72 -> {\n            hasTexCoords = true\n            hasColor = true\n        }\n        73 -> {\n        }\n        74, 75 -> {\n            hasDoubleTexCoords = true\n        }\n        else -> error(\"Unexpected chunk type ID: ${chunkTypeId}.\")\n    }\n\n    val strips: MutableList<NjTriangleStrip> = mutableListOf()\n\n    repeat(stripCount) {\n        val windingFlagAndIndexCount = cursor.short().toInt()\n        val clockwiseWinding = windingFlagAndIndexCount < 0\n        val indexCount = abs(windingFlagAndIndexCount)\n\n        val vertices: MutableList<NjMeshVertex> = mutableListOf()\n\n        for (j in 0 until indexCount) {\n            val index = cursor.uShort().toInt()\n\n            val texCoords = if (hasTexCoords) {\n                Vec2(cursor.uShort().toFloat() / 255f, cursor.uShort().toFloat() / 255f)\n            } else null\n\n            // Ignore ARGB8888 color.\n            if (hasColor) {\n                cursor.seek(4)\n            }\n\n            val normal = if (hasNormal) {\n                Vec3(\n                    cursor.uShort().toFloat() / 255f,\n                    cursor.uShort().toFloat() / 255f,\n                    cursor.uShort().toFloat() / 255f,\n                )\n            } else null\n\n            // Ignore double texture coordinates (Ua, Vb, Ua, Vb).\n            if (hasDoubleTexCoords) {\n                cursor.seek(8)\n            }\n\n            // User flags start at the third vertex because they are per-triangle.\n            if (j >= 2) {\n                cursor.seek(userFlagsSize)\n            }\n\n            vertices.add(NjMeshVertex(\n                index,\n                normal,\n                texCoords,\n            ))\n        }\n\n        strips.add(NjTriangleStrip(\n            ignoreLight,\n            ignoreSpecular,\n            ignoreAmbient,\n            useAlpha,\n            doubleSide,\n            flatShading,\n            environmentMapping,\n            clockwiseWinding,\n            hasTexCoords,\n            hasNormal,\n            textureId = null,\n            srcAlpha = null,\n            dstAlpha = null,\n            vertices,\n        ))\n    }\n\n    return strips\n}\n","package world.phantasmal.psolib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.Failure\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.fileFormats.parseIff\nimport world.phantasmal.psolib.fileFormats.parseIffHeaders\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val XVMH = 0x484d5658\nprivate const val XVRT = 0x54525658\n\nclass Xvm(\n    val textures: List<XvrTexture>,\n)\n\nclass XvrTexture(\n    val id: Int,\n    val format: Pair<Int, Int>,\n    val width: Int,\n    val height: Int,\n    val size: Int,\n    val data: Buffer,\n)\n\nfun parseXvr(cursor: Cursor): XvrTexture {\n    val format1 = cursor.int()\n    val format2 = cursor.int()\n    val id = cursor.int()\n    val width = cursor.uShort().toInt()\n    val height = cursor.uShort().toInt()\n    val size = cursor.int()\n    cursor.seek(36)\n    val data = cursor.buffer(size)\n    return XvrTexture(\n        id,\n        format = Pair(format1, format2),\n        width,\n        height,\n        size,\n        data,\n    )\n}\n\nfun isXvm(cursor: Cursor): Boolean {\n    val iffResult = parseIffHeaders(cursor, silent = true)\n    cursor.seekStart(0)\n\n    return iffResult is Success &&\n            iffResult.value.any { chunk -> chunk.type == XVMH || chunk.type == XVRT }\n}\n\nfun parseXvm(cursor: Cursor): PwResult<Xvm> {\n    val iffResult = parseIff(cursor)\n\n    if (iffResult !is Success) {\n        return iffResult as Failure\n    }\n\n    val result = PwResult.build<Xvm>(logger)\n    result.addResult(iffResult)\n    val chunks = iffResult.value\n    val headerChunk = chunks.find { it.type == XVMH }\n    val header = headerChunk?.data?.let(::parseHeader)\n\n    val textures = chunks\n        .filter { it.type == XVRT }\n        .map { parseXvr(it.data) }\n\n    if (header == null && textures.isEmpty()) {\n        result.addProblem(\n            Severity.Error,\n            \"Corrupted XVM file.\",\n            \"No header and no XVRT chunks found.\",\n        )\n\n        return result.failure()\n    }\n\n    if (header != null && header.textureCount != textures.size) {\n        result.addProblem(\n            Severity.Warning,\n            \"Corrupted XVM file.\",\n            \"Found ${textures.size} textures instead of ${header.textureCount} as defined in the header.\",\n        )\n    }\n\n    return result.success(Xvm(textures))\n}\n\nprivate class Header(\n    val textureCount: Int,\n)\n\nprivate fun parseHeader(cursor: Cursor): Header {\n    val textureCount = cursor.uShort().toInt()\n    return Header(textureCount)\n}\n","package world.phantasmal.psolib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.fileFormats.Vec2\nimport world.phantasmal.psolib.fileFormats.Vec3\nimport world.phantasmal.psolib.fileFormats.vec2Float\nimport world.phantasmal.psolib.fileFormats.vec3Float\n\nprivate val logger = KotlinLogging.logger {}\n\nfun parseXjModel(cursor: Cursor): XjModel {\n    cursor.seek(4) // Flags according to QEdit, seemingly always 0.\n    val vertexInfoTableOffset = cursor.int()\n    val vertexInfoCount = cursor.int()\n    val triangleStripTableOffset = cursor.int()\n    val triangleStripCount = cursor.int()\n    val transparentTriangleStripTableOffset = cursor.int()\n    val transparentTriangleStripCount = cursor.int()\n    val collisionSpherePosition = cursor.vec3Float()\n    val collisionSphereRadius = cursor.float()\n\n    val vertices = mutableListOf<XjVertex>()\n\n    if (vertexInfoCount > 0) {\n        // TODO: parse all vertex info tables.\n        vertices.addAll(parseVertexInfoTable(cursor, vertexInfoTableOffset))\n    }\n\n    val meshes = mutableListOf<XjMesh>()\n\n    meshes.addAll(\n        parseTriangleStripTable(cursor, triangleStripTableOffset, triangleStripCount),\n    )\n\n    meshes.addAll(\n        parseTriangleStripTable(\n            cursor,\n            transparentTriangleStripTableOffset,\n            transparentTriangleStripCount,\n        ),\n    )\n\n    return XjModel(\n        vertices,\n        meshes,\n        collisionSpherePosition,\n        collisionSphereRadius,\n    )\n}\n\nprivate fun parseVertexInfoTable(cursor: Cursor, vertexInfoTableOffset: Int): List<XjVertex> {\n    cursor.seekStart(vertexInfoTableOffset)\n    val vertexType = cursor.short().toInt()\n    cursor.seek(2) // Flags?\n    val vertexTableOffset = cursor.int()\n    val vertexSize = cursor.int()\n    val vertexCount = cursor.int()\n\n    return (0 until vertexCount).map { i ->\n        cursor.seekStart(vertexTableOffset + i * vertexSize)\n\n        val position = cursor.vec3Float()\n        var normal: Vec3? = null\n        var uv: Vec2? = null\n\n        when (vertexType) {\n            2 -> {\n                normal = cursor.vec3Float()\n            }\n            3 -> {\n                normal = cursor.vec3Float()\n                uv = cursor.vec2Float()\n            }\n            4 -> {\n                // Skip 4 bytes.\n            }\n            5 -> {\n                cursor.seek(4)\n                uv = cursor.vec2Float()\n            }\n            6 -> {\n                normal = cursor.vec3Float()\n                // Skip 4 bytes.\n            }\n            7 -> {\n                normal = cursor.vec3Float()\n                uv = cursor.vec2Float()\n            }\n            else -> {\n                logger.warn { \"Unknown vertex type $vertexType with size ${vertexSize}.\" }\n            }\n        }\n\n        XjVertex(\n            position,\n            normal,\n            uv,\n        )\n    }\n}\n\nprivate fun parseTriangleStripTable(\n    cursor: Cursor,\n    triangleStripListOffset: Int,\n    triangleStripCount: Int,\n): List<XjMesh> {\n    return (0 until triangleStripCount).map { i ->\n        cursor.seekStart(triangleStripListOffset + i * 20)\n\n        val materialTableOffset = cursor.int()\n        val materialTableSize = cursor.int()\n        val indexListOffset = cursor.int()\n        val indexCount = cursor.int()\n\n        val material = parseTriangleStripMaterial(\n            cursor,\n            materialTableOffset,\n            materialTableSize,\n        )\n\n        cursor.seekStart(indexListOffset)\n        val indices = cursor.uShortArray(indexCount)\n\n        XjMesh(\n            material,\n            indices = indices.map { it.toInt() },\n        )\n    }\n}\n\nprivate fun parseTriangleStripMaterial(\n    cursor: Cursor,\n    offset: Int,\n    size: Int,\n): XjMaterial {\n    var srcAlpha: Int? = null\n    var dstAlpha: Int? = null\n    var textureId: Int? = null\n    var diffuseR: Int? = null\n    var diffuseG: Int? = null\n    var diffuseB: Int? = null\n    var diffuseA: Int? = null\n\n    for (i in 0 until size) {\n        cursor.seekStart(offset + i * 16)\n\n        when (cursor.int()) {\n            2 -> {\n                srcAlpha = cursor.int()\n                dstAlpha = cursor.int()\n            }\n            3 -> {\n                textureId = cursor.int()\n            }\n            5 -> {\n                diffuseR = cursor.uByte().toInt()\n                diffuseG = cursor.uByte().toInt()\n                diffuseB = cursor.uByte().toInt()\n                diffuseA = cursor.uByte().toInt()\n            }\n        }\n    }\n\n    return XjMaterial(\n        srcAlpha,\n        dstAlpha,\n        textureId,\n        diffuseR,\n        diffuseG,\n        diffuseB,\n        diffuseA,\n    )\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.cursor.cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val DC_GC_OBJECT_CODE_OFFSET = 468\nprivate const val PC_OBJECT_CODE_OFFSET = 920\nprivate const val BB_OBJECT_CODE_OFFSET = 4652\n\nclass BinFile(\n    var format: BinFormat,\n    var questId: Int,\n    var language: Int,\n    var questName: String,\n    var shortDescription: String,\n    var longDescription: String,\n    val bytecode: Buffer,\n    val labelOffsets: IntArray,\n    val shopItems: UIntArray,\n)\n\nenum class BinFormat {\n    /**\n     * Dreamcast/GameCube\n     */\n    DC_GC,\n\n    /**\n     * Desktop\n     */\n    PC,\n\n    /**\n     * BlueBurst\n     */\n    BB,\n}\n\nfun parseBin(cursor: Cursor): BinFile {\n    val bytecodeOffset = cursor.int()\n    val labelOffsetTableOffset = cursor.int() // Relative offsets\n    val size = cursor.int()\n    cursor.seek(4) // Always seems to be 0xFFFFFFFF.\n\n    val format = when (bytecodeOffset) {\n        DC_GC_OBJECT_CODE_OFFSET -> BinFormat.DC_GC\n        PC_OBJECT_CODE_OFFSET -> BinFormat.PC\n        BB_OBJECT_CODE_OFFSET -> BinFormat.BB\n        else -> {\n            logger.warn {\n                \"Byte code at unexpected offset $bytecodeOffset, assuming file is a PC file.\"\n            }\n            BinFormat.PC\n        }\n    }\n\n    val questId: Int\n    val language: Int\n    val questName: String\n    val shortDescription: String\n    val longDescription: String\n\n    if (format == BinFormat.DC_GC) {\n        cursor.seek(1)\n        language = cursor.byte().toInt()\n        questId = cursor.short().toInt()\n        questName = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n        shortDescription = cursor.stringAscii(128, nullTerminated = true, dropRemaining = true)\n        longDescription = cursor.stringAscii(288, nullTerminated = true, dropRemaining = true)\n    } else {\n        if (format == BinFormat.PC) {\n            language = cursor.short().toInt()\n            questId = cursor.short().toInt()\n        } else {\n            questId = cursor.int()\n            language = cursor.int()\n        }\n\n        questName = cursor.stringUtf16(64, nullTerminated = true, dropRemaining = true)\n        shortDescription = cursor.stringUtf16(256, nullTerminated = true, dropRemaining = true)\n        longDescription = cursor.stringUtf16(576, nullTerminated = true, dropRemaining = true)\n    }\n\n    if (size != cursor.size) {\n        logger.warn { \"Value $size in bin size field does not match actual size ${cursor.size}.\" }\n    }\n\n    val shopItems = if (format == BinFormat.BB) {\n        cursor.seek(4) // Skip padding.\n        cursor.uIntArray(932)\n    } else {\n        UIntArray(0)\n    }\n\n    val labelOffsetCount = (cursor.size - labelOffsetTableOffset) / 4\n    val labelOffsets = cursor\n        .seekStart(labelOffsetTableOffset)\n        .intArray(labelOffsetCount)\n\n    val bytecode = cursor\n        .seekStart(bytecodeOffset)\n        .buffer(labelOffsetTableOffset - bytecodeOffset)\n\n    return BinFile(\n        format,\n        questId,\n        language,\n        questName,\n        shortDescription,\n        longDescription,\n        bytecode,\n        labelOffsets,\n        shopItems,\n    )\n}\n\nfun writeBin(bin: BinFile): Buffer {\n    require(bin.questName.length <= 32) {\n        \"questName can't be longer than 32 characters, was ${bin.questName.length}\"\n    }\n    require(bin.shortDescription.length <= 127) {\n        \"shortDescription can't be longer than 127 characters, was ${bin.shortDescription.length}\"\n    }\n    require(bin.longDescription.length <= 287) {\n        \"longDescription can't be longer than 287 characters, was ${bin.longDescription.length}\"\n    }\n    require(bin.shopItems.isEmpty() || bin.format == BinFormat.BB) {\n        \"shopItems is only supported in BlueBurst quests.\"\n    }\n    require(bin.shopItems.size <= 932) {\n        \"shopItems can't be larger than 932, was ${bin.shopItems.size}.\"\n    }\n\n    val bytecodeOffset = when (bin.format) {\n        BinFormat.DC_GC -> DC_GC_OBJECT_CODE_OFFSET\n        BinFormat.PC -> PC_OBJECT_CODE_OFFSET\n        BinFormat.BB -> BB_OBJECT_CODE_OFFSET\n    }\n\n    val fileSize = bytecodeOffset + bin.bytecode.size + 4 * bin.labelOffsets.size\n    val buffer = Buffer.withCapacity(fileSize)\n    val cursor = buffer.cursor()\n\n    cursor.writeInt(bytecodeOffset)\n    cursor.writeInt(bytecodeOffset + bin.bytecode.size) // Label table offset.\n    cursor.writeInt(fileSize)\n    cursor.writeInt(-1)\n\n    if (bin.format == BinFormat.DC_GC) {\n        cursor.writeByte(0)\n        cursor.writeByte(bin.language.toByte())\n        cursor.writeShort(bin.questId.toShort())\n        cursor.writeStringAscii(bin.questName, 32)\n        cursor.writeStringAscii(bin.shortDescription, 128)\n        cursor.writeStringAscii(bin.longDescription, 288)\n    } else {\n        if (bin.format == BinFormat.PC) {\n            cursor.writeShort(bin.language.toShort())\n            cursor.writeShort(bin.questId.toShort())\n        } else {\n            cursor.writeInt(bin.questId)\n            cursor.writeInt(bin.language)\n        }\n\n        cursor.writeStringUtf16(bin.questName, 64)\n        cursor.writeStringUtf16(bin.shortDescription, 256)\n        cursor.writeStringUtf16(bin.longDescription, 576)\n    }\n\n    if (bin.format == BinFormat.BB) {\n        cursor.writeInt(0)\n        cursor.writeUIntArray(bin.shopItems)\n\n        repeat(932 - bin.shopItems.size) {\n            cursor.writeUInt(0u)\n        }\n    }\n\n    check(cursor.position == bytecodeOffset) {\n        \"Expected to write $bytecodeOffset bytes before bytecode, but wrote ${cursor.position}.\"\n    }\n\n    cursor.writeCursor(bin.bytecode.cursor())\n\n    cursor.writeIntArray(bin.labelOffsets)\n\n    check(cursor.position == fileSize) {\n        \"Expected to write $fileSize bytes, but wrote ${cursor.position}.\"\n    }\n\n    return buffer\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.psolib.Endianness\nimport world.phantasmal.psolib.asm.*\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.getRegisterValue\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.getStackValue\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.BufferCursor\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.cursor.cursor\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val MAX_TOTAL_NOPS = 20\nprivate const val MAX_SEQUENTIAL_NOPS = 10\nprivate const val MAX_UNKNOWN_OPCODE_RATIO = 0.2\nprivate const val MAX_STACK_POP_WITHOUT_PRECEDING_PUSH_RATIO = 0.2\nprivate const val MAX_UNKNOWN_LABEL_RATIO = 0.2\n\nval SEGMENT_PRIORITY = mapOf(\n    SegmentType.Instructions to 2,\n    SegmentType.String to 1,\n    SegmentType.Data to 0,\n)\n\n/**\n * These functions are built into the client and can optionally be overridden on BB. Other versions\n * require you to always specify them in the script.\n */\nval BUILTIN_FUNCTIONS = setOf(\n    60,\n    70,\n    80,\n    90,\n    100,\n    110,\n    120,\n    130,\n    140,\n    800,\n    810,\n    820,\n    830,\n    840,\n    850,\n    860,\n    900,\n    910,\n    920,\n    930,\n    940,\n    950,\n    960,\n)\n\n/**\n * Parses bytecode into bytecode IR.\n */\nfun parseBytecode(\n    bytecode: Buffer,\n    labelOffsets: IntArray,\n    entryLabels: Set<Int>,\n    dcGcFormat: Boolean,\n    lenient: Boolean,\n): PwResult<BytecodeIr> {\n    val cursor = BufferCursor(bytecode)\n    val labelHolder = LabelHolder(labelOffsets)\n    val result = PwResult.build<BytecodeIr>(logger)\n    val offsetToSegment = mutableMapOf<Int, Segment>()\n\n    findAndParseSegments(\n        cursor,\n        labelHolder,\n        entryLabels.associateWith { SegmentType.Instructions },\n        offsetToSegment,\n        lenient,\n        dcGcFormat,\n    )\n\n    val segments: MutableList<Segment> = mutableListOf()\n\n    // Put segments in an array and try to parse leftover segments as instructions segments. When a\n    // segment can't be parsed as instructions, fall back to parsing it as a data segment.\n    var offset = 0\n\n    while (offset < cursor.size) {\n        var segment: Segment? = offsetToSegment[offset]\n\n        // If we have a segment, add it. Otherwise create a new data segment.\n        if (segment == null) {\n            val labels = labelHolder.getLabels(offset)\n            var endOffset: Int\n\n            if (labels == null) {\n                endOffset = cursor.size\n\n                for (label in labelHolder.labels) {\n                    if (label.offset > offset) {\n                        endOffset = label.offset\n                        break\n                    }\n                }\n            } else {\n                val info = labelHolder.getInfo(labels[0])!!\n                endOffset = info.next?.offset ?: cursor.size\n            }\n\n            cursor.seekStart(offset)\n\n            val isInstructionsSegment = tryParseInstructionsSegment(\n                offsetToSegment,\n                labelHolder,\n                cursor,\n                endOffset,\n                labels?.toMutableList() ?: mutableListOf(),\n                dcGcFormat,\n            )\n\n            if (!isInstructionsSegment) {\n                cursor.seekStart(offset)\n\n                parseDataSegment(\n                    offsetToSegment,\n                    cursor,\n                    endOffset,\n                    labels?.toMutableList() ?: mutableListOf()\n                )\n            }\n\n            segment = offsetToSegment[offset]\n\n            check(endOffset > offset) {\n                \"Next offset $endOffset was smaller than or equal to current offset ${offset}.\"\n            }\n            checkNotNull(segment) { \"Couldn't create segment for offset ${offset}.\" }\n        }\n\n        segments.add(segment)\n\n        offset += segment.size(dcGcFormat)\n    }\n\n    // Add unreferenced labels to their segment.\n    for ((label, labelOffset) in labelHolder.labels) {\n        val segment = offsetToSegment[labelOffset]\n\n        if (segment == null) {\n            result.addProblem(\n                Severity.Warning,\n                \"Label $label doesn't point to anything.\",\n                \"Label $label with offset $labelOffset doesn't point to anything.\",\n            )\n        } else {\n            if (label !in segment.labels) {\n                segment.labels.add(label)\n                segment.labels.sort()\n            }\n        }\n    }\n\n    // Sanity check parsed byte code.\n    if (cursor.size != offset) {\n        result.addProblem(\n            Severity.Error,\n            \"The script code is corrupt.\",\n            \"Expected to parse ${cursor.size} bytes but parsed $offset instead.\",\n        )\n\n        if (!lenient) {\n            return result.failure()\n        }\n    }\n\n    return result.success(BytecodeIr(segments))\n}\n\nprivate fun findAndParseSegments(\n    cursor: Cursor,\n    labelHolder: LabelHolder,\n    labels: Map<Int, SegmentType>,\n    offsetToSegment: MutableMap<Int, Segment>,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    var newLabels = labels\n    var startSegmentCount: Int\n    // Instruction segments which we've been able to fully analyze for label references so far.\n    val analyzedSegments = mutableSetOf<InstructionSegment>()\n\n    // Iteratively parse segments from label references.\n    do {\n        startSegmentCount = offsetToSegment.size\n\n        // Parse segments of which the type is known.\n        for ((label, type) in newLabels) {\n            parseSegment(offsetToSegment, labelHolder, cursor, label, type, lenient, dcGcFormat)\n        }\n\n        // Find label references.\n        val sortedSegments = offsetToSegment.entries\n            .filter { (_, s) -> s is InstructionSegment }\n            .sortedBy { it.key }\n            .map { (_, s) -> s as InstructionSegment }\n\n        val cfg = ControlFlowGraph.create(sortedSegments)\n\n        newLabels = mutableMapOf()\n\n        for (segment in sortedSegments) {\n            if (segment in analyzedSegments) continue\n\n            var foundAllLabels = true\n\n            for (instructionIdx in segment.instructions.indices) {\n                val instruction = segment.instructions[instructionIdx]\n                var i = 0\n\n                while (i < instruction.opcode.params.size) {\n                    val param = instruction.opcode.params[i]\n\n                    when (param.type) {\n                        is ILabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.Instructions,\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is ILabelVarType -> {\n                            // Never on the stack.\n                            // Eat all remaining arguments.\n                            while (i < instruction.args.size) {\n                                newLabels[(instruction.args[i] as IntArg).value] =\n                                    SegmentType.Instructions\n\n                                i++\n                            }\n                        }\n\n                        is DLabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.Data\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is SLabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.String\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is RegType -> if (param.type.registers != null) {\n                            for (j in param.type.registers.indices) {\n                                val registerParam = param.type.registers[j]\n\n                                // Never on the stack.\n                                if (registerParam.type is ILabelType) {\n                                    val firstRegister = instruction.args[0].value as Int\n                                    val labelValues = getRegisterValue(\n                                        cfg,\n                                        instruction,\n                                        firstRegister + j,\n                                    )\n\n                                    if (labelValues.size <= 20) {\n                                        for (label in labelValues) {\n                                            newLabels[label] = SegmentType.Instructions\n                                        }\n                                    } else {\n                                        foundAllLabels = false\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    i++\n                }\n            }\n\n            if (foundAllLabels) {\n                analyzedSegments.add(segment)\n            }\n        }\n    } while (offsetToSegment.size > startSegmentCount)\n}\n\n/**\n * Returns immediate arguments or stack arguments.\n */\nprivate fun getArgLabelValues(\n    cfg: ControlFlowGraph,\n    labels: MutableMap<Int, SegmentType>,\n    instructionSegment: InstructionSegment,\n    instructionIdx: Int,\n    paramIdx: Int,\n    segmentType: SegmentType,\n): Boolean {\n    val instruction = instructionSegment.instructions[instructionIdx]\n\n    if (instruction.opcode.stack === StackInteraction.Pop) {\n        val stackValues = getStackValue(\n            cfg,\n            instruction,\n            instruction.opcode.params.size - paramIdx - 1,\n        ).first\n\n        if (stackValues.size <= 20) {\n            for (value in stackValues) {\n                val oldType = labels[value]\n\n                if (\n                    oldType == null ||\n                    SEGMENT_PRIORITY.getValue(segmentType) > SEGMENT_PRIORITY.getValue(oldType)\n                ) {\n                    labels[value] = segmentType\n                }\n            }\n\n            return true\n        }\n    } else {\n        val value = (instruction.args[paramIdx] as IntArg).value\n        val oldType = labels[value]\n\n        if (\n            oldType == null ||\n            SEGMENT_PRIORITY.getValue(segmentType) > SEGMENT_PRIORITY.getValue(oldType)\n        ) {\n            labels[value] = segmentType\n        }\n\n        return true\n    }\n\n    return false\n}\n\nprivate fun parseSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    label: Int,\n    type: SegmentType,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    try {\n        val info = labelHolder.getInfo(label)\n\n        if (info == null) {\n            if (label !in BUILTIN_FUNCTIONS) {\n                logger.warn { \"Label $label is not registered in the label table.\" }\n            }\n\n            return\n        }\n\n        // Check whether we've already parsed this segment and reparse it if necessary.\n        val segment = offsetToSegment[info.offset]\n\n        val labels: MutableList<Int> =\n            if (segment == null) {\n                mutableListOf(label)\n            } else {\n                if (label !in segment.labels) {\n                    segment.labels.add(label)\n                    segment.labels.sort()\n                }\n\n                if (SEGMENT_PRIORITY.getValue(type) > SEGMENT_PRIORITY.getValue(segment.type)) {\n                    segment.labels\n                } else {\n                    return\n                }\n            }\n\n        val endOffset = info.next?.offset ?: cursor.size\n        cursor.seekStart(info.offset)\n\n        return when (type) {\n            SegmentType.Instructions ->\n                parseInstructionsSegment(\n                    offsetToSegment,\n                    labelHolder,\n                    cursor,\n                    endOffset,\n                    labels,\n                    info.next?.label,\n                    lenient,\n                    dcGcFormat,\n                )\n\n            SegmentType.Data ->\n                parseDataSegment(offsetToSegment, cursor, endOffset, labels)\n\n            SegmentType.String ->\n                parseStringSegment(offsetToSegment, cursor, endOffset, labels, dcGcFormat)\n        }\n    } catch (e: Exception) {\n        if (lenient) {\n            logger.error(e) { \"Couldn't fully parse byte code segment.\" }\n        } else {\n            throw e\n        }\n    }\n}\n\nprivate fun parseInstructionsSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    nextLabel: Int?,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    val instructions = mutableListOf<Instruction>()\n\n    val segment = InstructionSegment(\n        labels,\n        instructions,\n        SegmentSrcLoc()\n    )\n    offsetToSegment[cursor.position] = segment\n\n    while (cursor.position < endOffset) {\n        // Parse the opcode.\n        val mainOpcode = cursor.uByte()\n\n        val fullOpcode = when (mainOpcode.toInt()) {\n            0xF8, 0xF9 -> ((mainOpcode.toInt() shl 8) or cursor.uByte().toInt())\n            else -> mainOpcode.toInt()\n        }\n\n        val opcode = codeToOpcode(fullOpcode)\n\n        // Parse the arguments.\n        try {\n            val args = parseInstructionArguments(cursor, opcode, dcGcFormat)\n            instructions.add(Instruction(opcode, args, srcLoc = null, valid = true))\n        } catch (e: Exception) {\n            if (lenient) {\n                logger.error(e) {\n                    \"Exception occurred while parsing arguments for instruction ${opcode.mnemonic}.\"\n                }\n                instructions.add(Instruction(opcode, emptyList(), srcLoc = null, valid = false))\n            } else {\n                throw e\n            }\n        }\n    }\n\n    // Recurse on label drop-through.\n    if (nextLabel != null) {\n        // Find the last ret or jmp.\n        var dropThrough = true\n\n        for (i in instructions.lastIndex downTo 0) {\n            val opcode = instructions[i].opcode.code\n\n            if (opcode == OP_RET.code || opcode == OP_JMP.code) {\n                dropThrough = false\n                break\n            }\n        }\n\n        if (dropThrough) {\n            parseSegment(\n                offsetToSegment,\n                labelHolder,\n                cursor,\n                nextLabel,\n                SegmentType.Instructions,\n                lenient,\n                dcGcFormat,\n            )\n        }\n    }\n}\n\nprivate fun parseDataSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n) {\n    val startOffset = cursor.position\n    val segment = DataSegment(\n        labels,\n        cursor.buffer(endOffset - startOffset),\n        SegmentSrcLoc(),\n    )\n    offsetToSegment[startOffset] = segment\n}\n\nprivate fun parseStringSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    dcGcFormat: Boolean,\n) {\n    val startOffset = cursor.position\n    val byteLength = endOffset - startOffset\n    val segment = StringSegment(\n        labels,\n        if (dcGcFormat) {\n            cursor.stringAscii(\n                byteLength,\n                nullTerminated = true,\n                dropRemaining = true\n            )\n        } else {\n            cursor.stringUtf16(\n                byteLength,\n                nullTerminated = true,\n                dropRemaining = true\n            )\n        },\n        byteLength,\n        SegmentSrcLoc()\n    )\n    offsetToSegment[startOffset] = segment\n}\n\nprivate fun parseInstructionArguments(\n    cursor: Cursor,\n    opcode: Opcode,\n    dcGcFormat: Boolean,\n): List<Arg> {\n    val args = mutableListOf<Arg>()\n\n    if (opcode.stack != StackInteraction.Pop) {\n        var varargCount = 0\n\n        for (param in opcode.params) {\n            when (param.type) {\n                is ByteType ->\n                    args.add(IntArg(cursor.uByte().toInt()))\n\n                is ShortType ->\n                    args.add(IntArg(cursor.uShort().toInt()))\n\n                is IntType ->\n                    args.add(IntArg(cursor.int()))\n\n                is FloatType ->\n                    args.add(FloatArg(cursor.float()))\n\n                // Ensure this case is before the LabelType case because ILabelVarType extends\n                // LabelType.\n                is ILabelVarType -> {\n                    varargCount++\n                    val argSize = cursor.uByte()\n                    args.addAll(cursor.uShortArray(argSize.toInt()).map { IntArg(it.toInt()) })\n                }\n\n                is LabelType -> {\n                    args.add(IntArg(cursor.uShort().toInt()))\n                }\n\n                is StringType -> {\n                    val maxBytes = min(4096, cursor.bytesLeft)\n                    args.add(\n                        StringArg(\n                            if (dcGcFormat) {\n                                cursor.stringAscii(\n                                    maxBytes,\n                                    nullTerminated = true,\n                                    dropRemaining = false\n                                )\n                            } else {\n                                cursor.stringUtf16(\n                                    maxBytes,\n                                    nullTerminated = true,\n                                    dropRemaining = false\n                                )\n                            },\n                        )\n                    )\n                }\n\n                is RegType -> {\n                    args.add(IntArg(cursor.uByte().toInt()))\n                }\n\n                is RegVarType -> {\n                    varargCount++\n                    val argSize = cursor.uByte()\n                    args.addAll(cursor.uByteArray(argSize.toInt()).map { IntArg(it.toInt()) })\n                }\n\n                else -> error(\"Parameter type ${param.type} not implemented.\")\n            }\n        }\n\n        val minExpectedArgs = opcode.params.size - varargCount\n\n        check(args.size >= minExpectedArgs) {\n            \"Expected to parse at least $minExpectedArgs, only parsed ${args.size}.\"\n        }\n    }\n\n    return args\n}\n\nprivate fun tryParseInstructionsSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    dcGcFormat: Boolean,\n): Boolean {\n    val offset = cursor.position\n\n    fun logReason(reason: String, t: Throwable? = null) {\n        logger.trace(t) {\n            buildString {\n                append(\"Determined that segment \")\n\n                if (labels.isEmpty()) {\n                    append(\"without label\")\n                } else {\n                    if (labels.size == 1) append(\"with label \")\n                    else append(\"with labels \")\n\n                    labels.joinTo(this)\n                }\n\n                append(\" at offset \")\n                append(offset)\n                append(\" is not an instructions segment because \")\n                append(reason)\n                append(\".\")\n            }\n        }\n    }\n\n    try {\n        parseInstructionsSegment(\n            offsetToSegment,\n            labelHolder,\n            cursor,\n            endOffset,\n            labels,\n            nextLabel = null,\n            lenient = false,\n            dcGcFormat,\n        )\n\n        val segment = offsetToSegment[offset]\n        val instructions = (segment as InstructionSegment).instructions\n\n        // Heuristically try to detect whether the segment is actually a data segment.\n        var prevOpcode: Opcode? = null\n        var totalNopCount = 0\n        var sequentialNopCount = 0\n        var unknownOpcodeCount = 0\n        var stackPopCount = 0\n        var stackPopWithoutPrecedingPushCount = 0\n        var labelCount = 0\n        var unknownLabelCount = 0\n\n        for (inst in instructions) {\n            if (inst.opcode.code == OP_NOP.code) {\n                if (++totalNopCount > MAX_TOTAL_NOPS) {\n                    logReason(\"it has more than $MAX_TOTAL_NOPS nop instructions\")\n                    return false\n                }\n\n                if (++sequentialNopCount > MAX_SEQUENTIAL_NOPS) {\n                    logReason(\"it has more than $MAX_SEQUENTIAL_NOPS sequential nop instructions\")\n                    return false\n                }\n            } else {\n                sequentialNopCount = 0\n            }\n\n            if (!inst.opcode.known) {\n                unknownOpcodeCount++\n            }\n\n            if (inst.opcode.stack == StackInteraction.Pop) {\n                stackPopCount++\n\n                if (prevOpcode?.stack != StackInteraction.Push) {\n                    stackPopWithoutPrecedingPushCount++\n                }\n            }\n\n            for ((index, param) in inst.opcode.params.withIndex()) {\n                if (index >= inst.args.size) break\n\n                if (param.type is LabelType) {\n                    for (arg in inst.getArgs(index)) {\n                        labelCount++\n\n                        if (!labelHolder.hasLabel((arg as IntArg).value)) {\n                            unknownLabelCount++\n                        }\n                    }\n                }\n            }\n\n            prevOpcode = inst.opcode\n        }\n\n        val unknownLabelRatio = unknownLabelCount.toDouble() / labelCount\n\n        if (unknownLabelRatio > MAX_UNKNOWN_LABEL_RATIO) {\n            logReason(\n                \"${100 * unknownLabelRatio}% of its label references are to nonexistent labels\"\n            )\n            return false\n        }\n\n        val stackPopWithoutPrecedingPushRatio =\n            stackPopWithoutPrecedingPushCount.toDouble() / stackPopCount\n\n        if (stackPopWithoutPrecedingPushRatio > MAX_STACK_POP_WITHOUT_PRECEDING_PUSH_RATIO) {\n            logReason(\n                \"${100 * stackPopWithoutPrecedingPushRatio}% of its stack pop instructions don't have a preceding push instruction\"\n            )\n            return false\n        }\n\n        val unknownOpcodeRatio = unknownOpcodeCount.toDouble() / instructions.size\n\n        if (unknownOpcodeRatio > MAX_UNKNOWN_OPCODE_RATIO) {\n            logReason(\"${100 * unknownOpcodeRatio}% of its opcodes are unknown\")\n            return false\n        }\n\n        return true\n    } catch (e: Exception) {\n        logReason(\"parsing it resulted in an exception\", e)\n        return false\n    }\n}\n\nfun writeBytecode(bytecodeIr: BytecodeIr, dcGcFormat: Boolean): BytecodeAndLabelOffsets {\n    val buffer = Buffer.withCapacity(100 * bytecodeIr.segments.size, Endianness.Little)\n    val cursor = buffer.cursor()\n    // Keep track of label offsets.\n    val largestLabel = bytecodeIr.segments.asSequence().flatMap { it.labels }.maxOrNull() ?: -1\n    val labelOffsets = IntArray(largestLabel + 1) { -1 }\n\n    for (segment in bytecodeIr.segments) {\n        for (label in segment.labels) {\n            labelOffsets[label] = cursor.position\n        }\n\n        when (segment) {\n            is InstructionSegment -> {\n                for (instruction in segment.instructions) {\n                    val opcode = instruction.opcode\n\n                    if (opcode.size == 2) {\n                        cursor.writeByte((opcode.code ushr 8).toByte())\n                    }\n\n                    cursor.writeByte(opcode.code.toByte())\n\n                    if (opcode.stack != StackInteraction.Pop) {\n                        for (i in opcode.params.indices) {\n                            val param = opcode.params[i]\n                            val args = instruction.getArgs(i)\n                            val arg = args.firstOrNull()\n\n                            if (arg == null) {\n                                logger.warn {\n                                    \"No argument passed to ${opcode.mnemonic} for parameter ${i + 1}.\"\n                                }\n                                continue\n                            }\n\n                            when (param.type) {\n                                ByteType -> cursor.writeByte(arg.coerceInt().toByte())\n                                ShortType -> cursor.writeShort(arg.coerceInt().toShort())\n                                IntType -> cursor.writeInt(arg.coerceInt())\n                                FloatType -> cursor.writeFloat(arg.coerceFloat())\n                                // Ensure this case is before the LabelType case because\n                                // ILabelVarType extends LabelType.\n                                ILabelVarType -> {\n                                    cursor.writeByte(args.size.toByte())\n\n                                    for (a in args) {\n                                        cursor.writeShort(a.coerceInt().toShort())\n                                    }\n                                }\n                                is LabelType -> cursor.writeShort(arg.coerceInt().toShort())\n                                StringType -> {\n                                    val str = arg.coerceString()\n\n                                    if (dcGcFormat) cursor.writeStringAscii(str, str.length + 1)\n                                    else cursor.writeStringUtf16(str, 2 * str.length + 2)\n                                }\n                                is RegType -> {\n                                    cursor.writeByte(arg.coerceInt().toByte())\n                                }\n                                RegVarType -> {\n                                    cursor.writeByte(args.size.toByte())\n\n                                    for (a in args) {\n                                        cursor.writeByte(a.coerceInt().toByte())\n                                    }\n                                }\n                                else -> error(\n                                    \"Parameter type ${param.type::class.simpleName} not supported.\"\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n\n            is StringSegment -> {\n                // String segments should be multiples of 4 bytes.\n                if (dcGcFormat) {\n                    cursor.writeStringAscii(segment.value, segment.size(dcGcFormat))\n                } else {\n                    cursor.writeStringUtf16(segment.value, segment.size(dcGcFormat))\n                }\n            }\n\n            is DataSegment -> {\n                cursor.writeCursor(segment.data.cursor())\n            }\n        }\n    }\n\n    return BytecodeAndLabelOffsets(buffer, labelOffsets)\n}\n\nclass BytecodeAndLabelOffsets(\n    val bytecode: Buffer,\n    val labelOffsets: IntArray,\n) {\n    operator fun component1(): Buffer = bytecode\n    operator fun component2(): IntArray = labelOffsets\n}\n\nprivate data class LabelAndOffset(val label: Int, val offset: Int)\nprivate data class OffsetAndIndex(val offset: Int, val index: Int)\nprivate class LabelInfo(val offset: Int, val next: LabelAndOffset?)\n\nprivate class LabelHolder(labelOffsets: IntArray) {\n    /**\n     * Mapping of labels to their offset and index into [labels].\n     */\n    private val labelMap: MutableMap<Int, OffsetAndIndex> = mutableMapOf()\n\n    /**\n     * Mapping of offsets to lists of labels.\n     */\n    private val offsetMap: MutableMap<Int, MutableList<Int>> = mutableMapOf()\n\n    /**\n     * Labels and their offset sorted by offset and then label.\n     */\n    val labels: List<LabelAndOffset>\n\n    init {\n        val labels = mutableListOf<LabelAndOffset>()\n\n        // Populate the main label list.\n        for (label in labelOffsets.indices) {\n            val offset = labelOffsets[label]\n\n            if (offset != -1) {\n                labels.add(LabelAndOffset(label, offset))\n            }\n        }\n\n        // Sort by offset, then label.\n        labels.sortWith { a, b ->\n            if (a.offset - b.offset != 0) a.offset - b.offset\n            else a.label - b.label\n        }\n\n        this.labels = labels\n\n        // Populate the label and offset maps.\n        for (index in 0 until labels.size) {\n            val (label, offset) = labels[index]\n\n            labelMap[label] = OffsetAndIndex(offset, index)\n\n            offsetMap.getOrPut(offset) { mutableListOf() }.add(label)\n        }\n    }\n\n    fun hasLabel(label: Int): Boolean = label in labelMap\n\n    fun getLabels(offset: Int): List<Int>? = offsetMap[offset]\n\n    fun getInfo(label: Int): LabelInfo? {\n        val offsetAndIndex = labelMap[label] ?: return null\n\n        // Find the next label with a different offset.\n        var next: LabelAndOffset? = null\n\n        for (i in offsetAndIndex.index + 1 until labels.size) {\n            next = labels[i]\n\n            // Skip the label if it points to the same offset.\n            if (next.offset > offsetAndIndex.offset) {\n                break\n            } else {\n                next = null\n            }\n        }\n\n        return LabelInfo(offsetAndIndex.offset, next)\n    }\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.Endianness\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.cursor.WritableCursor\nimport world.phantasmal.psolib.cursor.cursor\nimport kotlin.math.max\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val EVENT_ACTION_SPAWN_NPCS: Byte = 0x8\nprivate const val EVENT_ACTION_UNLOCK: Byte = 0xA\nprivate const val EVENT_ACTION_LOCK: Byte = 0xB\nprivate const val EVENT_ACTION_TRIGGER_EVENT: Byte = 0xC\n\nconst val OBJECT_BYTE_SIZE = 68\nconst val NPC_BYTE_SIZE = 72\n\nclass DatFile(\n    val objs: MutableList<DatEntity>,\n    val npcs: MutableList<DatEntity>,\n    val events: MutableList<DatEvent>,\n    val unknowns: MutableList<DatUnknown>,\n)\n\nclass DatEntity(\n    var areaId: Int,\n    val data: Buffer,\n)\n\nclass DatEvent(\n    var id: Int,\n    var sectionId: Short,\n    var wave: Short,\n    var delay: Short,\n    val actions: MutableList<DatEventAction>,\n    var areaId: Int,\n    var unknown: Short,\n)\n\nsealed class DatEventAction {\n    class SpawnNpcs(\n        var sectionId: Short,\n        var appearFlag: Short,\n    ) : DatEventAction()\n\n    class Unlock(\n        var doorId: Short,\n    ) : DatEventAction()\n\n    class Lock(\n        var doorId: Short,\n    ) : DatEventAction()\n\n    class TriggerEvent(\n        var eventId: Int,\n    ) : DatEventAction()\n}\n\nclass DatUnknown(\n    var entityType: Int,\n    var totalSize: Int,\n    var areaId: Int,\n    var entitiesSize: Int,\n    val data: ByteArray,\n)\n\nfun parseDat(cursor: Cursor): DatFile {\n    val objs = mutableListOf<DatEntity>()\n    val npcs = mutableListOf<DatEntity>()\n    val events = mutableListOf<DatEvent>()\n    val unknowns = mutableListOf<DatUnknown>()\n\n    while (cursor.hasBytesLeft()) {\n        val entityType = cursor.int()\n        val totalSize = cursor.int()\n        val areaId = cursor.int()\n        val entitiesSize = cursor.int()\n\n        if (entityType == 0) {\n            break\n        } else {\n            require(entitiesSize == totalSize - 16) {\n                \"Malformed DAT file. Expected an entities size of ${totalSize - 16}, got ${entitiesSize}.\"\n            }\n\n            val entitiesCursor = cursor.take(entitiesSize)\n\n            when (entityType) {\n                1 -> parseEntities(entitiesCursor, areaId, objs, OBJECT_BYTE_SIZE)\n                2 -> parseEntities(entitiesCursor, areaId, npcs, NPC_BYTE_SIZE)\n                3 -> parseEvents(entitiesCursor, areaId, events)\n                else -> {\n                    // Unknown entity types 4 and 5 (challenge mode).\n                    unknowns.add(\n                        DatUnknown(\n                            entityType,\n                            totalSize,\n                            areaId,\n                            entitiesSize,\n                            data = cursor.byteArray(entitiesSize),\n                        )\n                    )\n                }\n            }\n\n            if (entitiesCursor.hasBytesLeft()) {\n                logger.warn {\n                    \"Read ${entitiesCursor.position} bytes instead of expected ${entitiesCursor.size} for entity type ${entityType}.\"\n                }\n            }\n        }\n    }\n\n    return DatFile(\n        objs,\n        npcs,\n        events,\n        unknowns\n    )\n}\n\nprivate fun parseEntities(\n    cursor: Cursor,\n    areaId: Int,\n    entities: MutableList<DatEntity>,\n    entitySize: Int,\n) {\n    val entityCount = cursor.size / entitySize\n\n    repeat(entityCount) {\n        entities.add(\n            DatEntity(\n                areaId,\n                data = cursor.buffer(entitySize),\n            )\n        )\n    }\n}\n\nprivate fun parseEvents(cursor: Cursor, areaId: Int, events: MutableList<DatEvent>) {\n    val actionsOffset = cursor.int()\n    cursor.seek(4) // Always 0x10\n    val eventCount = cursor.int()\n    cursor.seek(3) // Always 0\n    val eventType = cursor.byte()\n\n    require(eventType.toInt() != 0x32) {\n        \"Can't parse challenge mode quests yet.\"\n    }\n\n    cursor.seekStart(actionsOffset)\n    val actionsCursor = cursor.take(cursor.bytesLeft)\n    cursor.seekStart(16)\n\n    repeat(eventCount) {\n        val id = cursor.int()\n        cursor.seek(4) // Always 0x100\n        val sectionId = cursor.short()\n        val wave = cursor.short()\n        val delay = cursor.short()\n        val unknown = cursor.short() // \"wavesetting\"?\n        val eventActionsOffset = cursor.int()\n\n        val actions: MutableList<DatEventAction> =\n            if (eventActionsOffset < actionsCursor.size) {\n                actionsCursor.seekStart(eventActionsOffset)\n                parseEventActions(actionsCursor)\n            } else {\n                logger.warn { \"Invalid event actions offset $eventActionsOffset for event ${id}.\" }\n                mutableListOf()\n            }\n\n        events.add(\n            DatEvent(\n                id,\n                sectionId,\n                wave,\n                delay,\n                actions,\n                areaId,\n                unknown,\n            )\n        )\n    }\n\n    if (cursor.position != actionsOffset) {\n        logger.warn {\n            \"Read ${cursor.position - 16} bytes of event data instead of expected ${actionsOffset - 16}.\"\n        }\n    }\n\n    var lastByte: Byte = -1\n\n    while (actionsCursor.hasBytesLeft()) {\n        lastByte = actionsCursor.byte()\n\n        if (lastByte.toInt() != -1) {\n            break\n        }\n    }\n\n    if (lastByte.toInt() != -1) {\n        actionsCursor.seek(-1)\n    }\n\n    // Make sure the cursor position represents the amount of bytes we've consumed.\n    cursor.seekStart(actionsOffset + actionsCursor.position)\n}\n\nprivate fun parseEventActions(cursor: Cursor): MutableList<DatEventAction> {\n    val actions = mutableListOf<DatEventAction>()\n\n    outer@ while (cursor.hasBytesLeft()) {\n        when (val type = cursor.byte()) {\n            (1).toByte() -> break@outer\n\n            EVENT_ACTION_SPAWN_NPCS ->\n                actions.add(\n                    DatEventAction.SpawnNpcs(\n                        sectionId = cursor.short(),\n                        appearFlag = cursor.short(),\n                    )\n                )\n\n            EVENT_ACTION_UNLOCK ->\n                actions.add(\n                    DatEventAction.Unlock(\n                        doorId = cursor.short(),\n                    )\n                )\n\n            EVENT_ACTION_LOCK ->\n                actions.add(\n                    DatEventAction.Lock(\n                        doorId = cursor.short(),\n                    )\n                )\n\n            EVENT_ACTION_TRIGGER_EVENT ->\n                actions.add(\n                    DatEventAction.TriggerEvent(\n                        eventId = cursor.int(),\n                    )\n                )\n\n            else -> {\n                logger.warn { \"Unexpected event action type ${type}.\" }\n                break@outer\n            }\n        }\n    }\n\n    return actions\n}\n\nfun writeDat(dat: DatFile): Buffer {\n    val buffer = Buffer.withCapacity(\n        dat.objs.size * (16 + OBJECT_BYTE_SIZE) +\n                dat.npcs.size * (16 + NPC_BYTE_SIZE) +\n                dat.unknowns.sumOf { it.totalSize },\n        endianness = Endianness.Little,\n    )\n    val cursor = buffer.cursor()\n\n    writeEntities(cursor, dat.objs, 1, OBJECT_BYTE_SIZE)\n    writeEntities(cursor, dat.npcs, 2, NPC_BYTE_SIZE)\n    writeEvents(cursor, dat.events)\n\n    for (unknown in dat.unknowns) {\n        cursor.writeInt(unknown.entityType)\n        cursor.writeInt(unknown.totalSize)\n        cursor.writeInt(unknown.areaId)\n        cursor.writeInt(unknown.entitiesSize)\n        cursor.writeByteArray(unknown.data)\n    }\n\n    // Final header.\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n\n    return buffer\n}\n\nprivate fun writeEntities(\n    cursor: WritableCursor,\n    entities: List<DatEntity>,\n    entityType: Int,\n    entitySize: Int,\n) {\n    val groupedEntities = entities.groupBy { it.areaId }\n\n    for ((areaId, areaEntities) in groupedEntities.entries) {\n        val entitiesSize = areaEntities.size * entitySize\n        cursor.writeInt(entityType)\n        cursor.writeInt(16 + entitiesSize)\n        cursor.writeInt(areaId)\n        cursor.writeInt(entitiesSize)\n        val startPos = cursor.position\n\n        for (entity in areaEntities) {\n            require(entity.data.size == entitySize) {\n                \"Malformed entity in area $areaId, data buffer was of size ${\n                    entity.data.size\n                } instead of expected $entitySize.\"\n            }\n\n            cursor.writeCursor(entity.data.cursor())\n        }\n\n        check(cursor.position == startPos + entitiesSize) {\n            \"Wrote ${\n                cursor.position - startPos\n            } bytes of entity data instead of expected $entitiesSize bytes for area $areaId.\"\n        }\n    }\n}\n\nprivate fun writeEvents(cursor: WritableCursor, events: List<DatEvent>) {\n    val groupedEvents = events.groupBy { it.areaId }\n\n    for ((areaId, areaEvents) in groupedEvents.entries) {\n        // Standard header.\n        cursor.writeInt(3) // Entity type\n        val totalSizeOffset = cursor.position\n        cursor.writeInt(0) // Placeholder for the total size.\n        cursor.writeInt(areaId)\n        val entitiesSizeOffset = cursor.position\n        cursor.writeInt(0) // Placeholder for the entities size.\n\n        // Event header.\n        val startPos = cursor.position\n        // TODO: actual event size is dependent on the event type (challenge mode).\n        // Absolute offset.\n        val actionsOffset = startPos + 16 + 20 * areaEvents.size\n        cursor.size = max(actionsOffset, cursor.size)\n\n        cursor.writeInt(actionsOffset - startPos)\n        cursor.writeInt(0x10)\n        cursor.writeInt(areaEvents.size)\n        cursor.writeInt(0) // TODO: write event type (challenge mode).\n\n        // Relative offset.\n        var eventActionsOffset = 0\n\n        for (event in areaEvents) {\n            cursor.writeInt(event.id)\n            cursor.writeInt(0x10000)\n            cursor.writeShort(event.sectionId)\n            cursor.writeShort(event.wave)\n            cursor.writeShort(event.delay)\n            cursor.writeShort(event.unknown)\n            cursor.writeInt(eventActionsOffset)\n            val nextEventPos = cursor.position\n\n            cursor.seekStart(actionsOffset + eventActionsOffset)\n\n            for (action in event.actions) {\n                when (action) {\n                    is DatEventAction.SpawnNpcs -> {\n                        cursor.writeByte(EVENT_ACTION_SPAWN_NPCS)\n                        cursor.writeShort(action.sectionId)\n                        cursor.writeShort(action.appearFlag)\n                    }\n                    is DatEventAction.Unlock -> {\n                        cursor.writeByte(EVENT_ACTION_UNLOCK)\n                        cursor.writeShort(action.doorId)\n                    }\n                    is DatEventAction.Lock -> {\n                        cursor.writeByte(EVENT_ACTION_LOCK)\n                        cursor.writeShort(action.doorId)\n                    }\n                    is DatEventAction.TriggerEvent -> {\n                        cursor.writeByte(EVENT_ACTION_TRIGGER_EVENT)\n                        cursor.writeInt(action.eventId)\n                    }\n                }\n            }\n\n            // End of event actions.\n            cursor.writeByte(1)\n\n            eventActionsOffset = cursor.position - actionsOffset\n\n            cursor.seekStart(nextEventPos)\n        }\n\n        cursor.seekStart(actionsOffset + eventActionsOffset)\n\n        while ((cursor.position - actionsOffset) % 4 != 0) {\n            cursor.writeByte(-1)\n        }\n\n        val endPos = cursor.position\n\n        cursor.seekStart(totalSizeOffset)\n        cursor.writeInt(16 + endPos - startPos)\n\n        cursor.seekStart(entitiesSizeOffset)\n        cursor.writeInt(endPos - startPos)\n\n        cursor.seekStart(endPos)\n    }\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport world.phantasmal.psolib.Episode\n\nprivate val EP_AND_NAME_TO_NPC_TYPE: Map<Pair<String, Episode>, NpcType> =\n    mutableMapOf<Pair<String, Episode>, NpcType>().also { map ->\n        for (npcType in NpcType.VALUES) {\n            if (npcType.episode != null) {\n                map[Pair(npcType.simpleName, npcType.episode)] = npcType\n                map[Pair(npcType.ultimateName, npcType.episode)] = npcType\n            }\n        }\n    }\n\n/**\n * Uniquely identifies an NPC. Tries to match on [NpcType.simpleName] and [NpcType.ultimateName].\n */\nfun NpcType.Companion.fromNameAndEpisode(name: String, episode: Episode): NpcType? =\n    EP_AND_NAME_TO_NPC_TYPE[Pair(name, episode)]\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.core.filenameBase\nimport world.phantasmal.psolib.Endianness\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.cursor.WritableCursor\nimport world.phantasmal.psolib.cursor.cursor\nimport kotlin.math.ceil\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n// .qst format\nprivate const val DC_GC_PC_HEADER_SIZE = 60\nprivate const val BB_HEADER_SIZE = 88\nprivate const val ONLINE_QUEST = 0x44\nprivate const val DOWNLOAD_QUEST = 0xa6\n\n// Chunks\nprivate const val CHUNK_BODY_SIZE = 1024\nprivate const val DC_GC_PC_CHUNK_HEADER_SIZE = 20\nprivate const val DC_GC_PC_CHUNK_TRAILER_SIZE = 4\nprivate const val DC_GC_PC_CHUNK_SIZE =\n    CHUNK_BODY_SIZE + DC_GC_PC_CHUNK_HEADER_SIZE + DC_GC_PC_CHUNK_TRAILER_SIZE\nprivate const val BB_CHUNK_HEADER_SIZE = 24\nprivate const val BB_CHUNK_TRAILER_SIZE = 8\nprivate const val BB_CHUNK_SIZE = CHUNK_BODY_SIZE + BB_CHUNK_HEADER_SIZE + BB_CHUNK_TRAILER_SIZE\n\nclass QstContent(\n    val version: Version,\n    val online: Boolean,\n    val files: List<QstContainedFile>,\n)\n\nclass QstContainedFile(\n    val id: Int?,\n    val filename: String,\n    val questName: String?,\n    val data: Buffer,\n)\n\n/**\n * Low level parsing function for .qst files.\n */\nfun parseQst(cursor: Cursor): PwResult<QstContent> {\n    val result = PwResult.build<QstContent>(logger)\n\n    // A .qst file contains two headers that describe the embedded .dat and .bin files.\n    // Read headers and contained files.\n    val headers = parseHeaders(cursor)\n\n    if (headers.size < 2) {\n        return result\n            .addProblem(\n                Severity.Error,\n                \"This .qst file is corrupt.\",\n                \"Corrupt .qst file, expected at least 2 headers but only found ${headers.size}.\",\n            )\n            .failure()\n    }\n\n    var version: Version? = null\n    var online: Boolean? = null\n\n    for (header in headers) {\n        if (version != null && header.version != version) {\n            return result\n                .addProblem(\n                    Severity.Error,\n                    \"This .qst file is corrupt.\",\n                    \"Corrupt .qst file, header version ${header.version} for file ${\n                        header.filename\n                    } doesn't match the previous header's version ${version}.\",\n                )\n                .failure()\n        }\n\n        if (online != null && header.online != online) {\n            return result\n                .addProblem(\n                    Severity.Error,\n                    \"This .qst file is corrupt.\",\n                    \"Corrupt .qst file, header type ${\n                        if (header.online) \"\\\"online\\\"\" else \"\\\"download\\\"\"\n                    } for file ${header.filename} doesn't match the previous header's type ${\n                        if (online) \"\\\"online\\\"\" else \"\\\"download\\\"\"\n                    }.\",\n                )\n                .failure()\n        }\n\n        version = header.version\n        online = header.online\n    }\n\n    checkNotNull(version)\n    checkNotNull(online)\n\n    val parseFilesResult: PwResult<List<QstContainedFile>> = parseFiles(\n        cursor,\n        version,\n        headers.associateBy { it.filename },\n    )\n    result.addResult(parseFilesResult)\n\n    if (parseFilesResult !is Success) {\n        return result.failure()\n    }\n\n    return result.success(\n        QstContent(\n            version,\n            online,\n            parseFilesResult.value,\n        )\n    )\n}\n\nprivate class QstHeader(\n    val version: Version,\n    val online: Boolean,\n    val questId: Int,\n    val name: String,\n    val filename: String,\n    val size: Int,\n)\n\nprivate fun parseHeaders(cursor: Cursor): List<QstHeader> {\n    val headers = mutableListOf<QstHeader>()\n\n    var prevQuestId: Int? = null\n    var prevFilename: String? = null\n\n    // .qst files should have two headers. Some malformed files have more, so we tried to detect at\n    // most 4 headers.\n    repeat(4) {\n        // Detect version and whether it's an online or download quest.\n        val version: Version\n        val online: Boolean\n\n        val versionA = cursor.uByte().toInt()\n        cursor.seek(1)\n        val versionB = cursor.uByte().toInt()\n        cursor.seek(-3)\n\n        if (versionA == BB_HEADER_SIZE && versionB == ONLINE_QUEST) {\n            version = Version.BB\n            online = true\n        } else if (versionA == DC_GC_PC_HEADER_SIZE && versionB == ONLINE_QUEST) {\n            version = Version.PC\n            online = true\n        } else if (versionB == DC_GC_PC_HEADER_SIZE) {\n            val pos = cursor.position\n            cursor.seek(35)\n\n            version = if (cursor.byte().toInt() == 0) {\n                Version.GC\n            } else {\n                Version.DC\n            }\n\n            cursor.seekStart(pos)\n\n            online = when (versionA) {\n                ONLINE_QUEST -> true\n                DOWNLOAD_QUEST -> false\n                else -> return@repeat\n            }\n        } else {\n            return@repeat\n        }\n\n        // Read header.\n        val headerSize: Int\n        val questId: Int\n        val name: String\n        val filename: String\n        val size: Int\n\n        when (version) {\n            Version.DC -> {\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                headerSize = cursor.uShort().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(3)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                cursor.seek(1)\n                size = cursor.int()\n            }\n\n            Version.GC -> {\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                headerSize = cursor.uShort().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(4)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n            }\n\n            Version.PC -> {\n                headerSize = cursor.uShort().toInt()\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(4)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n            }\n\n            Version.BB -> {\n                headerSize = cursor.uShort().toInt()\n                cursor.seek(2) // Skip online/download.\n                questId = cursor.uShort().toInt()\n                cursor.seek(38)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n                name = cursor.stringAscii(24, nullTerminated = true, dropRemaining = true)\n            }\n        }\n\n        // Use some simple heuristics to figure out whether the file contains more than two headers.\n        // Some malformed .qst files have extra headers.\n        if (\n            prevQuestId != null &&\n            prevFilename != null &&\n            (questId != prevQuestId || filenameBase(filename) != filenameBase(prevFilename!!))\n        ) {\n            cursor.seek(-headerSize)\n            return@repeat\n        }\n\n        prevQuestId = questId\n        prevFilename = filename\n\n        headers.add(\n            QstHeader(\n                version,\n                online,\n                questId,\n                name,\n                filename,\n                size,\n            )\n        )\n    }\n\n    return headers\n}\n\nprivate class QstFileData(\n    val name: String,\n    val expectedSize: Int?,\n    val cursor: WritableCursor,\n    var chunkNos: MutableSet<Int>,\n)\n\nprivate fun parseFiles(\n    cursor: Cursor,\n    version: Version,\n    headers: Map<String, QstHeader>,\n): PwResult<List<QstContainedFile>> {\n    val result = PwResult.build<List<QstContainedFile>>(logger)\n\n    // Files are interleaved in 1048 or 1056 byte chunks, depending on the version.\n    // Each chunk has a 20 or 24 byte header, 1024 byte data segment and a 4 or 8 byte trailer.\n    val files = mutableMapOf<String, QstFileData>()\n\n    val chunkSize: Int // Size including padding, header and trailer.\n    val trailerSize: Int\n\n    when (version) {\n        Version.DC,\n        Version.GC,\n        Version.PC,\n        -> {\n            chunkSize = DC_GC_PC_CHUNK_SIZE\n            trailerSize = DC_GC_PC_CHUNK_TRAILER_SIZE\n        }\n\n        Version.BB -> {\n            chunkSize = BB_CHUNK_SIZE\n            trailerSize = BB_CHUNK_TRAILER_SIZE\n        }\n    }\n\n    while (cursor.bytesLeft >= chunkSize) {\n        val startPosition = cursor.position\n\n        // Read chunk header.\n        var chunkNo: Int\n\n        when (version) {\n            Version.DC,\n            Version.GC,\n            -> {\n                cursor.seek(1)\n                chunkNo = cursor.uByte().toInt()\n                cursor.seek(2)\n            }\n\n            Version.PC -> {\n                cursor.seek(3)\n                chunkNo = cursor.uByte().toInt()\n            }\n\n            Version.BB -> {\n                cursor.seek(4)\n                chunkNo = cursor.int()\n            }\n        }\n\n        val fileName = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n\n        val file = files.getOrPut(fileName) {\n            val header = headers[fileName]\n            QstFileData(\n                fileName,\n                header?.size,\n                Buffer.withCapacity(\n                    header?.size ?: (10 * CHUNK_BODY_SIZE),\n                    Endianness.Little\n                ).cursor(),\n                mutableSetOf()\n            )\n        }\n\n        if (chunkNo in file.chunkNos) {\n            result.addProblem(\n                Severity.Warning,\n                \"File chunk Int $chunkNo of file $fileName was already encountered, overwriting previous chunk.\",\n            )\n        } else {\n            file.chunkNos.add(chunkNo)\n        }\n\n        // Read file data.\n        var size = cursor.seek(CHUNK_BODY_SIZE).int()\n        cursor.seek(-CHUNK_BODY_SIZE - 4)\n\n        if (size > CHUNK_BODY_SIZE) {\n            result.addProblem(\n                Severity.Warning,\n                \"Data segment size of $size is larger than expected maximum size, reading just $CHUNK_BODY_SIZE bytes.\",\n            )\n            size = CHUNK_BODY_SIZE\n        }\n\n        val data = cursor.take(size)\n        val chunkPosition = chunkNo * CHUNK_BODY_SIZE\n        file.cursor.size = max(chunkPosition + size, file.cursor.size)\n        file.cursor.seekStart(chunkPosition).writeCursor(data)\n\n        // Skip the padding and the trailer.\n        cursor.seek(CHUNK_BODY_SIZE - data.size + trailerSize)\n\n        check(cursor.position == startPosition + chunkSize) {\n            \"Read ${\n                cursor.position - startPosition\n            } file chunk message bytes instead of expected ${chunkSize}.\"\n        }\n    }\n\n    if (cursor.hasBytesLeft()) {\n        result.addProblem(Severity.Warning, \"${cursor.bytesLeft} Bytes left in file.\")\n    }\n\n    for (file in files.values) {\n        // Clean up file properties.\n        file.cursor.seekStart(0)\n        file.chunkNos = file.chunkNos.sorted().toMutableSet()\n\n        // Check whether the expected size was correct.\n        if (file.expectedSize != null && file.cursor.size != file.expectedSize) {\n            result.addProblem(\n                Severity.Warning,\n                \"File ${file.name} has an actual size of ${\n                    file.cursor.size\n                } instead of the expected size ${file.expectedSize}.\",\n            )\n        }\n\n        // Detect missing file chunks.\n        val actualSize = max(file.cursor.size, file.expectedSize ?: 0)\n        val expectedChunkCount = ceil(actualSize.toDouble() / CHUNK_BODY_SIZE).toInt()\n\n        for (chunkNo in 0 until expectedChunkCount) {\n            if (chunkNo !in file.chunkNos) {\n                result.addProblem(\n                    Severity.Warning,\n                    \"File ${file.name} is missing chunk ${chunkNo}.\",\n                )\n            }\n        }\n    }\n\n    return result.success(\n        files.values.map { file ->\n            val header = headers[file.name]\n            QstContainedFile(\n                header?.questId,\n                file.name,\n                header?.name,\n                file.cursor.seekStart(0).buffer(),\n            )\n        }\n    )\n}\n\nfun writeQst(qst: QstContent): Buffer {\n    val fileHeaderSize: Int\n    val chunkSize: Int\n\n    when (qst.version) {\n        Version.DC, Version.GC, Version.PC -> {\n            fileHeaderSize = DC_GC_PC_HEADER_SIZE\n            chunkSize = DC_GC_PC_CHUNK_SIZE\n        }\n        Version.BB -> {\n            fileHeaderSize = BB_HEADER_SIZE\n            chunkSize = BB_CHUNK_SIZE\n        }\n    }\n\n    val totalSize = qst.files.sumOf {\n        fileHeaderSize + ceil(it.data.size.toDouble() / CHUNK_BODY_SIZE).toInt() * chunkSize\n    }\n\n    val buffer = Buffer.withCapacity(totalSize)\n    val cursor = buffer.cursor()\n\n    writeFileHeaders(cursor, qst.files, qst.version, qst.online, fileHeaderSize)\n    writeFileChunks(cursor, qst.files, qst.version)\n\n    check(cursor.position == totalSize) {\n        \"Expected a final file size of $totalSize, but got ${cursor.position}.\"\n    }\n\n    return buffer\n}\n\nprivate fun writeFileHeaders(\n    cursor: WritableCursor,\n    files: List<QstContainedFile>,\n    version: Version,\n    online: Boolean,\n    headerSize: Int,\n) {\n    val maxId: Int\n    val maxQuestNameLength: Int\n\n    if (version == Version.BB) {\n        maxId = 0xffff\n        maxQuestNameLength = 23\n    } else {\n        maxId = 0xff\n        maxQuestNameLength = 31\n    }\n\n    for (file in files) {\n        require(file.id == null || (file.id in 0..maxId)) {\n            \"Quest ID should be between 0 and $maxId, inclusive.\"\n        }\n        require(file.questName == null || file.questName.length <= maxQuestNameLength) {\n            \"File ${file.filename} has a quest name longer than $maxQuestNameLength characters (${file.questName}).\"\n        }\n        require(file.filename.length <= 15) {\n            \"File ${file.filename} has a filename longer than 15 characters.\"\n        }\n\n        when (version) {\n            Version.DC -> {\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeByte(0)\n                cursor.writeByte(0)\n                cursor.writeByte(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeByte(0)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.GC -> {\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeInt(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.PC -> {\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeInt(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.BB -> {\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeUShort((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUShort())\n                cursor.writeUShort(file.id?.toUShort() ?: 0u)\n                repeat(38) { cursor.writeByte(0) }\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n                cursor.writeStringAscii(file.questName ?: file.filename, 24)\n            }\n        }\n    }\n}\n\nprivate class FileToChunk(\n    var no: Int,\n    val data: Cursor,\n    val name: String,\n)\n\nprivate fun writeFileChunks(\n    cursor: WritableCursor,\n    files: List<QstContainedFile>,\n    version: Version,\n) {\n    // Files are interleaved in chunks. Each chunk has a header, fixed-size data segment and a\n    // trailer.\n    val filesToChunk = files.map { file ->\n        FileToChunk(\n            no = 0,\n            data = file.data.cursor(),\n            name = file.filename,\n        )\n    }\n    var done = 0\n\n    while (done < filesToChunk.size) {\n        for (fileToChunk in filesToChunk) {\n            if (fileToChunk.data.hasBytesLeft()) {\n                if (\n                    !writeFileChunk(\n                        cursor,\n                        fileToChunk.data,\n                        fileToChunk.no++,\n                        fileToChunk.name,\n                        version,\n                    )\n                ) {\n                    done++\n                }\n            }\n        }\n    }\n\n    for (fileToChunk in filesToChunk) {\n        val expectedChunks = ceil(fileToChunk.data.size.toDouble() / CHUNK_BODY_SIZE).toInt()\n\n        check(fileToChunk.no == expectedChunks) {\n            \"\"\"Expected to write $expectedChunks chunks for file \"${\n                fileToChunk.name\n            }\" but ${fileToChunk.no} where written.\"\"\"\n        }\n    }\n}\n\n/**\n * Returns true if there are bytes left to write in [data], false otherwise.\n */\nprivate fun writeFileChunk(\n    cursor: WritableCursor,\n    data: Cursor,\n    chunkNo: Int,\n    name: String,\n    version: Version,\n): Boolean {\n    when (version) {\n        Version.DC,\n        Version.GC,\n        -> {\n            cursor.writeByte(0)\n            cursor.writeUByte(chunkNo.toUByte())\n            cursor.writeShort(0)\n        }\n\n        Version.PC -> {\n            cursor.writeByte(0)\n            cursor.writeByte(0)\n            cursor.writeByte(0)\n            cursor.writeUByte(chunkNo.toUByte())\n        }\n\n        Version.BB -> {\n            cursor.writeByte(28)\n            cursor.writeByte(4)\n            cursor.writeByte(19)\n            cursor.writeByte(0)\n            cursor.writeInt(chunkNo)\n        }\n    }\n\n    cursor.writeStringAscii(name, 16)\n\n    val size = min(CHUNK_BODY_SIZE, data.bytesLeft)\n    cursor.writeCursor(data.take(size))\n\n    // Padding.\n    repeat(CHUNK_BODY_SIZE - size) {\n        cursor.writeByte(0)\n    }\n\n    cursor.writeInt(size)\n\n    if (version == Version.BB) {\n        cursor.writeInt(0)\n    }\n\n    return data.hasBytesLeft()\n}\n","package world.phantasmal.psolib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.*\nimport world.phantasmal.psolib.Episode\nimport world.phantasmal.psolib.asm.BytecodeIr\nimport world.phantasmal.psolib.asm.InstructionSegment\nimport world.phantasmal.psolib.asm.OP_SET_EPISODE\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.psolib.asm.dataFlowAnalysis.getMapDesignations\nimport world.phantasmal.psolib.buffer.Buffer\nimport world.phantasmal.psolib.compression.prs.prsCompress\nimport world.phantasmal.psolib.compression.prs.prsDecompress\nimport world.phantasmal.psolib.cursor.Cursor\nimport world.phantasmal.psolib.cursor.cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nclass Quest(\n    var id: Int,\n    var language: Int,\n    var name: String,\n    var shortDescription: String,\n    var longDescription: String,\n    var episode: Episode,\n    val objects: MutableList<QuestObject>,\n    val npcs: MutableList<QuestNpc>,\n    val events: MutableList<DatEvent>,\n    /**\n     * (Partial) raw DAT data that can't be parsed yet by Phantasmal.\n     */\n    val datUnknowns: MutableList<DatUnknown>,\n    var bytecodeIr: BytecodeIr,\n    val shopItems: UIntArray,\n    val mapDesignations: MutableMap<Int, Int>,\n)\n\n/**\n * High level quest parsing function that delegates to [parseBin] and [parseDat].\n */\nfun parseBinDatToQuest(\n    binCursor: Cursor,\n    datCursor: Cursor,\n    lenient: Boolean = false,\n): PwResult<Quest> {\n    val result = PwResult.build<Quest>(logger)\n\n    // Decompress and parse files.\n    val binDecompressed = prsDecompress(binCursor)\n    result.addResult(binDecompressed)\n\n    if (binDecompressed !is Success) {\n        return result.failure()\n    }\n\n    val bin = parseBin(binDecompressed.value)\n\n    val datDecompressed = prsDecompress(datCursor)\n    result.addResult(datDecompressed)\n\n    if (datDecompressed !is Success) {\n        return result.failure()\n    }\n\n    val dat = parseDat(datDecompressed.value)\n    val objects = dat.objs.mapTo(mutableListOf()) { QuestObject(it.areaId, it.data) }\n    // Initialize NPCs with random episode and correct it later.\n    val npcs = dat.npcs.mapTo(mutableListOf()) { QuestNpc(Episode.I, it.areaId, it.data) }\n\n    // Extract episode and map designations from byte code.\n    var episode = Episode.I\n    var mapDesignations = mutableMapOf<Int, Int>()\n\n    val parseBytecodeResult = parseBytecode(\n        bin.bytecode,\n        bin.labelOffsets,\n        extractScriptEntryPoints(objects, npcs),\n        bin.format == BinFormat.DC_GC,\n        lenient,\n    )\n\n    result.addResult(parseBytecodeResult)\n\n    if (parseBytecodeResult !is Success) {\n        return result.failure()\n    }\n\n    val bytecodeIr = parseBytecodeResult.value\n\n    if (bytecodeIr.segments.isEmpty()) {\n        result.addProblem(Severity.Warning, \"File contains no instruction labels.\")\n    } else {\n        val instructionSegments = bytecodeIr.instructionSegments()\n\n        var label0Segment: InstructionSegment? = null\n\n        for (segment in instructionSegments) {\n            if (0 in segment.labels) {\n                label0Segment = segment\n                break\n            }\n        }\n\n        if (label0Segment != null) {\n            episode = getEpisode(result, label0Segment)\n\n            for (npc in npcs) {\n                npc.episode = episode\n            }\n\n            mapDesignations =\n                getMapDesignations(label0Segment) { ControlFlowGraph.create(bytecodeIr) }\n        } else {\n            result.addProblem(Severity.Warning, \"No instruction segment for label 0 found.\")\n        }\n    }\n\n    return result.success(Quest(\n        id = bin.questId,\n        language = bin.language,\n        name = bin.questName,\n        shortDescription = bin.shortDescription,\n        longDescription = bin.longDescription,\n        episode,\n        objects,\n        npcs,\n        events = dat.events,\n        datUnknowns = dat.unknowns,\n        bytecodeIr,\n        shopItems = bin.shopItems,\n        mapDesignations,\n    ))\n}\n\nclass QuestData(\n    val quest: Quest,\n    val version: Version,\n    val online: Boolean,\n)\n\n/**\n * High level .qst parsing function that delegates to [parseQst], [parseBin] and [parseDat].\n */\nfun parseQstToQuest(cursor: Cursor, lenient: Boolean = false): PwResult<QuestData> {\n    val result = PwResult.build<QuestData>(logger)\n\n    // Extract contained .dat and .bin files.\n    val qstResult = parseQst(cursor)\n    result.addResult(qstResult)\n\n    if (qstResult !is Success) {\n        return result.failure()\n    }\n\n    val version = qstResult.value.version\n    val online = qstResult.value.online\n    val files = qstResult.value.files\n    var datFile: QstContainedFile? = null\n    var binFile: QstContainedFile? = null\n\n    for (file in files) {\n        val fileName = file.filename.trim().lowercase()\n\n        if (fileName.endsWith(\".dat\")) {\n            datFile = file\n        } else if (fileName.endsWith(\".bin\")) {\n            binFile = file\n        }\n    }\n\n    if (datFile == null) {\n        return result.addProblem(Severity.Error, \"File contains no DAT file.\").failure()\n    }\n\n    if (binFile == null) {\n        return result.addProblem(Severity.Error, \"File contains no BIN file.\").failure()\n    }\n\n    val questResult = parseBinDatToQuest(\n        binFile.data.cursor(),\n        datFile.data.cursor(),\n        lenient,\n    )\n    result.addResult(questResult)\n\n    if (questResult !is Success) {\n        return result.failure()\n    }\n\n    return result.success(QuestData(\n        questResult.value,\n        version,\n        online,\n    ))\n}\n\n/**\n * Defaults to episode I.\n */\nprivate fun getEpisode(rb: PwResultBuilder<*>, func0Segment: InstructionSegment): Episode {\n    val setEpisode = func0Segment.instructions.find {\n        it.opcode == OP_SET_EPISODE\n    }\n\n    if (setEpisode == null) {\n        logger.debug { \"Function 0 has no set_episode instruction.\" }\n        return Episode.I\n    }\n\n    return when (val episode = setEpisode.args[0].value) {\n        0 -> Episode.I\n        1 -> Episode.II\n        2 -> Episode.IV\n        else -> {\n            rb.addProblem(\n                Severity.Warning,\n                \"Unknown episode $episode in function 0 set_episode instruction.\"\n            )\n            Episode.I\n        }\n    }\n}\n\nprivate fun extractScriptEntryPoints(\n    objects: List<QuestObject>,\n    npcs: List<QuestNpc>,\n): Set<Int> {\n    val entryPoints = mutableSetOf(0)\n\n    objects.forEach { obj ->\n        obj.scriptLabel?.let(entryPoints::add)\n        obj.scriptLabel2?.let(entryPoints::add)\n    }\n\n    npcs.forEach { npc ->\n        entryPoints.add(npc.scriptLabel)\n    }\n\n    return entryPoints\n}\n\n/**\n * Returns a .bin and .dat file in that order.\n */\nfun writeQuestToBinDat(quest: Quest, version: Version): Pair<Buffer, Buffer> {\n    val dat = writeDat(DatFile(\n        objs = quest.objects.mapTo(mutableListOf()) { DatEntity(it.areaId, it.data) },\n        npcs = quest.npcs.mapTo(mutableListOf()) { DatEntity(it.areaId, it.data) },\n        events = quest.events,\n        unknowns = quest.datUnknowns,\n    ))\n\n    val binFormat = when (version) {\n        Version.DC, Version.GC -> BinFormat.DC_GC\n        Version.PC -> BinFormat.PC\n        Version.BB -> BinFormat.BB\n    }\n\n    val (bytecode, labelOffsets) = writeBytecode(quest.bytecodeIr, binFormat == BinFormat.DC_GC)\n\n    val bin = writeBin(BinFile(\n        binFormat,\n        quest.id,\n        quest.language,\n        quest.name,\n        quest.shortDescription,\n        quest.longDescription,\n        bytecode,\n        labelOffsets,\n        quest.shopItems,\n    ))\n\n    return Pair(bin, dat)\n}\n\n/**\n * Creates a .qst file from [quest].\n */\nfun writeQuestToQst(quest: Quest, filename: String, version: Version, online: Boolean): Buffer {\n    val (bin, dat) = writeQuestToBinDat(quest, version)\n\n    val baseFilename = (filenameBase(filename) ?: filename).take(11)\n    val questName = quest.name.take(if (version == Version.BB) 23 else 31)\n\n    return writeQst(QstContent(\n        version,\n        online,\n        files = listOf(\n            QstContainedFile(\n                id = quest.id,\n                filename = \"$baseFilename.dat\",\n                questName = questName,\n                data = prsCompress(dat.cursor()).buffer(),\n            ),\n            QstContainedFile(\n                id = quest.id,\n                filename = \"$baseFilename.bin\",\n                questName = questName,\n                data = prsCompress(bin.cursor()).buffer(),\n            ),\n        ),\n    ))\n}\n","package world.phantasmal.psolib.vm\n\nimport mu.KotlinLogging\nimport world.phantasmal.psolib.Endianness\nimport world.phantasmal.psolib.Episode\nimport world.phantasmal.psolib.asm.*\nimport world.phantasmal.psolib.buffer.Buffer\n\nprivate val logger = KotlinLogging.logger {}\n\nenum class ExecutionResult {\n    /**\n     * There are no live threads, nothing to do.\n     */\n    Suspended,\n\n    /**\n     * Execution is paused because of the [ExecutionInterceptor].\n     */\n    Paused,\n\n    /**\n     * All threads have yielded.\n     */\n    WaitingVsync,\n\n    /**\n     * Execution has halted because the VM encountered an `exit` instruction, a fatal error was\n     * raised or the VM was halted from outside.\n     */\n    Halted,\n}\n\ninterface ExecutionInterceptor {\n    /**\n     * Called before the VM executes an instruction. If false is returned, the VM won't execute the\n     * instruction and pause.\n     */\n    fun intercept(instruction: InstructionReference): Boolean\n}\n\n/**\n * This class emulates the PSO script engine. It's in charge of memory, threading and executing\n * instructions.\n */\nclass VirtualMachine {\n    // Quest Details\n\n    private var episode: Episode = Episode.I\n\n    var bytecode: BytecodeIr = BytecodeIr(emptyList())\n        private set\n\n    private val labelToSegIdx: MutableMap<Int, Int> = mutableMapOf()\n\n    // VM State\n\n    private val registers = Buffer.withSize(REGISTER_COUNT * REGISTER_SIZE, Endianness.Little)\n    private var stringArgStore = \"\"\n\n    /**\n     * All live threads.\n     */\n    private val threads: MutableList<Thread> = mutableListOf()\n\n    /**\n     * Current thread index into [threads].\n     */\n    private var threadIdx = 0\n\n    var halted = true\n        private set\n\n    var executionInterceptor: ExecutionInterceptor? = null\n\n    /**\n     * Halts and resets the VM, then loads new bytecode.\n     */\n    fun loadBytecode(bytecode: BytecodeIr, episode: Episode) {\n        halt()\n\n        logger.debug { \"Starting.\" }\n\n        this.bytecode = bytecode\n        this.episode = episode\n\n        labelToSegIdx.clear()\n\n        for ((segIdx, segment) in bytecode.segments.withIndex()) {\n            for (label in segment.labels) {\n                labelToSegIdx[label] = segIdx\n            }\n        }\n\n        halted = false\n    }\n\n    /**\n     * Executes instructions while possible.\n     */\n    fun execute(): ExecutionResult {\n        require(!halted) { \"Halted.\" }\n        require(threads.isNotEmpty()) { \"Suspended.\" }\n        require(threadIdx < threads.size) { \"Awaiting vsync.\" }\n\n        try {\n            // Limit amount of instructions executed to prevent infinite loops.\n            var executionCounter = 0\n\n            while (executionCounter++ < 10_000) {\n                // Execute the instruction pointed to by the current thread.\n                val thread = currentThread()!!\n                val instRef = thread.instructionPointer!!\n\n                if (executionInterceptor?.intercept(instRef) == false) {\n                    return ExecutionResult.Paused\n                } else {\n                    val result = executeInstruction()\n\n                    if (result != null && result != ExecutionResult.WaitingVsync) {\n                        return result\n                    }\n                }\n\n                if (threads.isEmpty()) {\n                    return ExecutionResult.Suspended\n                }\n\n                if (threadIdx > threads.lastIndex) {\n                    return ExecutionResult.WaitingVsync\n                }\n            }\n\n            // TODO: Output error \"Maximum execution count reached. The code probably contains an infinite loop.\".\n            halt()\n            return ExecutionResult.Halted\n        } catch (e: Throwable) {\n            // TODO: Output error.\n            halt()\n            return ExecutionResult.Halted\n        }\n    }\n\n    /**\n     * Signal to the VM that a vsync has happened.\n     */\n    fun vsync() {\n        if (threadIdx > threads.lastIndex) {\n            threadIdx = 0\n        }\n    }\n\n    /**\n     * Halts execution of all threads.\n     */\n    fun halt() {\n        if (!halted) {\n            logger.debug { \"Halting.\" }\n\n            registers.zero()\n            stringArgStore = \"\"\n            threads.clear()\n            threadIdx = 0\n            // TODO:\n//            window_msg_open = false\n//            set_episode_called = false\n//            list_open = false\n//            selection_reg = 0\n            halted = true\n//            paused = false\n//            breakpoints.splice(0, Infinity)\n//            unsupported_opcodes_logged.clear()\n            Thread.resetIdCounter()\n        }\n    }\n\n    private fun executeInstruction(): ExecutionResult? {\n        val thread = threads[threadIdx]\n        val inst = thread.instructionPointer!!.instruction\n        val args = inst.args.map { it.value }\n\n        var advance = true\n        var result: ExecutionResult? = null\n\n        when (inst.opcode.code) {\n            OP_NOP.code -> {\n            }\n            OP_RET.code -> {\n                popFrame(threadIdx)\n            }\n            OP_SYNC.code -> {\n                advanceInstructionPointer(threadIdx)\n                threadIdx++\n                advance = false\n                result = ExecutionResult.WaitingVsync\n            }\n            OP_EXIT.code -> {\n                halt()\n            }\n            OP_THREAD.code -> {\n                TODO()\n            }\n            OP_CALL.code -> {\n                pushFrame(thread, args[0] as Int)\n                advance = false\n            }\n            OP_JMP.code -> {\n                jumpToLabel(thread, args[0] as Int)\n                advance = false\n            }\n        }\n\n        if (advance) {\n            advanceInstructionPointer(threadIdx)\n        }\n\n        return result\n    }\n\n    /**\n     * Simply advance to the next instruction no matter what the current instruction is. I.e. this\n     * method simply advances past jumps and calls.\n     */\n    private fun advanceInstructionPointer(threadIdx: Int) {\n        val thread = threads[threadIdx]\n        require(thread.live) { \"Trying to advance the instruction pointer within a dead thread.\" }\n\n        val frame = thread.currentStackFrame()!!\n        val next = frame.instructionPointer.next()\n\n        if (next == null) {\n            // Reached EOF.\n            // Game will crash if call stack is not empty.\n            require(thread.callStack.isEmpty()) {\n                \"Reached EOF but call stack was not empty\"\n            }\n\n            thread.popFrame()\n            terminateThread(threadIdx)\n        } else {\n            frame.instructionPointer = next\n        }\n    }\n\n    private fun currentThread(): Thread? = threads.getOrNull(threadIdx)\n\n    private fun terminateThread(idx: Int) {\n        val thread = threads.removeAt(idx)\n\n        if (threadIdx >= idx && threadIdx > 0) {\n            threadIdx--\n        }\n\n        logger.debug { \"Thread #${thread.id} terminated.\" }\n    }\n\n    private fun pushFrame(thread: Thread, label: Int) {\n        val segIdx = getSegmentIndexByLabel(label)\n        val segment = bytecode.segments[segIdx]\n\n        require(segment.type == SegmentType.Instructions) {\n            \"Label $label points to a ${segment.type} segment, expecting ${\n                SegmentType.Instructions\n            }.\"\n        }\n\n        thread.pushFrame(InstructionReference(segIdx, 0, bytecode))\n    }\n\n    private fun popFrame(threadIdx: Int) {\n        val thread = threads[threadIdx]\n        thread.popFrame()\n\n        if (!thread.live) {\n            terminateThread(threadIdx)\n        }\n    }\n\n    private fun jumpToLabel(thread: Thread, label: Int) {\n        thread.currentStackFrame()!!.instructionPointer =\n            InstructionReference(getSegmentIndexByLabel(label), 0, bytecode)\n    }\n\n    private fun getSegmentIndexByLabel(label: Int): Int =\n        labelToSegIdx[label] ?: error(\"Invalid argument: No such label $label.\")\n\n    companion object {\n        private const val REGISTER_SIZE = 4\n\n        const val REGISTER_COUNT = 256\n    }\n}\n","package world.phantasmal.web.shared\n\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonBuilder\n\nval JSON_FORMAT = Json {\n    defaultConfig()\n}\n\nval JSON_FORMAT_PRETTY = Json {\n    defaultConfig()\n    prettyPrint = true\n}\n\nprivate fun JsonBuilder.defaultConfig() {\n    ignoreUnknownKeys = true\n    classDiscriminator = \"#type\"\n}\n","package world.phantasmal.web.shared.messages\n\nimport kotlinx.serialization.Serializable\nimport world.phantasmal.core.Severity\n\n/*\n * The protocol between the AsmAnalyser and the assembly web worker is loosely based on the language\n * server protocol. With the idea that at some point we might implement a full LSP server.\n *\n * There are 3 kinds of messages:\n * - Request: sent by the client expecting a response.\n * - Response: sent by server in response to a request.\n * - Notifications: sent by either the client or server. No response is required.\n */\n\n@Serializable\nsealed class ClientMessage\n\n@Serializable\nsealed class ClientNotification : ClientMessage() {\n    @Serializable\n    class SetAsm(\n        val asm: List<String>,\n        val inlineStackArgs: Boolean,\n    ) : ClientNotification()\n\n    @Serializable\n    class UpdateAsm(\n        val changes: List<AsmChange>,\n    ) : ClientNotification()\n}\n\n@Serializable\nsealed class Request : ClientMessage() {\n    /**\n     * Will be echoed in the response so the client can match responses to requests.\n     */\n    abstract val id: Int\n\n    @Serializable\n    class GetCompletions(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetSignatureHelp(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetHover(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetDefinition(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetLabels(override val id: Int) : Request()\n\n    @Serializable\n    class GetHighlights(override val id: Int, val lineNo: Int, val col: Int) : Request()\n}\n\n@Serializable\nsealed class ServerMessage\n\n@Serializable\nsealed class ServerNotification : ServerMessage() {\n    @Serializable\n    class MapDesignations(\n        val mapDesignations: Map<Int, Int>,\n    ) : ServerNotification()\n\n    @Serializable\n    class Problems(\n        val problems: List<AssemblyProblem>,\n    ) : ServerNotification()\n}\n\n@Serializable\nsealed class Response<T> : ServerMessage() {\n    /**\n     * ID of the related request.\n     */\n    abstract val id: Int\n\n    abstract val result: T\n\n    @Serializable\n    class GetCompletions(\n        override val id: Int,\n        override val result: List<CompletionItem>,\n    ) : Response<List<CompletionItem>>()\n\n    @Serializable\n    class GetSignatureHelp(\n        override val id: Int,\n        override val result: SignatureHelp?,\n    ) : Response<SignatureHelp?>()\n\n    @Serializable\n    class GetHover(\n        override val id: Int,\n        override val result: Hover?,\n    ) : Response<Hover?>()\n\n    @Serializable\n    class GetDefinition(\n        override val id: Int,\n        override val result: List<AsmRange>,\n    ) : Response<List<AsmRange>>()\n\n    @Serializable\n    class GetLabels(\n        override val id: Int,\n        override val result: List<Label>,\n    ) : Response<List<Label>>()\n\n    @Serializable\n    class GetHighlights(\n        override val id: Int,\n        override val result: List<AsmRange>,\n    ) : Response<List<AsmRange>>()\n}\n\n@Serializable\ndata class AsmRange(\n    /**\n     * Starting line of the range, inclusive.\n     */\n    val startLineNo: Int,\n    /**\n     * Starting column of the range, inclusive.\n     */\n    val startCol: Int,\n    /**\n     * Ending line of the range, exclusive.\n     */\n    val endLineNo: Int,\n    /**\n     * Ending column of the range, exclusive.\n     */\n    val endCol: Int,\n)\n\nenum class CompletionItemType {\n    Keyword, Opcode\n}\n\n@Serializable\nclass CompletionItem(\n    val label: String,\n    val type: CompletionItemType,\n    val detail: String?,\n    val documentation: String?,\n    val insertText: String,\n)\n\n@Serializable\nclass SignatureHelp(val signature: Signature, val activeParameter: Int)\n\n@Serializable\nclass Signature(val label: String, val documentation: String?, val parameters: List<Parameter>)\n\n@Serializable\nclass Parameter(\n    /**\n     * Start index of the parameter label within [Signature.label].\n     */\n    val labelStart: Int,\n    /**\n     * End index (exclusive) of the parameter label within [Signature.label].\n     */\n    val labelEnd: Int,\n    val documentation: String?,\n)\n\n@Serializable\nclass Hover(\n    /**\n     * List of markdown strings.\n     */\n    val contents: List<String>,\n)\n\n@Serializable\nclass AsmChange(\n    val range: AsmRange,\n    val newAsm: String,\n)\n\n@Serializable\nclass AssemblyProblem(\n    val severity: Severity,\n    val message: String,\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n)\n\n@Serializable\nclass Label(\n    val name: Int,\n    val range: AsmRange,\n)\n","package world.phantasmal.web.shared\n\nimport world.phantasmal.web.shared.externals.self\n\n/**\n * Helper for limiting the amount of times a function is called within a given window.\n *\n * @param wait The number of milliseconds to throttle invocations to.\n * @param leading Invoke on the leading edge of the timeout window.\n * @param trailing Invoke on the trailing edge of the timeout window.\n */\nclass Throttle(\n    private val wait: Int,\n    private val leading: Boolean = true,\n    private val trailing: Boolean = true,\n) {\n    private var timeout: Int? = null\n    private var invokeOnTimeout = false\n    private var function: () -> Unit = {}\n\n    operator fun invoke(f: () -> Unit) {\n        function = f\n\n        if (timeout == null) {\n            if (leading) {\n                function()\n            } else if (trailing) {\n                invokeOnTimeout = true\n            }\n\n            timeout = self.setTimeout({\n                if (invokeOnTimeout) {\n                    function()\n                }\n\n                timeout = null\n                invokeOnTimeout = false\n            }, wait)\n        } else {\n            invokeOnTimeout = trailing\n        }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nimport mu.Appender\n\nclass LogAppender : Appender {\n    override fun trace(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.log(message.message, message.throwable)\n        } else {\n            console.log(message)\n        }\n    }\n\n    override fun debug(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.log(message.message, message.throwable)\n        } else {\n            console.log(message)\n        }\n    }\n\n    override fun info(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.info(message.message, message.throwable)\n        } else {\n            console.info(message)\n        }\n    }\n\n    override fun warn(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.warn(message.message, message.throwable)\n        } else {\n            console.warn(message)\n        }\n    }\n\n    override fun error(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.error(message.message, message.throwable)\n        } else {\n            console.error(message)\n        }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nimport mu.Formatter\nimport mu.KotlinLoggingLevel\nimport mu.Marker\n\nclass LogFormatter : Formatter {\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        msg: () -> Any?,\n    ): String =\n        \"${level.str()} $loggerName - ${msg.toStringSafe()}\"\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        t: Throwable?,\n        msg: () -> Any?,\n    ): MessageWithThrowable =\n        MessageWithThrowable(formatMessage(level, loggerName, msg), t)\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        marker: Marker?,\n        msg: () -> Any?,\n    ): String =\n        \"${level.str()} $loggerName [${marker?.getName()}] - ${msg.toStringSafe()}\"\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        marker: Marker?,\n        t: Throwable?,\n        msg: () -> Any?,\n    ): MessageWithThrowable =\n        MessageWithThrowable(formatMessage(level, loggerName, marker, msg), t)\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun (() -> Any?).toStringSafe(): String {\n        return try {\n            invoke().toString()\n        } catch (e: Exception) {\n            \"Log message invocation failed: $e\"\n        }\n    }\n\n    private fun KotlinLoggingLevel.str(): String =\n        name.padEnd(MIN_LEVEL_LEN)\n\n    companion object {\n        private val MIN_LEVEL_LEN: Int = KotlinLoggingLevel.values().maxOf { it.name.length }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nclass MessageWithThrowable(\n    val message: Any?,\n    val throwable: Throwable?,\n)\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(804);\n"],"sourceRoot":""}