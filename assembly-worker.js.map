{"version":3,"sources":["webpack://assembly-worker/webpack/universalModuleDefinition","webpack://assembly-worker/webpack/bootstrap","webpack://assembly-worker/./kotlin-dce/wrapper.js","webpack://assembly-worker/./kotlin-dce/misc.js","webpack://assembly-worker/./kotlin-dce/polyfills.js","webpack://assembly-worker/./kotlin-dce/core.js","webpack://assembly-worker/./kotlin-dce/markerFunctions.js","webpack://assembly-worker/./kotlin-dce/arrayUtils.js","webpack://assembly-worker/./kotlin-dce/callableReferenceUtils.js","webpack://assembly-worker/./kotlin-dce/conversions.js","webpack://assembly-worker/./kotlin-dce/long.js","webpack://assembly-worker/./kotlin-dce/rtti.js","webpack://assembly-worker/./kotlin-dce/runtime/arrayUtils.kt","webpack://assembly-worker/./kotlin-dce/runtime/Enum.kt","webpack://assembly-worker/primitiveCompanionObjects.kt","webpack://assembly-worker/./kotlin-dce/generated/_Arrays.kt","webpack://assembly-worker/./kotlin-dce/generated/_Ranges.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UByte.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UInt.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UShort.kt","webpack://assembly-worker/./kotlin-dce/Ranges.kt","webpack://assembly-worker/./kotlin-dce/collections/Collections.kt","webpack://assembly-worker/./kotlin-dce/collections/Maps.kt","webpack://assembly-worker/./kotlin-dce/collections/Sets.kt","webpack://assembly-worker/./kotlin-dce/text/StringNumberConversions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UnsignedUtils.kt","webpack://assembly-worker/./kotlin-dce/collections/Sequences.kt","webpack://assembly-worker/./kotlin-dce/generated/_Collections.kt","webpack://assembly-worker/./kotlin-dce/collections/Iterables.kt","webpack://assembly-worker/./kotlin-dce/generated/_Sequences.kt","webpack://assembly-worker/./kotlin-dce/util/Preconditions.kt","webpack://assembly-worker/./kotlin-dce/generated/_Strings.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/string.kt","webpack://assembly-worker/./kotlin-dce/Iterators.kt","webpack://assembly-worker/./kotlin-dce/ProgressionIterators.kt","webpack://assembly-worker/./kotlin-dce/Progressions.kt","webpack://assembly-worker/./kotlin-dce/Collections.kt","webpack://assembly-worker/./kotlin-dce/Range.kt","webpack://assembly-worker/./kotlin-dce/Unit.kt","webpack://assembly-worker/./kotlin-dce/internal/progressionUtil.kt","webpack://assembly-worker/./kotlin-dce/kotlin/builtins.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/CoroutineImpl.kt","webpack://assembly-worker/./kotlin-dce/util/Standard.kt","webpack://assembly-worker/./kotlin-dce/util/Result.kt","webpack://assembly-worker/./kotlin-dce/coroutines/Continuation.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/exceptions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/kotlin.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/numberConversions_js-v1.kt","webpack://assembly-worker/./kotlin-dce/generated/_ArraysJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableCollection.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableList.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/AbstractMutableSet.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/ArrayList.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/ArraySorting.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/EqualityComparator.kt","webpack://assembly-worker/./kotlin-dce/kotlin/Comparator.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/HashMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/HashSet.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/InternalHashCodeMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/InternalStringMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/LinkedHashMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/LinkedHashSet.kt","webpack://assembly-worker/./kotlin-dce/kotlin/console.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/SafeContinuationJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/exceptionUtils.kt","webpack://assembly-worker/./kotlin-dce/kotlin/json.kt","webpack://assembly-worker/./kotlin-dce/kotlin/math.kt","webpack://assembly-worker/./kotlin-dce/kotlin/numbers_js-v1.kt","webpack://assembly-worker/./kotlin-dce/kotlin/numbers.kt","webpack://assembly-worker/./kotlin-dce/kotlin/random/PlatformRandom.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/KClassImpl.kt","webpack://assembly-worker/./kotlin-dce/kotlin/collections/InternalMap.kt","webpack://assembly-worker/./kotlin-dce/kotlin/jsOperators.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/KTypeImpl.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/primitives.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/reflection.kt","webpack://assembly-worker/./kotlin-dce/kotlin/regexp.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/StringBuilderJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/char.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/numberConversions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/regex.kt","webpack://assembly-worker/./kotlin-dce/text/Strings.kt","webpack://assembly-worker/./kotlin-dce/generated/_ComparisonsJs.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/stringsCode.kt","webpack://assembly-worker/./kotlin-dce/kotlin/time/DurationUnit.kt","webpack://assembly-worker/./kotlin-dce/kotlin/time/MonoTimeSource.kt","webpack://assembly-worker/./kotlin-dce/kotlin/time/formatToDecimals.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractCollection.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractList.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractMap.kt","webpack://assembly-worker/./kotlin-dce/collections/AbstractSet.kt","webpack://assembly-worker/./kotlin-dce/collections/IndexedValue.kt","webpack://assembly-worker/./kotlin-dce/collections/Iterators.kt","webpack://assembly-worker/./kotlin-dce/collections/MapWithDefault.kt","webpack://assembly-worker/./kotlin-dce/collections/MutableCollections.kt","webpack://assembly-worker/./kotlin-dce/collections/SequenceBuilder.kt","webpack://assembly-worker/./kotlin-dce/coroutines/ContinuationInterceptor.kt","webpack://assembly-worker/./kotlin-dce/coroutines/CoroutineContext.kt","webpack://assembly-worker/./kotlin-dce/coroutines/CoroutineContextImpl.kt","webpack://assembly-worker/./kotlin-dce/coroutines/intrinsics/Intrinsics.kt","webpack://assembly-worker/./kotlin-dce/random/Random.kt","webpack://assembly-worker/./kotlin-dce/random/XorWowRandom.kt","webpack://assembly-worker/./kotlin-dce/ranges/Ranges.kt","webpack://assembly-worker/./kotlin-dce/reflect/KTypeProjection.kt","webpack://assembly-worker/./kotlin-dce/reflect/KVariance.kt","webpack://assembly-worker/./kotlin-dce/text/Appendable.kt","webpack://assembly-worker/./kotlin-dce/text/Char.kt","webpack://assembly-worker/./kotlin-dce/text/Indent.kt","webpack://assembly-worker/./kotlin-dce/text/regex/MatchResult.kt","webpack://assembly-worker/./kotlin-dce/time/Duration.kt","webpack://assembly-worker/./kotlin-dce/time/DurationUnit.kt","webpack://assembly-worker/./kotlin-dce/time/TimeSource.kt","webpack://assembly-worker/./kotlin-dce/text/StringBuilder.kt","webpack://assembly-worker/./kotlin-dce/time/TimeSources.kt","webpack://assembly-worker/./kotlin-dce/time/measureTime.kt","webpack://assembly-worker/./kotlin-dce/util/Lazy.kt","webpack://assembly-worker/./kotlin-dce/util/Tuples.kt","webpack://assembly-worker/./kotlin-dce/kotlin/ULong.kt","webpack://assembly-worker/./kotlin-dce/experimental/bitwiseOperations.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UIntRange.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UIterators.kt","webpack://assembly-worker/./kotlin-dce/kotlin/ULongRange.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UProgressionUtil.kt","webpack://assembly-worker/./kotlin-dce/kotlin/UStrings.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflection_js-v1.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/JsClass.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/KTypeHelpers.kt","webpack://assembly-worker/./kotlin-dce/comparisons/Comparisons.kt","webpack://assembly-worker/./kotlin-dce/kotlin/MathH.kt","webpack://assembly-worker/./kotlin-dce/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://assembly-worker/./kotlin-dce/kotlin/text/utf8Encoding.kt","webpack://assembly-worker/./kotlin-dce/util/DeepRecursive.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/ConsoleOutputAppender.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/DefaultMessageFormatter.kt","webpack://assembly-worker/../../../../../src/commonMain/kotlin/mu/internal/MessageInvoker.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/KotlinLogging.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/KotlinLoggingConfiguration.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/KotlinLoggingLevel.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/internal/ErrorMessageProducer.kt","webpack://assembly-worker/../../../../../src/jsMain/kotlin/mu/internal/KLoggerJS.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/commonMain/kotlin/world/phantasmal/core/PwResult.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/JsExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/commonMain/kotlin/world/phantasmal/core/math/Math.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/PrimitiveExtensions.kt","webpack://assembly-worker/./kotlin-dce/kotlin/reflect/AssociatedObjects.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/PolymorphicSerializer.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/SealedSerializer.kt","webpack://assembly-worker/./kotlin-dce/collections/Grouping.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/SerializationException.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/Serializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/builtins/BuiltinSerializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptor.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialKinds.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/PluginGeneratedSerialDescriptor.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/AbstractDecoder.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/AbstractEncoder.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/AbstractPolymorphicSerializer.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/CollectionDescriptors.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/CollectionSerializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Enums.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/InlineClassDescriptor.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/InlineClasses.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/NoOpEncoder.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/NullableSerializer.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/ObjectSerializer.kt","webpack://assembly-worker/./kotlin-dce/util/HashCode.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/PrimitiveArraysSerializers.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/PluginHelperInterfaces.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Primitives.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Tagged.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/Tuples.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/modules/SerializersModule.kt","webpack://assembly-worker/../../../../../core/jsMain/src/kotlinx/serialization/Serializers.kt","webpack://assembly-worker/../../../../../core/jsMain/src/kotlinx/serialization/internal/Platform.kt","webpack://assembly-worker/./kotlin-dce/generated/_Maps.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/internal/JsonInternalDependencies.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/build/js/node_modules/process/browser.js","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/GetRegisterValue.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/ValueSet.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/Endianness.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/Episode.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/AsmTokenization.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/Assembly.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/BytecodeIr.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/Opcode.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/StandardExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/Strings.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/ControlFlowGraph.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/GetMapDesignations.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/dataFlowAnalysis/GetStackValue.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Areas.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/EntityProp.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/NpcType.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/jsMain/kotlin/world/phantasmal/lib/buffer/Buffer.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/build/generated-src/commonMain/kotlin/world/phantasmal/lib/asm/Opcodes.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/asm/Disassembly.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/compression/prs/PrsDecompress.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/Afs.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/AreaRenderGeometry.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/Iff.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Angle.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Nj.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Texture.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/ninja/Xj.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Bin.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Bytecode.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Dat.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/NpcTypeExtensions.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Qst.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/fileFormats/quest/Quest.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/lib/src/commonMain/kotlin/world/phantasmal/lib/vm/VirtualMachine.kt","webpack://assembly-worker/./kotlin/collections/Collections.kt","webpack://assembly-worker/./kotlin/time/measureTime.kt","webpack://assembly-worker/./kotlin/kotlin/collections.kt","webpack://assembly-worker/./kotlin/generated/_Collections.kt","webpack://assembly-worker/./kotlin/text/Strings.kt","webpack://assembly-worker/./kotlin/kotlin/math.kt","webpack://assembly-worker/./kotlin/generated/_Sequences.kt","webpack://assembly-worker/./kotlin/comparisons/Comparisons.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/AssemblyWorker.kt","webpack://assembly-worker/./kotlin/kotlin/text/string.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/core/src/jsMain/kotlin/world/phantasmal/core/Js.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/assembly-worker/src/main/kotlin/world/phantasmal/web/assemblyWorker/Main.kt","webpack://assembly-worker/../../../../../core/commonMain/src/kotlinx/serialization/SerialFormat.kt","webpack://assembly-worker/../../../../../common/src/Delay.kt","webpack://assembly-worker/../../../../../common/src/EventLoop.common.kt","webpack://assembly-worker/../../../../../common/src/flow/SharedFlow.kt","webpack://assembly-worker/../../../../../common/src/internal/LockFreeTaskQueue.kt","webpack://assembly-worker/../../../../../js/src/JSDispatcher.kt","webpack://assembly-worker/../../../../../common/src/AbstractCoroutine.kt","webpack://assembly-worker/../../../../../common/src/Builders.common.kt","webpack://assembly-worker/../../../../../common/src/CancellableContinuation.kt","webpack://assembly-worker/../../../../../common/src/CancellableContinuationImpl.kt","webpack://assembly-worker/../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://assembly-worker/../../../../../common/src/CompletionState.kt","webpack://assembly-worker/../../../../../common/src/CoroutineDispatcher.kt","webpack://assembly-worker/../../../../../common/src/CoroutineExceptionHandler.kt","webpack://assembly-worker/../../../../../common/src/CompletableDeferred.kt","webpack://assembly-worker/../../../../../common/src/CoroutineName.kt","webpack://assembly-worker/../../../../../common/src/CoroutineScope.kt","webpack://assembly-worker/../../../../../common/src/CoroutineStart.kt","webpack://assembly-worker/../../../../../common/src/Job.kt","webpack://assembly-worker/../../../../../common/src/JobSupport.kt","webpack://assembly-worker/../../../../../js/src/internal/LinkedList.kt","webpack://assembly-worker/../../../../../common/src/MainCoroutineDispatcher.kt","webpack://assembly-worker/../../../../../common/src/NonCancellable.kt","webpack://assembly-worker/../../../../../common/src/Supervisor.kt","webpack://assembly-worker/../../../../../common/src/Timeout.kt","webpack://assembly-worker/../../../../../common/src/channels/AbstractChannel.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Reduce.kt","webpack://assembly-worker/../../../../../common/src/internal/ThreadSafeHeap.kt","webpack://assembly-worker/../../../../../common/src/selects/Select.kt","webpack://assembly-worker/../../../../../common/src/flow/operators/Zip.kt","webpack://assembly-worker/../../../../../common/src/flow/internal/SafeCollector.common.kt","webpack://assembly-worker/../../../../../common/src/internal/ConcurrentLinkedList.kt","webpack://assembly-worker/../../../../../atomicfu/src/jsMain/kotlin/kotlinx/atomicfu/AtomicFU.kt","webpack://assembly-worker/../../../../../common/src/internal/DispatchedContinuation.kt","webpack://assembly-worker/../../../../../common/src/internal/InlineList.kt","webpack://assembly-worker/../../../../../common/src/internal/Scopes.kt","webpack://assembly-worker/../../../../../common/src/intrinsics/Undispatched.kt","webpack://assembly-worker/../../../../../js/src/Runnable.kt","webpack://assembly-worker/../../../../../common/src/sync/Semaphore.kt","webpack://assembly-worker/../../../../../common/src/channels/Channels.common.kt","webpack://assembly-worker/../../../../../common/src/flow/operators/Limit.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Collection.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Collect.kt","webpack://assembly-worker/../../../../../common/src/flow/terminal/Count.kt","webpack://assembly-worker/../../../../../common/src/internal/ArrayQueue.kt","webpack://assembly-worker/../../../../../common/src/internal/Atomic.kt","webpack://assembly-worker/../../../../../js/src/internal/Synchronized.kt","webpack://assembly-worker/../../../../../common/src/intrinsics/Cancellable.kt","webpack://assembly-worker/../../../../../common/src/sync/Mutex.kt","webpack://assembly-worker/../../../../../js/src/CompletionHandler.kt","webpack://assembly-worker/../../../../../js/src/CoroutineContext.kt","webpack://assembly-worker/./kotlin-dce/kotlin/jsTypeOf.kt","webpack://assembly-worker/../../../../../js/src/CoroutineExceptionHandlerImpl.kt","webpack://assembly-worker/../../../../../js/src/Debug.kt","webpack://assembly-worker/../../../../../js/src/Dispatchers.kt","webpack://assembly-worker/../../../../../js/src/EventLoop.kt","webpack://assembly-worker/../../../../../js/src/Promise.kt","webpack://assembly-worker/../../../../../js/src/Window.kt","webpack://assembly-worker/../../../../../js/src/internal/CopyOnWriteList.kt","webpack://assembly-worker/../../../../../js/src/Exceptions.kt","webpack://assembly-worker/../../../../../js/src/flow/internal/FlowExceptions.kt","webpack://assembly-worker/../../../../../js/src/flow/internal/SafeCollector.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/commonMain/kotlin/world/phantasmal/web/shared/JsonFormat.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/commonMain/kotlin/world/phantasmal/web/shared/messages/Messages.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/Throttle.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/LogAppender.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/LogFormatter.kt","webpack://assembly-worker//home/runner/work/phantasmal-world/phantasmal-world/web/shared/src/jsMain/kotlin/world/phantasmal/web/shared/logging/MessageWithThrowable.kt","webpack://assembly-worker/../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicDecoders.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/Json.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElement.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementSerializers.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonConf.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonExceptions.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonParser.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonReader.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/Polymorphic.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonEncoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/PolymorphismValidator.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonDecoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonEncoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StringOps.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonDecoder.kt","webpack://assembly-worker/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/WriteMode.kt"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Kotlin","buf","bufFloat64","bufFloat32","bufInt32","lowIndex","highIndex","_","getObjectHashCode","obj","hash","Math","random","throwMarkerError","Error","imul","a","b","isBooleanArray","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","toString","String","fromCharCode","map","e","join","arrayEquals","length","equals","arrayHashCode","arr","result","hashCode","getCallableRef","f","callableName","toShort","toByte","toChar","numberToInt","Long","toInt","doubleToInt","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","objType","numberHashCode","Number","str","code","charCodeAt","getStringHashCode","identityHashCode","low_","low","high_","high","$metadata$","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","pow","size","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","setCoroutineResult","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","floatToRawBits","ensureNotNull","x","throwNPE","startsWith","searchString","position","lastIndexOf","endsWith","subjectString","undefined","lastIndex","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","y","exp","y1","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","fill","TypeError","O","len","start","relativeStart","k","end","relativeEnd","finalValue","normalizeOffset","offset","typedArraySlice","begin","constructor","subarray","arrays","TypedArray","slice","Function","self","array","callback","totalOrderComparator","sort","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","getPrototypeOf","isType","proto","kind","OBJECT","klassMetadata","INTERFACE","isInheritanceFromInterface","ctor","iface","metadata","interfaces","superPrototype","superConstructor","isNumber","isChar","isComparable","type","Comparable","isCharSequence","CharSequence","ordinal","initValue","fillArrayVal","init","element","index","IntRange","destination","item","asCollection","emptySet","setOf","toCollection","emptySequence","iterator","hasNext","NoSuchElementException","last","next","isEmpty","single","j","emptyList","listOf","optimizeReadOnlyList","optimizeReadOnlySet","separator","prefix","postfix","limit","truncated","transform","buffer","count","to","first","step","EMPTY","minimumValue","maximumValue","FilteringSequence","predicate","it","TakeSequence","TransformingSequence","CharIterator","IntIterator","LongIterator","getProgressionLastElement","endInclusive","sortedList","NotImplementedError","nextByte","nextChar","nextShort","nextInt","nextLong","nextFloat","nextDouble","nextBoolean","CharProgressionIterator","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","context","current","v","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","cause","message","Exception","RuntimeException","src","dst","srcLen","dstLen","source","newSize","defaultValue","checkRadix","ArrayList","fromIndex","toIndex","toArray","copyToArrayImpl","collection","push","pair","list","copyToArray","comparator","collectionsSort","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","initialCapacity","elements","_stableSortingIsSupported","comparison","getStableSortingIsSupported","median","left","leftIndex","rightIndex","right","leftValue","rightValue","target","mergeSort","checkIsMutable","remove","modified","_index","changed","times","hasPrevious","newValue","oldValue","entries","clear","from","iter","entry","modCount","splice","concat","pop","value1","value2","internalMap","equality","InternalHashCodeMap","loadFactor","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","ClassCastException","pairs","NEGATIVE_INFINITY","toRawBits","bits","POSITIVE_INFINITY","isInfinite","hi26","INV_2_26","low27","INV_2_53","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","old","newEntry","build","println","outputStream","write","messageString","flush","console","cur","simpleName","jsClass","PrimitiveKClassImpl","classifier","isMarkedNullable","kClass","variance","prefixString","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","content","matches","toUpperCase","uppercase","MIN_HIGH_SURROGATE","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","MAX_LOW_SURROGATE","toLowerCase","char","pattern","options","collectionSizeOrDefault","RegExp","match","IndexOutOfBoundsException","startIndex","endIndex","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","destinationOffset","dstIndex","stringCsq","reset","exec","input","test","findNext","Regex","replace","replacement","lastStart","sb","foundMatch","range","nonGlobalOptions","subSequence","literal","AbstractList","ignoreCase","n1","n2","s1","s2","regex","regionMatchesImpl","thisOffset","otherOffset","sourceUnit","targetUnit","sourceCompareTarget","isNode","HrTimeSource","MatchGroup","markNow","TimeMark","process","hrtime","AbstractDoubleTimeSource","startedAt","seconds","nanos","performance","now","decimals","round","toFixed","toLocaleString","json","toExponential","previous","nextIndex","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","ArithmeticException","values","contains","isVarargs","IndexingIterator","IndexedValue","checkIndexOverflow","putAll","emptyMap","filterInPlace","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","block","SequenceScope","asSequence","sequence","throwOnFailure","FlatteningSequence","GeneratorSequence","seedFunction","nextFunction","nextItem","nextState","itemIterator","nextItemIterator","SubSequence","safe","getOrThrow","acc","removed","interceptor","CombinedContext","baseKey","operation","initial","newLeft","Random","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","rnd","doubleFromParts","r1","nextDown","steps","remainder","vr","seed","boundsErrorMessage","seed1","seed2","KTypeProjection","v0","takeUpperBits","star","uppercaseChar","newIndent","lines","isBlank","line","isWhitespace","int","firstChar","limitBeforeMul","digitOf","digit","limitForMaxRadix","NumberFormatException","padChar","padStart","indices","regionMatches","currentStartIndex","strings","findAnyOf","currentIndex","second","DelimitedRangesSequence","asList","delimiters","splitToSequence","lineSequence","Duration","nextSearchIndex","groupValues","convertDurationUnit","unit","scale","action","inDays","hoursComponent","minutesComponent","secondsComponent","nanosecondsComponent","inHours","inMinutes","inSeconds","inNanoseconds","absoluteValue","scientific","maxDecimals","absNs","formatScientific","formatUpToDecimals","formatToExactDecimals","shortName","number","hours","nanoseconds","minutes","hasSeconds","hasHours","hasMinutes","nss","AdjustedTimeMark","duration","elapsedNow","mark","adjustment","read","initializer","isInitialized","InitializedLazyImpl","Pair","that","UByte","third","UInt","uintCompare","data","ulongCompare","uintDivide","ulongDivide","uintRemainder","ulongRemainder","UIntProgression","UIntRange","uintToDouble","UIntProgressionIterator","UIntIterator","ULong","nextUInt","nextULong","ULongProgression","ulongToDouble","ulongToString","ULongProgressionIterator","ULongIterator","ac","bc","UShort","uradix","beforeAdding","v1","v2","divisor","dividend","quotient","base","toMutableList","IndexingIterable","resultSize","throwCountOverflow","sequenceOf","fillFrom","arrayCopyResize","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","captureStackTrace","instance","stack","UnsafeLazyImpl","rangeSize","set","subrange","original","delegate","NullPointerException","KTypeImpl","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","toByteOrNull","numberFormatError","toShortOrNull","toIntOrNull","toLongOrNull","getOrImplicitDefault","mapOf","optimizeReadOnlyMap","toSet","replaceIndent","startFound","padEnd","delimiter","currentOffset","isLimited","toUByteOrNull","toUShortOrNull","toUIntOrNull","toULongOrNull","NodeJsOutput","BufferedOutputToConsoleLog","Comparator","severity","uiMessage","joinToString","problems","PwResultBuilder","logger","PwResult","problem","Problem","Success","Failure","close","PI","DataView","sourceIterator","mapCapacity","findAssociatedObject","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","args","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","episode","LineTokenizer","srcLoc","SegmentSrcLoc","Segment","labels","AnyType","isLabel","HEX_INT_REGEX","hexStr","drop","FLOAT_REGEX","floatStr","toDoubleOrNull","isRegister","prevWasBackSpace","terminated","replaceAll","ident","nextToken","hasLabel","BytecodeIr","InstructionSegment","seg","instructions","Instruction","opcode","InstructionSrcLoc","mnemonicSrcLoc","argSrcLocs","stackArgSrcLocs","DataSegment","bytes","oldSize","StringSegment","AssemblyProblem","col","intValue","label","segment","mutableListOf","section","mnemonicToOpcode","strValue","inlineArgs","inlineArgSrcLocs","stackArgs","argCount","semiValid","shouldBeArg","paramI","prevCol","prevLen","params","param","varargs","typeMatch","Arg","floatValue","arg","srcLocs","OP_ARG_PUSHB","OP_ARG_PUSHR","OP_ARG_PUSHW","OP_ARG_PUSHL","OP_ARG_PUSHS","typeStr","startCol","paramCount","errorLength","bitSize","minValue","maxValue","toByteArray","SrcLoc","segments","copy","sum","dcGcFormat","paramToArgs","pArgs","paramIndex","ValueType","LabelType","RefType","registers","joinTo","uiName","getOpcode","OPCODES","OPCODES_F8","OPCODES_F9","mnemonic","UNKNOWN_OPCODE_MNEMONIC_REGEX","codeStr","codeToOpcode","opcodes","Opcode","access","instruction","bytecodeIr","instructionSegments","ControlFlowGraphBuilder","createBasicBlocks","cfg","blocks","getOrNull","branchType","nextBlock","branchLabels","labelsToBlock","callers","caller","ret","linkReturningBlocks","linkBlocks","firstBlock","inst","OP_RET","OP_JMP","OP_JMP_ON","OP_JMP_OFF","OP_JMP_E","OP_JMPI_E","OP_JMP_NE","OP_JMPI_NE","OP_UJMP_G","OP_UJMPI_G","OP_JMP_G","OP_JMPI_G","OP_UJMP_L","OP_UJMPI_L","OP_JMP_L","OP_JMPI_L","OP_UJMP_GE","OP_UJMPI_GE","OP_JMP_GE","OP_JMPI_GE","OP_UJMP_LE","OP_UJMPI_LE","OP_JMP_LE","OP_JMPI_LE","OP_SWITCH_JMP","OP_CALL","OP_VA_CALL","OP_SWITCH_CALL","BasicBlockImpl","instructionsToBlock","labelBlocks","linkReturningBlocksRecurse","encountered","toBlock","register","RegisterValueFinder","minOrNull","ControlFlowGraph","all","OP_SYNC","path","isNotEmpty","OP_LET","OP_LETI","OP_LETB","OP_LETW","OP_SYNC_LETI","OP_SET","OP_CLEAR","OP_REV","prevVals","OP_ADDI","OP_SUBI","OP_MULI","OP_DIVI","OP_IF_ZONE_CLEAR","OP_GET_DIFFLVL","OP_GET_SLOTNUMBER","OP_GET_RANDOM","maxOrNull","OP_STACK_PUSHM","OP_STACK_POPM","minReg","maxReg","argLen","writes","regRef","empty","vaStartIdx","vaCallIdx","OP_VA_START","OP_ARG_PUSHA","OP_ARG_PUSHO","pos","getRegisterValue","idx","firstOrNull","lastOrNull","Interval","scalar","addI","oldStart","oldEnd","newEnd","newStart","ValueSet","Area","id","order","avs","variants","AreaVariant","avId","area","uniqueName","rareType","lazy","FRIENDLY_NPC_PROPERTIES","EntityProp","arrayBuffer","endianness","byteLength","getUint8","getUint16","getUint32","getInt8","getInt16","getInt32","getFloat32","maxByteLength","nullTerminated","codePoint","setUint8","setUint16","setUint32","setInt8","setInt16","setInt32","setFloat32","btoa","Buffer","minNewSize","capacity","Uint8Array","newBuffer","initialSize","toTypedArray","atob","inlineStackArgs","Assembler","assemble","time","checkCountOverflow","inMilliseconds","warnings","errors","func0Segment","OP_MAP_DESIGNATE","OP_MAP_DESIGNATE_EX","createCfg","areaId","variantIdRegister","variantId","mapDesignations","OP_BB_MAP_DESIGNATE","StackValueFinder","Param","RegRefType","KotlinLogging","repeat","createArea","ep1","ep2","ep4","VALUES","npcType","ultimateName","compareValues","selector","Throttle","CompletionItem","sortedWith","filterNotNull","asmChanges","otherMessages","messages","asm","changes","lineNo","change","startLineNo","endLineNo","endCol","split","newAsm","linesChanged","newLines","newLineParts","lineStart","lineEnd","newLinePart","startLine","endLine","startLineStart","endLineEnd","toList","assemblyResult","getMapDesignations","designations","trim","text","filter","suggestions","startingWith","containing","requestId","completions","signature","activeParam","SignatureHelp","Parameter","doc","Signature","sig","parameters","activeParameter","labelStart","labelEnd","contents","documentation","Hover","hover","paramIdx","argSrcLoc","getStackValue","labelValues","addAll","mapNotNull","labelIdx","AsmRange","JSON_FORMAT","postMessage","KotlinLoggingConfiguration","LogFormatter","LogAppender","location","hostname","AssemblyWorker","onmessage","ignoreUnknownKeys","classDiscriminator","ClientMessage","ClientNotification","Request","ServerMessage","ServerNotification","Response","throwable","info","warn","error","level","loggerName","msg","MessageWithThrowable","Date","date","getHours","getMinutes","getSeconds","getMilliseconds","Json","defaultConfig","prettyPrint","toDouble"],"mappings":"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Z,GIuCtBpZ,EJvCwCmZ,KIuC/Bra,EJvC2Cqa,OIuCpD,EJvCsBC,GIuCHpZ,EJvCqBmZ,KIuCZra,EJvCwBqa,OIuCjC,EAChE,YJwNsC,IAAAW,GIxNnB7Z,GACnB,YAAuB,eAASD,EAAW,oBCtG/C,mBAEI,M3GyHoDuZ,G2GzH3CrtB,EAAI3C,GACb,E3GwHoDgwB,G2GxH3CptB,EAAI5C,GACb,O3GiDkE2vB,G2GjDvDoB,E3GiDwEnB,K2GjDlEoB,E3GiD8EpB,O2GjDpF,E3GgF2C,IAAAF,G2GhFjCqB,E3GgF2CnB,K2GhFtCoB,E3GgFuDpB,KAAZ,GAbhB,IAAAF,GAAU,IAaTA,G2GhFpBqB,E3GgF8BnB,K2GhFzBoB,E3GgF0CpB,KAAZ,GAbNA,K2GnEnB5vB,E3GmEmC4vB,KAAX,G2GhExE,mBACI,MLsHsDK,GKtH7CttB,EAAI3C,GACb,ELqHsDiwB,GKrH7CrtB,EAAI5C,GACb,OLmDmE6vB,GKnDxDkB,ELmD0EnB,KKnDpEoB,ELmDgFpB,OKnDtF,EL6E6C,IAAAW,GK7EnCQ,EL6E8CnB,KAAK,SK7E9CoB,EL6E0DpB,OAb7B,IAAAW,GAAW,IAaVA,GK7EtBQ,EL6EiCnB,KAAK,SK7EjCoB,EL6E6CpB,OAblBA,KAAK,IKhE3B5vB,ELgEsC4vB,OK7DtF,mBAmBI,GAAAlZ,EAAO,EADuE,O3GsBZiZ,G2GrBlDve,E3GqBmEwe,K2GrB1Dre,E3GqBsEqe,O2GrB/E,EAAcre,E3GoDwB,IAAAme,G2GpDfne,E3GoDyBqe,K2GpDnB,GAAiBre,EAAKH,E3G8QhC,IAAAse,G2G9QuChZ,I3GoDOkZ,KAAZ,G2GnDrE,GAAAlZ,EAAO,EAFuE,O3GsBZiZ,G2GpBlDve,E3GoBmEwe,K2GpB1Dre,E3GoBsEqe,O2GpB/E,EAAcre,E3GsCuB,IAAAme,G2GtCdne,E3GsCwBqe,K2GtClB,GAAiBxe,EAAOG,E3G6QlC,IAAAme,G2G7QwC,GAAChZ,I3GsCGkZ,KAAX,G2GrC5D,MAAa,GAAyB,iBAGlD,mBAmBI,GAAAlZ,EAAA,WAAO,EAD2E,OLMfmZ,GKLnDze,ELKqEwe,KKL5Dre,ELKwEqe,OK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","file":"assembly-worker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assembly-worker\"] = factory();\n\telse\n\t\troot[\"assembly-worker\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}",null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Array<out T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.scanReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.scanReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.scanReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.scanReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.scanReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.scanReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.scanReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    return runningReduceIndexed(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\n@file:OptIn(ExperimentalUnsignedTypes::class)\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = @OptIn(ExperimentalStdlibApi::class) buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence from the second time.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n/** Returns true when it's safe to convert this collection to a set without changing contains method behavior. */\nprivate fun <T> Collection<T>.safeToConvertToSet() = size > 2 && this is ArrayList\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperationWith(source: Iterable<T>): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection ->\n            when {\n                source is Collection && source.size < 2 -> this\n                else -> if (this.safeToConvertToSet()) toHashSet() else this\n            }\n        else -> toHashSet()\n    }\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperation(): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection -> if (this.safeToConvertToSet()) toHashSet() else this\n        else -> toHashSet()\n    }\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun CharSequence.scanReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement = last.toInt()\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first.toInt() else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start.toInt(), endInclusive.toInt(), step).toInt()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start.toLong(), endInclusive.toLong(), step).toLong()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\npublic inline class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @JsName(\"toJSON\")\n    open fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    // TODO: should we implement them this way? Currently it's unspecified in JVM\n                    override fun equals(other: Any?): Boolean {\n                        if (this === other) return true\n                        if (other !is Collection<*>) return false\n                        return AbstractList.orderedEquals(this, other)\n                    }\n\n                    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual constructor(initialCapacity: Int = 0) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n    override fun toArray(): Array<Any?> = js(\"[]\").slice.call(array)\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    protected open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * An interface for indexing access to a collection of key-value pairs, where type of key is [String] and type of value is [Any?][Any].\n */\npublic external interface Json {\n    /**\n     * Calls to the function will be translated to indexing operation (square brackets) on the receiver with [propertyName] as the argument.\n     *\n     * E.g. for next code:\n     * ```kotlin\n     * fun test(j: Json, p: String) = j[\"prop\"] + j.get(p)\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p) {\n     *     return j[\"prop\"] + j[p];\n     * }\n     * ```\n     */\n    operator fun get(propertyName: String): Any?\n\n    /**\n     * Calls of the function will be translated to an assignment of [value] to the receiver indexed (with square brackets/index operation) with [propertyName].\n     *\n     * E.g. for the following code:\n     * ```kotlin\n     * fun test(j: Json, p: String, newValue: Any) {\n     *     j[\"prop\"] = 1\n     *     j.set(p, newValue)\n     * }\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p, newValue) {\n     *     j[\"prop\"] = 1;\n     *     j[p] = newValue;\n     * }\n     * }\n     * ```\n     */\n    operator fun set(propertyName: String, value: Any?): Unit\n}\n\n/**\n * Returns a simple JavaScript object (as [Json]) using provided key-value pairs as names and values of its properties.\n */\npublic fun json(vararg pairs: Pair<String, Any?>): Json {\n    val res: dynamic = js(\"({})\")\n    for ((name, value) in pairs) {\n        res[name] = value\n    }\n    return res\n}\n\n/**\n * Adds key-value pairs from [other] to [this].\n * Returns the original receiver.\n */\npublic fun Json.add(other: Json): Json {\n    val keys: Array<String> = js(\"Object\").keys(other)\n    for (key in keys) {\n        if (other.asDynamic().hasOwnProperty(key)) {\n            this[key] = other[key];\n        }\n    }\n    return this\n}\n\n/**\n * Exposes the JavaScript [JSON object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external object JSON {\n    public fun stringify(o: Any?): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: Int): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: String): String\n    public fun stringify(o: Any?, replacer: Array<String>): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: Int): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: String): String\n\n    public fun <T> parse(text: String): T\n    public fun <T> parse(text: String, reviver: ((key: String, value: Any?) -> Any?)): T\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"DEPRECATION_ERROR\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = kotlin.js.Math.clz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal class KTypeImpl(\n    override val classifier: KClassifier,\n    override val arguments: List<KTypeProjection>,\n    override val isMarkedNullable: Boolean\n) : KType {\n    override fun equals(other: Any?): Boolean =\n        other is KTypeImpl &&\n                classifier == other.classifier && arguments == other.arguments && isMarkedNullable == other.isMarkedNullable\n\n    override fun hashCode(): Int =\n        (classifier.hashCode() * 31 + arguments.hashCode()) * 31 + isMarkedNullable.hashCode()\n\n    override fun toString(): String {\n        val kClass = (classifier as? KClass<*>)\n        val classifierName = when {\n            kClass == null -> classifier.toString()\n            kClass.simpleName != null -> kClass.simpleName\n            else -> \"(non-denotable type)\"\n        }\n\n        val args =\n            if (arguments.isEmpty()) \"\"\n            else arguments.joinToString(\", \", \"<\", \">\") { it.asString() }\n        val nullable = if (isMarkedNullable) \"?\" else \"\"\n\n        return classifierName + args + nullable\n    }\n\n    // TODO: this should be the implementation of KTypeProjection.toString, see KT-30071\n    private fun KTypeProjection.asString(): String {\n        if (variance == null) return \"*\"\n        return variance.prefixString() + type.toString()\n    }\n}\n\ninternal object DynamicKType : KType {\n    override val classifier: KClassifier? = null\n    override val arguments: List<KTypeProjection> = emptyList()\n    override val isMarkedNullable: Boolean = false\n    override fun toString(): String = \"dynamic\"\n}\n\ninternal fun KVariance.prefixString() =\n    when (this) {\n        KVariance.INVARIANT -> \"\"\n        KVariance.IN -> \"in \"\n        KVariance.OUT -> \"out \"\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [RegExp object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external class RegExp(pattern: String, flags: String? = definedExternally) {\n\n    public fun test(str: String): Boolean\n\n    public fun exec(str: String): RegExpMatch?\n\n    public override fun toString(): String\n\n    /**\n     * The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.\n     */\n    public var lastIndex: Int\n\n    public val global: Boolean\n    public val ignoreCase: Boolean\n    public val multiline: Boolean\n}\n\n/**\n * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the beginning of the input string.\n */\npublic fun RegExp.reset() {\n    lastIndex = 0\n}\n\n// TODO: Inherit from array or introduce asArray() extension\n/**\n * Represents the return value of [RegExp.exec].\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external interface RegExpMatch {\n    public val index: Int\n    public val input: String\n    public val length: Int\n}\n\n/**\n * Returns the entire text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis\n * at the given index.\n */\npublic inline operator fun RegExpMatch.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Converts the result of [RegExp.exec] to an array where the first element contains the entire matched text and each subsequent\n * element is the text matched by each capturing parenthesis.\n */\npublic inline fun RegExpMatch.asArray(): Array<out String?> = unsafeCast<Array<out String?>>()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n// actually \\s is enough to match all whitespace, but \\xA0 added because of different regexp behavior of Rhino used in Selenium tests\npublic actual fun Char.isWhitespace(): Boolean = toString().matches(\"[\\\\s\\\\xA0]\")\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = toString().asDynamic().toLowerCase().charCodeAt(0).unsafeCast<Int>().toChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase() as String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase() as String\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Provides enumeration values to use to set regular expression options.\n */\npublic actual enum class RegexOption(val value: String) {\n    /** Enables case-insensitive matching. */\n    IGNORE_CASE(\"i\"),\n    /** Enables multiline mode.\n     *\n     * In multiline mode the expressions `^` and `$` match just after or just before,\n     * respectively, a line terminator or the end of the input sequence. */\n    MULTILINE(\"m\")\n}\n\n\n/**\n * Represents the results from a single capturing group within a [MatchResult] of [Regex].\n *\n * @param value The value of captured group.\n */\npublic actual data class MatchGroup(actual val value: String)\n\n\n/**\n * Represents a compiled regular expression.\n * Provides functions to match strings in text with a pattern, replace the found occurrences and split text around matches.\n *\n * For pattern syntax reference see [MDN RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions)\n * and [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](https://www.w3schools.com/jsref/jsref_obj_regexp.asp).\n *\n * @constructor Creates a regular expression from the specified [pattern] string and the specified set of [options].\n */\npublic actual class Regex actual constructor(pattern: String, options: Set<RegexOption>) {\n\n    /** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n    public actual constructor(pattern: String, option: RegexOption) : this(pattern, setOf(option))\n\n    /** Creates a regular expression from the specified [pattern] string and the default options.  */\n    public actual constructor(pattern: String) : this(pattern, emptySet())\n\n\n    /** The pattern string of this regular expression. */\n    public actual val pattern: String = pattern\n    /** The set of options that were used to create this regular expression. */\n    public actual val options: Set<RegexOption> = options.toSet()\n    private val nativePattern: RegExp = RegExp(pattern, options.map { it.value }.joinToString(separator = \"\") + \"g\")\n\n    /** Indicates whether the regular expression matches the entire [input]. */\n    public actual infix fun matches(input: CharSequence): Boolean {\n        nativePattern.reset()\n        val match = nativePattern.exec(input.toString())\n        return match != null && match.index == 0 && nativePattern.lastIndex == input.length\n    }\n\n    /** Indicates whether the regular expression can find at least one match in the specified [input]. */\n    public actual fun containsMatchIn(input: CharSequence): Boolean {\n        nativePattern.reset()\n        return nativePattern.test(input.toString())\n    }\n\n    /** Returns the first match of a regular expression in the [input], beginning at the specified [startIndex].\n     *\n     * @param startIndex An index to start search with, by default 0. Must be not less than zero and not greater than `input.length()`\n     * @return An instance of [MatchResult] if match was found or `null` otherwise.\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun find(input: CharSequence, startIndex: Int = 0): MatchResult? {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return nativePattern.findNext(input.toString(), startIndex)\n    }\n\n    /**\n     * Returns a sequence of all occurrences of a regular expression within the [input] string, beginning at the specified [startIndex].\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     *\n     * @sample samples.text.Regexps.findAll\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence<MatchResult> {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return generateSequence({ find(input, startIndex) }, { match -> match.next() })\n    }\n\n    /**\n     * Attempts to match the entire [input] CharSequence against the pattern.\n     *\n     * @return An instance of [MatchResult] if the entire input matches or `null` otherwise.\n     */\n    public actual fun matchEntire(input: CharSequence): MatchResult? {\n        if (pattern.startsWith('^') && pattern.endsWith('$'))\n            return find(input)\n        else\n            return Regex(\"^${pattern.trimStart('^').trimEnd('$')}$\", options).find(input)\n    }\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replace(input: CharSequence, replacement: String): String = input.toString().nativeReplace(nativePattern, replacement)\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with the result of\n     * the given function [transform] that takes [MatchResult] and returns a string to be used as a\n     * replacement for that match.\n     */\n    public actual inline fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String {\n        var match = find(input)\n        if (match == null) return input.toString()\n\n        var lastStart = 0\n        val length = input.length\n        val sb = StringBuilder(length)\n        do {\n            val foundMatch = match!!\n            sb.append(input, lastStart, foundMatch.range.start)\n            sb.append(transform(foundMatch))\n            lastStart = foundMatch.range.endInclusive + 1\n            match = foundMatch.next()\n        } while (lastStart < length && match != null)\n\n        if (lastStart < length) {\n            sb.append(input, lastStart, length)\n        }\n\n        return sb.toString()\n    }\n\n    /**\n     * Replaces the first occurrence of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replaceFirst(input: CharSequence, replacement: String): String {\n        val nonGlobalOptions = options.map { it.value }.joinToString(separator = \"\")\n        return input.toString().nativeReplace(RegExp(pattern, nonGlobalOptions), replacement)\n    }\n\n    /**\n     * Splits the [input] CharSequence around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun split(input: CharSequence, limit: Int = 0): List<String> {\n        require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n        val matches = findAll(input).let { if (limit == 0) it else it.take(limit - 1) }\n        val result = mutableListOf<String>()\n        var lastStart = 0\n\n        for (match in matches) {\n            result.add(input.subSequence(lastStart, match.range.start).toString())\n            lastStart = match.range.endInclusive + 1\n        }\n        result.add(input.subSequence(lastStart, input.length).toString())\n        return result\n    }\n\n\n    /**\n     * Returns the string representation of this regular expression, namely the [pattern] of this regular expression.\n     *\n     * Note that another regular expression constructed from the same pattern string may have different [options]\n     * and may match strings differently.\n     */\n    public override fun toString(): String = nativePattern.toString()\n\n    actual companion object {\n        /**\n         * Returns a regular expression that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun fromLiteral(literal: String): Regex = Regex(escape(literal))\n\n        /**\n         * Returns a regular expression pattern string that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun escape(literal: String): String = literal.nativeReplace(patternEscape, \"\\\\$&\")\n\n        /**\n         * Returns a literal replacement expression for the specified [literal] string.\n         * No characters of that string will have special meaning when it is used as a replacement string in [Regex.replace] function.\n         */\n        public actual fun escapeReplacement(literal: String): String = literal.nativeReplace(replacementEscape, \"$$$$\")\n\n        private val patternEscape = RegExp(\"\"\"[-\\\\^$*+?.()|[\\]{}]\"\"\", \"g\")\n        private val replacementEscape = RegExp(\"\"\"\\$\"\"\", \"g\")\n    }\n}\n\n/** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_sb3q2\\$\")\npublic fun Regex_0(pattern: String, option: RegexOption): Regex = Regex(pattern, setOf(option))\n\n/** Creates a regular expression from the specified [pattern] string and the default options.  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_61zpoe\\$\")\npublic fun Regex_1(pattern: String): Regex = Regex(pattern, emptySet())\n\n\n\n\nprivate fun RegExp.findNext(input: String, from: Int): MatchResult? {\n    this.lastIndex = from\n    val match = exec(input)\n    if (match == null) return null\n    val range = match.index..lastIndex - 1\n\n    return object : MatchResult {\n        override val range: IntRange = range\n        override val value: String\n            get() = match[0]!!\n\n        override val groups: MatchGroupCollection = object : MatchGroupCollection, AbstractCollection<MatchGroup?>() {\n            override val size: Int get() = match.length\n            override fun iterator(): Iterator<MatchGroup?> = indices.asSequence().map { this[it] }.iterator()\n            override fun get(index: Int): MatchGroup? = match[index]?.let { MatchGroup(it) }\n        }\n\n\n        private var groupValues_: List<String>? = null\n\n        override val groupValues: List<String>\n            get() {\n                if (groupValues_ == null) {\n                    groupValues_ = object : AbstractList<String>() {\n                        override val size: Int get() = match.length\n                        override fun get(index: Int): String = match[index] ?: \"\"\n                    }\n                }\n                return groupValues_!!\n            }\n\n        override fun next(): MatchResult? = this@findNext.findNext(input, if (range.isEmpty()) range.start + 1 else range.endInclusive + 1)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\npublic fun String.matches(regex: String): Boolean {\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || (if (this is String) this else this.toString()).matches(\"^[\\\\s\\\\xA0]+$\")\n\n@OptIn(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean =\n    if (this == null)\n        other == null\n    else if (!ignoreCase)\n        this == other\n    else\n        other != null && this.lowercase() == other.lowercase()\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toUpperCase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toLowerCase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gi\" else \"g\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gi\" else \"g\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"i\" else \"\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"i\" else \"\"), newChar.toString())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic actual enum class DurationUnit(internal val scale: Double) {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS(1e0),\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS(1e3),\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS(1e6),\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS(1e9),\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES(60e9),\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS(3600e9),\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS(86400e9);\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal actual fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> value * (sourceUnit.scale / targetUnit.scale)\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale)\n        else -> value\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport org.w3c.performance.GlobalPerformance\nimport org.w3c.performance.Performance\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal actual object MonotonicTimeSource : TimeSource {\n\n    private val actualSource: TimeSource = run {\n        val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n\n        if (isNode)\n            HrTimeSource(js(\"process\").unsafeCast<Process>())\n        else\n            js(\"self\").unsafeCast<GlobalPerformance?>()?.performance?.let(::PerformanceTimeSource)\n                ?: DateNowTimeSource\n\n    }\n\n    override fun markNow(): TimeMark = actualSource.markNow()\n}\n\ninternal external interface Process {\n    fun hrtime(time: Array<Double> = definedExternally): Array<Double>\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal class HrTimeSource(val process: Process) : TimeSource {\n\n    override fun markNow(): TimeMark = object : TimeMark() {\n        val startedAt = process.hrtime()\n        override fun elapsedNow(): Duration =\n            process.hrtime(startedAt).let { (seconds, nanos) -> seconds.seconds + nanos.nanoseconds }\n    }\n\n    override fun toString(): String = \"TimeSource(process.hrtime())\"\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal class PerformanceTimeSource(val performance: Performance) : AbstractDoubleTimeSource(unit = DurationUnit.MILLISECONDS) {\n    override fun read(): Double = performance.now()\n    override fun toString(): String = \"TimeSource(self.performance.now())\"\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal object DateNowTimeSource : AbstractDoubleTimeSource(unit = DurationUnit.MILLISECONDS) {\n    override fun read(): Double = kotlin.js.Date.now()\n    override fun toString(): String = \"TimeSource(Date.now())\"\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.js.json\nimport kotlin.math.*\n\ninternal actual fun formatToExactDecimals(value: Double, decimals: Int): String {\n    val rounded = if (decimals == 0) {\n        value\n    } else {\n        val pow = 10.0.pow(decimals)\n        @Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\n        kotlin.js.Math.round(abs(value) * pow) / pow * sign(value)\n    }\n    return rounded.asDynamic().toFixed(decimals).unsafeCast<String>()\n}\n\ninternal actual fun formatUpToDecimals(value: Double, decimals: Int): String {\n    return value.asDynamic().toLocaleString(\"en-us\", json(\"maximumFractionDigits\" to decimals)).unsafeCast<String>()\n}\n\ninternal actual fun formatScientific(value: Double): String {\n    return value.asDynamic().toExponential(2).unsafeCast<String>()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] that wraps each element produced by the original iterator\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(checkIndexOverflow(index++), iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'sequence { }' function instead.\", ReplaceWith(\"sequence(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildSequence(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(builderAction) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'iterator { }' function instead.\", ReplaceWith(\"iterator(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildIterator(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Iterator<T> = iterator(builderAction)\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\n@Deprecated(\"Use SequenceScope class instead.\", ReplaceWith(\"SequenceScope<T>\"), level = DeprecationLevel.ERROR)\npublic typealias SequenceBuilder<T> = SequenceScope<T>\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     *\n     * @sample samples.random.Randoms.nextBits\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextInt\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextLong\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + nextInt()\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     *\n     * @sample samples.random.Randoms.nextBoolean\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextDouble\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextFloat\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random() {\n\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray = defaultRandom.nextBytes(array, fromIndex, toIndex)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\n@OptIn(ExperimentalStdlibApi::class)\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom\ninternal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random() {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmStatic\n\n\n\n/**\n * Represents a type projection. Type projection is usually the argument to another type in a type usage.\n * For example, in the type `Array<out Number>`, `out Number` is the covariant projection of the type represented by the class `Number`.\n *\n * Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.\n *\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#type-projections)\n * for more information.\n */\n@SinceKotlin(\"1.1\")\npublic data class KTypeProjection constructor(\n    /**\n     * The use-site variance specified in the projection, or `null` if this is a star projection.\n     */\n    public val variance: KVariance?,\n    /**\n     * The type specified in the projection, or `null` if this is a star projection.\n     */\n    public val type: KType?\n) {\n\n    init {\n        require((variance == null) == (type == null)) {\n            if (variance == null)\n                \"Star projection must have no type specified.\"\n            else\n                \"The projection variance $variance requires type to be specified.\"\n        }\n    }\n\n    override fun toString(): String = when (variance) {\n        null -> \"*\"\n        KVariance.INVARIANT -> type.toString()\n        KVariance.IN -> \"in $type\"\n        KVariance.OUT -> \"out $type\"\n    }\n\n    public companion object {\n        // provided for compiler access\n        @JvmField\n        @PublishedApi\n        internal val star: KTypeProjection = KTypeProjection(null, null)\n\n        /**\n         * Star projection, denoted by the `*` character.\n         * For example, in the type `KClass<*>`, `*` is the star projection.\n         * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#star-projections)\n         * for more information.\n         */\n        public val STAR: KTypeProjection get() = star\n\n        /**\n         * Creates an invariant projection of a given type. Invariant projection is just the type itself,\n         * without any use-site variance modifiers applied to it.\n         * For example, in the type `Set<String>`, `String` is an invariant projection of the type represented by the class `String`.\n         */\n        @JvmStatic\n        public fun invariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.INVARIANT, type)\n\n        /**\n         * Creates a contravariant projection of a given type, denoted by the `in` modifier applied to a type.\n         * For example, in the type `MutableList<in Number>`, `in Number` is a contravariant projection of the type of class `Number`.\n         */\n        @JvmStatic\n        public fun contravariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.IN, type)\n\n        /**\n         * Creates a covariant projection of a given type, denoted by the `out` modifier applied to a type.\n         * For example, in the type `Array<out Number>`, `out Number` is a covariant projection of the type of class `Number`.\n         */\n        @JvmStatic\n        public fun covariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.OUT, type)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\n/**\n * Represents variance applied to a type parameter on the declaration site (*declaration-site variance*),\n * or to a type in a projection (*use-site variance*).\n *\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#variance)\n * for more information.\n *\n * @see [KTypeParameter.variance]\n * @see [KTypeProjection]\n */\n@SinceKotlin(\"1.1\")\nenum class KVariance {\n    /**\n     * The affected type parameter or type is *invariant*, which means it has no variance applied to it.\n     */\n    INVARIANT,\n\n    /**\n     * The affected type parameter or type is *contravariant*. Denoted by the `in` modifier in the source code.\n     */\n    IN,\n\n    /**\n     * The affected type parameter or type is *covariant*. Denoted by the `out` modifier in the source code.\n     */\n    OUT,\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if the Char is one of the ASCII decimal digits '0' through '9'.\n * In this case, `this.code - '0'.code` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToInt(): Int {\n    if (this in '0'..'9') {\n        return this - '0'\n    }\n    throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - The Char is one of the ASCII decimal digits '0' through '9' and its [code] is less than `radix + '0'.code`. In this case, `this.code - '0'.code` is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if the Char is one of the ASCII decimal digits '0' through '9'.\n * In this case, `this.code - '0'.code` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToIntOrNull(): Int? {\n    if (this in '0'..'9') {\n        return this - '0'\n    }\n    return null\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - The Char is one of the ASCII decimal digits '0' through '9' and its [code] is less than `radix + '0'.code`. In this case, `this.code - '0'.code` is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this in '0'..'9') {\n        val digit = this - '0'\n        return if (digit < radix) digit else null\n    }\n    val a = if (this <= 'Z') 'A' else 'a'\n    val digit = 10 + (this - a)\n    return if (digit in 10 until radix) digit else null\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@ExperimentalStdlibApi\n@SinceKotlin(\"1.4\")\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun Char.uppercase(): String\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n *\n * Two characters are considered the same ignoring case if at least one of the following is `true`:\n *   - The two characters are the same (as compared by the == operator)\n *   - Applying the method [uppercaseChar] to each character produces the same result\n *   - Applying the method [lowercaseChar] to each character produces the same result\n *\n * @sample samples.text.Chars.equals\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    if (this.uppercaseChar() == other.uppercaseChar()) return true\n    if (this.lowercaseChar() == other.lowercaseChar()) return true\n    return false\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2 — of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2] — of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.math.abs\n\n@OptIn(ExperimentalTime::class)\nprivate inline val storageUnit get() = DurationUnit.NANOSECONDS\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inHours], [inMinutes], [inSeconds], [inNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\npublic inline class Duration internal constructor(internal val value: Double) : Comparable<Duration> {\n// TODO: backend fails on init block, wait for KT-28055\n\n//    init {\n//        require(_value.isNaN().not())\n//    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0.0)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = Duration(Double.POSITIVE_INFINITY)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = Duration(-value)\n\n    /** Returns a duration whose value is the sum of this and [other] duration values. */\n    public operator fun plus(other: Duration): Duration = Duration(value + other.value)\n\n    /** Returns a duration whose value is the difference between this and [other] duration values. */\n    public operator fun minus(other: Duration): Duration = Duration(value - other.value)\n\n    /** Returns a duration whose value is this duration value multiplied by the given [scale] number. */\n    public operator fun times(scale: Int): Duration = Duration(value * scale)\n\n    /** Returns a duration whose value is this duration value multiplied by the given [scale] number. */\n    public operator fun times(scale: Double): Duration = Duration(value * scale)\n\n    /** Returns a duration whose value is this duration value divided by the given [scale] number. */\n    public operator fun div(scale: Int): Duration = Duration(value / scale)\n\n    /** Returns a duration whose value is this duration value divided by the given [scale] number. */\n    public operator fun div(scale: Double): Duration = Duration(value / scale)\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double = this.value / other.value\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = value < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = value > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = value.isInfinite()\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = value.isFinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int = this.value.compareTo(other.value)\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inDays.toInt(), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inHours.toInt(), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inMinutes.toInt(), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inSeconds.toLong(), nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int get() = (inHours % 24).toInt()\n    @PublishedApi\n    internal val minutesComponent: Int get() = (inMinutes % 60).toInt()\n    @PublishedApi\n    internal val secondsComponent: Int get() = (inSeconds % 60).toInt()\n    @PublishedApi\n    internal val nanosecondsComponent: Int get() = (inNanoseconds % 1e9).toInt()\n\n\n    // conversion to units\n\n    /** Returns the value of this duration expressed as a [Double] number of the specified [unit]. */\n    public fun toDouble(unit: DurationUnit): Double = convertDurationUnit(value, storageUnit, unit)\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     */\n    public fun toLong(unit: DurationUnit): Long = toDouble(unit).toLong()\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the value doesn't fit in the range of [Int] type, it is coerced into that range, see the conversion [Double.toInt] for details.\n     */\n    public fun toInt(unit: DurationUnit): Int = toDouble(unit).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately ±292 years.\n     */\n    public fun toLongNanoseconds(): Long = toLong(DurationUnit.NANOSECONDS)\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately ±292 million years.\n     */\n    public fun toLongMilliseconds(): Long = toLong(DurationUnit.MILLISECONDS)\n\n    /**\n     * Returns a string representation of this duration value expressed in the unit which yields the most compact and readable number value.\n     *\n     * Special cases:\n     *  - zero duration is formatted as `\"0s\"`\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *  - very small durations (less than 1e-15 s) are expressed in seconds and formatted in scientific notation\n     *  - very big durations (more than 1e+7 days) are expressed in days and formatted in scientific notation\n     *\n     * @return the value of duration in the automatically determined unit followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when {\n        isInfinite() -> value.toString()\n        value == 0.0 -> \"0s\"\n        else -> {\n            val absNs = absoluteValue.inNanoseconds\n            var scientific = false\n            var maxDecimals = 0\n            val unit = when {\n                absNs < 1e-6 -> DurationUnit.SECONDS.also { scientific = true }\n                absNs < 1 -> DurationUnit.NANOSECONDS.also { maxDecimals = 7 }\n                absNs < 1e3 -> DurationUnit.NANOSECONDS\n                absNs < 1e6 -> DurationUnit.MICROSECONDS\n                absNs < 1e9 -> DurationUnit.MILLISECONDS\n                absNs < 1000e9 -> DurationUnit.SECONDS\n                absNs < 60_000e9 -> DurationUnit.MINUTES\n                absNs < 3600_000e9 -> DurationUnit.HOURS\n                absNs < 86400e9 * 1e7 -> DurationUnit.DAYS\n                else -> DurationUnit.DAYS.also { scientific = true }\n            }\n            val value = toDouble(unit)\n            when {\n                scientific -> formatScientific(value)\n                maxDecimals > 0 -> formatUpToDecimals(value, maxDecimals)\n                else -> formatToExactDecimals(value, precision(abs(value)))\n            } + unit.shortName()\n        }\n    }\n\n    private fun precision(value: Double): Int = when {\n        value < 1 -> 3\n        value < 10 -> 2\n        value < 100 -> 1\n        else -> 0\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        if (isInfinite()) return value.toString()\n        val number = toDouble(unit)\n        return when {\n            abs(number) < 1e14 -> formatToExactDecimals(number, decimals.coerceAtMost(12))\n            else -> formatScientific(number)\n        } + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            val hasHours = hours != 0\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                append(seconds)\n                if (nanoseconds != 0) {\n                    append('.')\n                    val nss = nanoseconds.toString().padStart(9, '0')\n                    when {\n                        nanoseconds % 1_000_000 == 0 -> appendRange(nss, 0, 3)\n                        nanoseconds % 1_000 == 0 -> appendRange(nss, 0, 6)\n                        else -> append(nss)\n                    }\n                }\n                append('S')\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration = toDouble().toDuration(unit)\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration = toDouble().toDuration(unit)\n\n/** Returns a [Duration] equal to this [Double] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration = Duration(convertDurationUnit(this, unit, storageUnit))\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Double] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Double] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Double] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\ninternal expect fun formatScientific(value: Double): String","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass()\n@file:kotlin.jvm.JvmName(\"DurationUnitKt\")\n\npackage kotlin.time\n\n\n/**\n * The list of possible time measurement units, in which a duration can be expressed.\n *\n * The smallest time unit is [NANOSECONDS] and the largest is [DAYS], which corresponds to exactly 24 [HOURS].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic expect enum class DurationUnit {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS,\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS,\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS,\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS,\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES,\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS,\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS;\n}\n\n/** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal expect fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double\n\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal fun DurationUnit.shortName(): String = when (this) {\n    DurationUnit.NANOSECONDS -> \"ns\"\n    DurationUnit.MICROSECONDS -> \"us\"\n    DurationUnit.MILLISECONDS -> \"ms\"\n    DurationUnit.SECONDS -> \"s\"\n    DurationUnit.MINUTES -> \"m\"\n    DurationUnit.HOURS -> \"h\"\n    DurationUnit.DAYS -> \"d\"\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n/**\n * A source of time for measuring time intervals.\n *\n * The only operation provided by the time source is [markNow]. It returns a [TimeMark], which can be used to query the elapsed time later.\n *\n * @see [measureTime]\n * @see [measureTimedValue]\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic interface TimeSource {\n    /**\n     * Marks a point in time on this time source.\n     *\n     * The returned [TimeMark] instance encapsulates the captured time point and allows querying\n     * the duration of time interval [elapsed][TimeMark.elapsedNow] from that point.\n     */\n    public fun markNow(): TimeMark\n\n    /**\n     * The most precise time source available in the platform.\n     *\n     * This time source returns its readings from a source of monotonic time when it is available in a target platform,\n     * and resorts to a non-monotonic time source otherwise.\n     */\n    public object Monotonic : TimeSource by MonotonicTimeSource {\n        override fun toString(): String = MonotonicTimeSource.toString()\n    }\n\n\n    public companion object {\n\n    }\n}\n\n/**\n * Represents a time point notched on a particular [TimeSource]. Remains bound to the time source it was taken from\n * and allows querying for the duration of time elapsed from that point (see the function [elapsedNow]).\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class TimeMark {\n    /**\n     * Returns the amount of time passed from this mark measured with the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     */\n    public abstract fun elapsedNow(): Duration\n\n    /**\n     * Returns a time mark on the same time source that is ahead of this time mark by the specified [duration].\n     *\n     * The returned time mark is more _late_ when the [duration] is positive, and more _early_ when the [duration] is negative.\n     */\n    public open operator fun plus(duration: Duration): TimeMark = AdjustedTimeMark(this, duration)\n\n    /**\n     * Returns a time mark on the same time source that is behind this time mark by the specified [duration].\n     *\n     * The returned time mark is more _early_ when the [duration] is positive, and more _late_ when the [duration] is negative.\n     */\n    public open operator fun minus(duration: Duration): TimeMark = plus(-duration)\n\n\n    /**\n     * Returns true if this time mark has passed according to the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     * If the time source is monotonic, it can change only from `false` to `true`, namely, when the time mark becomes behind the current point of the time source.\n     */\n    public fun hasPassedNow(): Boolean = !elapsedNow().isNegative()\n\n    /**\n     * Returns false if this time mark has not passed according to the time source from which this mark was taken.\n     *\n     * Note that the value returned by this function can change on subsequent invocations.\n     * If the time source is monotonic, it can change only from `true` to `false`, namely, when the time mark becomes behind the current point of the time source.\n     */\n    public fun hasNotPassedNow(): Boolean = elapsedNow().isNegative()\n}\n\n\n@ExperimentalTime\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Deprecated(\n    \"Subtracting one TimeMark from another is not a well defined operation because these time marks could have been obtained from the different time sources.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline operator fun TimeMark.minus(other: TimeMark): Duration = throw Error(\"Operation is disallowed.\")\n\n@ExperimentalTime\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Deprecated(\n    \"Comparing one TimeMark to another is not a well defined operation because these time marks could have been obtained from the different time sources.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline operator fun TimeMark.compareTo(other: TimeMark): Int = throw Error(\"Operation is disallowed.\")\n\n\n@ExperimentalTime\nprivate class AdjustedTimeMark(val mark: TimeMark, val adjustment: Duration) : TimeMark() {\n    override fun elapsedNow(): Duration = mark.elapsedNow() - adjustment\n\n    override fun plus(duration: Duration): TimeMark = AdjustedTimeMark(mark, adjustment + duration)\n}\n\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TimeSource interface instead.\", ReplaceWith(\"TimeSource\", \"kotlin.time.TimeSource\"), DeprecationLevel.ERROR)\npublic typealias Clock = TimeSource\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TimeMark class instead.\", ReplaceWith(\"TimeMark\", \"kotlin.time.TimeMark\"), DeprecationLevel.ERROR)\npublic typealias ClockMark = TimeMark\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\ninternal expect object MonotonicTimeSource : TimeSource\n\n/**\n * An abstract class used to implement time sources that return their readings as [Long] values in the specified [unit].\n *\n * @property unit The unit in which this time source's readings are expressed.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class AbstractLongTimeSource(protected val unit: DurationUnit) : TimeSource {\n    /**\n     * This protected method should be overridden to return the current reading of the time source expressed as a [Long] number\n     * in the unit specified by the [unit] property.\n     */\n    protected abstract fun read(): Long\n\n    private class LongTimeMark(private val startedAt: Long, private val timeSource: AbstractLongTimeSource, private val offset: Duration) : TimeMark() {\n        override fun elapsedNow(): Duration = (timeSource.read() - startedAt).toDuration(timeSource.unit) - offset\n        override fun plus(duration: Duration): TimeMark = LongTimeMark(startedAt, timeSource, offset + duration)\n    }\n\n    override fun markNow(): TimeMark = LongTimeMark(read(), this, Duration.ZERO)\n}\n\n/**\n * An abstract class used to implement time sources that return their readings as [Double] values in the specified [unit].\n *\n * @property unit The unit in which this time source's readings are expressed.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic abstract class AbstractDoubleTimeSource(protected val unit: DurationUnit) : TimeSource {\n    /**\n     * This protected method should be overridden to return the current reading of the time source expressed as a [Double] number\n     * in the unit specified by the [unit] property.\n     */\n    protected abstract fun read(): Double\n\n    private class DoubleTimeMark(private val startedAt: Double, private val timeSource: AbstractDoubleTimeSource, private val offset: Duration) : TimeMark() {\n        override fun elapsedNow(): Duration = (timeSource.read() - startedAt).toDuration(timeSource.unit) - offset\n        override fun plus(duration: Duration): TimeMark = DoubleTimeMark(startedAt, timeSource, offset + duration)\n    }\n\n    override fun markNow(): TimeMark = DoubleTimeMark(read(), this, Duration.ZERO)\n}\n\n/**\n * A time source that has programmatically updatable readings. It is useful as a predictable source of time in tests.\n *\n * The current reading value can be advanced by the specified duration amount with the operator [plusAssign]:\n *\n * ```\n * val timeSource = TestTimeSource()\n * timeSource += 10.seconds\n * ```\n *\n * Implementation note: the current reading value is stored as a [Long] number of nanoseconds,\n * thus it's capable to represent a time range of approximately ±292 years.\n * Should the reading value overflow as the result of [plusAssign] operation, an [IllegalStateException] is thrown.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic class TestTimeSource : AbstractLongTimeSource(unit = DurationUnit.NANOSECONDS) {\n    private var reading: Long = 0L\n\n    override fun read(): Long = reading\n\n    /**\n     * Advances the current reading value of this time source by the specified [duration].\n     *\n     * [duration] value is rounded down towards zero when converting it to a [Long] number of nanoseconds.\n     * For example, if the duration being added is `0.6.nanoseconds`, the reading doesn't advance because\n     * the duration value is rounded to zero nanoseconds.\n     *\n     * @throws IllegalStateException when the reading value overflows as the result of this operation.\n     */\n    public operator fun plusAssign(duration: Duration) {\n        val delta = duration.toDouble(unit)\n        val longDelta = delta.toLong()\n        reading = if (longDelta != Long.MIN_VALUE && longDelta != Long.MAX_VALUE) {\n            // when delta fits in long, add it as long\n            val newReading = reading + longDelta\n            if (reading xor longDelta >= 0 && reading xor newReading < 0) overflow(duration)\n            newReading\n        } else {\n            // when delta is greater than long, add it as double\n            val newReading = reading + delta\n            if (newReading > Long.MAX_VALUE || newReading < Long.MIN_VALUE) overflow(duration)\n            newReading.toLong()\n        }\n    }\n\n    private fun overflow(duration: Duration) {\n        throw IllegalStateException(\"TestTimeSource will overflow if its reading ${reading}ns is advanced by $duration.\")\n    }\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TimeSource.Monotonic instead.\", ReplaceWith(\"TimeSource.Monotonic\", \"kotlin.time.TimeSource\"), DeprecationLevel.ERROR)\npublic typealias MonoClock = TimeSource.Monotonic\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use AbstractLongTimeSource instead.\", ReplaceWith(\"AbstractLongTimeSource\", \"kotlin.time.AbstractLongTimeSource\"), DeprecationLevel.ERROR)\npublic typealias AbstractLongClock = AbstractLongTimeSource\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use AbstractDoubleTimeSource instead.\", ReplaceWith(\"AbstractDoubleTimeSource\", \"kotlin.time.AbstractDoubleTimeSource\"), DeprecationLevel.ERROR)\npublic typealias AbstractDoubleClock = AbstractDoubleTimeSource\n\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use TestTimeSource instead.\", ReplaceWith(\"TestTimeSource\", \"kotlin.time.TestTimeSource\"), DeprecationLevel.ERROR)\npublic typealias TestClock = TestTimeSource\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return TimeSource.Monotonic.measureTime(block)\n}\n\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun TimeSource.measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    block()\n    return mark.elapsedNow()\n}\n\n\n/**\n * Data class representing a result of executing an action, along with the duration of elapsed time interval.\n *\n * @property value the result of the action.\n * @property duration the time elapsed to execute the action.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic data class TimedValue<T>(val value: T, val duration: Duration)\n\n/**\n * Executes the given function [block] and returns an instance of [TimedValue] class, containing both\n * the result of the function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return TimeSource.Monotonic.measureTimedValue(block)\n}\n\n/**\n * Executes the given [block] and returns an instance of [TimedValue] class, containing both\n * the result of function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> TimeSource.measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    val result = block()\n    return TimedValue(result, mark.elapsedNow())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `UInt`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic class UIntRange(start: UInt, endInclusive: UInt) : UIntProgression(start, endInclusive, 1), ClosedRange<UInt> {\n    override val start: UInt get() = first\n    override val endInclusive: UInt get() = last\n\n    override fun contains(value: UInt): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type UInt. */\n        public val EMPTY: UIntRange = UIntRange(UInt.MAX_VALUE, UInt.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `UInt`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic open class UIntProgression\ninternal constructor(\n    start: UInt,\n    endInclusive: UInt,\n    step: Int\n) : Iterable<UInt> {\n    init {\n        if (step == 0.toInt()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: UInt = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: UInt = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): UIntIterator = UIntProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step.toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates UIntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression = UIntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `UInt`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\nprivate class UIntProgressionIterator(first: UInt, last: UInt, step: Int) : UIntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toUInt() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextUInt(): UInt {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `UByte`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class UByteIterator : Iterator<UByte> {\n    override final fun next() = nextUByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUByte(): UByte\n}\n\n/** An iterator over a sequence of values of type `UShort`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class UShortIterator : Iterator<UShort> {\n    override final fun next() = nextUShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUShort(): UShort\n}\n\n/** An iterator over a sequence of values of type `UInt`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class UIntIterator : Iterator<UInt> {\n    override final fun next() = nextUInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUInt(): UInt\n}\n\n/** An iterator over a sequence of values of type `ULong`. */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic abstract class ULongIterator : Iterator<ULong> {\n    override final fun next() = nextULong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextULong(): ULong\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `ULong`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic class ULongRange(start: ULong, endInclusive: ULong) : ULongProgression(start, endInclusive, 1), ClosedRange<ULong> {\n    override val start: ULong get() = first\n    override val endInclusive: ULong get() = last\n\n    override fun contains(value: ULong): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type ULong. */\n        public val EMPTY: ULongRange = ULongRange(ULong.MAX_VALUE, ULong.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `ULong`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic open class ULongProgression\ninternal constructor(\n    start: ULong,\n    endInclusive: ULong,\n    step: Long\n) : Iterable<ULong> {\n    init {\n        if (step == 0.toLong()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: ULong = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: ULong = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): ULongIterator = ULongProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt()) + (step xor (step ushr 32)).toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates ULongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression = ULongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `ULong`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\nprivate class ULongProgressionIterator(first: ULong, last: ULong, step: Long) : ULongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toULong() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextULong(): ULong {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:OptIn(ExperimentalUnsignedTypes::class)\npackage kotlin.internal\n\n// (a - b) mod c\nprivate fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\nprivate fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toUInt())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toUInt())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toULong())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toULong())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"UStringsKt\")  // string representation of unsigned numbers\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UByte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UShort.toString(radix: Int): String = this.toInt().toString(radix)\n\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UInt.toString(radix: Int): String = this.toLong().toString(radix)\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULong.toString(radix: Int): String = ulongToString(this.toLong(), checkRadix(radix))\n\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByte(): UByte = toUByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByte(radix: Int): UByte = toUByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShort(): UShort = toUShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShort(radix: Int): UShort = toUShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUInt(): UInt = toUIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUInt(radix: Int): UInt = toUIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULong(): ULong = toULongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULong(radix: Int): ULong = toULongOrNull(radix) ?: numberFormatError(this)\n\n\n\n\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByteOrNull(): UByte? = toUByteOrNull(radix = 10)\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUByteOrNull(radix: Int): UByte? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UByte.MAX_VALUE) return null\n    return int.toUByte()\n}\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShortOrNull(): UShort? = toUShortOrNull(radix = 10)\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUShortOrNull(radix: Int): UShort? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UShort.MAX_VALUE) return null\n    return int.toUShort()\n}\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUIntOrNull(): UInt? = toUIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toUIntOrNull(radix: Int): UInt? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: UInt = UInt.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n    val limitForMaxRadix = 119304647u  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toUInt()\n    var result = 0u\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULongOrNull(): ULong? = toULongOrNull(radix = 10)\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun String.toULongOrNull(radix: Int): ULong? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: ULong = ULong.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n\n    val limitForMaxRadix = 512409557603043100uL  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toULong()\n    var result = 0uL\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.reflect.KClass\n\n@PublishedApi\ninternal fun <T : Annotation> KClass<*>.findAssociatedObject(@Suppress(\"UNUSED_PARAMETER\") annotationClass: KClass<T>): Any? {\n    // This API is not supported in js-v1. Return `null` to be source-compatible with js-ir.\n    return null\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport getKClass\nimport kotlin.reflect.KClass\nimport kotlin.reflect.js.internal.KClassImpl\n\n/**\n * Represents the constructor of a class. Instances of `JsClass` can be passed to JavaScript APIs that expect a constructor reference.\n */\nexternal interface JsClass<T : Any> {\n    /**\n     * Returns the unqualified name of the class represented by this instance.\n     */\n    val name: String\n}\n\n/**\n * Obtains a constructor reference for the given `KClass`.\n */\nval <T : Any> KClass<T>.js: JsClass<T>\n    get() = (this as KClassImpl<T>).jClass\n\n/**\n * Obtains a `KClass` instance for the given constructor reference.\n */\nval <T : Any> JsClass<T>.kotlin: KClass<T>\n    get() = getKClass(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n// TODO: Remove once JsReflectionAPICallChecker supports more reflection types\n@file:Suppress(\"Unsupported\")\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"createKType\")\ninternal fun createKType(\n    classifier: KClassifier,\n    arguments: Array<KTypeProjection>,\n    isMarkedNullable: Boolean\n) =\n    KTypeImpl(classifier, arguments.asList(), isMarkedNullable)\n\n@JsName(\"createDynamicKType\")\ninternal fun createDynamicKType(): KType = DynamicKType\n\n@JsName(\"markKTypeNullable\")\ninternal fun markKTypeNullable(kType: KType) = KTypeImpl(kType.classifier!!, kType.arguments, true)\n\n@JsName(\"createKTypeParameter\")\ninternal fun createKTypeParameter(\n    name: String,\n    upperBounds: Array<KType>,\n    variance: String\n): KTypeParameter {\n    val kVariance = when (variance) {\n        \"in\" -> KVariance.IN\n        \"out\" -> KVariance.OUT\n        else -> KVariance.INVARIANT\n    }\n\n    return KTypeParameterImpl(name, upperBounds.asList(), kVariance, false)\n}\n\n@JsName(\"getStarKTypeProjection\")\ninternal fun getStarKTypeProjection(): KTypeProjection =\n    KTypeProjection.STAR\n\n@JsName(\"createCovariantKTypeProjection\")\ninternal fun createCovariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.covariant(type)\n\n@JsName(\"createInvariantKTypeProjection\")\ninternal fun createInvariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.invariant(type)\n\n@JsName(\"createContravariantKTypeProjection\")\ninternal fun createContravariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.contravariant(type)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MathKt\")\n\n\npackage kotlin.math\n\n\n\n// constants, can't use them from nativeMath as they are not constants there\n\n/** Ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n@SinceKotlin(\"1.2\")\npublic const val PI: Double = 3.141592653589793\n/** Base of the natural logarithms, approximately 2.71828. */\n@SinceKotlin(\"1.2\")\npublic const val E: Double = 2.718281828459045\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Double): Double\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Double): Double\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Double): Double\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Double): Double\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Double): Double\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Double): Double\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Double, x: Double): Double\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Double): Double\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Double): Double\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Double): Double\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Double, y: Double): Double\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Double): Double\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Double): Double\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Double): Double\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Double, base: Double): Double\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Double): Double\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Double): Double\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Double): Double\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Double): Double\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Double): Double\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Double): Double\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Double): Double\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Double, b: Double): Double\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Double, b: Double): Double\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(x: Double): Double\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(n: Int): Double\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.absoluteValue: Double\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.sign: Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Double): Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Int): Double\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.ulp: Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextUp(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextDown(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextTowards(to: Double): Double\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToInt(): Int\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToLong(): Long\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Float): Float\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Float): Float\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Float): Float\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Float): Float\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Float): Float\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Float): Float\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Float, x: Float): Float\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Float): Float\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Float): Float\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Float): Float\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Float, y: Float): Float\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Float): Float\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Float): Float\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Float): Float\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Float, base: Float): Float\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Float): Float\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Float): Float\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Float): Float\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Float): Float\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Float): Float\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Float): Float\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Float): Float\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Float, b: Float): Float\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Float, b: Float): Float\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(x: Float): Float\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(n: Int): Float\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.absoluteValue: Float\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.sign: Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Float): Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Int): Float\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToInt(): Int\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToLong(): Long\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Int): Int\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Int, b: Int): Int\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Int, b: Int): Int\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.absoluteValue: Int\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.sign: Int\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Long): Long\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Long, b: Long): Long\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Long, b: Long): Long\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.absoluteValue: Long\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.sign: Int\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].toInt()\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].toInt()\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces [StackOverflowError] because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\n@ExperimentalStdlibApi\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\n@ExperimentalStdlibApi\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n",null,null,null,null,null,null,null,null,"package world.phantasmal.core\n\nimport mu.KLogger\n\nsealed class PwResult<out T>(val problems: List<Problem>) {\n    fun getOrNull(): T? = when (this) {\n        is Success -> value\n        is Failure -> null\n    }\n\n    fun unwrap(): T = when (this) {\n        is Success -> value\n        is Failure -> error(problems.joinToString(\"\\n\") { \"[${it.severity}] ${it.uiMessage}\" })\n    }\n\n    companion object {\n        fun <T> build(logger: KLogger): PwResultBuilder<T> =\n            PwResultBuilder(logger)\n    }\n}\n\nclass Success<T>(val value: T, problems: List<Problem> = emptyList()) : PwResult<T>(problems)\n\nclass Failure(problems: List<Problem>) : PwResult<Nothing>(problems)\n\nopen class Problem(\n    val severity: Severity,\n    /**\n     * Readable message meant for users.\n     */\n    val uiMessage: String,\n    /**\n     * Message meant for developers.\n     */\n    val message: String? = null,\n    val cause: Throwable? = null,\n)\n\nenum class Severity {\n    Trace,\n    Debug,\n    Info,\n    Warning,\n    Error,\n}\n\n/**\n * Useful for building up a [PwResult] and logging problems at the same time.\n */\nclass PwResultBuilder<T>(private val logger: KLogger) {\n    private val problems: MutableList<Problem> = mutableListOf()\n\n    /**\n     * Add a problem to the problems list and log it with [logger].\n     */\n    fun addProblem(\n        problem: Problem,\n    ): PwResultBuilder<T> {\n        when (problem.severity) {\n            Severity.Trace -> logger.trace(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Debug -> logger.debug(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Info -> logger.info(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Warning -> logger.warn(problem.cause) { problem.message ?: problem.uiMessage }\n            Severity.Error -> logger.error(problem.cause) { problem.message ?: problem.uiMessage }\n        }\n\n        problems.add(problem)\n        return this\n    }\n\n    /**\n     * Add a problem to the problems list and log it with [logger].\n     */\n    fun addProblem(\n        severity: Severity,\n        uiMessage: String,\n        message: String? = null,\n        cause: Throwable? = null,\n    ): PwResultBuilder<T> =\n        addProblem(Problem(severity, uiMessage, message, cause))\n\n    /**\n     * Add the given result's problems.\n     */\n    fun addResult(result: PwResult<*>): PwResultBuilder<T> {\n        problems.addAll(result.problems)\n        return this\n    }\n\n    fun success(value: T): Success<T> =\n        Success(value, problems)\n\n    fun failure(): Failure =\n        Failure(problems)\n}\n","package world.phantasmal.core\n\nimport kotlinx.coroutines.await\nimport world.phantasmal.core.externals.browser.WritableStream\n\nsuspend inline fun <S : WritableStream, R> S.use(block: (S) -> R): R {\n    try {\n        return block(this)\n    } finally {\n        close().await()\n    }\n}\n","package world.phantasmal.core.math\n\nimport kotlin.math.PI\n\nprivate const val TO_DEG = 180 / PI\nprivate const val TO_RAD = PI / 180\n\n/**\n * Converts radians to degrees.\n */\nfun radToDeg(rad: Double): Double = rad * TO_DEG\n\n/**\n * Converts degrees to radians.\n */\nfun degToRad(deg: Double): Double = deg * TO_RAD\n\n/**\n * Returns the floored modulus of its arguments. The computed value will have the same sign as the\n * [divisor].\n */\nfun floorMod(dividend: Double, divisor: Double): Double =\n    ((dividend % divisor) + divisor) % divisor\n","package world.phantasmal.core\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.DataView\n\nprivate val dataView = DataView(ArrayBuffer(4))\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun Char.fastIsWhitespace(): Boolean =\n    asDynamic() == 0x20 || (asDynamic() >= 0x09 && asDynamic() <= 0x0D)\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun Char.isDigit(): Boolean =\n    asDynamic() >= 0x30 && asDynamic() <= 0x39\n\nactual fun Int.reinterpretAsFloat(): Float {\n    dataView.setInt32(0, this)\n    return dataView.getFloat32(0)\n}\n\nactual fun Float.reinterpretAsInt(): Int {\n    dataView.setFloat32(0, this)\n    return dataView.getInt32(0)\n}\n\nactual fun Float.reinterpretAsUInt(): UInt {\n    dataView.setFloat32(0, this)\n    return dataView.getUint32(0).toUInt()\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport findAssociatedObject\n\n/**\n * The experimental marker for associated objects API.\n *\n * Any usage of a declaration annotated with `@ExperimentalAssociatedObjects` must be accepted either by\n * annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalAssociatedObjects::class)`,\n * or by using the compiler argument `-Xopt-in=kotlin.reflect.ExperimentalAssociatedObjects`.\n */\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Retention(value = AnnotationRetention.BINARY)\npublic annotation class ExperimentalAssociatedObjects\n\n/**\n * Makes the annotated annotation class an associated object key.\n *\n * An associated object key annotation should have single [KClass] parameter.\n * When applied to a class with reference to an object declaration as an argument, it binds\n * the object to the class, making this binding discoverable at runtime using [findAssociatedObject].\n */\n@ExperimentalAssociatedObjects\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.ANNOTATION_CLASS)\npublic annotation class AssociatedObjectKey\n\n/**\n * If [T] is an @[AssociatedObjectKey]-annotated annotation class and [this] class is annotated with @[T] (`S::class`),\n * returns object `S`.\n *\n * Otherwise returns `null`.\n */\n@ExperimentalAssociatedObjects\npublic inline fun <reified T : Annotation> KClass<*>.findAssociatedObject(): Any? =\n    this.findAssociatedObject(T::class)",null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"GroupingKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.collections\n\n/**\n * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.\n *\n * A [Grouping] structure serves as an intermediate step in group-and-fold operations:\n * they group elements by their keys and then fold each group with some aggregating operation.\n *\n * It is created by attaching `keySelector: (T) -> K` function to a source of elements.\n * To get an instance of [Grouping] use one of `groupingBy` extension functions:\n * - [Iterable.groupingBy]\n * - [Sequence.groupingBy]\n * - [Array.groupingBy]\n * - [CharSequence.groupingBy]\n *\n * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.\n */\n@SinceKotlin(\"1.1\")\npublic interface Grouping<T, out K> {\n    /** Returns an [Iterator] over the elements of the source of this grouping. */\n    fun sourceIterator(): Iterator<T>\n    /** Extracts the key of an [element]. */\n    fun keyOf(element: T): K\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation function is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * @return a [Map] associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadix\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.aggregate(\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): Map<K, R> {\n    return aggregateTo(mutableMapOf<K, R>(), operation)\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * If the [destination] map already has a value corresponding to some key,\n * then the elements being aggregated for that key are never considered as `first`.\n *\n * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadixTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(\n    destination: M,\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): M {\n    for (e in this.sourceIterator()) {\n        val key = keyOf(e)\n        val accumulator = destination[key]\n        destination[key] = operation(key, accumulator, e, accumulator == null && !destination.containsKey(key))\n    }\n    return destination\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * If the [destination] map already has a value corresponding to some key, that value is used as an initial value of\n * the accumulator for that group and the [initialValueSelector] function is not called for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in a new map.\n * An initial value of accumulator is the first element of the group.\n *\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowels\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K> Grouping<T, K>.reduce(\n    operation: (key: K, accumulator: S, element: T) -> S\n): Map<K, S> =\n    aggregate { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the first element of the group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group and the first element of that group is also\n * subjected to the [operation].\n\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being folded;\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowelsTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T, K>.reduceTo(\n    destination: M,\n    operation: (key: K, accumulator: S, element: T) -> S\n): M =\n    aggregateTo(destination) { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n\n/**\n * Groups elements from the [Grouping] source by key and counts elements in each group to the given [destination] map.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the counter for that group.\n *\n * @return the [destination] map associating the key of each group with the count of elements in the group.\n *\n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M): M =\n    foldTo(destination, 0) { acc, _ -> acc + 1 }\n\n/*\n/**\n * Groups elements from the [Grouping] source by key and sums values provided by the [valueSelector] function for elements in each group\n * to the given [destination] map.\n *\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the sum for that group.\n *\n * @return the [destination] map associating the key of each group with the sum of elements in the group.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachSumOfTo(destination: M, valueSelector: (T) -> Int): M =\n        foldTo(destination, 0) { acc, e -> acc + valueSelector(e)}\n*/\n\n\n/*\n// TODO: sum by long and by double overloads\n\npublic inline fun <T, K, M : MutableMap<in K, Long>> Grouping<T, K>.sumEachByLongTo(destination: M, valueSelector: (T) -> Long): M =\n        foldTo(destination, 0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByLong(valueSelector: (T) -> Long): Map<K, Long> =\n        fold(0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K, M : MutableMap<in K, Double>> Grouping<T, K>.sumEachByDoubleTo(destination: M, valueSelector: (T) -> Double): M =\n        foldTo(destination, 0.0) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByDouble(valueSelector: (T) -> Double): Map<K, Double> =\n        fold(0.0) { acc, e -> acc + valueSelector(e)}\n*/\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.internal.InlineOnly\n\n\n/**\n * Returns a hash code value for the object or zero if the object is `null`.\n *\n * @see Any.hashCode\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun Any?.hashCode(): Int = this?.hashCode() ?: 0\n",null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n",null,"// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.asm.*\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * Computes the possible values of a register right before a specific instruction.\n */\nfun getRegisterValue(cfg: ControlFlowGraph, instruction: Instruction, register: Int): ValueSet {\n    require(register in 0..255) {\n        \"register should be between 0 and 255, inclusive but was $register.\"\n    }\n\n    val block = cfg.getBlockForInstruction(instruction)\n\n    return RegisterValueFinder().find(\n        mutableSetOf(),\n        block,\n        block.indexOfInstruction(instruction),\n        register\n    )\n}\n\nprivate class RegisterValueFinder {\n    private var iterations = 0\n\n    fun find(\n        path: MutableSet<BasicBlock>,\n        block: BasicBlock,\n        end: Int,\n        register: Int,\n    ): ValueSet {\n        if (++iterations > 100) {\n            logger.warn { \"Too many iterations.\" }\n            return ValueSet.all()\n        }\n\n        for (i in end - 1 downTo block.start) {\n            val instruction = block.segment.instructions[i]\n            val args = instruction.args\n\n            when (instruction.opcode.code) {\n                OP_SYNC.code -> {\n                    // After a sync call, concurrent code could have modified the register. We don't\n                    // check whether concurrent code *ever* writes to the register to possibly\n                    // continue the analysis.\n                    return ValueSet.all()\n                }\n\n                OP_VA_CALL.code -> {\n                    val value = vaCall(path, block, i, register)\n                    if (value.isNotEmpty()) return value\n                }\n\n                OP_LET.code -> {\n                    if (args[0].value == register) {\n                        return find(LinkedHashSet(path), block, i, args[1].value as Int)\n                    }\n                }\n\n                OP_LETI.code,\n                OP_LETB.code,\n                OP_LETW.code,\n                OP_SYNC_LETI.code,\n                -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(args[1].value as Int)\n                    }\n                }\n\n                OP_SET.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(1)\n                    }\n                }\n\n                OP_CLEAR.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.of(0)\n                    }\n                }\n\n                OP_REV.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n\n                        return if (prevVals.size == 1L && prevVals[0] == 0) {\n                            ValueSet.of(1)\n                        } else if (0 in prevVals) {\n                            ValueSet.ofInterval(0, 1)\n                        } else {\n                            ValueSet.of(0)\n                        }\n                    }\n                }\n\n                OP_ADDI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals += args[1].value as Int\n                        return prevVals\n                    }\n                }\n\n                OP_SUBI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals -= args[1].value as Int\n                        return prevVals\n                    }\n                }\n\n                OP_MULI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals *= args[1].value as Int\n                        return prevVals\n                    }\n                }\n\n                OP_DIVI.code -> {\n                    if (args[0].value == register) {\n                        val prevVals = find(LinkedHashSet(path), block, i, register)\n                        prevVals /= args[1].value as Int\n                        return prevVals\n                    }\n                }\n\n                OP_IF_ZONE_CLEAR.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 1)\n                    }\n                }\n\n                OP_GET_DIFFLVL.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 2)\n                    }\n                }\n\n                OP_GET_SLOTNUMBER.code -> {\n                    if (args[0].value == register) {\n                        return ValueSet.ofInterval(0, 3)\n                    }\n                }\n\n                OP_GET_RANDOM.code -> {\n                    if (args[1].value == register) {\n                        // TODO: undefined values.\n                        val min = find(\n                            LinkedHashSet(path),\n                            block,\n                            i,\n                            args[0].value as Int\n                        ).minOrNull()!!\n\n                        val max = max(\n                            find(\n                                LinkedHashSet(path),\n                                block,\n                                i,\n                                args[0].value as Int + 1\n                            ).maxOrNull()!!,\n                            min + 1,\n                        )\n\n                        return ValueSet.ofInterval(min, max - 1)\n                    }\n                }\n\n                OP_STACK_PUSHM.code,\n                OP_STACK_POPM.code,\n                -> {\n                    val minReg = args[0].value as Int\n                    val maxReg = args[0].value as Int + args[1].value as Int\n\n                    if (register in minReg until maxReg) {\n                        return ValueSet.all()\n                    }\n                }\n\n                else -> {\n                    // Assume any other opcodes that write to the register can produce any value.\n                    val params = instruction.opcode.params\n                    val argLen = min(args.size, params.size)\n\n                    for (j in 0 until argLen) {\n                        val param = params[j]\n\n                        if (param.type is RegRefType && param.type.registers != null) {\n                            val regRef = args[j].value as Int\n\n                            for ((k, regParam) in param.type.registers.withIndex()) {\n                                if (regParam.writes && regRef + k == register) {\n                                    return ValueSet.all()\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        val values = ValueSet.empty()\n        path.add(block)\n\n        for (from in block.from) {\n            // Bail out from loops.\n            if (from in path) {\n                return ValueSet.all()\n            }\n\n            values.union(find(LinkedHashSet(path), from, from.end, register))\n        }\n\n        // If values is empty at this point, we know nothing ever sets the register's value from\n        // this thread or handler. Concurrent code could have modified it, we don't yet try to\n        // exclude this possibility so we just return all values.\n        if (values.isEmpty()) {\n            return ValueSet.all()\n        }\n\n        return values\n    }\n\n    /**\n     * After a va_start instruction, 0 or more arg_push instructions can be used. When va_call is\n     * executed the values on the stack will become the values of registers r1..r7 (inclusive) in\n     * the order that they were pushed.\n     *\n     * E.g.:\n     *\n     * va_start\n     * arg_pushl 10\n     * arg_pushl 20\n     * va_call 777\n     * va_end\n     *\n     * This means call 777 with r1 = 10 and r2 = 20.\n     */\n    private fun vaCall(\n        path: MutableSet<BasicBlock>,\n        block: BasicBlock,\n        vaCallIdx: Int,\n        register: Int,\n    ): ValueSet {\n        if (register !in 1..7) return ValueSet.empty()\n\n        var vaStartIdx = -1\n        val stack = mutableListOf<Instruction>()\n\n        for (i in block.start until vaCallIdx) {\n            val instruction = block.segment.instructions[i]\n            val opcode = instruction.opcode\n\n            if (opcode.code == OP_VA_START.code) {\n                vaStartIdx = i\n            } else if (vaStartIdx != -1) {\n                when (opcode.code) {\n                    OP_ARG_PUSHR.code,\n                    OP_ARG_PUSHL.code,\n                    OP_ARG_PUSHB.code,\n                    OP_ARG_PUSHW.code,\n                    OP_ARG_PUSHA.code,\n                    OP_ARG_PUSHO.code,\n                    OP_ARG_PUSHS.code -> stack.add(instruction)\n                }\n            }\n        }\n\n        return if (register in 1..stack.size) {\n            val instruction = stack[register - 1]\n            val value = instruction.args.first().value\n\n            when (instruction.opcode.code) {\n                OP_ARG_PUSHR.code -> find(LinkedHashSet(path), block, vaStartIdx, value as Int)\n\n                OP_ARG_PUSHL.code,\n                OP_ARG_PUSHB.code,\n                OP_ARG_PUSHW.code -> ValueSet.of(value as Int)\n\n                // TODO: Deal with strings.\n                else -> ValueSet.all() // String or pointer\n            }\n        } else {\n            ValueSet.of(0)\n        }\n    }\n}\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport kotlin.math.max\nimport kotlin.math.min\n\n/**\n * Represents a sorted set of integers.\n */\nclass ValueSet private constructor(private val intervals: MutableList<Interval>) : Iterable<Int> {\n    val size: Long\n        get() = intervals.fold(0L) { acc, i -> acc + i.end - i.start + 1L }\n\n    operator fun get(i: Int): Int? {\n        var idx = i\n\n        for ((start, end) in intervals) {\n            val size = end - start + 1\n\n            if (idx < size) {\n                return start + idx\n            } else {\n                idx -= size\n            }\n        }\n\n        return null\n    }\n\n    fun isEmpty(): Boolean =\n        intervals.isEmpty()\n\n    fun isNotEmpty(): Boolean =\n        intervals.isNotEmpty()\n\n    fun minOrNull(): Int? =\n        intervals.firstOrNull()?.start\n\n    fun maxOrNull(): Int? =\n        intervals.lastOrNull()?.end\n\n    operator fun contains(value: Int): Boolean {\n        for (int in intervals) {\n            if (value in int) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    /**\n     * Sets this ValueSet to the given integer.\n     */\n    fun setValue(value: Int): ValueSet {\n        intervals.clear()\n        intervals.add(Interval(value, value))\n        return this\n    }\n\n    /**\n     * Sets this ValueSet to the values in the given interval.\n     *\n     * @param start lower bound, inclusive\n     * @param end upper bound, inclusive\n     */\n    fun setInterval(start: Int, end: Int): ValueSet {\n        require(end >= start) {\n            \"Interval upper bound should be greater than or equal to lower bound, got [${start}, ${end}].\"\n        }\n\n        intervals.clear()\n        intervals.add(Interval(start, end))\n        return this\n    }\n\n    /**\n     * Scalar addition.\n     */\n    operator fun plusAssign(scalar: Int) {\n        if (scalar >= 0) {\n            var i = 0\n            var addI = 0\n\n            while (i < intervals.size) {\n                val int = intervals[i]\n                val oldStart = int.start\n                val oldEnd = int.end\n                int.start += scalar\n                int.end += scalar\n\n                if (int.start < oldStart) {\n                    // Integer overflow of both start and end.\n                    intervals.removeAt(i)\n                    intervals.add(addI++, int)\n                } else if (int.end < oldEnd) {\n                    // Integer overflow of end.\n                    val newEnd = int.end\n                    int.end = Int.MAX_VALUE\n\n                    if (newEnd + 1 == intervals.first().start) {\n                        intervals.first().start = Int.MIN_VALUE\n                    } else {\n                        intervals.add(0, Interval(Int.MIN_VALUE, newEnd))\n                        addI++\n                        // Increment i twice because we left this interval and inserted a new one.\n                        i++\n                    }\n                }\n\n                i++\n            }\n        } else {\n            var i = intervals.lastIndex\n            var addI = 0\n\n            while (i >= 0) {\n                val int = intervals[i]\n                val oldStart = int.start\n                val oldEnd = int.end\n                int.start += scalar\n                int.end += scalar\n\n                if (int.end > oldEnd) {\n                    // Integer underflow of both start and end.\n                    intervals.removeAt(i)\n                    intervals.add(intervals.size - addI++, int)\n                } else if (int.start > oldStart) {\n                    // Integer underflow of start.\n                    val newStart = int.start\n                    int.start = Int.MIN_VALUE\n\n                    if (newStart - 1 == intervals.last().end) {\n                        intervals.last().end = Int.MAX_VALUE\n                    } else {\n                        intervals.add(Interval(newStart, Int.MAX_VALUE))\n                        addI++\n                    }\n                }\n\n                i--\n            }\n        }\n    }\n\n    /**\n     * Scalar subtraction.\n     */\n    operator fun minusAssign(scalar: Int) {\n        plusAssign(-scalar)\n    }\n\n    /**\n     * Doesn't take into account integer overflow.\n     */\n    operator fun timesAssign(s: Int) {\n        for (int in intervals) {\n            int.start *= s\n            int.end *= s\n        }\n    }\n\n    /**\n     * Integer division.\n     */\n    operator fun divAssign(s: Int) {\n        for (int in intervals) {\n            int.start /= s\n            int.end /= s\n        }\n    }\n\n    fun union(other: ValueSet): ValueSet {\n        var i = 0\n\n        outer@ for (b in other.intervals) {\n            while (i < intervals.size) {\n                val a = intervals[i]\n\n                if (b.end < a.start - 1L) {\n                    // b lies entirely before a, insert it right before a.\n                    intervals.add(i, b.copy())\n                    i++\n                    continue@outer\n                } else if (b.start <= a.end + 1L) {\n                    // a and b overlap or form a continuous interval (e.g. [1, 2] and [3, 4]).\n                    a.start = min(a.start, b.start)\n\n                    // Merge all intervals that overlap with b.\n                    val j = i + 1\n\n                    while (j < intervals.size) {\n                        if (b.end >= intervals[j].start - 1L) {\n                            a.end = intervals[j].end\n                            intervals.removeAt(j)\n                        } else {\n                            break\n                        }\n                    }\n\n                    a.end = max(a.end, b.end)\n                    i++\n                    continue@outer\n                } else {\n                    // b lies entirely after a, check next a.\n                    i++\n                }\n            }\n\n            // b lies after every a, add it to the end of our intervals.\n            intervals.add(b.copy())\n        }\n\n        return this\n    }\n\n    override fun iterator(): Iterator<Int> =\n        object : Iterator<Int> {\n            private var intIdx = 0\n            private var nextValue: Int? = minOrNull()\n\n            override fun hasNext(): Boolean =\n                nextValue != null\n\n            override fun next(): Int {\n                val v = nextValue ?: throw NoSuchElementException()\n\n                nextValue =\n                    if (v < intervals[intIdx].end) {\n                        v + 1\n                    } else {\n                        intIdx++\n\n                        if (intIdx < intervals.size) {\n                            intervals[intIdx].start\n                        } else {\n                            null\n                        }\n                    }\n\n                return v\n            }\n        }\n\n    companion object {\n        /**\n         * Returns an empty [ValueSet].\n         */\n        fun empty(): ValueSet = ValueSet(mutableListOf())\n\n        /**\n         * Returns a [ValueSet] containing all possible Int values.\n         */\n        fun all(): ValueSet = ofInterval(Int.MIN_VALUE, Int.MAX_VALUE)\n\n        /**\n         * Returns a [ValueSet] with a single initial [value].\n         */\n        fun of(value: Int): ValueSet = ValueSet(mutableListOf(Interval(value, value)))\n\n        /**\n         * Returns a [ValueSet] with all values between [start] and [end], inclusively.\n         */\n        fun ofInterval(start: Int, end: Int): ValueSet =\n            ValueSet(mutableListOf(Interval(start, end)))\n    }\n}\n\n/**\n * Closed interval [start, end].\n */\nprivate data class Interval(var start: Int, var end: Int) {\n    operator fun contains(value: Int): Boolean =\n        value in start..end\n}\n","package world.phantasmal.lib\n\nenum class Endianness {\n    Little,\n    Big\n}\n","package world.phantasmal.lib\n\nenum class Episode {\n    I,\n    II,\n    IV;\n\n    fun toInt(): Int = when(this) {\n        I -> 1\n        II -> 2\n        IV -> 4\n    }\n\n    companion object {\n        fun fromInt(episode: Int) = when (episode) {\n            1 -> I\n            2 -> II\n            4 -> IV\n            else -> error(\"$episode is invalid.\")\n        }\n    }\n}\n","package world.phantasmal.lib.asm\n\nimport world.phantasmal.core.fastIsWhitespace\nimport world.phantasmal.core.fastReplace\nimport world.phantasmal.core.getCodePointAt\nimport world.phantasmal.core.isDigit\n\nprivate val HEX_INT_REGEX = Regex(\"\"\"^0[xX][0-9a-fA-F]+$\"\"\")\nprivate val FLOAT_REGEX = Regex(\"\"\"^-?\\d+(\\.\\d+)?(e-?\\d+)?$\"\"\")\n\nenum class Token {\n    Int32,\n    Float32,\n    InvalidNumber,\n    Register,\n    Label,\n    CodeSection,\n    DataSection,\n    StrSection,\n    InvalidSection,\n    Str,\n    UnterminatedStr,\n    Ident,\n    InvalidIdent,\n    ArgSeparator,\n}\n\nclass LineTokenizer {\n    private var line = \"\"\n    private var index = 0\n    private var startIndex = 0\n\n    private var value: Any? = null\n\n    var type: Token? = null\n        private set\n\n    val col: Int get() = startIndex + 1\n    val len: Int get() = index - startIndex\n\n    fun tokenize(line: String) {\n        this.line = line\n        index = 0\n        startIndex = 0\n    }\n\n    val intValue: Int\n        get() {\n            require(type === Token.Int32 || type === Token.Register || type === Token.Label)\n            return value as Int\n        }\n\n    val floatValue: Float\n        get() {\n            require(type === Token.Float32)\n            return value as Float\n        }\n\n    val strValue: String\n        get() {\n            require(\n                type === Token.Str ||\n                        type === Token.UnterminatedStr ||\n                        type === Token.Ident ||\n                        type === Token.InvalidIdent\n            )\n            return value as String\n        }\n\n    fun nextToken(): Boolean {\n        type = null\n        value = null\n\n        while (hasNext()) {\n            startIndex = index\n            val char = peek()\n\n            if (char == '/') {\n                skip()\n\n                if (peek() == '/') {\n                    // It's a comment.\n                    break\n                } else {\n                    back()\n                }\n            }\n\n            if (char.fastIsWhitespace()) {\n                skip()\n                continue\n            }\n\n            if (char == '-' || char.isDigit()) {\n                tokenizeNumberOrLabel()\n            } else if (char == ',') {\n                type = Token.ArgSeparator\n                skip()\n            } else if (char == '.') {\n                tokenizeSection()\n            } else if (char == '\"') {\n                tokenizeString()\n            } else if (char == 'r') {\n                tokenizeRegisterOrIdent()\n            } else {\n                tokenizeIdent()\n            }\n\n            break\n        }\n\n        return type != null\n    }\n\n    private fun hasNext(): Boolean = index < line.length\n\n    private fun next(): Char = line[index++]\n\n    private fun peek(): Char = line[index]\n\n    private fun skip() {\n        index++\n    }\n\n    private fun back() {\n        index--\n    }\n\n    private fun slice(from: Int = 0, to: Int = 0): String =\n        line.substring(startIndex + from, index - to)\n\n    private fun eatRestOfToken() {\n        while (hasNext()) {\n            val char = next()\n\n            if (char == ',' || char.fastIsWhitespace()) {\n                back()\n                break\n            }\n        }\n    }\n\n    private fun tokenizeNumberOrLabel() {\n        val firstChar = next()\n        var isLabel = false\n\n        while (hasNext()) {\n            val char = peek()\n\n            if (char == '.' || char == 'e') {\n                tokenizeFloat()\n                return\n            } else if (firstChar == '0' && (char == 'x' || char == 'X')) {\n                tokenizeHexNumber()\n                return\n            } else if (char == ':') {\n                isLabel = true\n                break\n            } else if (char == ',' || char.fastIsWhitespace()) {\n                break\n            } else {\n                skip()\n            }\n        }\n\n        value = slice().toIntOrNull()\n\n        if (isLabel) {\n            skip()\n        }\n\n        type = when {\n            value == null -> Token.InvalidNumber\n            isLabel -> Token.Label\n            else -> Token.Int32\n        }\n    }\n\n    private fun tokenizeHexNumber() {\n        eatRestOfToken()\n        val hexStr = slice()\n\n        if (HEX_INT_REGEX.matches(hexStr)) {\n            value = hexStr.drop(2).toIntOrNull(16)\n\n            if (value != null) {\n                type = Token.Int32\n                return\n            }\n        }\n\n        type = Token.InvalidNumber\n    }\n\n    private fun tokenizeFloat() {\n        eatRestOfToken()\n        val floatStr = slice()\n\n        if (FLOAT_REGEX.matches(floatStr)) {\n            value = floatStr.toFloatOrNull()\n\n            if (value != null) {\n                type = Token.Float32\n                return\n            }\n        }\n\n        type = Token.InvalidNumber\n    }\n\n    private fun tokenizeRegisterOrIdent() {\n        skip()\n        var isRegister = false\n\n        while (hasNext()) {\n            val char = peek()\n\n            if (char.isDigit()) {\n                isRegister = true\n                skip()\n            } else {\n                break\n            }\n        }\n\n        if (isRegister) {\n            value = slice(from = 1).toInt()\n            type = Token.Register\n        } else {\n            back()\n            tokenizeIdent()\n        }\n    }\n\n    private fun tokenizeSection() {\n        while (hasNext()) {\n            if (peek().fastIsWhitespace()) {\n                break\n            } else {\n                skip()\n            }\n        }\n\n        type = when (slice()) {\n            \".code\" -> Token.CodeSection\n            \".data\" -> Token.DataSection\n            \".string\" -> Token.StrSection\n            else -> Token.InvalidSection\n        }\n    }\n\n    private fun tokenizeString() {\n        skip()\n        var prevWasBackSpace = false\n        var terminated = false\n\n        loop@ // Use label as workaround for https://youtrack.jetbrains.com/issue/KT-43943.\n        while (hasNext()) {\n            when (peek()) {\n                '\\\\' -> {\n                    prevWasBackSpace = true\n                }\n                '\"' -> {\n                    if (!prevWasBackSpace) {\n                        skip()\n                        terminated = true\n                        break@loop\n                    }\n\n                    prevWasBackSpace = false\n                }\n                else -> {\n                    prevWasBackSpace = false\n                }\n            }\n\n            skip()\n        }\n\n        value = slice(from = 1, to = if (terminated) 1 else 0)\n            .fastReplace(\"\\\\\\\"\", \"\\\"\")\n            .fastReplace(\"\\\\n\", \"\\n\")\n\n        type = if (terminated) {\n            Token.Str\n        } else {\n            Token.UnterminatedStr\n        }\n    }\n\n    private fun tokenizeIdent() {\n        while (hasNext()) {\n            val char = peek()\n\n            if (char == ',' || char.fastIsWhitespace()) {\n                break\n            } else if (char == '/') {\n                skip()\n\n                if (peek() == '/') {\n                    back()\n                    break\n                }\n            } else {\n                skip()\n            }\n        }\n\n        val ident = slice()\n        value = ident\n\n        if (ident.getCodePointAt(0) !in ('a'.toInt())..('z'.toInt())) {\n            type = Token.InvalidIdent\n            return\n        }\n\n        for (i in 1 until ident.length) {\n            when (ident.getCodePointAt(i)) {\n                in ('0'.toInt())..('9'.toInt()),\n                in ('a'.toInt())..('z'.toInt()),\n                ('_').toInt(),\n                ('=').toInt(),\n                ('<').toInt(),\n                ('>').toInt(),\n                ('!').toInt(),\n                -> {\n                    // Valid character.\n                }\n                else -> {\n                    type = Token.InvalidIdent\n                    return\n                }\n            }\n        }\n\n        type = Token.Ident\n    }\n}\n","package world.phantasmal.lib.asm\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.Problem\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.buffer.Buffer\nimport kotlin.time.measureTimedValue\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AssemblyProblem(\n    severity: Severity,\n    uiMessage: String,\n    message: String? = null,\n    cause: Throwable? = null,\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n) : Problem(severity, uiMessage, message, cause)\n\nfun assemble(\n    asm: List<String>,\n    inlineStackArgs: Boolean = true,\n): PwResult<BytecodeIr> {\n    logger.trace {\n        \"Assembling ${asm.size} lines with ${\n            if (inlineStackArgs) \"inline stack arguments\" else \"stack push instructions\"\n        }.\"\n    }\n\n    val (result, time) = measureTimedValue { Assembler(asm, inlineStackArgs).assemble() }\n\n    logger.trace {\n        val warnings = result.problems.count { it.severity == Severity.Warning }\n        val errors = result.problems.count { it.severity == Severity.Error }\n\n        \"Assembly finished in ${time.inMilliseconds}ms with $warnings warnings and $errors errors.\"\n    }\n\n    return result\n}\n\nprivate class Assembler(private val asm: List<String>, private val inlineStackArgs: Boolean) {\n    private var lineNo = 1\n    private val tokenizer = LineTokenizer()\n    private var ir: MutableList<Segment> = mutableListOf()\n\n    /**\n     * The current segment.\n     */\n    private var segment: Segment? = null\n\n    /**\n     * Encountered labels.\n     */\n    private val labels: MutableSet<Int> = mutableSetOf()\n    private var section: SegmentType = SegmentType.Instructions\n    private var firstSectionMarker = true\n    private var prevLineHadLabel = false\n\n    private val result = PwResult.build<BytecodeIr>(logger)\n\n    fun assemble(): PwResult<BytecodeIr> {\n        // Tokenize and assemble line by line.\n        for (line in asm) {\n            tokenizer.tokenize(line)\n            tokenizer.nextToken()\n\n            if (tokenizer.type != null) {\n                var hasLabel = false\n\n                // Token type checks are ordered from most frequent to least frequent for increased\n                // perf.\n                when (tokenizer.type) {\n                    Token.Ident -> {\n                        if (section === SegmentType.Instructions) {\n                            parseInstruction()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.Label -> {\n                        parseLabel()\n                        hasLabel = true\n                    }\n                    Token.CodeSection -> {\n                        parseCodeSection()\n                    }\n                    Token.DataSection -> {\n                        parseDataSection()\n                    }\n                    Token.StrSection -> {\n                        parseStrSection()\n                    }\n                    Token.Int32 -> {\n                        if (section === SegmentType.Data) {\n                            parseBytes()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.Str -> {\n                        if (section === SegmentType.String) {\n                            parseString()\n                        } else {\n                            addUnexpectedTokenError()\n                        }\n                    }\n                    Token.InvalidSection -> {\n                        addError(\"Invalid section type.\")\n                    }\n                    Token.InvalidIdent -> {\n                        addError(\"Invalid identifier.\")\n                    }\n                    else -> {\n                        addUnexpectedTokenError()\n                    }\n                }\n\n                prevLineHadLabel = hasLabel\n            }\n\n            lineNo++\n        }\n\n        return result.success(BytecodeIr(ir))\n    }\n\n    private fun addInstruction(\n        opcode: Opcode,\n        args: List<Arg>,\n        mnemonicSrcLoc: SrcLoc?,\n        argSrcLocs: List<SrcLoc>,\n        stackArgSrcLocs: List<SrcLoc>,\n    ) {\n        when (val seg = segment) {\n            null -> {\n                // Unreachable code, technically valid.\n                segment = InstructionSegment(\n                    labels = mutableListOf(),\n                    instructions = mutableListOf(),\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is InstructionSegment -> {\n                seg.instructions.add(\n                    Instruction(\n                        opcode,\n                        args,\n                        InstructionSrcLoc(\n                            mnemonic = mnemonicSrcLoc,\n                            args = argSrcLocs,\n                            stackArgs = stackArgSrcLocs,\n                        )\n                    )\n                )\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected instructions segment.\" }\n            }\n        }\n    }\n\n    private fun addBytes(bytes: ByteArray) {\n        when (val seg = segment) {\n            null -> {\n                // Unaddressable data, technically valid.\n                segment = DataSegment(\n                    labels = mutableListOf(),\n                    data = Buffer.fromByteArray(bytes),\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is DataSegment -> {\n                val oldSize = seg.data.size\n                seg.data.size += bytes.size\n\n                for (i in bytes.indices) {\n                    seg.data.setByte(i + oldSize, bytes[i])\n                }\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected data segment.\" }\n            }\n        }\n    }\n\n    private fun addString(str: String) {\n        when (val seg = segment) {\n            null -> {\n                // Unaddressable data, technically valid.\n                segment = StringSegment(\n                    labels = mutableListOf(),\n                    value = str,\n                    bytecodeSize = null,\n                    srcLoc = SegmentSrcLoc()\n                )\n\n                ir.add(segment!!)\n            }\n\n            is StringSegment -> {\n                seg.value += str\n            }\n\n            else -> {\n                logger.error { \"Line $lineNo: Expected string segment.\" }\n            }\n        }\n    }\n\n    private fun addError(col: Int, len: Int, uiMessage: String, message: String? = null) {\n        result.addProblem(\n            AssemblyProblem(\n                Severity.Error,\n                uiMessage,\n                message ?: \"$uiMessage At $lineNo:$col.\",\n                lineNo = lineNo,\n                col = col,\n                len = len\n            )\n        )\n    }\n\n    private fun addError(uiMessage: String, message: String? = null) {\n        addError(tokenizer.col, tokenizer.len, uiMessage, message)\n    }\n\n    private fun addUnexpectedTokenError() {\n        addError(\n            \"Unexpected token.\",\n            \"Unexpected ${tokenizer.type?.name} at $lineNo:${tokenizer.col}.\",\n        )\n    }\n\n    private fun addWarning(uiMessage: String) {\n        result.addProblem(\n            AssemblyProblem(\n                Severity.Warning,\n                uiMessage,\n                lineNo = lineNo,\n                col = tokenizer.col,\n                len = tokenizer.len,\n            )\n        )\n    }\n\n    private fun parseLabel() {\n        val label = tokenizer.intValue\n\n        if (!labels.add(label)) {\n            addError(\"Duplicate label.\")\n        }\n\n        val srcLoc = srcLocFromTokenizer()\n\n        if (prevLineHadLabel) {\n            val segment = ir.last()\n            segment.labels.add(label)\n            segment.srcLoc.labels.add(srcLoc)\n        }\n\n        tokenizer.nextToken()\n\n        when (section) {\n            SegmentType.Instructions -> {\n                if (!prevLineHadLabel) {\n                    segment = InstructionSegment(\n                        labels = mutableListOf(label),\n                        instructions = mutableListOf(),\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Ident) {\n                    parseInstruction()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected opcode mnemonic.\")\n                }\n            }\n\n            SegmentType.Data -> {\n                if (!prevLineHadLabel) {\n                    segment = DataSegment(\n                        labels = mutableListOf(label),\n                        data = Buffer.withCapacity(0),\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Int32) {\n                    parseBytes()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected bytes.\")\n                }\n            }\n\n            SegmentType.String -> {\n                if (!prevLineHadLabel) {\n                    segment = StringSegment(\n                        labels = mutableListOf(label),\n                        value = \"\",\n                        bytecodeSize = null,\n                        srcLoc = SegmentSrcLoc(labels = mutableListOf(srcLoc)),\n                    )\n                    ir.add(segment!!)\n                }\n\n                if (tokenizer.type === Token.Str) {\n                    parseString()\n                } else if (tokenizer.type != null) {\n                    addError(\"Expected a string.\")\n                }\n            }\n        }\n    }\n\n    private fun parseCodeSection() {\n        parseSection(SegmentType.Instructions)\n    }\n\n    private fun parseDataSection() {\n        parseSection(SegmentType.Data)\n    }\n\n    private fun parseStrSection() {\n        parseSection(SegmentType.String)\n    }\n\n    private fun parseSection(section: SegmentType) {\n        if (this.section == section && !firstSectionMarker) {\n            addWarning(\"Unnecessary section marker.\")\n        }\n\n        this.section = section\n        firstSectionMarker = false\n\n        if (tokenizer.nextToken()) {\n            addUnexpectedTokenError()\n        }\n    }\n\n    private fun parseInstruction() {\n        val opcode = mnemonicToOpcode(tokenizer.strValue)\n        val mnemonicSrcLoc = srcLocFromTokenizer()\n\n        if (opcode == null) {\n            addError(\"Unknown opcode.\")\n        } else {\n            // Inline arguments.\n            val inlineArgs = mutableListOf<Arg>()\n            val inlineArgSrcLocs = mutableListOf<SrcLoc>()\n            // Stack arguments.\n            val stackArgs = mutableListOf<Arg>()\n            val stackArgSrcLocs = mutableListOf<SrcLoc>()\n\n            if (opcode.stack !== StackInteraction.Pop) {\n                // Arguments should be inlined right after the opcode.\n                if (!parseArgs(\n                        opcode,\n                        mnemonicSrcLoc.col,\n                        inlineArgs,\n                        inlineArgSrcLocs,\n                        stack = false,\n                    )\n                ) {\n                    return\n                }\n            } else {\n                // Arguments should be passed to the opcode via the stack.\n                if (!parseArgs(\n                        opcode,\n                        mnemonicSrcLoc.col,\n                        stackArgs,\n                        stackArgSrcLocs,\n                        stack = true,\n                    )\n                ) {\n                    return\n                }\n            }\n\n            addInstruction(\n                opcode,\n                inlineArgs,\n                mnemonicSrcLoc,\n                inlineArgSrcLocs,\n                stackArgSrcLocs,\n            )\n        }\n    }\n\n    /**\n     * Returns true iff arguments can be translated to byte code, possibly after truncation.\n     */\n    private fun parseArgs(\n        opcode: Opcode,\n        startCol: Int,\n        args: MutableList<Arg>,\n        srcLocs: MutableList<SrcLoc>,\n        stack: Boolean,\n    ): Boolean {\n        var argCount = 0\n        var semiValid = true\n        var shouldBeArg = true\n        var paramI = 0\n        var prevCol = 0\n        var prevLen = 0\n\n        while (tokenizer.nextToken()) {\n            if (tokenizer.type !== Token.ArgSeparator) {\n                argCount++\n            }\n\n            if (paramI < opcode.params.size) {\n                val param = opcode.params[paramI]\n\n                if (tokenizer.type === Token.ArgSeparator) {\n                    if (shouldBeArg) {\n                        addError(\"Expected an argument.\")\n                    } else if (!param.varargs) {\n                        paramI++\n                    }\n\n                    shouldBeArg = true\n                } else {\n                    if (!shouldBeArg) {\n                        val col = prevCol + prevLen\n                        addError(col, tokenizer.col - col, \"Expected a comma.\")\n                    }\n\n                    shouldBeArg = false\n\n                    // Try to match token type parameter type.\n                    var typeMatch: Boolean\n\n                    // If arg is nonnull, types match and argument is syntactically valid.\n                    val arg: Arg? = when (tokenizer.type) {\n                        Token.Int32 -> {\n                            when (param.type) {\n                                ByteType -> {\n                                    typeMatch = true\n                                    parseInt(1)\n                                }\n                                ShortType,\n                                is LabelType,\n                                -> {\n                                    typeMatch = true\n                                    parseInt(2)\n                                }\n                                IntType -> {\n                                    typeMatch = true\n                                    parseInt(4)\n                                }\n                                FloatType -> {\n                                    typeMatch = true\n                                    Arg(tokenizer.intValue.toFloat())\n                                }\n                                else -> {\n                                    typeMatch = false\n                                    null\n                                }\n                            }\n                        }\n\n                        Token.Float32 -> {\n                            typeMatch = param.type === FloatType\n\n                            if (typeMatch) {\n                                Arg(tokenizer.floatValue)\n                            } else {\n                                null\n                            }\n                        }\n\n                        Token.Register -> {\n                            typeMatch = stack ||\n                                    param.type === RegRefVarType ||\n                                    param.type is RegRefType\n\n                            parseRegister()\n                        }\n\n                        Token.Str -> {\n                            typeMatch = param.type === StringType\n\n                            if (typeMatch) {\n                                Arg(tokenizer.strValue)\n                            } else {\n                                null\n                            }\n                        }\n\n                        else -> {\n                            typeMatch = false\n                            null\n                        }\n                    }\n\n                    val srcLoc = srcLocFromTokenizer()\n\n                    if (arg != null) {\n                        args.add(arg)\n                        srcLocs.add(srcLoc)\n                    }\n\n                    if (!typeMatch) {\n                        semiValid = false\n\n                        val typeStr: String? = when (param.type) {\n                            ByteType -> \"an 8-bit integer\"\n                            ShortType -> \"a 16-bit integer\"\n                            IntType -> \"a 32-bit integer\"\n                            FloatType -> \"a float\"\n\n                            ILabelType,\n                            ILabelVarType,\n                            -> \"an instruction label\"\n\n                            DLabelType -> \"a data label\"\n                            SLabelType -> \"a string label\"\n\n                            is LabelType -> \"a label\"\n\n                            StringType -> \"a string\"\n\n                            RegRefVarType,\n                            is RegRefType,\n                            -> \"a register reference\"\n\n                            else -> null\n                        }\n\n                        addError(\n                            if (typeStr == null) \"Unexpected token.\" else \"Expected ${typeStr}.\"\n                        )\n                    } else if (stack && arg != null) {\n                        // Inject stack push instructions if necessary.\n                        // If the token is a register, push it as a register, otherwise coerce type.\n                        if (tokenizer.type === Token.Register) {\n                            if (param.type is RegRefType) {\n                                addInstruction(\n                                    OP_ARG_PUSHB,\n                                    listOf(arg),\n                                    null,\n                                    listOf(srcLoc),\n                                    emptyList(),\n                                )\n                            } else {\n                                addInstruction(\n                                    OP_ARG_PUSHR,\n                                    listOf(arg),\n                                    null,\n                                    listOf(srcLoc),\n                                    emptyList(),\n                                )\n                            }\n                        } else {\n                            when (param.type) {\n                                ByteType,\n                                is RegRefType,\n                                -> {\n                                    addInstruction(\n                                        OP_ARG_PUSHB,\n                                        listOf(arg),\n                                        null,\n                                        listOf(srcLoc),\n                                        emptyList(),\n                                    )\n                                }\n\n                                ShortType,\n                                is LabelType,\n                                -> {\n                                    addInstruction(\n                                        OP_ARG_PUSHW,\n                                        listOf(arg),\n                                        null,\n                                        listOf(srcLoc),\n                                        emptyList(),\n                                    )\n                                }\n\n                                IntType -> {\n                                    addInstruction(\n                                        OP_ARG_PUSHL,\n                                        listOf(arg),\n                                        null,\n                                        listOf(srcLoc),\n                                        emptyList(),\n                                    )\n                                }\n\n                                FloatType -> {\n                                    addInstruction(\n                                        OP_ARG_PUSHL,\n                                        listOf(Arg((arg.value as Float).toRawBits())),\n                                        null,\n                                        listOf(srcLoc),\n                                        emptyList(),\n                                    )\n                                }\n\n                                StringType -> {\n                                    addInstruction(\n                                        OP_ARG_PUSHS,\n                                        listOf(arg),\n                                        null,\n                                        listOf(srcLoc),\n                                        emptyList(),\n                                    )\n                                }\n\n                                else -> {\n                                    logger.error {\n                                        \"Line $lineNo: Type ${param.type::class} not implemented.\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            prevCol = tokenizer.col\n            prevLen = tokenizer.len\n        }\n\n        val paramCount =\n            if (!inlineStackArgs && opcode.stack === StackInteraction.Pop) 0\n            else opcode.params.size\n\n        val errorLength = prevCol + prevLen - startCol\n\n        if (!opcode.varargs && argCount != paramCount) {\n            semiValid = argCount >= paramCount\n            addError(\n                startCol,\n                errorLength,\n                \"Expected $paramCount argument${\n                    if (paramCount == 1) \"\" else \"s\"\n                }, got $argCount.\",\n            )\n        } else if (opcode.varargs && argCount < paramCount) {\n            semiValid = argCount >= paramCount - 1\n            // TODO: This check assumes we want at least 1 argument for a vararg parameter.\n            //       Is this correct?\n            addError(\n                startCol,\n                errorLength,\n                \"Expected at least $paramCount argument${\n                    if (paramCount == 1) \"\" else \"s\"\n                }, got $argCount.\",\n            )\n        }\n\n        return semiValid\n    }\n\n    private fun parseInt(size: Int): Arg? {\n        val value = tokenizer.intValue\n\n        // Fast-path 32-bit ints for improved JS perf. Otherwise maxValue would have to be a Long\n        // or UInt, which incurs a perf hit in JS.\n        if (size == 4) {\n            return Arg(value)\n        } else {\n            val bitSize = 8 * size\n            // Minimum of the signed version of this integer type.\n            val minValue = -(1 shl (bitSize - 1))\n            // Maximum of the unsigned version of this integer type.\n            val maxValue = (1 shl (bitSize)) - 1\n\n            return when {\n                value < minValue -> {\n                    addError(\"${bitSize}-Bit integer can't be less than ${minValue}.\")\n                    null\n                }\n                value > maxValue -> {\n                    addError(\"${bitSize}-Bit integer can't be greater than ${maxValue}.\")\n                    null\n                }\n                else -> {\n                    Arg(value)\n                }\n            }\n        }\n    }\n\n    private fun parseRegister(): Arg? {\n        val value = tokenizer.intValue\n\n        return if (value > 255) {\n            addError(\"Invalid register reference, expected r0-r255.\")\n            null\n        } else {\n            Arg(value)\n        }\n    }\n\n    private fun parseBytes() {\n        val bytes = mutableListOf<Byte>()\n\n        while (tokenizer.type === Token.Int32) {\n            val value = tokenizer.intValue\n\n            if (value < 0) {\n                addError(\"Unsigned 8-bit integer can't be less than 0.\")\n            } else if (value > 255) {\n                addError(\"Unsigned 8-bit integer can't be greater than 255.\")\n            }\n\n            bytes.add(value.toByte())\n\n            tokenizer.nextToken()\n        }\n\n        if (tokenizer.type != null) {\n            addError(\"Expected an unsigned 8-bit integer.\")\n        }\n\n        addBytes(bytes.toByteArray())\n    }\n\n    private fun parseString() {\n        addString(tokenizer.strValue.replace(\"\\n\", \"<cr>\"))\n\n        if (tokenizer.nextToken()) {\n            addUnexpectedTokenError()\n        }\n    }\n\n    private fun srcLocFromTokenizer(): SrcLoc = SrcLoc(lineNo, tokenizer.col, tokenizer.len)\n}\n","package world.phantasmal.lib.asm\n\nimport world.phantasmal.core.unsafe.unsafeAssertNotNull\nimport world.phantasmal.lib.buffer.Buffer\nimport kotlin.math.ceil\n\n/**\n * Intermediate representation of PSO bytecode. Used by most ASM/bytecode analysis code.\n */\nclass BytecodeIr(\n    val segments: List<Segment>,\n) {\n    fun instructionSegments(): List<InstructionSegment> =\n        segments.filterIsInstance<InstructionSegment>()\n\n    fun copy(): BytecodeIr =\n        BytecodeIr(segments.map { it.copy() })\n}\n\nenum class SegmentType {\n    Instructions,\n    Data,\n    String,\n}\n\n/**\n * Segment of bytecode. A segment starts with an instruction, data block or string that is\n * referenced by one or more labels. The segment ends right before the next instruction, data block\n * or string that is referenced by a label.\n */\nsealed class Segment(\n    val type: SegmentType,\n    val labels: MutableList<Int>,\n    val srcLoc: SegmentSrcLoc,\n) {\n    abstract fun size(dcGcFormat: Boolean): Int\n    abstract fun copy(): Segment\n}\n\nclass InstructionSegment(\n    labels: MutableList<Int>,\n    val instructions: MutableList<Instruction>,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.Instructions, labels, srcLoc) {\n    override fun size(dcGcFormat: Boolean): Int =\n        instructions.sumBy { it.getSize(dcGcFormat) }\n\n    override fun copy(): InstructionSegment =\n        InstructionSegment(\n            ArrayList(labels),\n            instructions.mapTo(ArrayList(instructions.size)) { it.copy() },\n            srcLoc.copy(),\n        )\n}\n\nclass DataSegment(\n    labels: MutableList<Int>,\n    val data: Buffer,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.Data, labels, srcLoc) {\n    override fun size(dcGcFormat: Boolean): Int =\n        data.size\n\n    override fun copy(): DataSegment =\n        DataSegment(ArrayList(labels), data.copy(), srcLoc.copy())\n}\n\nclass StringSegment(\n    labels: MutableList<Int>,\n    value: String,\n    /**\n     * Normally string segments have a byte length that is a multiple of 4, but some bytecode is\n     * malformed so we store the initial size in the bytecode.\n     */\n    private var bytecodeSize: Int?,\n    srcLoc: SegmentSrcLoc = SegmentSrcLoc(mutableListOf()),\n) : Segment(SegmentType.String, labels, srcLoc) {\n    var value: String = value\n        set(value) {\n            bytecodeSize = null\n            field = value\n        }\n\n    override fun size(dcGcFormat: Boolean): Int =\n        // String segments should be multiples of 4 bytes.\n        bytecodeSize\n            ?: if (dcGcFormat) {\n                4 * ceil((value.length + 1) / 4.0).toInt()\n            } else {\n                4 * ceil((value.length + 1) / 2.0).toInt()\n            }\n\n    override fun copy(): StringSegment =\n        StringSegment(ArrayList(labels), value, bytecodeSize, srcLoc.copy())\n}\n\n/**\n * Opcode invocation.\n */\nclass Instruction(\n    val opcode: Opcode,\n    /**\n     * Immediate arguments for the opcode.\n     */\n    val args: List<Arg>,\n    val srcLoc: InstructionSrcLoc?,\n) {\n    /**\n     * Maps each parameter by index to its immediate arguments.\n     */\n    // Avoid using lazy to keep GC pressure low.\n    private var paramToArgs: List<List<Arg>>? = null\n\n    /**\n     * Returns the immediate arguments for the parameter at the given index.\n     */\n    fun getArgs(paramIndex: Int): List<Arg> {\n        if (paramToArgs == null) {\n            val paramToArgs: MutableList<MutableList<Arg>> = mutableListOf()\n            this.paramToArgs = paramToArgs\n\n            if (opcode.stack !== StackInteraction.Pop) {\n                for (i in opcode.params.indices) {\n                    val param = opcode.params[i]\n                    val pArgs = mutableListOf<Arg>()\n                    paramToArgs.add(pArgs)\n\n                    // Variable length arguments are always last, so we can just gobble up all\n                    // arguments from this point.\n                    if (param.varargs) {\n                        check(i == opcode.params.lastIndex)\n\n                        for (j in i until args.size) {\n                            pArgs.add(args[j])\n                        }\n                    } else {\n                        pArgs.add(args[i])\n                    }\n                }\n            }\n        }\n\n        return paramToArgs.unsafeAssertNotNull()[paramIndex]\n    }\n\n    /**\n     * Returns the source locations of the immediate arguments for the parameter at the given index.\n     */\n    fun getArgSrcLocs(paramIndex: Int): List<SrcLoc> {\n        val argSrcLocs = srcLoc?.args\n            ?: return emptyList()\n\n        val param = opcode.params[paramIndex]\n\n        // Variable length arguments are always last, so we can just gobble up all SrcLocs from\n        // paramIndex onward.\n        return if (param.varargs) {\n            argSrcLocs.drop(paramIndex)\n        } else {\n            listOf(argSrcLocs[paramIndex])\n        }\n    }\n\n    /**\n     * Returns the source locations of the stack arguments for the parameter at the given index.\n     */\n    fun getStackArgSrcLocs(paramIndex: Int): List<SrcLoc> {\n        val argSrcLocs = srcLoc?.stackArgs\n\n        if (argSrcLocs == null || paramIndex > argSrcLocs.lastIndex) {\n            return emptyList()\n        }\n\n        val param = opcode.params[paramIndex]\n\n        // Variable length arguments are always last, so we can just gobble up all SrcLocs from\n        // paramIndex onward.\n        return if (param.varargs) {\n            argSrcLocs.drop(paramIndex)\n        } else {\n            listOf(argSrcLocs[paramIndex])\n        }\n    }\n\n    /**\n     * Returns the byte size of the entire instruction, i.e. the sum of the opcode size and all\n     * argument sizes.\n     */\n    fun getSize(dcGcFormat: Boolean): Int {\n        var size = opcode.size\n\n        if (opcode.stack === StackInteraction.Pop) return size\n\n        for (i in opcode.params.indices) {\n            val type = opcode.params[i].type\n            val args = getArgs(i)\n\n            size += when (type) {\n                ByteType -> 1\n\n                // Ensure this case is before the LabelType case because ILabelVarType extends\n                // LabelType.\n                ILabelVarType -> 1 + 2 * args.size\n\n                ShortType -> 2\n\n                IntType,\n                FloatType,\n                -> 4\n\n                StringType -> {\n                    if (dcGcFormat) {\n                        (args[0].value as String).length + 1\n                    } else {\n                        2 * (args[0].value as String).length + 2\n                    }\n                }\n\n                RegRefVarType -> 1 + args.size\n\n                // Check RegRefType and LabelType last, because \"is\" checks are very slow in JS.\n\n                is RegRefType -> 1\n\n                is LabelType -> 2\n\n                else -> error(\"Parameter type ${type::class} not implemented.\")\n            }\n        }\n\n        return size\n    }\n\n    fun copy(): Instruction =\n        Instruction(opcode, args, srcLoc)\n}\n\n/**\n * Instruction argument.\n */\ndata class Arg(val value: Any)\n\n/**\n * Position and length of related source assembly code.\n */\nclass SrcLoc(\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n)\n\n/**\n * Locations of the instruction parts in the source assembly code.\n */\nclass InstructionSrcLoc(\n    val mnemonic: SrcLoc?,\n    val args: List<SrcLoc> = emptyList(),\n    val stackArgs: List<SrcLoc> = emptyList(),\n)\n\n/**\n * Locations of a segment's labels in the source assembly code.\n */\nclass SegmentSrcLoc(val labels: MutableList<SrcLoc> = mutableListOf()) {\n    fun copy(): SegmentSrcLoc =\n        SegmentSrcLoc(ArrayList(labels))\n}\n","package world.phantasmal.lib.asm\n\nimport world.phantasmal.core.unsafe.UnsafeMap\n\nprivate val MNEMONIC_TO_OPCODES: UnsafeMap<String, Opcode> by lazy {\n    val map = UnsafeMap<String, Opcode>()\n\n    OPCODES.forEach { if (it != null) map.set(it.mnemonic, it) }\n    OPCODES_F8.forEach { if (it != null) map.set(it.mnemonic, it) }\n    OPCODES_F9.forEach { if (it != null) map.set(it.mnemonic, it) }\n\n    map\n}\nprivate val UNKNOWN_OPCODE_MNEMONIC_REGEX = Regex(\"\"\"^unknown_((f8|f9)?[0-9a-f]{2})$\"\"\")\n\n/**\n * Abstract super type of all types.\n */\nsealed class AnyType {\n    abstract val uiName: String\n\n    object Instance : AnyType() {\n        override val uiName = \"Any\"\n    }\n}\n\n/**\n * Purely abstract super type of all value types.\n */\nsealed class ValueType : AnyType()\n\n/**\n * 8-Bit integer.\n */\nobject ByteType : ValueType() {\n    override val uiName = \"Byte\"\n}\n\n/**\n * 16-Bit integer.\n */\nobject ShortType : ValueType() {\n    override val uiName = \"Short\"\n}\n\n/**\n * 32-Bit integer.\n */\nobject IntType : ValueType() {\n    override val uiName = \"Int\"\n}\n\n/**\n * 32-Bit floating point number.\n */\nobject FloatType : ValueType() {\n    override val uiName = \"Float\"\n}\n\n/**\n * Abstract super type of all label types.\n */\nsealed class LabelType : ValueType() {\n    object Instance : LabelType() {\n        override val uiName = \"Label\"\n    }\n}\n\n/**\n * Named reference to an instruction.\n */\nobject ILabelType : LabelType() {\n    override val uiName = \"ILabel\"\n}\n\n/**\n * Named reference to a data segment.\n */\nobject DLabelType : LabelType() {\n    override val uiName = \"DLabel\"\n}\n\n/**\n * Named reference to a string segment.\n */\nobject SLabelType : LabelType() {\n    override val uiName = \"SLabel\"\n}\n\n/**\n * Arbitrary amount of instruction labels (variadic arguments).\n */\nobject ILabelVarType : LabelType() {\n    override val uiName = \"...ILabel\"\n}\n\n/**\n * String of arbitrary size.\n */\nobject StringType : ValueType() {\n    override val uiName = \"String\"\n}\n\n/**\n * Purely abstract super type of all reference types.\n */\nsealed class RefType : AnyType()\n\n/**\n * Register reference. If [registers] is null, references one or more consecutive registers of any\n * type (only stack_pushm and stack_popm use this). If [registers] is not null, references a fixed\n * amount of consecutive registers of specific types. [Param.type] can't be a variadic type.\n */\nclass RegRefType(val registers: List<Param>?) : RefType() {\n    override val uiName = buildString {\n        append(\"Register\")\n\n        if (registers != null) {\n            if (registers.size > 1) append(\"s\")\n            append(\"<\")\n            registers.joinTo(this) { it.type.uiName }\n            append(\">\")\n        }\n    }\n}\n\n/**\n * Arbitrary amount of register references (variadic arguments).\n */\nobject RegRefVarType : RefType() {\n    override val uiName = \"...Register\"\n}\n\n/**\n * Raw memory pointer.\n */\nobject PointerType : AnyType() {\n    override val uiName = \"Pointer\"\n}\n\nenum class ParamAccess {\n    Read,\n    Write,\n    ReadWrite\n}\n\nclass Param(\n    val type: AnyType,\n    /**\n     * Documentation string.\n     */\n    val doc: String?,\n    /**\n     * The way referenced registers are accessed by the instruction. Only set when type is a\n     * register reference.\n     */\n    val access: ParamAccess?,\n) {\n    /**\n     * Whether or not this parameter takes a variable number of arguments.\n     */\n    val varargs: Boolean = type === ILabelVarType || type === RegRefVarType\n\n    /**\n     * Whether or not the instruction reads this parameter.\n     */\n    val reads: Boolean\n        get() =\n            access === ParamAccess.Read || access === ParamAccess.ReadWrite\n\n    /**\n     * Whether or not the instruction writes this parameter.\n     */\n    val writes: Boolean\n        get() =\n            access === ParamAccess.Write || access === ParamAccess.ReadWrite\n}\n\nenum class StackInteraction {\n    Push,\n    Pop,\n}\n\n/**\n * Opcode for script byte code. Invoked by instructions.\n * Don't directly instantiate this class, use the global constants and lookup functions.\n */\nclass Opcode internal constructor(\n    /**\n     * 1- Or 2-byte big-endian representation of this opcode as used in byte code.\n     */\n    val code: Int,\n    /**\n     * String representation of this opcode as used in assembly.\n     */\n    val mnemonic: String,\n    /**\n     * Documentation string.\n     */\n    val doc: String?,\n    /**\n     * Parameters passed in directly or via the stack, depending on the value of [stack].\n     */\n    val params: List<Param>,\n    /**\n     * Stack interaction.\n     */\n    val stack: StackInteraction?,\n    /**\n     * Whether or not the last parameter of this opcode takes a variable number of arguments.\n     */\n    val varargs: Boolean,\n    /**\n     * Whether or not the working of this opcode is known.\n     */\n    val known: Boolean,\n) {\n    /**\n     * Byte size of the opcode, either 1 or 2.\n     */\n    val size: Int = if (code < 0xFF) 1 else 2\n\n    override fun equals(other: Any?): Boolean = this === other\n\n    override fun hashCode(): Int = code\n}\n\nfun codeToOpcode(code: Int): Opcode =\n    when {\n        code <= 0xFF -> getOpcode(code, code, OPCODES)\n        code <= 0xF8FF -> getOpcode(code, code and 0xFF, OPCODES_F8)\n        else -> getOpcode(code, code and 0xFF, OPCODES_F9)\n    }\n\nfun mnemonicToOpcode(mnemonic: String): Opcode? {\n    var opcode = MNEMONIC_TO_OPCODES.get(mnemonic)\n\n    if (opcode == null) {\n        UNKNOWN_OPCODE_MNEMONIC_REGEX.matchEntire(mnemonic)?.destructured?.let { (codeStr) ->\n            val code = codeStr.toInt(16)\n            opcode = codeToOpcode(code)\n            MNEMONIC_TO_OPCODES.set(mnemonic, opcode!!)\n        }\n    }\n\n    return opcode\n}\n\nprivate fun getOpcode(code: Int, index: Int, opcodes: Array<Opcode?>): Opcode {\n    var opcode = opcodes[index]\n\n    if (opcode == null) {\n        opcode = Opcode(\n            code,\n            mnemonic = \"unknown_${code.toString(16)}\",\n            doc = null,\n            params = emptyList(),\n            stack = null,\n            varargs = false,\n            known = false,\n        )\n        opcodes[index] = opcode\n    }\n\n    return opcode\n}\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun String.fastReplace(oldValue: String, newValue: String): String =\n    asDynamic().replaceAll(oldValue, newValue).unsafeCast<String>()\n","package world.phantasmal.core\n\n@Suppress(\"NOTHING_TO_INLINE\")\nactual inline fun String.getCodePointAt(index: Int): Int =\n    asDynamic().charCodeAt(index).unsafeCast<Int>()\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport world.phantasmal.lib.asm.*\n\n// See https://en.wikipedia.org/wiki/Control-flow_graph.\n\nenum class BranchType {\n    /**\n     * Only encountered when the last segment of a script has no jump or return.\n     */\n    None,\n\n    /**\n     * ret.\n     */\n    Return,\n\n    /**\n     * jmp.\n     */\n    Jump,\n\n    /**\n     * Every other jump instruction.\n     */\n    ConditionalJump,\n\n    /**\n     * call, switch_call or va_call.\n     */\n    Call,\n}\n\n/**\n * Instruction sequence into which control flow only enters at the start and only leaves at the end.\n * No code jumps/returns/calls into the middle of a basic block or branches out of a basic block\n * from the middle.\n */\ninterface BasicBlock {\n    /**\n     * The instruction segment that this block is a part of.\n     */\n    val segment: InstructionSegment\n\n    /**\n     * Index of this block's first instruction.\n     */\n    val start: Int\n\n    /**\n     * Index of the instruction right after this block's last instruction.\n     */\n    val end: Int\n\n    /**\n     * The way control flow leaves this block.\n     */\n    val branchType: BranchType\n\n    /**\n     * Either jumps or calls when non-empty, depending on [branchType].\n     */\n    val branchLabels: List<Int>\n\n    /**\n     * The blocks which branch to this block.\n     */\n    val from: List<BasicBlock>\n\n    /**\n     * The blocks this block branches to.\n     */\n    val to: List<BasicBlock>\n\n    fun indexOfInstruction(instruction: Instruction): Int\n}\n\n/**\n * Graph representing the flow of control through the [BasicBlock]s of a script.\n */\nclass ControlFlowGraph internal constructor(\n    val blocks: List<BasicBlock>,\n    private val instructionToBlock: Map<Instruction, BasicBlock>,\n) {\n    fun getBlockForInstruction(instruction: Instruction): BasicBlock {\n        val block = instructionToBlock[instruction]\n        requireNotNull(block) { \"Instruction is not part of the control-flow graph.\" }\n        return block\n    }\n\n    companion object {\n        fun create(bytecodeIr: BytecodeIr): ControlFlowGraph =\n            create(bytecodeIr.instructionSegments())\n\n        fun create(segments: List<InstructionSegment>): ControlFlowGraph {\n            val cfg = ControlFlowGraphBuilder()\n\n            // Mapping of labels to basic blocks.\n            for (segment in segments) {\n                createBasicBlocks(cfg, segment)\n            }\n\n            linkBlocks(cfg)\n            return cfg.build()\n        }\n    }\n}\n\nprivate class ControlFlowGraphBuilder {\n    val blocks: MutableList<BasicBlockImpl> = mutableListOf()\n    val instructionsToBlock: MutableMap<Instruction, BasicBlockImpl> = mutableMapOf()\n    val labelsToBlock: MutableMap<Int, BasicBlockImpl> = mutableMapOf()\n\n    fun build(): ControlFlowGraph =\n        ControlFlowGraph(blocks, instructionsToBlock)\n}\n\nprivate class BasicBlockImpl(\n    override val segment: InstructionSegment,\n    override val start: Int,\n    override val end: Int,\n    override val branchType: BranchType,\n    override val branchLabels: List<Int>,\n) : BasicBlock {\n    override val from: MutableList<BasicBlockImpl> = mutableListOf()\n    override val to: MutableList<BasicBlockImpl> = mutableListOf()\n\n    override fun indexOfInstruction(instruction: Instruction): Int {\n        var index = -1\n\n        for (i in start until end) {\n            if (instruction == segment.instructions[i]) {\n                index = i\n                break\n            }\n        }\n\n        return index\n    }\n\n    fun linkTo(other: BasicBlockImpl) {\n        if (other !in to) {\n            to.add(other)\n            other.from.add(this)\n        }\n    }\n}\n\nprivate fun createBasicBlocks(cfg: ControlFlowGraphBuilder, segment: InstructionSegment) {\n    val len = segment.instructions.size\n    var start = 0\n    var firstBlock = true\n\n    for (i in 0 until len) {\n        val inst = segment.instructions[i]\n\n        var branchType: BranchType\n        var branchLabels: List<Int>\n\n        when (inst.opcode.code) {\n            // Return.\n            OP_RET.code -> {\n                branchType = BranchType.Return\n                branchLabels = emptyList()\n            }\n\n            // Unconditional jump.\n            OP_JMP.code -> {\n                branchType = BranchType.Jump\n                branchLabels = listOf(inst.args[0].value as Int)\n            }\n\n            // Conditional jumps.\n            OP_JMP_ON.code,\n            OP_JMP_OFF.code,\n            -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = listOf(inst.args[0].value as Int)\n            }\n            OP_JMP_E.code,\n            OP_JMPI_E.code,\n            OP_JMP_NE.code,\n            OP_JMPI_NE.code,\n            OP_UJMP_G.code,\n            OP_UJMPI_G.code,\n            OP_JMP_G.code,\n            OP_JMPI_G.code,\n            OP_UJMP_L.code,\n            OP_UJMPI_L.code,\n            OP_JMP_L.code,\n            OP_JMPI_L.code,\n            OP_UJMP_GE.code,\n            OP_UJMPI_GE.code,\n            OP_JMP_GE.code,\n            OP_JMPI_GE.code,\n            OP_UJMP_LE.code,\n            OP_UJMPI_LE.code,\n            OP_JMP_LE.code,\n            OP_JMPI_LE.code,\n            -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = listOf(inst.args[2].value as Int)\n            }\n            OP_SWITCH_JMP.code -> {\n                branchType = BranchType.ConditionalJump\n                branchLabels = inst.args.drop(1).map { it.value as Int }\n            }\n\n            // Calls.\n            OP_CALL.code,\n            OP_VA_CALL.code,\n            -> {\n                branchType = BranchType.Call\n                branchLabels = listOf(inst.args[0].value as Int)\n            }\n            OP_SWITCH_CALL.code -> {\n                branchType = BranchType.Call\n                branchLabels = inst.args.drop(1).map { it.value as Int }\n            }\n\n            // All other opcodes.\n            else -> {\n                if (i == len - 1) {\n                    // This is the last block of the segment.\n                    branchType = BranchType.None\n                    branchLabels = emptyList()\n                } else {\n                    // Non-branching instruction, part of the current block.\n                    continue\n                }\n            }\n        }\n\n        val block = BasicBlockImpl(segment, start, i + 1, branchType, branchLabels)\n\n        for (j in block.start until block.end) {\n            cfg.instructionsToBlock[block.segment.instructions[j]] = block\n        }\n\n        cfg.blocks.add(block)\n\n        if (firstBlock) {\n            for (label in segment.labels) {\n                cfg.labelsToBlock[label] = block\n            }\n\n            firstBlock = false\n        }\n\n        start = i + 1\n    }\n}\n\nprivate fun linkBlocks(cfg: ControlFlowGraphBuilder) {\n    // Pairs of calling block and block to which callees should return to.\n    val callers = mutableListOf<Pair<BasicBlockImpl, BasicBlockImpl>>()\n\n    for (i in cfg.blocks.indices) {\n        val block = cfg.blocks[i]\n        val nextBlock = cfg.blocks.getOrNull(i + 1)\n\n        when (block.branchType) {\n            BranchType.Return ->\n                continue\n\n            BranchType.Call ->\n                nextBlock?.let { callers.add(block to nextBlock); }\n\n            BranchType.None,\n            BranchType.ConditionalJump,\n            -> nextBlock?.let(block::linkTo)\n\n            BranchType.Jump -> {\n                // Ignore.\n            }\n        }\n\n        for (label in block.branchLabels) {\n            cfg.labelsToBlock[label]?.let { toBlock ->\n                block.linkTo(toBlock)\n            }\n        }\n    }\n\n    for ((caller, ret) in callers) {\n        linkReturningBlocks(cfg.labelsToBlock, ret, caller)\n    }\n}\n\n/**\n * Links returning blocks to their callers.\n *\n * @param labelBlocks Mapping of labels to basic blocks.\n * @param ret Basic block the caller should return to.\n * @param caller Calling basic block.\n */\nprivate fun linkReturningBlocks(\n    labelBlocks: Map<Int, BasicBlockImpl>,\n    ret: BasicBlockImpl,\n    caller: BasicBlockImpl,\n) {\n    for (label in caller.branchLabels) {\n        labelBlocks[label]?.let { callee ->\n            if (callee.branchType === BranchType.Return) {\n                callee.linkTo(ret)\n            } else {\n                linkReturningBlocksRecurse(mutableSetOf(), ret, callee)\n            }\n        }\n    }\n}\n\n/**\n * @param encountered For avoiding infinite loops.\n * @param ret\n * @param block\n */\nprivate fun linkReturningBlocksRecurse(\n    encountered: MutableSet<BasicBlockImpl>,\n    ret: BasicBlockImpl,\n    block: BasicBlockImpl,\n) {\n    if (block in encountered) {\n        return\n    } else {\n        encountered.add(block)\n    }\n\n    for (toBlock in block.to) {\n        if (toBlock.branchType === BranchType.Return) {\n            toBlock.linkTo(ret)\n        } else {\n            linkReturningBlocksRecurse(encountered, ret, toBlock)\n        }\n    }\n}\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.asm.InstructionSegment\nimport world.phantasmal.lib.asm.OP_BB_MAP_DESIGNATE\nimport world.phantasmal.lib.asm.OP_MAP_DESIGNATE\nimport world.phantasmal.lib.asm.OP_MAP_DESIGNATE_EX\n\nprivate val logger = KotlinLogging.logger {}\n\nfun getMapDesignations(\n    func0Segment: InstructionSegment,\n    createCfg: () -> ControlFlowGraph,\n): MutableMap<Int, Int> {\n    val mapDesignations = mutableMapOf<Int, Int>()\n    var cfg: ControlFlowGraph? = null\n\n    for (inst in func0Segment.instructions) {\n        when (inst.opcode.code) {\n            OP_MAP_DESIGNATE.code,\n            OP_MAP_DESIGNATE_EX.code,\n            -> {\n                if (cfg == null) {\n                    cfg = createCfg()\n                }\n\n                val areaId = getRegisterValue(cfg, inst, inst.args[0].value as Int)\n\n                if (areaId.size > 1) {\n                    logger.warn {\n                        \"Couldn't determine area ID for ${inst.opcode.mnemonic} instruction.\"\n                    }\n                    continue\n                }\n\n                val variantIdRegister =\n                    inst.args[0].value as Int + (if (inst.opcode == OP_MAP_DESIGNATE) 2 else 3)\n                val variantId = getRegisterValue(cfg, inst, variantIdRegister)\n\n                if (variantId.size > 1) {\n                    logger.warn {\n                        \"Couldn't determine area variant ID for ${inst.opcode.mnemonic} instruction.\"\n                    }\n                    continue\n                }\n\n                mapDesignations[areaId[0]!!] = variantId[0]!!\n            }\n\n            OP_BB_MAP_DESIGNATE.code -> {\n                mapDesignations[inst.args[0].value as Int] = inst.args[2].value as Int\n            }\n        }\n    }\n\n    return mapDesignations\n}\n","package world.phantasmal.lib.asm.dataFlowAnalysis\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.asm.*\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * Computes the possible values of a stack element at the nth position from the top, right before a\n * specific instruction.\n */\nfun getStackValue(cfg: ControlFlowGraph, instruction: Instruction, position: Int): ValueSet {\n    val block = cfg.getBlockForInstruction(instruction)\n\n    return StackValueFinder().find(\n        mutableSetOf(),\n        cfg,\n        block,\n        block.indexOfInstruction(instruction),\n        position,\n    )\n}\n\nprivate class StackValueFinder {\n    private var iterations = 0\n\n    fun find(\n        path: MutableSet<BasicBlock>,\n        cfg: ControlFlowGraph,\n        block: BasicBlock,\n        end: Int,\n        position: Int,\n    ): ValueSet {\n        if (++iterations > 100) {\n            logger.warn { \"Too many iterations.\" }\n            return ValueSet.all()\n        }\n\n        var pos = position\n\n        for (i in end - 1 downTo block.start) {\n            val instruction = block.segment.instructions[i]\n\n            if (instruction.opcode.stack == StackInteraction.Pop) {\n                pos += instruction.opcode.params.size\n                continue\n            }\n\n            val args = instruction.args\n\n            when (instruction.opcode.code) {\n                OP_ARG_PUSHR.code -> {\n                    if (pos == 0) {\n                        return getRegisterValue(cfg, instruction, args[0].value as Int)\n                    } else {\n                        pos--\n                    }\n                }\n\n                OP_ARG_PUSHL.code,\n                OP_ARG_PUSHB.code,\n                OP_ARG_PUSHW.code,\n                -> {\n                    if (pos == 0) {\n                        return ValueSet.of(args[0].value as Int)\n                    } else {\n                        pos--\n                    }\n                }\n\n                OP_ARG_PUSHA.code,\n                OP_ARG_PUSHO.code,\n                OP_ARG_PUSHS.code,\n                -> {\n                    if (pos == 0) {\n                        return ValueSet.all()\n                    } else {\n                        pos--\n                    }\n                }\n            }\n        }\n\n        val values = ValueSet.empty()\n        path.add(block)\n\n        for (from in block.from) {\n            // Bail out from loops.\n            if (from in path) {\n                return ValueSet.all()\n            }\n\n            values.union(find(LinkedHashSet(path), cfg, from, from.end, pos))\n        }\n\n        return values\n    }\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport world.phantasmal.lib.Episode\n\nclass Area(\n    val id: Int,\n    val name: String,\n    val order: Int,\n    val areaVariants: List<AreaVariant>,\n)\n\nclass AreaVariant(\n    val id: Int,\n    val area: Area,\n)\n\nfun getAreasForEpisode(episode: Episode): List<Area> =\n    AREAS.getValue(episode)\n\nprivate val AREAS by lazy {\n    var order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep1 = listOf(\n        createArea(0, \"Pioneer II\", order++, 1),\n        createArea(1, \"Forest 1\", order++, 1),\n        createArea(2, \"Forest 2\", order++, 1),\n        createArea(11, \"Under the Dome\", order++, 1),\n        createArea(3, \"Cave 1\", order++, 6),\n        createArea(4, \"Cave 2\", order++, 5),\n        createArea(5, \"Cave 3\", order++, 6),\n        createArea(12, \"Underground Channel\", order++, 1),\n        createArea(6, \"Mine 1\", order++, 6),\n        createArea(7, \"Mine 2\", order++, 6),\n        createArea(13, \"Monitor Room\", order++, 1),\n        createArea(8, \"Ruins 1\", order++, 5),\n        createArea(9, \"Ruins 2\", order++, 5),\n        createArea(10, \"Ruins 3\", order++, 5),\n        createArea(14, \"Dark Falz\", order++, 1),\n        // TODO:\n        // createArea(15, \"BA Ruins\", order++, 3),\n        // createArea(16, \"BA Spaceship\", order++, 3),\n        // createArea(17, \"Lobby\", order++, 15),\n    )\n\n    order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep2 = listOf(\n        createArea(0, \"Lab\", order++, 1),\n        createArea(1, \"VR Temple Alpha\", order++, 3),\n        createArea(2, \"VR Temple Beta\", order++, 3),\n        createArea(14, \"VR Temple Final\", order++, 1),\n        createArea(3, \"VR Spaceship Alpha\", order++, 3),\n        createArea(4, \"VR Spaceship Beta\", order++, 3),\n        createArea(15, \"VR Spaceship Final\", order++, 1),\n        createArea(5, \"Central Control Area\", order++, 1),\n        createArea(6, \"Jungle Area East\", order++, 1),\n        createArea(7, \"Jungle Area North\", order++, 1),\n        createArea(8, \"Mountain Area\", order++, 3),\n        createArea(9, \"Seaside Area\", order++, 1),\n        createArea(12, \"Cliffs of Gal Da Val\", order++, 1),\n        createArea(10, \"Seabed Upper Levels\", order++, 3),\n        createArea(11, \"Seabed Lower Levels\", order++, 3),\n        createArea(13, \"Test Subject Disposal Area\", order++, 1),\n        createArea(16, \"Seaside Area at Night\", order++, 2),\n        createArea(17, \"Control Tower\", order++, 5),\n    )\n\n    order = 0\n\n    @Suppress(\"UNUSED_CHANGED_VALUE\")\n    val ep4 = listOf(\n        createArea(0, \"Pioneer II\", order++, 1),\n        createArea(1, \"Crater Route 1\", order++, 1),\n        createArea(2, \"Crater Route 2\", order++, 1),\n        createArea(3, \"Crater Route 3\", order++, 1),\n        createArea(4, \"Crater Route 4\", order++, 1),\n        createArea(5, \"Crater Interior\", order++, 1),\n        createArea(6, \"Subterranean Desert 1\", order++, 3),\n        createArea(7, \"Subterranean Desert 2\", order++, 3),\n        createArea(8, \"Subterranean Desert 3\", order++, 3),\n        createArea(9, \"Meteor Impact Site\", order++, 1),\n    )\n\n    mapOf(\n        Episode.I to ep1,\n        Episode.II to ep2,\n        Episode.IV to ep4,\n    )\n}\n\nprivate fun createArea(id: Int, name: String, order: Int, variants: Int): Area {\n    val avs = mutableListOf<AreaVariant>()\n    val area = Area(id, name, order, avs)\n\n    for (avId in 0 until variants) {\n        avs.add(AreaVariant(avId, area))\n    }\n\n    return area\n}\n","package world.phantasmal.lib.fileFormats.quest\n\n/**\n * Represents an entity type-specific property for accessing ambiguous parts of the entity data.\n */\nclass EntityProp(\n    val name: String,\n    val offset: Int,\n    val type: EntityPropType,\n)\n\nenum class EntityPropType {\n    I32,\n    F32,\n\n    /**\n     * Signed 32-bit integer that represents an angle. 0x10000 is 360°.\n     */\n    Angle,\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport world.phantasmal.lib.Episode\n\nprivate val FRIENDLY_NPC_PROPERTIES = listOf(\n    EntityProp(name = \"Movement distance\", offset = 44, type = EntityPropType.F32),\n    EntityProp(name = \"Hide register\", offset = 52, type = EntityPropType.F32),\n    EntityProp(name = \"Character ID\", offset = 56, type = EntityPropType.F32),\n    EntityProp(name = \"Script label\", offset = 60, type = EntityPropType.F32),\n    EntityProp(name = \"Movement flag\", offset = 64, type = EntityPropType.I32)\n)\n\nenum class NpcType(\n    override val uniqueName: String,\n    override val simpleName: String = uniqueName,\n    val ultimateName: String = simpleName,\n    val episode: Episode? = null,\n    val enemy: Boolean = false,\n    rareType: (() -> NpcType)? = null,\n    /**\n     * IDs of the areas this NPC can be found in.\n     */\n    val areaIds: List<Int>,\n    /**\n     * Type ID used by the game.\n     */\n    val typeId: Int? = null,\n    /**\n     * Skin value used by the game.\n     */\n    val skin: Int? = null,\n    /**\n     * Boolean specifying whether an NPC is the regular or special variant.\n     * Sometimes signifies a variant (e.g. Barbarous Wolf), sometimes a rare variant (e.g. Pouilly\n     * Slime).\n     */\n    val special: Boolean? = null,\n    /**\n     * NPC-specific properties.\n     */\n    override val properties: List<EntityProp> = emptyList(),\n) : EntityType {\n    //\n    // Unknown NPCs\n    //\n\n    Unknown(\n        uniqueName = \"Unknown\",\n        areaIds = listOf(),\n    ),\n\n    //\n    // Friendly NPCs\n    //\n\n    FemaleFat(\n        uniqueName = \"Female Fat\",\n        areaIds = listOf(0),\n        typeId = 4,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    FemaleMacho(\n        uniqueName = \"Female Macho\",\n        areaIds = listOf(0),\n        typeId = 5,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    FemaleTall(\n        uniqueName = \"Female Tall\",\n        areaIds = listOf(0),\n        typeId = 7,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleDwarf(\n        uniqueName = \"Male Dwarf\",\n        areaIds = listOf(0),\n        typeId = 10,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleFat(\n        uniqueName = \"Male Fat\",\n        areaIds = listOf(0),\n        typeId = 11,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleMacho(\n        uniqueName = \"Male Macho\",\n        areaIds = listOf(0),\n        typeId = 12,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    MaleOld(\n        uniqueName = \"Male Old\",\n        areaIds = listOf(0),\n        typeId = 13,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    BlueSoldier(\n        uniqueName = \"Blue Soldier\",\n        areaIds = listOf(0),\n        typeId = 25,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    RedSoldier(\n        uniqueName = \"Red Soldier\",\n        areaIds = listOf(0),\n        typeId = 26,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Principal(\n        uniqueName = \"Principal\",\n        areaIds = listOf(0),\n        typeId = 27,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Tekker(\n        uniqueName = \"Tekker\",\n        areaIds = listOf(0),\n        typeId = 28,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    GuildLady(\n        uniqueName = \"Guild Lady\",\n        areaIds = listOf(0),\n        typeId = 29,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Scientist(\n        uniqueName = \"Scientist\",\n        areaIds = listOf(0),\n        typeId = 30,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Nurse(\n        uniqueName = \"Nurse\",\n        areaIds = listOf(0),\n        typeId = 31,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Irene(\n        uniqueName = \"Irene\",\n        areaIds = listOf(0),\n        typeId = 32,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    ItemShop(\n        uniqueName = \"Item Shop\",\n        areaIds = listOf(0),\n        typeId = 241,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n    Nurse2(\n        uniqueName = \"Nurse (Ep. II)\",\n        simpleName = \"Nurse\",\n        episode = Episode.II,\n        areaIds = listOf(0),\n        typeId = 254,\n        skin = 0,\n        special = false,\n        properties = FRIENDLY_NPC_PROPERTIES,\n    ),\n\n    //\n    // Enemy NPCs\n    //\n\n    // Episode I Forest\n\n    Hildebear(\n        uniqueName = \"Hildebear\",\n        ultimateName = \"Hildelt\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { Hildeblue },\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 0,\n        special = false,\n    ),\n    Hildeblue(\n        uniqueName = \"Hildeblue\",\n        ultimateName = \"Hildetorr\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 1,\n        special = false,\n    ),\n    RagRappy(\n        uniqueName = \"Rag Rappy\",\n        ultimateName = \"El Rappy\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { AlRappy },\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    AlRappy(\n        uniqueName = \"Al Rappy\",\n        ultimateName = \"Pal Rappy\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    Monest(\n        uniqueName = \"Monest\",\n        ultimateName = \"Mothvist\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 66,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"State\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Start number\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Total number\", offset = 52, type = EntityPropType.F32)\n        ),\n    ),\n    Mothmant(\n        uniqueName = \"Mothmant\",\n        ultimateName = \"Mothvert\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    SavageWolf(\n        uniqueName = \"Savage Wolf\",\n        ultimateName = \"Gulgus\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 67,\n        skin = 0,\n        special = false,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    BarbarousWolf(\n        uniqueName = \"Barbarous Wolf\",\n        ultimateName = \"Gulgus-Gue\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 67,\n        skin = 0,\n        special = true,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    Booma(\n        uniqueName = \"Booma\",\n        ultimateName = \"Bartle\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Gobooma(\n        uniqueName = \"Gobooma\",\n        ultimateName = \"Barble\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Gigobooma(\n        uniqueName = \"Gigobooma\",\n        ultimateName = \"Tollaw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 68,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Dragon(\n        uniqueName = \"Dragon\",\n        ultimateName = \"Sil Dragon\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(11),\n        typeId = 192,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Caves\n\n    GrassAssassin(\n        uniqueName = \"Grass Assassin\",\n        ultimateName = \"Crimson Assassin\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 96,\n        skin = 0,\n        special = false,\n    ),\n    PoisonLily(\n        uniqueName = \"Poison Lily\",\n        ultimateName = \"Ob Lily\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { NarLily },\n        areaIds = listOf(3, 4, 5),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    NarLily(\n        uniqueName = \"Nar Lily\",\n        ultimateName = \"Mil Lily\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 97,\n        skin = 1,\n        special = true,\n    ),\n    NanoDragon(\n        uniqueName = \"Nano Dragon\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 98,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spawn flag\", offset = 64, type = EntityPropType.I32)\n        ),\n    ),\n    EvilShark(\n        uniqueName = \"Evil Shark\",\n        ultimateName = \"Vulmer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    PalShark(\n        uniqueName = \"Pal Shark\",\n        ultimateName = \"Govulmer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    GuilShark(\n        uniqueName = \"Guil Shark\",\n        ultimateName = \"Melqueek\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 99,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    PofuillySlime(\n        uniqueName = \"Pofuilly Slime\",\n        episode = Episode.I,\n        enemy = true,\n        rareType = { PouillySlime },\n        areaIds = listOf(3, 4, 5),\n        typeId = 100,\n        skin = 0,\n        special = false,\n    ),\n    PouillySlime(\n        uniqueName = \"Pouilly Slime\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 100,\n        skin = 0,\n        special = true,\n    ),\n    PanArms(\n        uniqueName = \"Pan Arms\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(3, 4, 5),\n        typeId = 101,\n        skin = 0,\n        special = false,\n    ),\n    Migium(\n        uniqueName = \"Migium\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Hidoom(\n        uniqueName = \"Hidoom\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    DeRolLe(\n        uniqueName = \"De Rol Le\",\n        ultimateName = \"Dal Ra Lie\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(12),\n        typeId = 193,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Mines\n\n    Dubchic(\n        uniqueName = \"Dubchic\",\n        ultimateName = \"Dubchich\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 128,\n        skin = 0,\n        special = false,\n    ),\n    Gilchic(\n        uniqueName = \"Gilchic\",\n        ultimateName = \"Gilchich\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 128,\n        skin = 1,\n        special = false,\n    ),\n    Garanz(\n        uniqueName = \"Garanz\",\n        ultimateName = \"Baranz\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 129,\n        skin = 0,\n        special = false,\n    ),\n    SinowBeat(\n        uniqueName = \"Sinow Beat\",\n        ultimateName = \"Sinow Blue\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 130,\n        skin = 0,\n        special = false,\n    ),\n    SinowGold(\n        uniqueName = \"Sinow Gold\",\n        ultimateName = \"Sinow Red\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 130,\n        skin = 0,\n        special = true,\n    ),\n    Canadine(\n        uniqueName = \"Canadine\",\n        ultimateName = \"Canabin\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 131,\n        skin = 0,\n        special = false,\n    ),\n    Canane(\n        uniqueName = \"Canane\",\n        ultimateName = \"Canune\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 132,\n        skin = 0,\n        special = false,\n    ),\n    Dubswitch(\n        uniqueName = \"Dubswitch\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(6, 7),\n        typeId = 133,\n        skin = 0,\n        special = false,\n    ),\n    VolOptPart1(\n        uniqueName = \"Vol Opt (Part 1)\",\n        simpleName = \"Vol Opt\",\n        ultimateName = \"Vol Opt ver.2\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 194,\n        skin = 0,\n        special = false,\n    ),\n    VolOptPart2(\n        uniqueName = \"Vol Opt (Part 2)\",\n        simpleName = \"Vol Opt\",\n        ultimateName = \"Vol Opt ver.2\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 197,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode I Ruins\n\n    Delsaber(\n        uniqueName = \"Delsaber\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 160,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Jump distance\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Block HP\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    ChaosSorcerer(\n        uniqueName = \"Chaos Sorcerer\",\n        ultimateName = \"Gran Sorcerer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 161,\n        skin = 0,\n        special = false,\n    ),\n    DarkGunner(\n        uniqueName = \"Dark Gunner\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 162,\n        skin = 0,\n        special = false,\n    ),\n    DeathGunner(\n        uniqueName = \"Death Gunner\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    ChaosBringer(\n        uniqueName = \"Chaos Bringer\",\n        ultimateName = \"Dark Bringer\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 164,\n        skin = 0,\n        special = false,\n    ),\n    DarkBelra(\n        uniqueName = \"Dark Belra\",\n        ultimateName = \"Indi Belra\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 165,\n        skin = 0,\n        special = false,\n    ),\n    Dimenian(\n        uniqueName = \"Dimenian\",\n        ultimateName = \"Arlan\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    LaDimenian(\n        uniqueName = \"La Dimenian\",\n        ultimateName = \"Merlan\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    SoDimenian(\n        uniqueName = \"So Dimenian\",\n        ultimateName = \"Del-D\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 166,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    Bulclaw(\n        uniqueName = \"Bulclaw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 167,\n        skin = 0,\n        special = false,\n    ),\n    Bulk(\n        uniqueName = \"Bulk\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Claw(\n        uniqueName = \"Claw\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(8, 9, 10),\n        typeId = 168,\n        skin = 0,\n        special = false,\n    ),\n    DarkFalz(\n        uniqueName = \"Dark Falz\",\n        episode = Episode.I,\n        enemy = true,\n        areaIds = listOf(14),\n        typeId = 200,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II VR Temple\n\n    Hildebear2(\n        uniqueName = \"Hildebear (Ep. II)\",\n        simpleName = \"Hildebear\",\n        ultimateName = \"Hildelt\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { Hildeblue2 },\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 0,\n        special = false,\n    ),\n    Hildeblue2(\n        uniqueName = \"Hildeblue (Ep. II)\",\n        simpleName = \"Hildeblue\",\n        ultimateName = \"Hildetorr\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 64,\n        skin = 1,\n        special = false,\n    ),\n    RagRappy2(\n        uniqueName = \"Rag Rappy (Ep. II)\",\n        simpleName = \"Rag Rappy\",\n        ultimateName = \"El Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { LoveRappy },\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    LoveRappy(\n        uniqueName = \"Love Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    StRappy(\n        uniqueName = \"St. Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    HalloRappy(\n        uniqueName = \"Hallo Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    EggRappy(\n        uniqueName = \"Egg Rappy\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Monest2(\n        uniqueName = \"Monest (Ep. II)\",\n        simpleName = \"Monest\",\n        ultimateName = \"Mothvist\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 66,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"State\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Start number\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Total number\", offset = 52, type = EntityPropType.F32)\n        ),\n    ),\n    Mothmant2(\n        uniqueName = \"Mothmant\",\n        ultimateName = \"Mothvert\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    PoisonLily2(\n        uniqueName = \"Poison Lily (Ep. II)\",\n        simpleName = \"Poison Lily\",\n        ultimateName = \"Ob Lily\",\n        episode = Episode.II,\n        enemy = true,\n        rareType = { NarLily2 },\n        areaIds = listOf(1, 2),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    NarLily2(\n        uniqueName = \"Nar Lily (Ep. II)\",\n        simpleName = \"Nar Lily\",\n        ultimateName = \"Mil Lily\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 97,\n        skin = 1,\n        special = false,\n    ),\n    GrassAssassin2(\n        uniqueName = \"Grass Assassin (Ep. II)\",\n        simpleName = \"Grass Assassin\",\n        ultimateName = \"Crimson Assassin\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 96,\n        skin = 0,\n        special = false,\n    ),\n    Dimenian2(\n        uniqueName = \"Dimenian (Ep. II)\",\n        simpleName = \"Dimenian\",\n        ultimateName = \"Arlan\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    LaDimenian2(\n        uniqueName = \"La Dimenian (Ep. II)\",\n        simpleName = \"La Dimenian\",\n        ultimateName = \"Merlan\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    SoDimenian2(\n        uniqueName = \"So Dimenian (Ep. II)\",\n        simpleName = \"So Dimenian\",\n        ultimateName = \"Del-D\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 166,\n        skin = 2,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Idle distance\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    DarkBelra2(\n        uniqueName = \"Dark Belra (Ep. II)\",\n        simpleName = \"Dark Belra\",\n        ultimateName = \"Indi Belra\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(1, 2),\n        typeId = 165,\n        skin = 0,\n        special = false,\n    ),\n    BarbaRay(\n        uniqueName = \"Barba Ray\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(14),\n        typeId = 203,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II VR Spaceship\n\n    SavageWolf2(\n        uniqueName = \"Savage Wolf (Ep. II)\",\n        simpleName = \"Savage Wolf\",\n        ultimateName = \"Gulgus\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 67,\n        skin = 0,\n        special = false,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    BarbarousWolf2(\n        uniqueName = \"Barbarous Wolf (Ep. II)\",\n        simpleName = \"Barbarous Wolf\",\n        ultimateName = \"Gulgus-Gue\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 67,\n        skin = 0,\n        special = true,\n        properties = listOf(EntityProp(name = \"Group ID\", offset = 44, type = EntityPropType.F32)),\n    ),\n    PanArms2(\n        uniqueName = \"Pan Arms (Ep. II)\",\n        simpleName = \"Pan Arms\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 101,\n        skin = 0,\n        special = false,\n    ),\n    Migium2(\n        uniqueName = \"Migium (Ep. II)\",\n        simpleName = \"Migium\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Hidoom2(\n        uniqueName = \"Hidoom (Ep. II)\",\n        simpleName = \"Hidoom\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    Dubchic2(\n        uniqueName = \"Dubchic (Ep. II)\",\n        simpleName = \"Dubchic\",\n        ultimateName = \"Dubchich\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 128,\n        skin = 0,\n        special = false,\n    ),\n    Gilchic2(\n        uniqueName = \"Gilchic (Ep. II)\",\n        simpleName = \"Gilchic\",\n        ultimateName = \"Gilchich\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 128,\n        skin = 1,\n        special = false,\n    ),\n    Garanz2(\n        uniqueName = \"Garanz (Ep. II)\",\n        simpleName = \"Garanz\",\n        ultimateName = \"Baranz\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 129,\n        skin = 0,\n        special = false,\n    ),\n    Dubswitch2(\n        uniqueName = \"Dubswitch (Ep. II)\",\n        simpleName = \"Dubswitch\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 133,\n        skin = 0,\n        special = false,\n    ),\n    Delsaber2(\n        uniqueName = \"Delsaber (Ep. II)\",\n        simpleName = \"Delsaber\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 160,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Jump distance\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Block HP\", offset = 48, type = EntityPropType.F32)\n        ),\n    ),\n    ChaosSorcerer2(\n        uniqueName = \"Chaos Sorcerer (Ep. II)\",\n        simpleName = \"Chaos Sorcerer\",\n        ultimateName = \"Gran Sorcerer\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(3, 4),\n        typeId = 161,\n        skin = 0,\n        special = false,\n    ),\n    GolDragon(\n        uniqueName = \"Gol Dragon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(15),\n        typeId = 204,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II Central Control Area\n\n    SinowBerill(\n        uniqueName = \"Sinow Berill\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 212,\n        skin = 0,\n        special = false,\n    ),\n    SinowSpigell(\n        uniqueName = \"Sinow Spigell\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 212,\n        skin = 1,\n        special = false,\n    ),\n    Merillia(\n        uniqueName = \"Merillia\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 213,\n        skin = 0,\n        special = false,\n    ),\n    Meriltas(\n        uniqueName = \"Meriltas\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 213,\n        skin = 1,\n        special = false,\n    ),\n    Mericarol(\n        uniqueName = \"Mericarol\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 0,\n        special = false,\n    ),\n    Mericus(\n        uniqueName = \"Mericus\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 1,\n        special = false,\n    ),\n    Merikle(\n        uniqueName = \"Merikle\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 214,\n        skin = 2,\n        special = false,\n    ),\n    UlGibbon(\n        uniqueName = \"Ul Gibbon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 215,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spot appear\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Jump appear\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Back jump\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Run tech\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Back tech\", offset = 60, type = EntityPropType.F32)\n        ),\n    ),\n    ZolGibbon(\n        uniqueName = \"Zol Gibbon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 215,\n        skin = 1,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Spot appear\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Jump appear\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Back jump\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Run tech\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Back tech\", offset = 60, type = EntityPropType.F32)\n        ),\n    ),\n    Gibbles(\n        uniqueName = \"Gibbles\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 216,\n        skin = 0,\n        special = false,\n    ),\n    Gee(\n        uniqueName = \"Gee\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16),\n        typeId = 217,\n        skin = 0,\n        special = false,\n    ),\n    GiGue(\n        uniqueName = \"Gi Gue\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(5, 6, 7, 8, 9, 16, 17),\n        typeId = 218,\n        skin = 0,\n        special = false,\n    ),\n    IllGill(\n        uniqueName = \"Ill Gill\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 225,\n        skin = 0,\n        special = false,\n    ),\n    DelLily(\n        uniqueName = \"Del Lily\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 97,\n        skin = 0,\n        special = false,\n    ),\n    Epsilon(\n        uniqueName = \"Epsilon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(17),\n        typeId = 224,\n        skin = 0,\n        special = false,\n    ),\n    GalGryphon(\n        uniqueName = \"Gal Gryphon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(12),\n        typeId = 192,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode II Seabed\n\n    Deldepth(\n        uniqueName = \"Deldepth\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 219,\n        skin = 0,\n        special = false,\n    ),\n    Delbiter(\n        uniqueName = \"Delbiter\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11, 17),\n        typeId = 220,\n        skin = 0,\n        special = false,\n        properties = listOf(\n            EntityProp(name = \"Howl percent\", offset = 44, type = EntityPropType.F32),\n            EntityProp(name = \"Confuse percent\", offset = 48, type = EntityPropType.F32),\n            EntityProp(name = \"Confuse distance\", offset = 52, type = EntityPropType.F32),\n            EntityProp(name = \"Laser percent\", offset = 56, type = EntityPropType.F32),\n            EntityProp(name = \"Charge percent\", offset = 60, type = EntityPropType.F32),\n            EntityProp(name = \"Type\", offset = 64, type = EntityPropType.I32)\n        ),\n    ),\n    Dolmolm(\n        uniqueName = \"Dolmolm\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 221,\n        skin = 0,\n        special = false,\n    ),\n    Dolmdarl(\n        uniqueName = \"Dolmdarl\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 221,\n        skin = 1,\n        special = false,\n    ),\n    Morfos(\n        uniqueName = \"Morfos\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 222,\n        skin = 0,\n        special = false,\n    ),\n    Recobox(\n        uniqueName = \"Recobox\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11, 17),\n        typeId = 223,\n        skin = 0,\n        special = false,\n    ),\n    Recon(\n        uniqueName = \"Recon\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(),\n    ),\n    SinowZoa(\n        uniqueName = \"Sinow Zoa\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 224,\n        skin = 0,\n        special = false,\n    ),\n    SinowZele(\n        uniqueName = \"Sinow Zele\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(10, 11),\n        typeId = 224,\n        skin = 1,\n        special = false,\n    ),\n    OlgaFlow(\n        uniqueName = \"Olga Flow\",\n        episode = Episode.II,\n        enemy = true,\n        areaIds = listOf(13),\n        typeId = 202,\n        skin = 0,\n        special = false,\n    ),\n\n    // Episode IV\n\n    SandRappy(\n        uniqueName = \"Sand Rappy\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { DelRappy },\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 65,\n        skin = 0,\n        special = false,\n    ),\n    DelRappy(\n        uniqueName = \"Del Rappy\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 65,\n        skin = 1,\n        special = false,\n    ),\n    Astark(\n        uniqueName = \"Astark\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 272,\n        skin = 0,\n        special = false,\n    ),\n    SatelliteLizard(\n        uniqueName = \"Satellite Lizard\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 273,\n        skin = 0,\n        special = false,\n    ),\n    Yowie(\n        uniqueName = \"Yowie\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 273,\n        skin = 0,\n        special = true,\n    ),\n    MerissaA(\n        uniqueName = \"Merissa A\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { MerissaAA },\n        areaIds = listOf(6, 7, 8),\n        typeId = 274,\n        skin = 0,\n        special = false,\n    ),\n    MerissaAA(\n        uniqueName = \"Merissa AA\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 274,\n        skin = 1,\n        special = false,\n    ),\n    Girtablulu(\n        uniqueName = \"Girtablulu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 275,\n        skin = 0,\n        special = false,\n    ),\n    Zu(\n        uniqueName = \"Zu\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Pazuzu },\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 276,\n        skin = 0,\n        special = false,\n    ),\n    Pazuzu(\n        uniqueName = \"Pazuzu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5, 6, 7, 8),\n        typeId = 276,\n        skin = 1,\n        special = false,\n    ),\n    Boota(\n        uniqueName = \"Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 0,\n        special = false,\n    ),\n    ZeBoota(\n        uniqueName = \"Ze Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 1,\n        special = false,\n    ),\n    BaBoota(\n        uniqueName = \"Ba Boota\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 277,\n        skin = 2,\n        special = false,\n    ),\n    Dorphon(\n        uniqueName = \"Dorphon\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { DorphonEclair },\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 278,\n        skin = 0,\n        special = false,\n    ),\n    DorphonEclair(\n        uniqueName = \"Dorphon Eclair\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(1, 2, 3, 4, 5),\n        typeId = 278,\n        skin = 1,\n        special = false,\n    ),\n    Goran(\n        uniqueName = \"Goran\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 0,\n        special = false,\n    ),\n    PyroGoran(\n        uniqueName = \"Pyro Goran\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 1,\n        special = false,\n    ),\n    GoranDetonator(\n        uniqueName = \"Goran Detonator\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(6, 7, 8),\n        typeId = 279,\n        skin = 2,\n        special = false,\n    ),\n    SaintMilion(\n        uniqueName = \"Saint-Milion\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Kondrieu },\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 0,\n        special = false,\n    ),\n    Shambertin(\n        uniqueName = \"Shambertin\",\n        episode = Episode.IV,\n        enemy = true,\n        rareType = { Kondrieu },\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 1,\n        special = false,\n    ),\n    Kondrieu(\n        uniqueName = \"Kondrieu\",\n        episode = Episode.IV,\n        enemy = true,\n        areaIds = listOf(9),\n        typeId = 281,\n        skin = 0,\n        special = true,\n    );\n\n    /**\n     * The type of this NPC's rare variant if it has one.\n     */\n    val rareType: NpcType? by lazy { rareType?.invoke() }\n\n    companion object {\n        /**\n         * Use this instead of [values] to avoid unnecessary copying.\n         */\n        val VALUES: Array<NpcType> = values()\n    }\n}\n","package world.phantasmal.lib.buffer\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.DataView\nimport org.khronos.webgl.Int8Array\nimport org.khronos.webgl.Uint8Array\nimport org.w3c.dom.WindowOrWorkerGlobalScope\nimport world.phantasmal.lib.Endianness\n\nexternal val self: WindowOrWorkerGlobalScope\n\nactual class Buffer private constructor(\n    arrayBuffer: ArrayBuffer,\n    size: Int,\n    endianness: Endianness,\n) {\n    var arrayBuffer = arrayBuffer\n        private set\n\n    private var dataView = DataView(arrayBuffer)\n    private var littleEndian = endianness == Endianness.Little\n\n    actual var size: Int = size\n        set(value) {\n            ensureCapacity(value)\n            field = value\n        }\n\n    actual var endianness: Endianness\n        get() = if (littleEndian) Endianness.Little else Endianness.Big\n        set(value) {\n            littleEndian = value == Endianness.Little\n        }\n\n    actual val capacity: Int\n        get() = arrayBuffer.byteLength\n\n    actual fun getUByte(offset: Int): UByte {\n        checkOffset(offset, 1)\n        return dataView.getUint8(offset).toUByte()\n    }\n\n    actual fun getUShort(offset: Int): UShort {\n        checkOffset(offset, 2)\n        return dataView.getUint16(offset, littleEndian).toUShort()\n    }\n\n    actual fun getUInt(offset: Int): UInt {\n        checkOffset(offset, 4)\n        return dataView.getUint32(offset, littleEndian).toUInt()\n    }\n\n    actual fun getByte(offset: Int): Byte {\n        checkOffset(offset, 1)\n        return dataView.getInt8(offset)\n    }\n\n    actual fun getShort(offset: Int): Short {\n        checkOffset(offset, 2)\n        return dataView.getInt16(offset, littleEndian)\n    }\n\n    actual fun getInt(offset: Int): Int {\n        checkOffset(offset, 4)\n        return dataView.getInt32(offset, littleEndian)\n    }\n\n    actual fun getFloat(offset: Int): Float {\n        checkOffset(offset, 4)\n        return dataView.getFloat32(offset, littleEndian)\n    }\n\n    actual fun getStringUtf16(\n        offset: Int,\n        maxByteLength: Int,\n        nullTerminated: Boolean,\n    ): String =\n        buildString {\n            val len = maxByteLength / 2\n\n            for (i in 0 until len) {\n                val codePoint = getShort(offset + i * 2).toChar()\n\n                if (nullTerminated && codePoint == '0') {\n                    break\n                }\n\n                append(codePoint)\n            }\n        }\n\n    actual fun slice(offset: Int, size: Int): Buffer {\n        checkOffset(offset, size)\n        return fromArrayBuffer(\n            arrayBuffer.slice(offset, (offset + size)),\n            endianness\n        )\n    }\n\n    actual fun setUByte(offset: Int, value: UByte): Buffer {\n        checkOffset(offset, 1)\n        dataView.setUint8(offset, value.toByte())\n        return this\n    }\n\n    actual fun setUShort(offset: Int, value: UShort): Buffer {\n        checkOffset(offset, 2)\n        dataView.setUint16(offset, value.toShort(), littleEndian)\n        return this\n    }\n\n    actual fun setUInt(offset: Int, value: UInt): Buffer {\n        checkOffset(offset, 4)\n        dataView.setUint32(offset, value.toInt(), littleEndian)\n        return this\n    }\n\n    actual fun setByte(offset: Int, value: Byte): Buffer {\n        checkOffset(offset, 1)\n        dataView.setInt8(offset, value)\n        return this\n    }\n\n    actual fun setShort(offset: Int, value: Short): Buffer {\n        checkOffset(offset, 2)\n        dataView.setInt16(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setInt(offset: Int, value: Int): Buffer {\n        checkOffset(offset, 4)\n        dataView.setInt32(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun setFloat(offset: Int, value: Float): Buffer {\n        checkOffset(offset, 4)\n        dataView.setFloat32(offset, value, littleEndian)\n        return this\n    }\n\n    actual fun zero(): Buffer =\n        fillByte(0)\n\n    actual fun fillByte(value: Byte): Buffer {\n        (Int8Array(arrayBuffer, 0, size).asDynamic()).fill(value)\n        return this\n    }\n\n    actual fun toBase64(): String {\n        var str = \"\"\n\n        for (i in 0 until size) {\n            str += (getByte(i).toInt() and 0xff).toChar()\n        }\n\n        return self.btoa(str)\n    }\n\n    actual fun copy(): Buffer =\n        Buffer(arrayBuffer.slice(0, size), size, endianness)\n\n    /**\n     * Checks whether we can read [size] bytes at [offset].\n     */\n    private fun checkOffset(offset: Int, size: Int) {\n        require(offset >= 0 && offset + size <= this.size) {\n            \"Offset $offset is out of bounds.\"\n        }\n    }\n\n    /**\n     * Reallocates the underlying ArrayBuffer if necessary.\n     */\n    private fun ensureCapacity(minNewSize: Int) {\n        if (minNewSize > capacity) {\n            var newSize = if (capacity == 0) minNewSize else capacity\n\n            do {\n                newSize *= 2\n            } while (newSize < minNewSize)\n\n            val newBuffer = ArrayBuffer(newSize)\n            Uint8Array(newBuffer).set(Uint8Array(arrayBuffer, 0, size))\n            arrayBuffer = newBuffer\n            dataView = DataView(arrayBuffer)\n        }\n    }\n\n    actual companion object {\n        actual fun withCapacity(\n            initialCapacity: Int,\n            endianness: Endianness,\n        ): Buffer =\n            Buffer(ArrayBuffer(initialCapacity), size = 0, endianness)\n\n        actual fun withSize(initialSize: Int, endianness: Endianness): Buffer =\n            Buffer(ArrayBuffer(initialSize), initialSize, endianness)\n\n        actual fun fromByteArray(array: ByteArray, endianness: Endianness): Buffer {\n            val arrayBuffer = ArrayBuffer(array.size)\n            Int8Array(arrayBuffer).set(array.toTypedArray())\n            return Buffer(arrayBuffer, array.size, endianness)\n        }\n\n        fun fromArrayBuffer(arrayBuffer: ArrayBuffer, endianness: Endianness): Buffer =\n            Buffer(arrayBuffer, arrayBuffer.byteLength, endianness)\n\n        actual fun fromBase64(data: String, endianness: Endianness): Buffer {\n            val str = self.atob(data)\n            val buf = withSize(str.length, endianness)\n\n            for (i in 0 until buf.size) {\n                buf.setByte(i, str[i].toByte())\n            }\n\n            return buf\n        }\n    }\n}\n","@file:Suppress(\"unused\")\n\npackage world.phantasmal.lib.asm\n\nval OPCODES: Array<Opcode?> = Array(256) { null }\nval OPCODES_F8: Array<Opcode?> = Array(256) { null }\nval OPCODES_F9: Array<Opcode?> = Array(256) { null }\n\nval OP_NOP = Opcode(\n    code = 0x00,\n    mnemonic = \"nop\",\n    doc = \"No operation, does nothing.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x00] = it }\n\nval OP_RET = Opcode(\n    code = 0x01,\n    mnemonic = \"ret\",\n    doc = \"Returns control to caller.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x01] = it }\n\nval OP_SYNC = Opcode(\n    code = 0x02,\n    mnemonic = \"sync\",\n    doc = \"Yields control for the rest of the current frame. Execution will continue the following frame.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x02] = it }\n\nval OP_EXIT = Opcode(\n    code = 0x03,\n    mnemonic = \"exit\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x03] = it }\n\nval OP_THREAD = Opcode(\n    code = 0x04,\n    mnemonic = \"thread\",\n    doc = \"Starts a new thread. Thread execution will start at the given label.\\nOften used to check a register every frame. Make sure to yield control with sync when looping.\",\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x04] = it }\n\nval OP_VA_START = Opcode(\n    code = 0x05,\n    mnemonic = \"va_start\",\n    doc = \"Initializes a variable argument list.\\nMake sure to call va_end after va_start and va_call.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x05] = it }\n\nval OP_VA_END = Opcode(\n    code = 0x06,\n    mnemonic = \"va_end\",\n    doc = \"Restores the registers overwritten by arg_push* instructions.\\nCalled after va_call.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x06] = it }\n\nval OP_VA_CALL = Opcode(\n    code = 0x07,\n    mnemonic = \"va_call\",\n    doc = \"Calls the variable argument function at the given label.\\nCalled after initializing the argument list with va_start and pushing arguments onto the stack with arg_push* instructions. Make sure to call va_end afterwards.\",\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x07] = it }\n\nval OP_LET = Opcode(\n    code = 0x08,\n    mnemonic = \"let\",\n    doc = \"Sets the first register's value to second one's value.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x08] = it }\n\nval OP_LETI = Opcode(\n    code = 0x09,\n    mnemonic = \"leti\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x09] = it }\n\nval OP_LETB = Opcode(\n    code = 0x0A,\n    mnemonic = \"letb\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(ByteType, null, ParamAccess.Write),\n        )), null, null),\n        Param(ByteType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0A] = it }\n\nval OP_LETW = Opcode(\n    code = 0x0B,\n    mnemonic = \"letw\",\n    doc = \"Sets a register to the given value.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(ShortType, null, ParamAccess.Write),\n        )), null, null),\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0B] = it }\n\nval OP_LETA = Opcode(\n    code = 0x0C,\n    mnemonic = \"leta\",\n    doc = \"Sets the first register to the memory address of the second register. Not used by Sega.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(PointerType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0C] = it }\n\nval OP_LETO = Opcode(\n    code = 0x0D,\n    mnemonic = \"leto\",\n    doc = \"Sets a register to the memory address of the given label. Not used by Sega.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(PointerType, null, ParamAccess.Write),\n        )), null, null),\n        Param(LabelType.Instance, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x0D] = it }\n\nval OP_SET = Opcode(\n    code = 0x10,\n    mnemonic = \"set\",\n    doc = \"Sets a register to 1.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x10] = it }\n\nval OP_CLEAR = Opcode(\n    code = 0x11,\n    mnemonic = \"clear\",\n    doc = \"Sets a register to 0.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x11] = it }\n\nval OP_REV = Opcode(\n    code = 0x12,\n    mnemonic = \"rev\",\n    doc = \"Sets a register to 1 if its current value is 0, otherwise sets it to 0.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.ReadWrite),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x12] = it }\n\nval OP_GSET = Opcode(\n    code = 0x13,\n    mnemonic = \"gset\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x13] = it }\n\nval OP_GCLEAR = Opcode(\n    code = 0x14,\n    mnemonic = \"gclear\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x14] = it }\n\nval OP_GREV = Opcode(\n    code = 0x15,\n    mnemonic = \"grev\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x15] = it }\n\nval OP_GLET = Opcode(\n    code = 0x16,\n    mnemonic = \"glet\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x16] = it }\n\nval OP_GGET = Opcode(\n    code = 0x17,\n    mnemonic = \"gget\",\n    doc = \"Sets a register to value of the given flag.\",\n    params = listOf(\n        Param(ShortType, null, null),\n        Param(RegRefType(listOf(\n            Param(ShortType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x17] = it }\n\nval OP_ADD = Opcode(\n    code = 0x18,\n    mnemonic = \"add\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x18] = it }\n\nval OP_ADDI = Opcode(\n    code = 0x19,\n    mnemonic = \"addi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x19] = it }\n\nval OP_SUB = Opcode(\n    code = 0x1A,\n    mnemonic = \"sub\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1A] = it }\n\nval OP_SUBI = Opcode(\n    code = 0x1B,\n    mnemonic = \"subi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1B] = it }\n\nval OP_MUL = Opcode(\n    code = 0x1C,\n    mnemonic = \"mul\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1C] = it }\n\nval OP_MULI = Opcode(\n    code = 0x1D,\n    mnemonic = \"muli\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1D] = it }\n\nval OP_DIV = Opcode(\n    code = 0x1E,\n    mnemonic = \"div\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1E] = it }\n\nval OP_DIVI = Opcode(\n    code = 0x1F,\n    mnemonic = \"divi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x1F] = it }\n\nval OP_AND = Opcode(\n    code = 0x20,\n    mnemonic = \"and\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x20] = it }\n\nval OP_ANDI = Opcode(\n    code = 0x21,\n    mnemonic = \"andi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x21] = it }\n\nval OP_OR = Opcode(\n    code = 0x22,\n    mnemonic = \"or\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x22] = it }\n\nval OP_ORI = Opcode(\n    code = 0x23,\n    mnemonic = \"ori\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x23] = it }\n\nval OP_XOR = Opcode(\n    code = 0x24,\n    mnemonic = \"xor\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x24] = it }\n\nval OP_XORI = Opcode(\n    code = 0x25,\n    mnemonic = \"xori\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x25] = it }\n\nval OP_MOD = Opcode(\n    code = 0x26,\n    mnemonic = \"mod\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x26] = it }\n\nval OP_MODI = Opcode(\n    code = 0x27,\n    mnemonic = \"modi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x27] = it }\n\nval OP_JMP = Opcode(\n    code = 0x28,\n    mnemonic = \"jmp\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x28] = it }\n\nval OP_CALL = Opcode(\n    code = 0x29,\n    mnemonic = \"call\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x29] = it }\n\nval OP_JMP_ON = Opcode(\n    code = 0x2A,\n    mnemonic = \"jmp_on\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n        Param(RegRefVarType, null, ParamAccess.Read),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x2A] = it }\n\nval OP_JMP_OFF = Opcode(\n    code = 0x2B,\n    mnemonic = \"jmp_off\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n        Param(RegRefVarType, null, ParamAccess.Read),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x2B] = it }\n\nval OP_JMP_E = Opcode(\n    code = 0x2C,\n    mnemonic = \"jmp_=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2C] = it }\n\nval OP_JMPI_E = Opcode(\n    code = 0x2D,\n    mnemonic = \"jmpi_=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2D] = it }\n\nval OP_JMP_NE = Opcode(\n    code = 0x2E,\n    mnemonic = \"jmp_!=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2E] = it }\n\nval OP_JMPI_NE = Opcode(\n    code = 0x2F,\n    mnemonic = \"jmpi_!=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x2F] = it }\n\nval OP_UJMP_G = Opcode(\n    code = 0x30,\n    mnemonic = \"ujmp_>\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x30] = it }\n\nval OP_UJMPI_G = Opcode(\n    code = 0x31,\n    mnemonic = \"ujmpi_>\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x31] = it }\n\nval OP_JMP_G = Opcode(\n    code = 0x32,\n    mnemonic = \"jmp_>\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x32] = it }\n\nval OP_JMPI_G = Opcode(\n    code = 0x33,\n    mnemonic = \"jmpi_>\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x33] = it }\n\nval OP_UJMP_L = Opcode(\n    code = 0x34,\n    mnemonic = \"ujmp_<\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x34] = it }\n\nval OP_UJMPI_L = Opcode(\n    code = 0x35,\n    mnemonic = \"ujmpi_<\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x35] = it }\n\nval OP_JMP_L = Opcode(\n    code = 0x36,\n    mnemonic = \"jmp_<\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x36] = it }\n\nval OP_JMPI_L = Opcode(\n    code = 0x37,\n    mnemonic = \"jmpi_<\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x37] = it }\n\nval OP_UJMP_GE = Opcode(\n    code = 0x38,\n    mnemonic = \"ujmp_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x38] = it }\n\nval OP_UJMPI_GE = Opcode(\n    code = 0x39,\n    mnemonic = \"ujmpi_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x39] = it }\n\nval OP_JMP_GE = Opcode(\n    code = 0x3A,\n    mnemonic = \"jmp_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3A] = it }\n\nval OP_JMPI_GE = Opcode(\n    code = 0x3B,\n    mnemonic = \"jmpi_>=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3B] = it }\n\nval OP_UJMP_LE = Opcode(\n    code = 0x3C,\n    mnemonic = \"ujmp_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3C] = it }\n\nval OP_UJMPI_LE = Opcode(\n    code = 0x3D,\n    mnemonic = \"ujmpi_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3D] = it }\n\nval OP_JMP_LE = Opcode(\n    code = 0x3E,\n    mnemonic = \"jmp_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3E] = it }\n\nval OP_JMPI_LE = Opcode(\n    code = 0x3F,\n    mnemonic = \"jmpi_<=\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x3F] = it }\n\nval OP_SWITCH_JMP = Opcode(\n    code = 0x40,\n    mnemonic = \"switch_jmp\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelVarType, null, null),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x40] = it }\n\nval OP_SWITCH_CALL = Opcode(\n    code = 0x41,\n    mnemonic = \"switch_call\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(ILabelVarType, null, null),\n    ),\n    stack = null,\n    varargs = true,\n    known = true,\n).also { OPCODES[0x41] = it }\n\nval OP_STACK_PUSH = Opcode(\n    code = 0x42,\n    mnemonic = \"stack_push\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x42] = it }\n\nval OP_STACK_POP = Opcode(\n    code = 0x43,\n    mnemonic = \"stack_pop\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x43] = it }\n\nval OP_STACK_PUSHM = Opcode(\n    code = 0x44,\n    mnemonic = \"stack_pushm\",\n    doc = \"Pushes the values of an arbitrary amount of registers onto the stack.\",\n    params = listOf(\n        Param(RegRefType(null), null, ParamAccess.Read),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x44] = it }\n\nval OP_STACK_POPM = Opcode(\n    code = 0x45,\n    mnemonic = \"stack_popm\",\n    doc = \"Pops an arbitrary amount of values from the stack and writes them to registers.\",\n    params = listOf(\n        Param(RegRefType(null), null, ParamAccess.Write),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x45] = it }\n\nval OP_ARG_PUSHR = Opcode(\n    code = 0x48,\n    mnemonic = \"arg_pushr\",\n    doc = \"Pushes the value of the given register onto the stack.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x48] = it }\n\nval OP_ARG_PUSHL = Opcode(\n    code = 0x49,\n    mnemonic = \"arg_pushl\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x49] = it }\n\nval OP_ARG_PUSHB = Opcode(\n    code = 0x4A,\n    mnemonic = \"arg_pushb\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(ByteType, null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4A] = it }\n\nval OP_ARG_PUSHW = Opcode(\n    code = 0x4B,\n    mnemonic = \"arg_pushw\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4B] = it }\n\nval OP_ARG_PUSHA = Opcode(\n    code = 0x4C,\n    mnemonic = \"arg_pusha\",\n    doc = \"Pushes the memory address of the given register onto the stack. Not used by Sega.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4C] = it }\n\nval OP_ARG_PUSHO = Opcode(\n    code = 0x4D,\n    mnemonic = \"arg_pusho\",\n    doc = \"Pushes the memory address of the given label onto the stack. Not used by Sega.\",\n    params = listOf(\n        Param(LabelType.Instance, null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4D] = it }\n\nval OP_ARG_PUSHS = Opcode(\n    code = 0x4E,\n    mnemonic = \"arg_pushs\",\n    doc = \"Pushes the given value onto the stack.\",\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Push,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x4E] = it }\n\nval OP_UNKNOWN_4F = Opcode(\n    code = 0x4F,\n    mnemonic = \"unknown_4f\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0x4F] = it }\n\nval OP_MESSAGE = Opcode(\n    code = 0x50,\n    mnemonic = \"message\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x50] = it }\n\nval OP_LIST = Opcode(\n    code = 0x51,\n    mnemonic = \"list\",\n    doc = \"Used to display a list of items and retrieve the item selected by the player.\\nList items should be seperated by newlines. The selected item's index will be written to the given register.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(ByteType, null, ParamAccess.Write),\n        )), null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x51] = it }\n\nval OP_FADEIN = Opcode(\n    code = 0x52,\n    mnemonic = \"fadein\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x52] = it }\n\nval OP_FADEOUT = Opcode(\n    code = 0x53,\n    mnemonic = \"fadeout\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x53] = it }\n\nval OP_SE = Opcode(\n    code = 0x54,\n    mnemonic = \"se\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x54] = it }\n\nval OP_BGM = Opcode(\n    code = 0x55,\n    mnemonic = \"bgm\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x55] = it }\n\nval OP_ENABLE = Opcode(\n    code = 0x58,\n    mnemonic = \"enable\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x58] = it }\n\nval OP_DISABLE = Opcode(\n    code = 0x59,\n    mnemonic = \"disable\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x59] = it }\n\nval OP_WINDOW_MSG = Opcode(\n    code = 0x5A,\n    mnemonic = \"window_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5A] = it }\n\nval OP_ADD_MSG = Opcode(\n    code = 0x5B,\n    mnemonic = \"add_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5B] = it }\n\nval OP_MESEND = Opcode(\n    code = 0x5C,\n    mnemonic = \"mesend\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5C] = it }\n\nval OP_GETTIME = Opcode(\n    code = 0x5D,\n    mnemonic = \"gettime\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5D] = it }\n\nval OP_WINEND = Opcode(\n    code = 0x5E,\n    mnemonic = \"winend\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x5E] = it }\n\nval OP_NPC_CRT_V3 = Opcode(\n    code = 0x60,\n    mnemonic = \"npc_crt_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x60] = it }\n\nval OP_NPC_STOP = Opcode(\n    code = 0x61,\n    mnemonic = \"npc_stop\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x61] = it }\n\nval OP_NPC_PLAY = Opcode(\n    code = 0x62,\n    mnemonic = \"npc_play\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x62] = it }\n\nval OP_NPC_KILL = Opcode(\n    code = 0x63,\n    mnemonic = \"npc_kill\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x63] = it }\n\nval OP_NPC_NONT = Opcode(\n    code = 0x64,\n    mnemonic = \"npc_nont\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x64] = it }\n\nval OP_NPC_TALK = Opcode(\n    code = 0x65,\n    mnemonic = \"npc_talk\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x65] = it }\n\nval OP_NPC_CRP_V3 = Opcode(\n    code = 0x66,\n    mnemonic = \"npc_crp_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n            Param(AnyType.Instance, null, ParamAccess.Read),\n            Param(AnyType.Instance, null, ParamAccess.Read),\n            Param(ILabelType, null, ParamAccess.Read),\n            Param(AnyType.Instance, null, ParamAccess.Read),\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x66] = it }\n\nval OP_CREATE_PIPE = Opcode(\n    code = 0x68,\n    mnemonic = \"create_pipe\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x68] = it }\n\nval OP_P_HPSTAT_V3 = Opcode(\n    code = 0x69,\n    mnemonic = \"p_hpstat_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x69] = it }\n\nval OP_P_DEAD_V3 = Opcode(\n    code = 0x6A,\n    mnemonic = \"p_dead_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6A] = it }\n\nval OP_P_DISABLEWARP = Opcode(\n    code = 0x6B,\n    mnemonic = \"p_disablewarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6B] = it }\n\nval OP_P_ENABLEWARP = Opcode(\n    code = 0x6C,\n    mnemonic = \"p_enablewarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6C] = it }\n\nval OP_P_MOVE_V3 = Opcode(\n    code = 0x6D,\n    mnemonic = \"p_move_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6D] = it }\n\nval OP_P_LOOK = Opcode(\n    code = 0x6E,\n    mnemonic = \"p_look\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x6E] = it }\n\nval OP_P_ACTION_DISABLE = Opcode(\n    code = 0x70,\n    mnemonic = \"p_action_disable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x70] = it }\n\nval OP_P_ACTION_ENABLE = Opcode(\n    code = 0x71,\n    mnemonic = \"p_action_enable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x71] = it }\n\nval OP_DISABLE_MOVEMENT1 = Opcode(\n    code = 0x72,\n    mnemonic = \"disable_movement1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x72] = it }\n\nval OP_ENABLE_MOVEMENT1 = Opcode(\n    code = 0x73,\n    mnemonic = \"enable_movement1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x73] = it }\n\nval OP_P_NONCOL = Opcode(\n    code = 0x74,\n    mnemonic = \"p_noncol\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x74] = it }\n\nval OP_P_COL = Opcode(\n    code = 0x75,\n    mnemonic = \"p_col\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x75] = it }\n\nval OP_P_SETPOS = Opcode(\n    code = 0x76,\n    mnemonic = \"p_setpos\",\n    doc = \"Sets a player's position.\",\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"X coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Y coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Z coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Y-axis rotation.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x76] = it }\n\nval OP_P_RETURN_GUILD = Opcode(\n    code = 0x77,\n    mnemonic = \"p_return_guild\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x77] = it }\n\nval OP_P_TALK_GUILD = Opcode(\n    code = 0x78,\n    mnemonic = \"p_talk_guild\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x78] = it }\n\nval OP_NPC_TALK_PL_V3 = Opcode(\n    code = 0x79,\n    mnemonic = \"npc_talk_pl_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x79] = it }\n\nval OP_NPC_TALK_KILL = Opcode(\n    code = 0x7A,\n    mnemonic = \"npc_talk_kill\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7A] = it }\n\nval OP_NPC_CRTPK_V3 = Opcode(\n    code = 0x7B,\n    mnemonic = \"npc_crtpk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7B] = it }\n\nval OP_NPC_CRPPK_V3 = Opcode(\n    code = 0x7C,\n    mnemonic = \"npc_crppk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7C] = it }\n\nval OP_NPC_CRPTALK_V3 = Opcode(\n    code = 0x7D,\n    mnemonic = \"npc_crptalk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7D] = it }\n\nval OP_P_LOOK_AT_V1 = Opcode(\n    code = 0x7E,\n    mnemonic = \"p_look_at_v1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7E] = it }\n\nval OP_NPC_CRP_ID_V3 = Opcode(\n    code = 0x7F,\n    mnemonic = \"npc_crp_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x7F] = it }\n\nval OP_CAM_QUAKE = Opcode(\n    code = 0x80,\n    mnemonic = \"cam_quake\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x80] = it }\n\nval OP_CAM_ADJ = Opcode(\n    code = 0x81,\n    mnemonic = \"cam_adj\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x81] = it }\n\nval OP_CAM_ZMIN = Opcode(\n    code = 0x82,\n    mnemonic = \"cam_zmin\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x82] = it }\n\nval OP_CAM_ZMOUT = Opcode(\n    code = 0x83,\n    mnemonic = \"cam_zmout\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x83] = it }\n\nval OP_CAM_PAN_V3 = Opcode(\n    code = 0x84,\n    mnemonic = \"cam_pan_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x84] = it }\n\nval OP_GAME_LEV_SUPER = Opcode(\n    code = 0x85,\n    mnemonic = \"game_lev_super\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x85] = it }\n\nval OP_GAME_LEV_RESET = Opcode(\n    code = 0x86,\n    mnemonic = \"game_lev_reset\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x86] = it }\n\nval OP_POS_PIPE_V3 = Opcode(\n    code = 0x87,\n    mnemonic = \"pos_pipe_v3\",\n    doc = \"Create a telepipe at a specific position for the given player slot that takes players back to Pioneer 2 or the Lab.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"X coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Y coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Z coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x87] = it }\n\nval OP_IF_ZONE_CLEAR = Opcode(\n    code = 0x88,\n    mnemonic = \"if_zone_clear\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x88] = it }\n\nval OP_CHK_ENE_NUM = Opcode(\n    code = 0x89,\n    mnemonic = \"chk_ene_num\",\n    doc = \"Retrieves the amount of enemies killed during the quest.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x89] = it }\n\nval OP_UNHIDE_OBJ = Opcode(\n    code = 0x8A,\n    mnemonic = \"unhide_obj\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8A] = it }\n\nval OP_UNHIDE_ENE = Opcode(\n    code = 0x8B,\n    mnemonic = \"unhide_ene\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8B] = it }\n\nval OP_AT_COORDS_CALL = Opcode(\n    code = 0x8C,\n    mnemonic = \"at_coords_call\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(ILabelType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8C] = it }\n\nval OP_AT_COORDS_TALK = Opcode(\n    code = 0x8D,\n    mnemonic = \"at_coords_talk\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(ILabelType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8D] = it }\n\nval OP_COL_NPCIN = Opcode(\n    code = 0x8E,\n    mnemonic = \"col_npcin\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(ILabelType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8E] = it }\n\nval OP_COL_NPCINR = Opcode(\n    code = 0x8F,\n    mnemonic = \"col_npcinr\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x8F] = it }\n\nval OP_SWITCH_ON = Opcode(\n    code = 0x90,\n    mnemonic = \"switch_on\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x90] = it }\n\nval OP_SWITCH_OFF = Opcode(\n    code = 0x91,\n    mnemonic = \"switch_off\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x91] = it }\n\nval OP_PLAYBGM_EPI = Opcode(\n    code = 0x92,\n    mnemonic = \"playbgm_epi\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x92] = it }\n\nval OP_SET_MAINWARP = Opcode(\n    code = 0x93,\n    mnemonic = \"set_mainwarp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x93] = it }\n\nval OP_SET_OBJ_PARAM = Opcode(\n    code = 0x94,\n    mnemonic = \"set_obj_param\",\n    doc = \"Creates a targetable object.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"X coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Y coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Z coordinate.\", ParamAccess.Read),\n            Param(IntType, \"Collision radius.\", ParamAccess.Read),\n            Param(ILabelType, \"Function label.\", ParamAccess.Read),\n            Param(IntType, \"Vertical position of the cursor.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), \"Object handle.\", null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x94] = it }\n\nval OP_SET_FLOOR_HANDLER = Opcode(\n    code = 0x95,\n    mnemonic = \"set_floor_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Floor number.\", null),\n        Param(ILabelType, \"Handler function label.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x95] = it }\n\nval OP_CLR_FLOOR_HANDLER = Opcode(\n    code = 0x96,\n    mnemonic = \"clr_floor_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Floor number.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x96] = it }\n\nval OP_COL_PLINAW = Opcode(\n    code = 0x97,\n    mnemonic = \"col_plinaw\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x97] = it }\n\nval OP_HUD_HIDE = Opcode(\n    code = 0x98,\n    mnemonic = \"hud_hide\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x98] = it }\n\nval OP_HUD_SHOW = Opcode(\n    code = 0x99,\n    mnemonic = \"hud_show\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x99] = it }\n\nval OP_CINE_ENABLE = Opcode(\n    code = 0x9A,\n    mnemonic = \"cine_enable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x9A] = it }\n\nval OP_CINE_DISABLE = Opcode(\n    code = 0x9B,\n    mnemonic = \"cine_disable\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0x9B] = it }\n\nval OP_SET_QT_FAILURE = Opcode(\n    code = 0xA1,\n    mnemonic = \"set_qt_failure\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA1] = it }\n\nval OP_SET_QT_SUCCESS = Opcode(\n    code = 0xA2,\n    mnemonic = \"set_qt_success\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA2] = it }\n\nval OP_CLR_QT_FAILURE = Opcode(\n    code = 0xA3,\n    mnemonic = \"clr_qt_failure\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA3] = it }\n\nval OP_CLR_QT_SUCCESS = Opcode(\n    code = 0xA4,\n    mnemonic = \"clr_qt_success\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA4] = it }\n\nval OP_SET_QT_CANCEL = Opcode(\n    code = 0xA5,\n    mnemonic = \"set_qt_cancel\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA5] = it }\n\nval OP_CLR_QT_CANCEL = Opcode(\n    code = 0xA6,\n    mnemonic = \"clr_qt_cancel\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA6] = it }\n\nval OP_PL_WALK_V3 = Opcode(\n    code = 0xA8,\n    mnemonic = \"pl_walk_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xA8] = it }\n\nval OP_PL_ADD_MESETA = Opcode(\n    code = 0xB0,\n    mnemonic = \"pl_add_meseta\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB0] = it }\n\nval OP_THREAD_STG = Opcode(\n    code = 0xB1,\n    mnemonic = \"thread_stg\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB1] = it }\n\nval OP_DEL_OBJ_PARAM = Opcode(\n    code = 0xB2,\n    mnemonic = \"del_obj_param\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), \"Object handle.\", null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB2] = it }\n\nval OP_ITEM_CREATE = Opcode(\n    code = 0xB3,\n    mnemonic = \"item_create\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB3] = it }\n\nval OP_ITEM_CREATE2 = Opcode(\n    code = 0xB4,\n    mnemonic = \"item_create2\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB4] = it }\n\nval OP_ITEM_DELETE = Opcode(\n    code = 0xB5,\n    mnemonic = \"item_delete\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB5] = it }\n\nval OP_ITEM_DELETE2 = Opcode(\n    code = 0xB6,\n    mnemonic = \"item_delete2\",\n    doc = \"Deletes an item from the player's inventory.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB6] = it }\n\nval OP_ITEM_CHECK = Opcode(\n    code = 0xB7,\n    mnemonic = \"item_check\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB7] = it }\n\nval OP_SETEVT = Opcode(\n    code = 0xB8,\n    mnemonic = \"setevt\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB8] = it }\n\nval OP_GET_DIFFLVL = Opcode(\n    code = 0xB9,\n    mnemonic = \"get_difflvl\",\n    doc = \"Sets the given register to the current difficulty. 0 For normal, 1 for hard and 2 for both very hard and ultimate.\\nUse get_difficulty_level2 if you want to differentiate between very hard and ultimate.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xB9] = it }\n\nval OP_SET_QT_EXIT = Opcode(\n    code = 0xBA,\n    mnemonic = \"set_qt_exit\",\n    doc = null,\n    params = listOf(\n        Param(ILabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xBA] = it }\n\nval OP_CLR_QT_EXIT = Opcode(\n    code = 0xBB,\n    mnemonic = \"clr_qt_exit\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xBB] = it }\n\nval OP_PARTICLE_V3 = Opcode(\n    code = 0xC0,\n    mnemonic = \"particle_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC0] = it }\n\nval OP_NPC_TEXT = Opcode(\n    code = 0xC1,\n    mnemonic = \"npc_text\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC1] = it }\n\nval OP_NPC_CHKWARP = Opcode(\n    code = 0xC2,\n    mnemonic = \"npc_chkwarp\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC2] = it }\n\nval OP_PL_PKOFF = Opcode(\n    code = 0xC3,\n    mnemonic = \"pl_pkoff\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC3] = it }\n\nval OP_MAP_DESIGNATE = Opcode(\n    code = 0xC4,\n    mnemonic = \"map_designate\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC4] = it }\n\nval OP_MASTERKEY_ON = Opcode(\n    code = 0xC5,\n    mnemonic = \"masterkey_on\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC5] = it }\n\nval OP_MASTERKEY_OFF = Opcode(\n    code = 0xC6,\n    mnemonic = \"masterkey_off\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC6] = it }\n\nval OP_WINDOW_TIME = Opcode(\n    code = 0xC7,\n    mnemonic = \"window_time\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC7] = it }\n\nval OP_WINEND_TIME = Opcode(\n    code = 0xC8,\n    mnemonic = \"winend_time\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC8] = it }\n\nval OP_WINSET_TIME = Opcode(\n    code = 0xC9,\n    mnemonic = \"winset_time\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xC9] = it }\n\nval OP_GETMTIME = Opcode(\n    code = 0xCA,\n    mnemonic = \"getmtime\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCA] = it }\n\nval OP_SET_QUEST_BOARD_HANDLER = Opcode(\n    code = 0xCB,\n    mnemonic = \"set_quest_board_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCB] = it }\n\nval OP_CLEAR_QUEST_BOARD_HANDLER = Opcode(\n    code = 0xCC,\n    mnemonic = \"clear_quest_board_handler\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCC] = it }\n\nval OP_PARTICLE_ID_V3 = Opcode(\n    code = 0xCD,\n    mnemonic = \"particle_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCD] = it }\n\nval OP_NPC_CRPTALK_ID_V3 = Opcode(\n    code = 0xCE,\n    mnemonic = \"npc_crptalk_id_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCE] = it }\n\nval OP_NPC_LANG_CLEAN = Opcode(\n    code = 0xCF,\n    mnemonic = \"npc_lang_clean\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xCF] = it }\n\nval OP_PL_PKON = Opcode(\n    code = 0xD0,\n    mnemonic = \"pl_pkon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD0] = it }\n\nval OP_PL_CHK_ITEM2 = Opcode(\n    code = 0xD1,\n    mnemonic = \"pl_chk_item2\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD1] = it }\n\nval OP_ENABLE_MAINMENU = Opcode(\n    code = 0xD2,\n    mnemonic = \"enable_mainmenu\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD2] = it }\n\nval OP_DISABLE_MAINMENU = Opcode(\n    code = 0xD3,\n    mnemonic = \"disable_mainmenu\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD3] = it }\n\nval OP_START_BATTLEBGM = Opcode(\n    code = 0xD4,\n    mnemonic = \"start_battlebgm\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD4] = it }\n\nval OP_END_BATTLEBGM = Opcode(\n    code = 0xD5,\n    mnemonic = \"end_battlebgm\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD5] = it }\n\nval OP_DISP_MSG_QB = Opcode(\n    code = 0xD6,\n    mnemonic = \"disp_msg_qb\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD6] = it }\n\nval OP_CLOSE_MSG_QB = Opcode(\n    code = 0xD7,\n    mnemonic = \"close_msg_qb\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD7] = it }\n\nval OP_SET_EVENTFLAG_V3 = Opcode(\n    code = 0xD8,\n    mnemonic = \"set_eventflag_v3\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD8] = it }\n\nval OP_SYNC_LETI = Opcode(\n    code = 0xD9,\n    mnemonic = \"sync_leti\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xD9] = it }\n\nval OP_SET_RETURNHUNTER = Opcode(\n    code = 0xDA,\n    mnemonic = \"set_returnhunter\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDA] = it }\n\nval OP_SET_RETURNCITY = Opcode(\n    code = 0xDB,\n    mnemonic = \"set_returncity\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDB] = it }\n\nval OP_LOAD_PVR = Opcode(\n    code = 0xDC,\n    mnemonic = \"load_pvr\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDC] = it }\n\nval OP_LOAD_MIDI = Opcode(\n    code = 0xDD,\n    mnemonic = \"load_midi\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDD] = it }\n\nval OP_UNKNOWN_DE = Opcode(\n    code = 0xDE,\n    mnemonic = \"unknown_de\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDE] = it }\n\nval OP_NPC_PARAM_V3 = Opcode(\n    code = 0xDF,\n    mnemonic = \"npc_param_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xDF] = it }\n\nval OP_PAD_DRAGON = Opcode(\n    code = 0xE0,\n    mnemonic = \"pad_dragon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE0] = it }\n\nval OP_CLEAR_MAINWARP = Opcode(\n    code = 0xE1,\n    mnemonic = \"clear_mainwarp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE1] = it }\n\nval OP_PCAM_PARAM_V3 = Opcode(\n    code = 0xE2,\n    mnemonic = \"pcam_param_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE2] = it }\n\nval OP_START_SETEVT_V3 = Opcode(\n    code = 0xE3,\n    mnemonic = \"start_setevt_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE3] = it }\n\nval OP_WARP_ON = Opcode(\n    code = 0xE4,\n    mnemonic = \"warp_on\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE4] = it }\n\nval OP_WARP_OFF = Opcode(\n    code = 0xE5,\n    mnemonic = \"warp_off\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE5] = it }\n\nval OP_GET_SLOTNUMBER = Opcode(\n    code = 0xE6,\n    mnemonic = \"get_slotnumber\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE6] = it }\n\nval OP_GET_SERVERNUMBER = Opcode(\n    code = 0xE7,\n    mnemonic = \"get_servernumber\",\n    doc = \"Returns the index of the player who is the leader of the party.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE7] = it }\n\nval OP_SET_EVENTFLAG2 = Opcode(\n    code = 0xE8,\n    mnemonic = \"set_eventflag2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE8] = it }\n\nval OP_RES = Opcode(\n    code = 0xE9,\n    mnemonic = \"res\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xE9] = it }\n\nval OP_UNKNOWN_EA = Opcode(\n    code = 0xEA,\n    mnemonic = \"unknown_ea\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0xEA] = it }\n\nval OP_ENABLE_BGMCTRL = Opcode(\n    code = 0xEB,\n    mnemonic = \"enable_bgmctrl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEB] = it }\n\nval OP_SW_SEND = Opcode(\n    code = 0xEC,\n    mnemonic = \"sw_send\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEC] = it }\n\nval OP_CREATE_BGMCTRL = Opcode(\n    code = 0xED,\n    mnemonic = \"create_bgmctrl\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xED] = it }\n\nval OP_PL_ADD_MESETA2 = Opcode(\n    code = 0xEE,\n    mnemonic = \"pl_add_meseta2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEE] = it }\n\nval OP_SYNC_REGISTER = Opcode(\n    code = 0xEF,\n    mnemonic = \"sync_register\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xEF] = it }\n\nval OP_SEND_REGWORK = Opcode(\n    code = 0xF0,\n    mnemonic = \"send_regwork\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF0] = it }\n\nval OP_LETI_FIXED_CAMERA_V3 = Opcode(\n    code = 0xF1,\n    mnemonic = \"leti_fixed_camera_v3\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF1] = it }\n\nval OP_DEFAULT_CAMERA_POS1 = Opcode(\n    code = 0xF2,\n    mnemonic = \"default_camera_pos1\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xF2] = it }\n\nval OP_GET_GC_NUMBER = Opcode(\n    code = 0xFA,\n    mnemonic = \"get_gc_number\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES[0xFA] = it }\n\nval OP_UNKNOWN_FB = Opcode(\n    code = 0xFB,\n    mnemonic = \"unknown_fb\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES[0xFB] = it }\n\nval OP_SET_CHAT_CALLBACK = Opcode(\n    code = 0xF801,\n    mnemonic = \"set_chat_callback\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x01] = it }\n\nval OP_GET_DIFFICULTY_LEVEL2 = Opcode(\n    code = 0xF808,\n    mnemonic = \"get_difficulty_level2\",\n    doc = \"Sets the given register to the current difficulty. 0 For normal, 1 for hard, 2 for very hard and 3 for ultimate.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x08] = it }\n\nval OP_GET_NUMBER_OF_PLAYER1 = Opcode(\n    code = 0xF809,\n    mnemonic = \"get_number_of_player1\",\n    doc = \"Set the given register to the current number of players. Either 1, 2, 3 or 4.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x09] = it }\n\nval OP_GET_COORD_OF_PLAYER = Opcode(\n    code = 0xF80A,\n    mnemonic = \"get_coord_of_player\",\n    doc = \"Retrieves a player's position.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"X coordinate.\", ParamAccess.Write),\n            Param(IntType, \"Y coordinate.\", ParamAccess.Write),\n            Param(IntType, \"Z coordinate.\", ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0A] = it }\n\nval OP_ENABLE_MAP = Opcode(\n    code = 0xF80B,\n    mnemonic = \"enable_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0B] = it }\n\nval OP_DISABLE_MAP = Opcode(\n    code = 0xF80C,\n    mnemonic = \"disable_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0C] = it }\n\nval OP_MAP_DESIGNATE_EX = Opcode(\n    code = 0xF80D,\n    mnemonic = \"map_designate_ex\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x0D] = it }\n\nval OP_UNKNOWN_F80E = Opcode(\n    code = 0xF80E,\n    mnemonic = \"unknown_f80e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x0E] = it }\n\nval OP_UNKNOWN_F80F = Opcode(\n    code = 0xF80F,\n    mnemonic = \"unknown_f80f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x0F] = it }\n\nval OP_BA_INITIAL_FLOOR = Opcode(\n    code = 0xF810,\n    mnemonic = \"ba_initial_floor\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x10] = it }\n\nval OP_SET_BA_RULES = Opcode(\n    code = 0xF811,\n    mnemonic = \"set_ba_rules\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x11] = it }\n\nval OP_UNKNOWN_F812 = Opcode(\n    code = 0xF812,\n    mnemonic = \"unknown_f812\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x12] = it }\n\nval OP_UNKNOWN_F813 = Opcode(\n    code = 0xF813,\n    mnemonic = \"unknown_f813\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x13] = it }\n\nval OP_UNKNOWN_F814 = Opcode(\n    code = 0xF814,\n    mnemonic = \"unknown_f814\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x14] = it }\n\nval OP_UNKNOWN_F815 = Opcode(\n    code = 0xF815,\n    mnemonic = \"unknown_f815\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x15] = it }\n\nval OP_UNKNOWN_F816 = Opcode(\n    code = 0xF816,\n    mnemonic = \"unknown_f816\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x16] = it }\n\nval OP_UNKNOWN_F817 = Opcode(\n    code = 0xF817,\n    mnemonic = \"unknown_f817\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x17] = it }\n\nval OP_UNKNOWN_F818 = Opcode(\n    code = 0xF818,\n    mnemonic = \"unknown_f818\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x18] = it }\n\nval OP_UNKNOWN_F819 = Opcode(\n    code = 0xF819,\n    mnemonic = \"unknown_f819\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x19] = it }\n\nval OP_UNKNOWN_F81A = Opcode(\n    code = 0xF81A,\n    mnemonic = \"unknown_f81a\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x1A] = it }\n\nval OP_UNKNOWN_F81B = Opcode(\n    code = 0xF81B,\n    mnemonic = \"unknown_f81b\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x1B] = it }\n\nval OP_BA_DISP_MSG = Opcode(\n    code = 0xF81C,\n    mnemonic = \"ba_disp_msg\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1C] = it }\n\nval OP_DEATH_LVL_UP = Opcode(\n    code = 0xF81D,\n    mnemonic = \"death_lvl_up\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1D] = it }\n\nval OP_DEATH_TECH_LVL_UP = Opcode(\n    code = 0xF81E,\n    mnemonic = \"death_tech_lvl_up\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x1E] = it }\n\nval OP_CMODE_STAGE = Opcode(\n    code = 0xF820,\n    mnemonic = \"cmode_stage\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x20] = it }\n\nval OP_UNKNOWN_F823 = Opcode(\n    code = 0xF823,\n    mnemonic = \"unknown_f823\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x23] = it }\n\nval OP_UNKNOWN_F824 = Opcode(\n    code = 0xF824,\n    mnemonic = \"unknown_f824\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x24] = it }\n\nval OP_EXP_MULTIPLICATION = Opcode(\n    code = 0xF825,\n    mnemonic = \"exp_multiplication\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x25] = it }\n\nval OP_EXP_DIVISION = Opcode(\n    code = 0xF826,\n    mnemonic = \"exp_division\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x26] = it }\n\nval OP_GET_USER_IS_DEAD = Opcode(\n    code = 0xF827,\n    mnemonic = \"get_user_is_dead\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x27] = it }\n\nval OP_GO_FLOOR = Opcode(\n    code = 0xF828,\n    mnemonic = \"go_floor\",\n    doc = \"Sends a player to the given floor.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Floor ID.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x28] = it }\n\nval OP_GET_NUM_KILLS = Opcode(\n    code = 0xF829,\n    mnemonic = \"get_num_kills\",\n    doc = \"Returns the number of enemies a player has killed during the quest.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Result register.\", ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x29] = it }\n\nval OP_UNLOCK_DOOR2 = Opcode(\n    code = 0xF82B,\n    mnemonic = \"unlock_door2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2B] = it }\n\nval OP_LOCK_DOOR2 = Opcode(\n    code = 0xF82C,\n    mnemonic = \"lock_door2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2C] = it }\n\nval OP_IF_SWITCH_NOT_PRESSED = Opcode(\n    code = 0xF82D,\n    mnemonic = \"if_switch_not_pressed\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2D] = it }\n\nval OP_IF_SWITCH_PRESSED = Opcode(\n    code = 0xF82E,\n    mnemonic = \"if_switch_pressed\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Floor ID.\", ParamAccess.Read),\n            Param(IntType, \"Switch ID.\", ParamAccess.Read),\n            Param(IntType, \"Will be set to 1 if the switch is pressed, 0 otherwise.\", ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x2E] = it }\n\nval OP_UNKNOWN_F82F = Opcode(\n    code = 0xF82F,\n    mnemonic = \"unknown_f82f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x2F] = it }\n\nval OP_CONTROL_DRAGON = Opcode(\n    code = 0xF830,\n    mnemonic = \"control_dragon\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x30] = it }\n\nval OP_RELEASE_DRAGON = Opcode(\n    code = 0xF831,\n    mnemonic = \"release_dragon\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x31] = it }\n\nval OP_SHRINK = Opcode(\n    code = 0xF838,\n    mnemonic = \"shrink\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x38] = it }\n\nval OP_UNSHRINK = Opcode(\n    code = 0xF839,\n    mnemonic = \"unshrink\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x39] = it }\n\nval OP_DISPLAY_CLOCK2 = Opcode(\n    code = 0xF83C,\n    mnemonic = \"display_clock2\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x3C] = it }\n\nval OP_UNKNOWN_F83D = Opcode(\n    code = 0xF83D,\n    mnemonic = \"unknown_f83d\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x3D] = it }\n\nval OP_DELETE_AREA_TITLE = Opcode(\n    code = 0xF83E,\n    mnemonic = \"delete_area_title\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x3E] = it }\n\nval OP_LOAD_NPC_DATA = Opcode(\n    code = 0xF840,\n    mnemonic = \"load_npc_data\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x40] = it }\n\nval OP_GET_NPC_DATA = Opcode(\n    code = 0xF841,\n    mnemonic = \"get_npc_data\",\n    doc = null,\n    params = listOf(\n        Param(DLabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x41] = it }\n\nval OP_GIVE_DAMAGE_SCORE = Opcode(\n    code = 0xF848,\n    mnemonic = \"give_damage_score\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x48] = it }\n\nval OP_TAKE_DAMAGE_SCORE = Opcode(\n    code = 0xF849,\n    mnemonic = \"take_damage_score\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x49] = it }\n\nval OP_UNK_SCORE_F84A = Opcode(\n    code = 0xF84A,\n    mnemonic = \"unk_score_f84a\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4A] = it }\n\nval OP_UNK_SCORE_F84B = Opcode(\n    code = 0xF84B,\n    mnemonic = \"unk_score_f84b\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4B] = it }\n\nval OP_KILL_SCORE = Opcode(\n    code = 0xF84C,\n    mnemonic = \"kill_score\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4C] = it }\n\nval OP_DEATH_SCORE = Opcode(\n    code = 0xF84D,\n    mnemonic = \"death_score\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4D] = it }\n\nval OP_UNK_SCORE_F84E = Opcode(\n    code = 0xF84E,\n    mnemonic = \"unk_score_f84e\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4E] = it }\n\nval OP_ENEMY_DEATH_SCORE = Opcode(\n    code = 0xF84F,\n    mnemonic = \"enemy_death_score\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x4F] = it }\n\nval OP_MESETA_SCORE = Opcode(\n    code = 0xF850,\n    mnemonic = \"meseta_score\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x50] = it }\n\nval OP_UNKNOWN_F851 = Opcode(\n    code = 0xF851,\n    mnemonic = \"unknown_f851\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x51] = it }\n\nval OP_UNKNOWN_F852 = Opcode(\n    code = 0xF852,\n    mnemonic = \"unknown_f852\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x52] = it }\n\nval OP_REVERSE_WARPS = Opcode(\n    code = 0xF853,\n    mnemonic = \"reverse_warps\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x53] = it }\n\nval OP_UNREVERSE_WARPS = Opcode(\n    code = 0xF854,\n    mnemonic = \"unreverse_warps\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x54] = it }\n\nval OP_SET_ULT_MAP = Opcode(\n    code = 0xF855,\n    mnemonic = \"set_ult_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x55] = it }\n\nval OP_UNSET_ULT_MAP = Opcode(\n    code = 0xF856,\n    mnemonic = \"unset_ult_map\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x56] = it }\n\nval OP_SET_AREA_TITLE = Opcode(\n    code = 0xF857,\n    mnemonic = \"set_area_title\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x57] = it }\n\nval OP_EQUIP_ITEM = Opcode(\n    code = 0xF85A,\n    mnemonic = \"equip_item\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x5A] = it }\n\nval OP_UNEQUIP_ITEM = Opcode(\n    code = 0xF85B,\n    mnemonic = \"unequip_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x5B] = it }\n\nval OP_UNKNOWN_F85E = Opcode(\n    code = 0xF85E,\n    mnemonic = \"unknown_f85e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x5E] = it }\n\nval OP_UNKNOWN_F85F = Opcode(\n    code = 0xF85F,\n    mnemonic = \"unknown_f85f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x5F] = it }\n\nval OP_UNKNOWN_F860 = Opcode(\n    code = 0xF860,\n    mnemonic = \"unknown_f860\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x60] = it }\n\nval OP_UNKNOWN_F861 = Opcode(\n    code = 0xF861,\n    mnemonic = \"unknown_f861\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x61] = it }\n\nval OP_CMODE_RANK = Opcode(\n    code = 0xF864,\n    mnemonic = \"cmode_rank\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x64] = it }\n\nval OP_AWARD_ITEM_NAME = Opcode(\n    code = 0xF865,\n    mnemonic = \"award_item_name\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x65] = it }\n\nval OP_AWARD_ITEM_SELECT = Opcode(\n    code = 0xF866,\n    mnemonic = \"award_item_select\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x66] = it }\n\nval OP_AWARD_ITEM_GIVE_TO = Opcode(\n    code = 0xF867,\n    mnemonic = \"award_item_give_to\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x67] = it }\n\nval OP_UNKNOWN_F868 = Opcode(\n    code = 0xF868,\n    mnemonic = \"unknown_f868\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x68] = it }\n\nval OP_UNKNOWN_F869 = Opcode(\n    code = 0xF869,\n    mnemonic = \"unknown_f869\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x69] = it }\n\nval OP_ITEM_CREATE_CMODE = Opcode(\n    code = 0xF86A,\n    mnemonic = \"item_create_cmode\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6A] = it }\n\nval OP_UNKNOWN_F86B = Opcode(\n    code = 0xF86B,\n    mnemonic = \"unknown_f86b\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x6B] = it }\n\nval OP_AWARD_ITEM_OK = Opcode(\n    code = 0xF86C,\n    mnemonic = \"award_item_ok\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6C] = it }\n\nval OP_BA_SET_LIVES = Opcode(\n    code = 0xF86F,\n    mnemonic = \"ba_set_lives\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x6F] = it }\n\nval OP_BA_SET_TECH_LVL = Opcode(\n    code = 0xF870,\n    mnemonic = \"ba_set_tech_lvl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x70] = it }\n\nval OP_BA_SET_LVL = Opcode(\n    code = 0xF871,\n    mnemonic = \"ba_set_lvl\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x71] = it }\n\nval OP_BA_SET_TIME_LIMIT = Opcode(\n    code = 0xF872,\n    mnemonic = \"ba_set_time_limit\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x72] = it }\n\nval OP_BOSS_IS_DEAD = Opcode(\n    code = 0xF873,\n    mnemonic = \"boss_is_dead\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x73] = it }\n\nval OP_ENABLE_TECHS = Opcode(\n    code = 0xF877,\n    mnemonic = \"enable_techs\",\n    doc = \"Enables technique use for the given player.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x77] = it }\n\nval OP_DISABLE_TECHS = Opcode(\n    code = 0xF878,\n    mnemonic = \"disable_techs\",\n    doc = \"Disables technique use for the given player.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x78] = it }\n\nval OP_GET_GENDER = Opcode(\n    code = 0xF879,\n    mnemonic = \"get_gender\",\n    doc = \"Retrieves the player's gender. 0 If male, 1 if female.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player gender.\", ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x79] = it }\n\nval OP_GET_CHARA_CLASS = Opcode(\n    code = 0xF87A,\n    mnemonic = \"get_chara_class\",\n    doc = \"Retrieves the player's race and character class.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player race. 0 If human, 1 if newman, 2 if cast.\", ParamAccess.Write),\n            Param(IntType, \"Player class. 0 If hunter, 1 if ranger, 2 if force.\", ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7A] = it }\n\nval OP_TAKE_SLOT_MESETA = Opcode(\n    code = 0xF87B,\n    mnemonic = \"take_slot_meseta\",\n    doc = \"Takes an amount of meseta from a player's inventory.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n            Param(IntType, \"Amount of meseta to take.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Will be set to 1 if the meseta was taken, 0 otherwise.\", ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7B] = it }\n\nval OP_READ_GUILDCARD_FLAG = Opcode(\n    code = 0xF87F,\n    mnemonic = \"read_guildcard_flag\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x7F] = it }\n\nval OP_UNKNOWN_F880 = Opcode(\n    code = 0xF880,\n    mnemonic = \"unknown_f880\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x80] = it }\n\nval OP_GET_PL_NAME = Opcode(\n    code = 0xF881,\n    mnemonic = \"get_pl_name\",\n    doc = \"Sets the value of <pl_name> to the given player's name.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x81] = it }\n\nval OP_GET_PL_JOB = Opcode(\n    code = 0xF882,\n    mnemonic = \"get_pl_job\",\n    doc = \"Sets the value of <pl_job> to the given player's job (Hunter/Ranger/Force).\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x82] = it }\n\nval OP_UNKNOWN_F883 = Opcode(\n    code = 0xF883,\n    mnemonic = \"unknown_f883\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x83] = it }\n\nval OP_GET_PLAYER_STATUS = Opcode(\n    code = 0xF88A,\n    mnemonic = \"get_player_status\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8A] = it }\n\nval OP_SEND_MAIL = Opcode(\n    code = 0xF88B,\n    mnemonic = \"send_mail\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8B] = it }\n\nval OP_ONLINE_CHECK = Opcode(\n    code = 0xF88C,\n    mnemonic = \"online_check\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8C] = it }\n\nval OP_CHL_SET_TIMERECORD = Opcode(\n    code = 0xF88D,\n    mnemonic = \"chl_set_timerecord\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8D] = it }\n\nval OP_CHL_GET_TIMERECORD = Opcode(\n    code = 0xF88E,\n    mnemonic = \"chl_get_timerecord\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x8E] = it }\n\nval OP_UNKNOWN_F88F = Opcode(\n    code = 0xF88F,\n    mnemonic = \"unknown_f88f\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x8F] = it }\n\nval OP_LOAD_ENEMY_DATA = Opcode(\n    code = 0xF891,\n    mnemonic = \"load_enemy_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x91] = it }\n\nval OP_GET_PHYSICAL_DATA = Opcode(\n    code = 0xF892,\n    mnemonic = \"get_physical_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x92] = it }\n\nval OP_GET_ATTACK_DATA = Opcode(\n    code = 0xF893,\n    mnemonic = \"get_attack_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x93] = it }\n\nval OP_GET_RESIST_DATA = Opcode(\n    code = 0xF894,\n    mnemonic = \"get_resist_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x94] = it }\n\nval OP_GET_MOVEMENT_DATA = Opcode(\n    code = 0xF895,\n    mnemonic = \"get_movement_data\",\n    doc = null,\n    params = listOf(\n        Param(ShortType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x95] = it }\n\nval OP_SHIFT_LEFT = Opcode(\n    code = 0xF898,\n    mnemonic = \"shift_left\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x98] = it }\n\nval OP_SHIFT_RIGHT = Opcode(\n    code = 0xF899,\n    mnemonic = \"shift_right\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x99] = it }\n\nval OP_GET_RANDOM = Opcode(\n    code = 0xF89A,\n    mnemonic = \"get_random\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9A] = it }\n\nval OP_RESET_MAP = Opcode(\n    code = 0xF89B,\n    mnemonic = \"reset_map\",\n    doc = \"Sets all registers to 0 and resets the quest.\",\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9B] = it }\n\nval OP_DISP_CHL_RETRY_MENU = Opcode(\n    code = 0xF89C,\n    mnemonic = \"disp_chl_retry_menu\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9C] = it }\n\nval OP_CHL_REVERSER = Opcode(\n    code = 0xF89D,\n    mnemonic = \"chl_reverser\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0x9D] = it }\n\nval OP_UNKNOWN_F89E = Opcode(\n    code = 0xF89E,\n    mnemonic = \"unknown_f89e\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x9E] = it }\n\nval OP_UNKNOWN_F89F = Opcode(\n    code = 0xF89F,\n    mnemonic = \"unknown_f89f\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0x9F] = it }\n\nval OP_UNKNOWN_F8A8 = Opcode(\n    code = 0xF8A8,\n    mnemonic = \"unknown_f8a8\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xA8] = it }\n\nval OP_UNKNOWN_F8A9 = Opcode(\n    code = 0xF8A9,\n    mnemonic = \"unknown_f8a9\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xA9] = it }\n\nval OP_GET_NUMBER_OF_PLAYER2 = Opcode(\n    code = 0xF8AD,\n    mnemonic = \"get_number_of_player2\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xAD] = it }\n\nval OP_READ1 = Opcode(\n    code = 0xF8B0,\n    mnemonic = \"read1\",\n    doc = \"Reads a 1-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(ByteType, null, ParamAccess.Write),\n        )), \"Register to store the result to.\", null),\n        Param(IntType, \"Address to read from.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB0] = it }\n\nval OP_READ2 = Opcode(\n    code = 0xF8B1,\n    mnemonic = \"read2\",\n    doc = \"Reads a 2-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(ShortType, null, ParamAccess.Write),\n        )), \"Register to store the result to.\", null),\n        Param(IntType, \"Address to read from.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB1] = it }\n\nval OP_READ4 = Opcode(\n    code = 0xF8B2,\n    mnemonic = \"read4\",\n    doc = \"Reads a 4-byte value from an arbitrary location.\",\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), \"Register to store the result to.\", null),\n        Param(IntType, \"Address to read from.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB2] = it }\n\nval OP_WRITE1 = Opcode(\n    code = 0xF8B3,\n    mnemonic = \"write1\",\n    doc = \"Writes a 1-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, \"Address to write to.\", null),\n        Param(ByteType, \"Value to be written.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB3] = it }\n\nval OP_WRITE2 = Opcode(\n    code = 0xF8B4,\n    mnemonic = \"write2\",\n    doc = \"Writes a 2-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, \"Address to write to.\", null),\n        Param(ShortType, \"Value to be written.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB4] = it }\n\nval OP_WRITE4 = Opcode(\n    code = 0xF8B5,\n    mnemonic = \"write4\",\n    doc = \"Writes a 4-byte value to an arbitrary location.\",\n    params = listOf(\n        Param(IntType, \"Address to write to.\", null),\n        Param(IntType, \"Value to be written.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB5] = it }\n\nval OP_CHL_RECOVERY = Opcode(\n    code = 0xF8B9,\n    mnemonic = \"chl_recovery\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xB9] = it }\n\nval OP_SET_EPISODE = Opcode(\n    code = 0xF8BC,\n    mnemonic = \"set_episode\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xBC] = it }\n\nval OP_FILE_DL_REQ = Opcode(\n    code = 0xF8C0,\n    mnemonic = \"file_dl_req\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC0] = it }\n\nval OP_GET_DL_STATUS = Opcode(\n    code = 0xF8C1,\n    mnemonic = \"get_dl_status\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC1] = it }\n\nval OP_GBA_UNKNOWN4 = Opcode(\n    code = 0xF8C2,\n    mnemonic = \"gba_unknown4\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC2] = it }\n\nval OP_GET_GBA_STATE = Opcode(\n    code = 0xF8C3,\n    mnemonic = \"get_gba_state\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC3] = it }\n\nval OP_UNKNOWN_F8C4 = Opcode(\n    code = 0xF8C4,\n    mnemonic = \"unknown_f8c4\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xC4] = it }\n\nval OP_UNKNOWN_F8C5 = Opcode(\n    code = 0xF8C5,\n    mnemonic = \"unknown_f8c5\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xC5] = it }\n\nval OP_QEXIT = Opcode(\n    code = 0xF8C6,\n    mnemonic = \"qexit\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC6] = it }\n\nval OP_USE_ANIMATION = Opcode(\n    code = 0xF8C7,\n    mnemonic = \"use_animation\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Animation ID.\", ParamAccess.Read),\n            Param(IntType, \"Animation duration in number of frames.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC7] = it }\n\nval OP_STOP_ANIMATION = Opcode(\n    code = 0xF8C8,\n    mnemonic = \"stop_animation\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC8] = it }\n\nval OP_RUN_TO_COORD = Opcode(\n    code = 0xF8C9,\n    mnemonic = \"run_to_coord\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xC9] = it }\n\nval OP_SET_SLOT_INVINCIBLE = Opcode(\n    code = 0xF8CA,\n    mnemonic = \"set_slot_invincible\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCA] = it }\n\nval OP_UNKNOWN_F8CB = Opcode(\n    code = 0xF8CB,\n    mnemonic = \"unknown_f8cb\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xCB] = it }\n\nval OP_SET_SLOT_POISON = Opcode(\n    code = 0xF8CC,\n    mnemonic = \"set_slot_poison\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCC] = it }\n\nval OP_SET_SLOT_PARALYZE = Opcode(\n    code = 0xF8CD,\n    mnemonic = \"set_slot_paralyze\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCD] = it }\n\nval OP_SET_SLOT_SHOCK = Opcode(\n    code = 0xF8CE,\n    mnemonic = \"set_slot_shock\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCE] = it }\n\nval OP_SET_SLOT_FREEZE = Opcode(\n    code = 0xF8CF,\n    mnemonic = \"set_slot_freeze\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xCF] = it }\n\nval OP_SET_SLOT_SLOW = Opcode(\n    code = 0xF8D0,\n    mnemonic = \"set_slot_slow\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD0] = it }\n\nval OP_SET_SLOT_CONFUSE = Opcode(\n    code = 0xF8D1,\n    mnemonic = \"set_slot_confuse\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD1] = it }\n\nval OP_SET_SLOT_SHIFTA = Opcode(\n    code = 0xF8D2,\n    mnemonic = \"set_slot_shifta\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD2] = it }\n\nval OP_SET_SLOT_DEBAND = Opcode(\n    code = 0xF8D3,\n    mnemonic = \"set_slot_deband\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD3] = it }\n\nval OP_SET_SLOT_JELLEN = Opcode(\n    code = 0xF8D4,\n    mnemonic = \"set_slot_jellen\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD4] = it }\n\nval OP_SET_SLOT_ZALURE = Opcode(\n    code = 0xF8D5,\n    mnemonic = \"set_slot_zalure\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD5] = it }\n\nval OP_FLETI_FIXED_CAMERA = Opcode(\n    code = 0xF8D6,\n    mnemonic = \"fleti_fixed_camera\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD6] = it }\n\nval OP_FLETI_LOCKED_CAMERA = Opcode(\n    code = 0xF8D7,\n    mnemonic = \"fleti_locked_camera\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD7] = it }\n\nval OP_DEFAULT_CAMERA_POS2 = Opcode(\n    code = 0xF8D8,\n    mnemonic = \"default_camera_pos2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD8] = it }\n\nval OP_SET_MOTION_BLUR = Opcode(\n    code = 0xF8D9,\n    mnemonic = \"set_motion_blur\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xD9] = it }\n\nval OP_SET_SCREEN_BW = Opcode(\n    code = 0xF8DA,\n    mnemonic = \"set_screen_bw\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDA] = it }\n\nval OP_UNKNOWN_F8DB = Opcode(\n    code = 0xF8DB,\n    mnemonic = \"unknown_f8db\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(ShortType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xDB] = it }\n\nval OP_NPC_ACTION_STRING = Opcode(\n    code = 0xF8DC,\n    mnemonic = \"npc_action_string\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(SLabelType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDC] = it }\n\nval OP_GET_PAD_COND = Opcode(\n    code = 0xF8DD,\n    mnemonic = \"get_pad_cond\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDD] = it }\n\nval OP_GET_BUTTON_COND = Opcode(\n    code = 0xF8DE,\n    mnemonic = \"get_button_cond\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDE] = it }\n\nval OP_FREEZE_ENEMIES = Opcode(\n    code = 0xF8DF,\n    mnemonic = \"freeze_enemies\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xDF] = it }\n\nval OP_UNFREEZE_ENEMIES = Opcode(\n    code = 0xF8E0,\n    mnemonic = \"unfreeze_enemies\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE0] = it }\n\nval OP_FREEZE_EVERYTHING = Opcode(\n    code = 0xF8E1,\n    mnemonic = \"freeze_everything\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE1] = it }\n\nval OP_UNFREEZE_EVERYTHING = Opcode(\n    code = 0xF8E2,\n    mnemonic = \"unfreeze_everything\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE2] = it }\n\nval OP_RESTORE_HP = Opcode(\n    code = 0xF8E3,\n    mnemonic = \"restore_hp\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE3] = it }\n\nval OP_RESTORE_TP = Opcode(\n    code = 0xF8E4,\n    mnemonic = \"restore_tp\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE4] = it }\n\nval OP_CLOSE_CHAT_BUBBLE = Opcode(\n    code = 0xF8E5,\n    mnemonic = \"close_chat_bubble\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE5] = it }\n\nval OP_MOVE_COORDS_OBJECT = Opcode(\n    code = 0xF8E6,\n    mnemonic = \"move_coords_object\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE6] = it }\n\nval OP_AT_COORDS_CALL_EX = Opcode(\n    code = 0xF8E7,\n    mnemonic = \"at_coords_call_ex\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xE7] = it }\n\nval OP_UNKNOWN_F8E8 = Opcode(\n    code = 0xF8E8,\n    mnemonic = \"unknown_f8e8\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xE8] = it }\n\nval OP_UNKNOWN_F8E9 = Opcode(\n    code = 0xF8E9,\n    mnemonic = \"unknown_f8e9\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xE9] = it }\n\nval OP_UNKNOWN_F8EA = Opcode(\n    code = 0xF8EA,\n    mnemonic = \"unknown_f8ea\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEA] = it }\n\nval OP_UNKNOWN_F8EB = Opcode(\n    code = 0xF8EB,\n    mnemonic = \"unknown_f8eb\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEB] = it }\n\nval OP_UNKNOWN_F8EC = Opcode(\n    code = 0xF8EC,\n    mnemonic = \"unknown_f8ec\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F8[0xEC] = it }\n\nval OP_ANIMATION_CHECK = Opcode(\n    code = 0xF8ED,\n    mnemonic = \"animation_check\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xED] = it }\n\nval OP_CALL_IMAGE_DATA = Opcode(\n    code = 0xF8EE,\n    mnemonic = \"call_image_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(ShortType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xEE] = it }\n\nval OP_TURN_OFF_BGM_P2 = Opcode(\n    code = 0xF8F0,\n    mnemonic = \"turn_off_bgm_p2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF0] = it }\n\nval OP_TURN_ON_BGM_P2 = Opcode(\n    code = 0xF8F1,\n    mnemonic = \"turn_on_bgm_p2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF1] = it }\n\nval OP_LOAD_UNK_DATA = Opcode(\n    code = 0xF8F2,\n    mnemonic = \"load_unk_data\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(DLabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF2] = it }\n\nval OP_PARTICLE2 = Opcode(\n    code = 0xF8F3,\n    mnemonic = \"particle2\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F8[0xF3] = it }\n\nval OP_DEC2FLOAT = Opcode(\n    code = 0xF901,\n    mnemonic = \"dec2float\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x01] = it }\n\nval OP_FLOAT2DEC = Opcode(\n    code = 0xF902,\n    mnemonic = \"float2dec\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x02] = it }\n\nval OP_FLET = Opcode(\n    code = 0xF903,\n    mnemonic = \"flet\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x03] = it }\n\nval OP_FLETI = Opcode(\n    code = 0xF904,\n    mnemonic = \"fleti\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x04] = it }\n\nval OP_FADD = Opcode(\n    code = 0xF908,\n    mnemonic = \"fadd\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x08] = it }\n\nval OP_FADDI = Opcode(\n    code = 0xF909,\n    mnemonic = \"faddi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x09] = it }\n\nval OP_FSUB = Opcode(\n    code = 0xF90A,\n    mnemonic = \"fsub\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0A] = it }\n\nval OP_FSUBI = Opcode(\n    code = 0xF90B,\n    mnemonic = \"fsubi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0B] = it }\n\nval OP_FMUL = Opcode(\n    code = 0xF90C,\n    mnemonic = \"fmul\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0C] = it }\n\nval OP_FMULI = Opcode(\n    code = 0xF90D,\n    mnemonic = \"fmuli\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0D] = it }\n\nval OP_FDIV = Opcode(\n    code = 0xF90E,\n    mnemonic = \"fdiv\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0E] = it }\n\nval OP_FDIVI = Opcode(\n    code = 0xF90F,\n    mnemonic = \"fdivi\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(FloatType, null, ParamAccess.Write),\n        )), null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x0F] = it }\n\nval OP_GET_UNKNOWN_COUNT = Opcode(\n    code = 0xF910,\n    mnemonic = \"get_unknown_count\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x10] = it }\n\nval OP_GET_STACKABLE_ITEM_COUNT = Opcode(\n    code = 0xF911,\n    mnemonic = \"get_stackable_item_count\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, \"Player slot.\", ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n            Param(IntType, null, ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x11] = it }\n\nval OP_FREEZE_AND_HIDE_EQUIP = Opcode(\n    code = 0xF912,\n    mnemonic = \"freeze_and_hide_equip\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x12] = it }\n\nval OP_THAW_AND_SHOW_EQUIP = Opcode(\n    code = 0xF913,\n    mnemonic = \"thaw_and_show_equip\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x13] = it }\n\nval OP_SET_PALETTEX_CALLBACK = Opcode(\n    code = 0xF914,\n    mnemonic = \"set_palettex_callback\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x14] = it }\n\nval OP_ACTIVATE_PALETTEX = Opcode(\n    code = 0xF915,\n    mnemonic = \"activate_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x15] = it }\n\nval OP_ENABLE_PALETTEX = Opcode(\n    code = 0xF916,\n    mnemonic = \"enable_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x16] = it }\n\nval OP_RESTORE_PALETTEX = Opcode(\n    code = 0xF917,\n    mnemonic = \"restore_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x17] = it }\n\nval OP_DISABLE_PALETTEX = Opcode(\n    code = 0xF918,\n    mnemonic = \"disable_palettex\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x18] = it }\n\nval OP_GET_PALETTEX_ACTIVATED = Opcode(\n    code = 0xF919,\n    mnemonic = \"get_palettex_activated\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x19] = it }\n\nval OP_GET_UNKNOWN_PALETTEX_STATUS = Opcode(\n    code = 0xF91A,\n    mnemonic = \"get_unknown_palettex_status\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1A] = it }\n\nval OP_DISABLE_MOVEMENT2 = Opcode(\n    code = 0xF91B,\n    mnemonic = \"disable_movement2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1B] = it }\n\nval OP_ENABLE_MOVEMENT2 = Opcode(\n    code = 0xF91C,\n    mnemonic = \"enable_movement2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1C] = it }\n\nval OP_GET_TIME_PLAYED = Opcode(\n    code = 0xF91D,\n    mnemonic = \"get_time_played\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1D] = it }\n\nval OP_GET_GUILDCARD_TOTAL = Opcode(\n    code = 0xF91E,\n    mnemonic = \"get_guildcard_total\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1E] = it }\n\nval OP_GET_SLOT_MESETA = Opcode(\n    code = 0xF91F,\n    mnemonic = \"get_slot_meseta\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x1F] = it }\n\nval OP_GET_PLAYER_LEVEL = Opcode(\n    code = 0xF920,\n    mnemonic = \"get_player_level\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x20] = it }\n\nval OP_GET_SECTION_ID = Opcode(\n    code = 0xF921,\n    mnemonic = \"get_section_id\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x21] = it }\n\nval OP_GET_PLAYER_HP = Opcode(\n    code = 0xF922,\n    mnemonic = \"get_player_hp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, \"Maximum HP.\", ParamAccess.Write),\n            Param(IntType, \"Current HP.\", ParamAccess.Write),\n            Param(IntType, \"Maximum TP.\", ParamAccess.Write),\n            Param(IntType, \"Current TP.\", ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x22] = it }\n\nval OP_GET_FLOOR_NUMBER = Opcode(\n    code = 0xF923,\n    mnemonic = \"get_floor_number\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x23] = it }\n\nval OP_GET_COORD_PLAYER_DETECT = Opcode(\n    code = 0xF924,\n    mnemonic = \"get_coord_player_detect\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, \"Player slot.\", ParamAccess.Read),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Read),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x24] = it }\n\nval OP_READ_GLOBAL_FLAG = Opcode(\n    code = 0xF925,\n    mnemonic = \"read_global_flag\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x25] = it }\n\nval OP_WRITE_GLOBAL_FLAG = Opcode(\n    code = 0xF926,\n    mnemonic = \"write_global_flag\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x26] = it }\n\nval OP_UNKNOWN_F927 = Opcode(\n    code = 0xF927,\n    mnemonic = \"unknown_f927\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x27] = it }\n\nval OP_FLOOR_PLAYER_DETECT = Opcode(\n    code = 0xF928,\n    mnemonic = \"floor_player_detect\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n            Param(IntType, null, ParamAccess.Write),\n            Param(IntType, null, ParamAccess.Write),\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x28] = it }\n\nval OP_READ_DISK_FILE = Opcode(\n    code = 0xF929,\n    mnemonic = \"read_disk_file\",\n    doc = null,\n    params = listOf(\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x29] = it }\n\nval OP_OPEN_PACK_SELECT = Opcode(\n    code = 0xF92A,\n    mnemonic = \"open_pack_select\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2A] = it }\n\nval OP_ITEM_SELECT = Opcode(\n    code = 0xF92B,\n    mnemonic = \"item_select\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2B] = it }\n\nval OP_GET_ITEM_ID = Opcode(\n    code = 0xF92C,\n    mnemonic = \"get_item_id\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2C] = it }\n\nval OP_COLOR_CHANGE = Opcode(\n    code = 0xF92D,\n    mnemonic = \"color_change\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2D] = it }\n\nval OP_SEND_STATISTIC = Opcode(\n    code = 0xF92E,\n    mnemonic = \"send_statistic\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x2E] = it }\n\nval OP_UNKNOWN_F92F = Opcode(\n    code = 0xF92F,\n    mnemonic = \"unknown_f92f\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x2F] = it }\n\nval OP_CHAT_BOX = Opcode(\n    code = 0xF930,\n    mnemonic = \"chat_box\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x30] = it }\n\nval OP_CHAT_BUBBLE = Opcode(\n    code = 0xF931,\n    mnemonic = \"chat_bubble\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x31] = it }\n\nval OP_UNKNOWN_F933 = Opcode(\n    code = 0xF933,\n    mnemonic = \"unknown_f933\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x33] = it }\n\nval OP_SCROLL_TEXT = Opcode(\n    code = 0xF934,\n    mnemonic = \"scroll_text\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(FloatType, null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x34] = it }\n\nval OP_GBA_UNKNOWN1 = Opcode(\n    code = 0xF935,\n    mnemonic = \"gba_unknown1\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x35] = it }\n\nval OP_GBA_UNKNOWN2 = Opcode(\n    code = 0xF936,\n    mnemonic = \"gba_unknown2\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x36] = it }\n\nval OP_GBA_UNKNOWN3 = Opcode(\n    code = 0xF937,\n    mnemonic = \"gba_unknown3\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x37] = it }\n\nval OP_ADD_DAMAGE_TO = Opcode(\n    code = 0xF938,\n    mnemonic = \"add_damage_to\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x38] = it }\n\nval OP_ITEM_DELETE3 = Opcode(\n    code = 0xF939,\n    mnemonic = \"item_delete3\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x39] = it }\n\nval OP_GET_ITEM_INFO = Opcode(\n    code = 0xF93A,\n    mnemonic = \"get_item_info\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3A] = it }\n\nval OP_ITEM_PACKING1 = Opcode(\n    code = 0xF93B,\n    mnemonic = \"item_packing1\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3B] = it }\n\nval OP_ITEM_PACKING2 = Opcode(\n    code = 0xF93C,\n    mnemonic = \"item_packing2\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3C] = it }\n\nval OP_GET_LANG_SETTING = Opcode(\n    code = 0xF93D,\n    mnemonic = \"get_lang_setting\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(AnyType.Instance, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3D] = it }\n\nval OP_PREPARE_STATISTIC = Opcode(\n    code = 0xF93E,\n    mnemonic = \"prepare_statistic\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3E] = it }\n\nval OP_KEYWORD_DETECT = Opcode(\n    code = 0xF93F,\n    mnemonic = \"keyword_detect\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x3F] = it }\n\nval OP_KEYWORD = Opcode(\n    code = 0xF940,\n    mnemonic = \"keyword\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, \"Player slot.\", null),\n        Param(StringType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x40] = it }\n\nval OP_GET_GUILDCARD_NUM = Opcode(\n    code = 0xF941,\n    mnemonic = \"get_guildcard_num\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x41] = it }\n\nval OP_GET_WRAP_STATUS = Opcode(\n    code = 0xF944,\n    mnemonic = \"get_wrap_status\",\n    doc = null,\n    params = listOf(\n        Param(IntType, \"Player slot.\", null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x44] = it }\n\nval OP_INITIAL_FLOOR = Opcode(\n    code = 0xF945,\n    mnemonic = \"initial_floor\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x45] = it }\n\nval OP_SIN = Opcode(\n    code = 0xF946,\n    mnemonic = \"sin\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x46] = it }\n\nval OP_COS = Opcode(\n    code = 0xF947,\n    mnemonic = \"cos\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x47] = it }\n\nval OP_BOSS_IS_DEAD2 = Opcode(\n    code = 0xF94A,\n    mnemonic = \"boss_is_dead2\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x4A] = it }\n\nval OP_UNKNOWN_F94B = Opcode(\n    code = 0xF94B,\n    mnemonic = \"unknown_f94b\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x4B] = it }\n\nval OP_UNKNOWN_F94C = Opcode(\n    code = 0xF94C,\n    mnemonic = \"unknown_f94c\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x4C] = it }\n\nval OP_IS_THERE_CARDBATTLE = Opcode(\n    code = 0xF94D,\n    mnemonic = \"is_there_cardbattle\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x4D] = it }\n\nval OP_BB_P2_MENU = Opcode(\n    code = 0xF950,\n    mnemonic = \"bb_p2_menu\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x50] = it }\n\nval OP_BB_MAP_DESIGNATE = Opcode(\n    code = 0xF951,\n    mnemonic = \"bb_map_designate\",\n    doc = null,\n    params = listOf(\n        Param(ByteType, null, null),\n        Param(ShortType, null, null),\n        Param(ByteType, null, null),\n        Param(ByteType, null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x51] = it }\n\nval OP_BB_GET_NUMBER_IN_PACK = Opcode(\n    code = 0xF952,\n    mnemonic = \"bb_get_number_in_pack\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x52] = it }\n\nval OP_BB_SWAP_ITEM = Opcode(\n    code = 0xF953,\n    mnemonic = \"bb_swap_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x53] = it }\n\nval OP_BB_CHECK_WRAP = Opcode(\n    code = 0xF954,\n    mnemonic = \"bb_check_wrap\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x54] = it }\n\nval OP_BB_EXCHANGE_PD_ITEM = Opcode(\n    code = 0xF955,\n    mnemonic = \"bb_exchange_pd_item\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x55] = it }\n\nval OP_BB_EXCHANGE_PD_SRANK = Opcode(\n    code = 0xF956,\n    mnemonic = \"bb_exchange_pd_srank\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x56] = it }\n\nval OP_BB_EXCHANGE_PD_SPECIAL = Opcode(\n    code = 0xF957,\n    mnemonic = \"bb_exchange_pd_special\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x57] = it }\n\nval OP_BB_EXCHANGE_PD_PERCENT = Opcode(\n    code = 0xF958,\n    mnemonic = \"bb_exchange_pd_percent\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x58] = it }\n\nval OP_UNKNOWN_F959 = Opcode(\n    code = 0xF959,\n    mnemonic = \"unknown_f959\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x59] = it }\n\nval OP_BB_EXCHANGE_SLT = Opcode(\n    code = 0xF95C,\n    mnemonic = \"bb_exchange_slt\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5C] = it }\n\nval OP_BB_EXCHANGE_PC = Opcode(\n    code = 0xF95D,\n    mnemonic = \"bb_exchange_pc\",\n    doc = null,\n    params = emptyList(),\n    stack = null,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5D] = it }\n\nval OP_BB_BOX_CREATE_BP = Opcode(\n    code = 0xF95E,\n    mnemonic = \"bb_box_create_bp\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n        Param(FloatType, null, null),\n        Param(FloatType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5E] = it }\n\nval OP_BB_EXCHANGE_PT = Opcode(\n    code = 0xF95F,\n    mnemonic = \"bb_exchange_pt\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n        Param(IntType, null, null),\n        Param(ILabelType, null, null),\n        Param(ILabelType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = true,\n).also { OPCODES_F9[0x5F] = it }\n\nval OP_UNKNOWN_F960 = Opcode(\n    code = 0xF960,\n    mnemonic = \"unknown_f960\",\n    doc = null,\n    params = listOf(\n        Param(IntType, null, null),\n    ),\n    stack = StackInteraction.Pop,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x60] = it }\n\nval OP_UNKNOWN_F961 = Opcode(\n    code = 0xF961,\n    mnemonic = \"unknown_f961\",\n    doc = null,\n    params = listOf(\n        Param(RegRefType(listOf(\n            Param(IntType, null, ParamAccess.Write),\n        )), null, null),\n    ),\n    stack = null,\n    varargs = false,\n    known = false,\n).also { OPCODES_F9[0x61] = it }\n","package world.phantasmal.lib.asm\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.reinterpretAsFloat\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val INDENT_WIDTH = 4\nprivate val INDENT = \" \".repeat(INDENT_WIDTH)\n\n/**\n * @param inlineStackArgs If true, will output stack arguments inline instead of outputting stack\n * management instructions (argpush variants).\n */\nfun disassemble(bytecodeIr: BytecodeIr, inlineStackArgs: Boolean = true): List<String> {\n    logger.trace {\n        \"Disassembling ${bytecodeIr.segments.size} segments with ${\n            if (inlineStackArgs) \"inline stack arguments\" else \"stack push instructions\"\n        }.\"\n    }\n\n    val lines = mutableListOf<String>()\n    val stack = mutableListOf<ArgWithType>()\n    var sectionType: SegmentType? = null\n\n    for (segment in bytecodeIr.segments) {\n        // Section marker (.code, .data or .string).\n        if (sectionType != segment.type) {\n            sectionType = segment.type\n\n            if (lines.isNotEmpty()) {\n                lines.add(\"\")\n            }\n\n            val sectionMarker = when (segment) {\n                is InstructionSegment -> \".code\"\n                is DataSegment -> \".data\"\n                is StringSegment -> \".string\"\n            }\n\n            lines.add(sectionMarker)\n            lines.add(\"\")\n        }\n\n        // Labels.\n        for (label in segment.labels) {\n            lines.add(\"$label:\")\n        }\n\n        // Code or data lines.\n        when (segment) {\n            is InstructionSegment -> {\n                var inVaList = false\n\n                segment.instructions.forEachIndexed { i, instruction ->\n                    val opcode = instruction.opcode\n\n                    if (opcode.code == OP_VA_START.code) {\n                        inVaList = true\n                    } else if (opcode.code == OP_VA_END.code) {\n                        inVaList = false\n                    }\n\n                    if (inlineStackArgs &&\n                        !inVaList &&\n                        opcode.stack == StackInteraction.Push &&\n                        canInlinePushedArg(segment, i)\n                    ) {\n                        stack.addAll(addTypeToArgs(opcode.params, instruction.args))\n                    } else {\n                        val sb = StringBuilder(INDENT)\n                        sb.append(opcode.mnemonic)\n\n                        if (opcode.stack == StackInteraction.Pop) {\n                            if (inlineStackArgs) {\n                                sb.appendArgs(\n                                    opcode.params,\n                                    stack.takeLast(opcode.params.size),\n                                    stack = true,\n                                )\n                            }\n                        } else {\n                            sb.appendArgs(\n                                opcode.params,\n                                addTypeToArgs(opcode.params, instruction.args),\n                                stack = false\n                            )\n                        }\n\n                        if (opcode.stack != StackInteraction.Push) {\n                            stack.clear()\n                        }\n\n                        lines.add(sb.toString())\n                    }\n                }\n            }\n\n            is DataSegment -> {\n                val sb = StringBuilder(INDENT)\n\n                for (i in 0 until segment.data.size) {\n                    sb.append(\"0x\")\n                    sb.append(segment.data.getUByte(i).toString(16).padStart(2, '0'))\n\n                    when {\n                        // Last line.\n                        i == segment.data.size - 1 -> {\n                            lines.add(sb.toString())\n                        }\n                        // Start a new line after every 16 bytes.\n                        i % 16 == 15 -> {\n                            lines.add(sb.toString())\n                            sb.setLength(0)\n                            sb.append(INDENT)\n                        }\n                        // Add a space between each byte.\n                        else -> {\n                            sb.append(\" \")\n                        }\n                    }\n                }\n            }\n\n            is StringSegment -> {\n                lines.add(StringBuilder(INDENT).appendStringSegment(segment.value).toString())\n            }\n        }\n    }\n\n    // Ensure newline at the end.\n    lines.add(\"\")\n\n    logger.trace { \"Disassembly finished, line count: ${lines.size}.\" }\n\n    return lines\n}\n\nprivate data class ArgWithType(val arg: Arg, val type: AnyType)\n\nprivate fun canInlinePushedArg(segment: InstructionSegment, index: Int): Boolean {\n    var pushedArgCount = 0\n\n    for (i in index until segment.instructions.size) {\n        val opcode = segment.instructions[i].opcode\n\n        when (opcode.stack) {\n            StackInteraction.Push -> pushedArgCount++\n\n            StackInteraction.Pop -> {\n                var paramCount = 0\n                var varArgs = false\n\n                for (param in opcode.params) {\n                    when (param.type) {\n                        is ILabelVarType -> varArgs = true\n                        is RegRefVarType -> varArgs = true\n                        else -> paramCount++\n                    }\n                }\n\n                return pushedArgCount <= paramCount || (pushedArgCount > paramCount && varArgs)\n            }\n\n            null -> return false\n        }\n    }\n\n    return false\n}\n\nprivate fun addTypeToArgs(params: List<Param>, args: List<Arg>): List<ArgWithType> {\n    val argsWithType = mutableListOf<ArgWithType>()\n\n    for (i in 0 until min(params.size, args.size)) {\n        argsWithType.add(ArgWithType(args[i], params[i].type))\n    }\n\n    // Deal with varargs.\n    val lastParam = params.lastOrNull()\n\n    if (lastParam?.varargs == true) {\n        for (i in argsWithType.size until args.size) {\n            argsWithType.add(ArgWithType(args[i], lastParam.type))\n        }\n    }\n\n    return argsWithType\n}\n\nprivate fun StringBuilder.appendArgs(params: List<Param>, args: List<ArgWithType>, stack: Boolean) {\n    var i = 0\n\n    while (i < params.size) {\n        val paramType = params[i].type\n\n        if (i == 0) {\n            append(\" \")\n        } else {\n            append(\", \")\n        }\n\n        if (i < args.size) {\n            val (arg, argType) = args[i]\n\n            if (argType is RegRefType) {\n                append(\"r\")\n                append(arg.value)\n            } else {\n                when (paramType) {\n                    FloatType -> {\n                        // Floats are pushed onto the stack as integers with arg_pushl.\n                        if (stack) {\n                            append((arg.value as Int).reinterpretAsFloat())\n                        } else {\n                            append(arg.value)\n                        }\n                    }\n\n                    ILabelVarType -> {\n                        while (i < args.size) {\n                            append(args[i].arg.value)\n                            if (i < args.lastIndex) append(\", \")\n                            i++\n                        }\n                    }\n\n                    RegRefVarType -> {\n                        while (i < args.size) {\n                            append(\"r\")\n                            append(args[i].arg.value)\n                            if (i < args.lastIndex) append(\", \")\n                            i++\n                        }\n                    }\n\n                    is RegRefType -> {\n                        append(\"r\")\n                        append(arg.value)\n                    }\n\n                    StringType -> {\n                        appendStringArg(arg.value as String)\n                    }\n\n                    else -> {\n                        append(arg.value)\n                    }\n                }\n            }\n        }\n\n        i++\n    }\n}\n\nprivate fun StringBuilder.appendStringArg(value: String): StringBuilder {\n    append(\"\\\"\")\n\n    for (char in value) {\n        when (char) {\n            '\\r' -> append(\"\\\\r\")\n            '\\n' -> append(\"\\\\n\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            else -> append(char)\n        }\n    }\n\n    append(\"\\\"\")\n    return this\n}\n\nprivate fun StringBuilder.appendStringSegment(value: String): StringBuilder {\n    append(\"\\\"\")\n\n    var i = 0\n\n    while (i < value.length) {\n        when (val char = value[i]) {\n            // Replace <cr> with \\n.\n            '<' -> {\n                if (i + 3 < value.length &&\n                    value[i + 1] == 'c' &&\n                    value[i + 2] == 'r' &&\n                    value[i + 3] == '>'\n                ) {\n                    append(\"\\\\n\")\n                    i += 3\n                } else {\n                    append(char)\n                }\n            }\n            '\\r' -> append(\"\\\\r\")\n            '\\n' -> append(\"\\\\n\")\n            '\\t' -> append(\"\\\\t\")\n            '\"' -> append(\"\\\\\\\"\")\n            else -> append(char)\n        }\n\n        i++\n    }\n\n    append(\"\\\"\")\n    return this\n}\n","package world.phantasmal.lib.compression.prs\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.WritableCursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n// This code uses signed types for better KJS performance. In KJS unsigned types are always boxed.\n\nfun prsDecompress(cursor: Cursor): PwResult<Cursor> =\n    PrsDecompressor(cursor).decompress()\n\nprivate class PrsDecompressor(private val src: Cursor) {\n    private val dst: WritableCursor =\n        Buffer.withCapacity(6 * src.size, src.endianness).cursor()\n    private var flags = 0\n    private var flagBitsLeft = 0\n\n    fun decompress(): PwResult<Cursor> {\n        try {\n            while (true) {\n                if (readFlagBit() == 1) {\n                    // Single byte copy.\n                    copyByte()\n                } else {\n                    // Multi byte copy.\n                    if (readFlagBit() == 0) {\n                        // Short copy.\n                        val size = 2 + ((readFlagBit() shl 1) or readFlagBit())\n                        val offset = readUByte() - 256\n\n                        offsetCopy(offset, size)\n                    } else {\n                        // Long copy or end of file.\n                        var offset = readUShort()\n\n                        // Two zero bytes implies that this is the end of the file.\n                        if (offset == 0) {\n                            break\n                        }\n\n                        // Do we need to read a size byte, or is it encoded in what we already have?\n                        var size = offset and 0b111\n                        offset = offset ushr 3\n\n                        if (size == 0) {\n                            size = readUByte()\n                            size += 1\n                        } else {\n                            size += 2\n                        }\n\n                        offset -= 8192\n\n                        offsetCopy(offset, size)\n                    }\n                }\n            }\n\n            return Success(dst.seekStart(0))\n        } catch (e: Exception) {\n            return PwResult.build<Cursor>(logger)\n                .addProblem(Severity.Error, \"PRS-compressed stream is corrupt.\", cause = e)\n                .failure()\n        }\n    }\n\n    private fun readFlagBit(): Int {\n        // Fetch a new flag byte when the previous byte has been processed.\n        if (flagBitsLeft == 0) {\n            flags = readUByte()\n            flagBitsLeft = 8\n        }\n\n        val bit = flags and 1\n        flags = flags ushr 1\n        flagBitsLeft -= 1\n        return bit\n    }\n\n    private fun copyByte() {\n        dst.writeByte(src.byte())\n    }\n\n    private fun readUByte(): Int = src.byte().toInt() and 0xFF\n\n    private fun readUShort(): Int = src.short().toInt() and 0xFFFF\n\n    private fun offsetCopy(offset: Int, size: Int) {\n        require(offset in -8192..0) {\n            \"offset was ${offset}, should be between -8192 and 0.\"\n        }\n\n        require(size in 1..256) {\n            \"size was ${size}, should be between 1 and 256.\"\n        }\n\n        // Size can be larger than -offset, in that case we copy -offset bytes size/-offset times.\n        val bufSize = min(-offset, size)\n\n        dst.seek(offset)\n        val buf = dst.take(bufSize)\n        dst.seek(-offset - bufSize)\n\n        repeat(size / bufSize) {\n            dst.writeCursor(buf)\n            buf.seekStart(0)\n        }\n\n        dst.writeCursor(buf.take(size % bufSize))\n    }\n}\n","package world.phantasmal.lib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val AFS = 0x00534641\n\n/**\n * Returns the files contained in the given AFS archive. AFS is a simple archive format used by SEGA\n * for e.g. player character textures.\n */\nfun parseAfs(cursor: Cursor): PwResult<List<Buffer>> {\n    val result = PwResult.build<List<Buffer>>(logger)\n\n    if (cursor.bytesLeft < 8) {\n        return result\n            .addProblem(\n                Severity.Error,\n                \"AFS archive is corrupted.\",\n                \"Expected at least 8 bytes for the header, got ${cursor.bytesLeft} bytes.\",\n            )\n            .failure()\n    }\n\n    val magic = cursor.int()\n\n    if (magic != AFS) {\n        return result\n            .addProblem(Severity.Error, \"AFS archive is corrupted.\", \"Magic bytes not present.\")\n            .failure()\n    }\n\n    val fileCount = cursor.short()\n\n    // Skip two unused bytes (are these just part of the file count field?).\n    cursor.seek(2)\n\n    val files = mutableListOf<Buffer>()\n\n    for (i in 1..fileCount) {\n        if (cursor.bytesLeft < 8) {\n            result.addProblem(\n                Severity.Warning,\n                \"AFS file entry $i is invalid.\",\n                \"Couldn't read file entry $i, only ${cursor.bytesLeft} bytes left.\",\n            )\n\n            break\n        }\n\n        val offset = cursor.int()\n        val size = cursor.int()\n\n        when {\n            offset > cursor.size -> {\n                result.addProblem(\n                    Severity.Warning,\n                    \"AFS file entry $i is invalid.\",\n                    \"Invalid file offset $offset for entry $i.\",\n                )\n            }\n\n            offset + size > cursor.size -> {\n                result.addProblem(\n                    Severity.Warning,\n                    \"AFS file entry $i is invalid.\",\n                    \"File size $size (offset: $offset) of entry $i too large.\",\n                )\n            }\n\n            else -> {\n                val startPos = cursor.position\n                cursor.seekStart(offset)\n                files.add(cursor.buffer(size))\n                cursor.seekStart(startPos)\n            }\n        }\n    }\n\n    return result.success(files)\n}\n","package world.phantasmal.lib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.isBitSet\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.ninja.*\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AreaGeometry(\n    val sections: List<AreaSection>,\n)\n\nclass AreaSection(\n    val id: Int,\n    val position: Vec3,\n    val rotation: Vec3,\n    val radius: Float,\n    val objects: List<AreaObject.Simple>,\n    val animatedObjects: List<AreaObject.Animated>,\n)\n\nsealed class AreaObject {\n    abstract val offset: Int\n    abstract val xjObject: XjObject\n    abstract val flags: Int\n\n    class Simple(\n        override val offset: Int,\n        override val xjObject: XjObject,\n        override val flags: Int,\n    ) : AreaObject()\n\n    class Animated(\n        override val offset: Int,\n        override val xjObject: XjObject,\n        val njMotion: NjMotion,\n        val speed: Float,\n        override val flags: Int,\n    ) : AreaObject()\n}\n\nfun parseAreaRenderGeometry(cursor: Cursor): AreaGeometry {\n    val dataOffset = parseRel(cursor, parseIndex = false).dataOffset\n\n    cursor.seekStart(dataOffset)\n    val format = cursor.stringAscii(maxByteLength = 4, nullTerminated = true, dropRemaining = true)\n\n    if (format != \"fmt2\") {\n        logger.warn { \"\"\"Expected format to be \"fmt2\" but was \"$format\".\"\"\" }\n    }\n\n    cursor.seek(4)\n    val sectionsCount = cursor.int()\n    cursor.seek(4)\n    val sectionsOffset = cursor.int()\n\n    val sections = mutableListOf<AreaSection>()\n\n    // Cache keys are offsets.\n    val simpleAreaObjectCache = mutableMapOf<Int, List<AreaObject.Simple>>()\n    val animatedAreaObjectCache = mutableMapOf<Int, List<AreaObject.Animated>>()\n    val njMotionCache = mutableMapOf<Int, NjMotion>()\n\n    for (i in 0 until sectionsCount) {\n        cursor.seekStart(sectionsOffset + 52 * i)\n\n        val sectionId = cursor.int()\n        val sectionPosition = cursor.vec3Float()\n        val sectionRotation = Vec3(\n            angleToRad(cursor.int()),\n            angleToRad(cursor.int()),\n            angleToRad(cursor.int()),\n        )\n\n        val radius = cursor.float()\n\n        val simpleAreaObjectsOffset = cursor.int()\n        val animatedAreaObjectsOffset = cursor.int()\n        val simpleAreaObjectsCount = cursor.int()\n        val animatedAreaObjectsCount = cursor.int()\n        // Ignore the last 4 bytes.\n\n//        println(\"section $sectionId (index $i), simple geom at $simpleGeometryTableOffset, animated geom at $animatedGeometryTableOffset\")\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val simpleObjects = simpleAreaObjectCache.getOrPut(simpleAreaObjectsOffset) {\n            parseAreaObjects(\n                cursor,\n                njMotionCache,\n                simpleAreaObjectsOffset,\n                simpleAreaObjectsCount,\n                animated = false,\n            ) as List<AreaObject.Simple>\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val animatedObjects = animatedAreaObjectCache.getOrPut(animatedAreaObjectsOffset) {\n            parseAreaObjects(\n                cursor,\n                njMotionCache,\n                animatedAreaObjectsOffset,\n                animatedAreaObjectsCount,\n                animated = true,\n            ) as List<AreaObject.Animated>\n        }\n\n        sections.add(AreaSection(\n            sectionId,\n            sectionPosition,\n            sectionRotation,\n            radius,\n            simpleObjects,\n            animatedObjects,\n        ))\n    }\n\n    return AreaGeometry(sections)\n}\n\nprivate fun parseAreaObjects(\n    cursor: Cursor,\n    njMotionCache: MutableMap<Int, NjMotion>,\n    offset: Int,\n    count: Int,\n    animated: Boolean,\n): List<AreaObject> {\n    val objectSize = if (animated) 32 else 16\n    val objects = mutableListOf<AreaObject>()\n\n    for (i in 0 until count) {\n        val objectOffset = offset + objectSize * i\n        cursor.seekStart(objectOffset)\n\n        var xjObjectOffset = cursor.int()\n        val speed: Float?\n        val njMotionOffset: Int?\n\n        if (animated) {\n            njMotionOffset = cursor.int()\n            cursor.seek(8)\n            speed = cursor.float()\n        } else {\n            speed = null\n            njMotionOffset = null\n        }\n\n        cursor.seek(8) // Skip slide texture ID offset and swap texture ID offset.\n\n        val flags = cursor.int()\n\n        if (flags.isBitSet(2)) {\n            xjObjectOffset = cursor.seekStart(xjObjectOffset).int()\n        }\n\n        cursor.seekStart(xjObjectOffset)\n        val xjObjects = parseXjObject(cursor)\n\n        if (xjObjects.size > 1) {\n            logger.warn {\n                \"Expected exactly one xjObject at ${xjObjectOffset}, got ${xjObjects.size}.\"\n            }\n        }\n\n        val xjObject = xjObjects.first()\n\n        val njMotion = njMotionOffset?.let {\n            njMotionCache.getOrPut(njMotionOffset) {\n                cursor.seekStart(njMotionOffset)\n                parseMotion(cursor, v2Format = false)\n            }\n        }\n\n        objects.add(\n            if (animated) {\n                AreaObject.Animated(objectOffset, xjObject, njMotion!!, speed!!, flags)\n            } else {\n                AreaObject.Simple(objectOffset, xjObject, flags)\n            }\n        )\n    }\n\n    return objects\n}\n","package world.phantasmal.lib.fileFormats\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.cursor.Cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nclass IffChunk(val type: Int, val data: Cursor)\n\nclass IffChunkHeader(val type: Int, val size: Int)\n\n/**\n * PSO uses a little endian variant of the IFF format.\n * IFF files contain chunks preceded by an 8-byte header.\n * The header consists of 4 ASCII characters for the \"Type ID\" and a 32-bit integer specifying the chunk size.\n */\nfun parseIff(cursor: Cursor, silent: Boolean = false): PwResult<List<IffChunk>> =\n    parse(cursor, silent) { chunkCursor, type, size -> IffChunk(type, chunkCursor.take(size)) }\n\n/**\n * Parses just the chunk headers.\n */\nfun parseIffHeaders(cursor: Cursor, silent: Boolean = false): PwResult<List<IffChunkHeader>> =\n    parse(cursor, silent) { _, type, size -> IffChunkHeader(type, size) }\n\nprivate fun <T> parse(\n    cursor: Cursor,\n    silent: Boolean,\n    getChunk: (Cursor, type: Int, size: Int) -> T,\n): PwResult<List<T>> {\n    val result = PwResult.build<List<T>>(logger)\n    val chunks = mutableListOf<T>()\n    var corrupted = false\n\n    while (cursor.bytesLeft >= 8) {\n        val type = cursor.int()\n        val sizePos = cursor.position\n        val size = cursor.int()\n\n        if (size > cursor.bytesLeft) {\n            corrupted = true\n\n            if (!silent) {\n                result.addProblem(\n                    if (chunks.isEmpty()) Severity.Error else Severity.Warning,\n                    \"IFF file corrupted.\",\n                    \"Size $size was too large (only ${cursor.bytesLeft} bytes left) at position $sizePos.\"\n                )\n            }\n\n            break\n        }\n\n        chunks.add(getChunk(cursor, type, size))\n    }\n\n    return if (corrupted && chunks.isEmpty()) {\n        result.failure()\n    } else {\n        result.success(chunks)\n    }\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport kotlin.math.PI\nimport kotlin.math.round\n\nprivate const val ANGLE_TO_RAD = ((2 * PI) / 0x10000).toFloat()\nprivate const val RAD_TO_ANGLE = (0x10000 / (2 * PI)).toFloat()\n\nfun angleToRad(angle: Int): Float {\n    return angle * ANGLE_TO_RAD\n}\n\nfun radToAngle(rad: Float): Int {\n    return round(rad * RAD_TO_ANGLE).toInt()\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.isBitSet\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.Vec2\nimport world.phantasmal.lib.fileFormats.Vec3\nimport world.phantasmal.lib.fileFormats.vec3Float\nimport kotlin.math.abs\n\n// TODO:\n//  - colors\n//  - bump maps\n\nprivate val logger = KotlinLogging.logger {}\n\n// TODO: Simplify parser by not parsing chunks into vertices and meshes. Do the chunk to vertex/mesh\n//       conversion at a higher level.\nfun parseNjModel(cursor: Cursor, cachedChunks: MutableMap<Int, List<NjChunk>>): NjModel {\n    val vlistOffset = cursor.int() // Vertex list\n    val plistOffset = cursor.int() // Triangle strip index list\n    val collisionSphereCenter = cursor.vec3Float()\n    val collisionSphereRadius = cursor.float()\n    val vertices: MutableList<NjVertex?> = mutableListOf()\n    val meshes: MutableList<NjTriangleStrip> = mutableListOf()\n\n    if (vlistOffset != 0) {\n        cursor.seekStart(vlistOffset)\n\n        for (chunk in parseChunks(cursor)) {\n            if (chunk is NjChunk.Vertex) {\n                for (vertex in chunk.vertices) {\n                    while (vertices.size <= vertex.index) {\n                        vertices.add(null)\n                    }\n\n                    vertices[vertex.index] = NjVertex(\n                        vertex.position,\n                        vertex.normal,\n                        vertex.boneWeight,\n                        vertex.boneWeightStatus,\n                        vertex.calcContinue,\n                    )\n                }\n            }\n        }\n    }\n\n    if (plistOffset > 0) {\n        cursor.seekStart(plistOffset)\n\n        PolygonChunkProcessor(cachedChunks, meshes).process(parseChunks(cursor))\n    }\n\n    return NjModel(\n        vertices,\n        meshes,\n        collisionSphereCenter,\n        collisionSphereRadius,\n    )\n}\n\nprivate class PolygonChunkProcessor(\n    private val cachedChunks: MutableMap<Int, List<NjChunk>>,\n    private val meshes: MutableList<NjTriangleStrip>,\n) {\n    private var textureId: Int? = null\n    private var srcAlpha: Int? = null\n    private var dstAlpha: Int? = null\n\n    /**\n     * When [cacheList] is non-null we are caching chunks.\n     */\n    private var cacheList: MutableList<NjChunk>? = null\n\n    fun process(chunks: List<NjChunk>) {\n        for (chunk in chunks) {\n            if (cacheList == null) {\n                when (chunk) {\n                    is NjChunk.BlendAlpha -> {\n                        srcAlpha = chunk.srcAlpha\n                        dstAlpha = chunk.dstAlpha\n                    }\n\n                    is NjChunk.CachePolygonList -> {\n                        cacheList = mutableListOf()\n                        cachedChunks[chunk.cacheIndex] = cacheList!!\n                    }\n\n                    is NjChunk.DrawPolygonList -> {\n                        val cached = cachedChunks[chunk.cacheIndex]\n\n                        if (cached == null) {\n                            logger.debug {\n                                \"Draw Polygon List chunk pointed to nonexistent cache index ${chunk.cacheIndex}.\"\n                            }\n                        } else {\n                            process(cached)\n                        }\n                    }\n\n                    is NjChunk.Tiny -> {\n                        textureId = chunk.textureId\n                    }\n\n                    is NjChunk.Material -> {\n                        srcAlpha = chunk.srcAlpha\n                        dstAlpha = chunk.dstAlpha\n                    }\n\n                    is NjChunk.Strip -> {\n                        for (strip in chunk.triangleStrips) {\n                            strip.textureId = textureId\n                            strip.srcAlpha = srcAlpha\n                            strip.dstAlpha = dstAlpha\n                        }\n\n                        meshes.addAll(chunk.triangleStrips)\n                    }\n\n                    else -> {\n                        // Ignore\n                    }\n                }\n            } else {\n                cacheList!!.add(chunk)\n            }\n        }\n    }\n}\n\nprivate fun parseChunks(cursor: Cursor): List<NjChunk> {\n    val chunks: MutableList<NjChunk> = mutableListOf()\n\n    do {\n        val chunkStartPosition = cursor.position\n        val typeId = cursor.uByte().toInt()\n        val flags = cursor.uByte().toInt()\n        val chunkDataPosition = cursor.position\n        var size = 0\n        val chunk: NjChunk\n\n        when (typeId) {\n            0 -> {\n                chunk = NjChunk.Null\n            }\n            1 -> {\n                chunk = NjChunk.BlendAlpha(\n                    srcAlpha = (flags ushr 3) and 0b111,\n                    dstAlpha = flags and 0b111,\n                )\n            }\n            2 -> {\n                chunk = NjChunk.MipmapDAdjust(\n                    adjust = flags and 0b1111,\n                )\n            }\n            3 -> {\n                chunk = NjChunk.SpecularExponent(\n                    specular = flags and 0b11111,\n                )\n            }\n            4 -> {\n                chunk = NjChunk.CachePolygonList(\n                    cacheIndex = flags,\n                )\n            }\n            5 -> {\n                chunk = NjChunk.DrawPolygonList(\n                    cacheIndex = flags,\n                )\n            }\n            in 8..9 -> {\n                size = 2\n                val textureBitsAndId = cursor.uShort().toInt()\n\n                chunk = NjChunk.Tiny(\n                    typeId,\n                    flipU = flags.isBitSet(7),\n                    flipV = flags.isBitSet(6),\n                    clampU = flags.isBitSet(5),\n                    clampV = flags.isBitSet(4),\n                    mipmapDAdjust = flags.toUInt() and 0b1111u,\n                    filterMode = textureBitsAndId ushr 14,\n                    superSample = (textureBitsAndId and 0x40) != 0,\n                    textureId = textureBitsAndId and 0x1FFF,\n                )\n            }\n            in 17..31 -> {\n                val bodySize = 2 * cursor.short()\n                size = 2 + bodySize\n\n                var diffuse: NjArgb? = null\n                var ambient: NjArgb? = null\n                var specular: NjErgb? = null\n\n                if (typeId == 24) {\n                    // Skip bump map data.\n                    cursor.seek(bodySize)\n                } else {\n                    if (typeId.isBitSet(0)) {\n                        diffuse = NjArgb(\n                            b = cursor.uByte().toFloat() / 255f,\n                            g = cursor.uByte().toFloat() / 255f,\n                            r = cursor.uByte().toFloat() / 255f,\n                            a = cursor.uByte().toFloat() / 255f,\n                        )\n                    }\n\n                    if (typeId.isBitSet(1)) {\n                        ambient = NjArgb(\n                            b = cursor.uByte().toFloat() / 255f,\n                            g = cursor.uByte().toFloat() / 255f,\n                            r = cursor.uByte().toFloat() / 255f,\n                            a = cursor.uByte().toFloat() / 255f,\n                        )\n                    }\n\n                    if (typeId.isBitSet(2)) {\n                        specular = NjErgb(\n                            b = cursor.uByte(),\n                            g = cursor.uByte(),\n                            r = cursor.uByte(),\n                            e = cursor.uByte(),\n                        )\n                    }\n                }\n\n                chunk = NjChunk.Material(\n                    typeId,\n                    srcAlpha = (flags ushr 3) and 0b111,\n                    dstAlpha = flags and 0b111,\n                    diffuse,\n                    ambient,\n                    specular,\n                )\n            }\n            in 32..50 -> {\n                size = 2 + 4 * cursor.short()\n                chunk = NjChunk.Vertex(\n                    typeId,\n                    vertices = parseVertexChunk(cursor, typeId, flags),\n                )\n            }\n            in 56..58 -> {\n                size = 2 + 2 * cursor.short()\n                chunk = NjChunk.Volume(\n                    typeId,\n                )\n\n                // Skip volume information.\n                cursor.seek(2 * cursor.short())\n            }\n            in 64..75 -> {\n                size = 2 + 2 * cursor.short()\n                chunk = NjChunk.Strip(\n                    typeId,\n                    triangleStrips = parseTriangleStripChunk(cursor, typeId, flags),\n                )\n            }\n            255 -> {\n                chunk = NjChunk.End\n            }\n            else -> {\n                val bodySize = 2 * cursor.short()\n                size = 2 + bodySize\n                chunk = NjChunk.Unknown(\n                    typeId,\n                )\n                // Skip unknown data.\n                cursor.seek(bodySize)\n                logger.warn { \"Unknown chunk type $typeId at offset ${chunkStartPosition}.\" }\n            }\n        }\n\n        chunks.add(chunk)\n\n        val bytesRead = cursor.position - chunkDataPosition\n\n        check(bytesRead <= size) {\n            \"Expected to read at most $size bytes, actually read $bytesRead.\"\n        }\n\n        cursor.seekStart(chunkDataPosition + size)\n    } while (chunk != NjChunk.End)\n\n    return chunks\n}\n\nprivate fun parseVertexChunk(\n    cursor: Cursor,\n    chunkTypeId: Int,\n    flags: Int,\n): List<NjChunkVertex> {\n    val boneWeightStatus = flags and 0b11\n    val calcContinue = (flags and 0x80) != 0\n\n    val index = cursor.uShort()\n    val vertexCount = cursor.uShort()\n\n    val vertices: MutableList<NjChunkVertex> = mutableListOf()\n\n    for (i in (0u).toUShort() until vertexCount) {\n        var vertexIndex = index + i\n        val position = cursor.vec3Float()\n        var normal: Vec3? = null\n        var boneWeight: Float? = null\n\n        when (chunkTypeId) {\n            32 -> {\n                // NJD_CV_SH\n                cursor.seek(4) // Always 1.0\n            }\n            33 -> {\n                // NJD_CV_VN_SH\n                cursor.seek(4) // Always 1.0\n                normal = cursor.vec3Float()\n                cursor.seek(4) // Always 0.0\n            }\n            34 -> {\n                // NJD_CV\n                // Nothing to do.\n            }\n            in 35..40 -> {\n                if (chunkTypeId == 37) {\n                    // NJD_CV_NF\n                    // NinjaFlags32\n                    vertexIndex = index + cursor.uShort()\n                    boneWeight = cursor.uShort().toFloat() / 255f\n                } else {\n                    // NJD_CV_D8\n                    // NJD_CV_UF\n                    // NJD_CV_S5\n                    // NJD_CV_S4\n                    // NJD_CV_IN\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            41 -> {\n                // NJD_CV_VN\n                normal = cursor.vec3Float()\n            }\n            in 42..47 -> {\n                normal = cursor.vec3Float()\n\n                if (chunkTypeId == 44) {\n                    // NJD_CV_VN_NF\n                    // NinjaFlags32\n                    vertexIndex = index + cursor.uShort()\n                    boneWeight = cursor.uShort().toFloat() / 255f\n                } else {\n                    // NJD_CV_VN_D8\n                    // NJD_CV_VN_UF\n                    // NJD_CV_VN_S5\n                    // NJD_CV_VN_S4\n                    // NJD_CV_VN_IN\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            in 48..50 -> {\n                // NJD_CV_VNX\n                // 32-Bit vertex normal in format: reserved(2)|x(10)|y(10)|z(10)\n                val n = cursor.uInt()\n                normal = Vec3(\n                    ((n shr 20) and 0x3FFu).toFloat() / 0x3FF,\n                    ((n shr 10) and 0x3FFu).toFloat() / 0x3FF,\n                    (n and 0x3FFu).toFloat() / 0x3FF,\n                )\n\n                if (chunkTypeId >= 49) {\n                    // NJD_CV_VNX_D8\n                    // NJD_CV_VNX_UF\n                    // Skip user flags and material information.\n                    cursor.seek(4)\n                }\n            }\n            else -> error(\"Unexpected chunk type ID ${chunkTypeId}.\")\n        }\n\n        vertices.add(NjChunkVertex(\n            vertexIndex.toInt(),\n            position,\n            normal,\n            boneWeight,\n            boneWeightStatus,\n            calcContinue,\n        ))\n    }\n\n    return vertices\n}\n\nprivate fun parseTriangleStripChunk(\n    cursor: Cursor,\n    chunkTypeId: Int,\n    flags: Int,\n): List<NjTriangleStrip> {\n    val ignoreLight = flags.isBitSet(0)\n    val ignoreSpecular = flags.isBitSet(1)\n    val ignoreAmbient = flags.isBitSet(2)\n    val useAlpha = flags.isBitSet(3)\n    val doubleSide = flags.isBitSet(4)\n    val flatShading = flags.isBitSet(5)\n    val environmentMapping = flags.isBitSet(6)\n\n    val userOffsetAndStripCount = cursor.short().toInt()\n    val userFlagsSize = 2 * (userOffsetAndStripCount ushr 14)\n    val stripCount = userOffsetAndStripCount and 0x3FFF\n\n    var hasTexCoords = false\n    var hasColor = false\n    var hasNormal = false\n    var hasDoubleTexCoords = false\n\n    when (chunkTypeId) {\n        64 -> {\n        }\n        65, 66 -> {\n            hasTexCoords = true\n        }\n        67 -> {\n            hasNormal = true\n        }\n        68, 69 -> {\n            hasTexCoords = true\n            hasNormal = true\n        }\n        70 -> {\n            hasColor = true\n        }\n        71, 72 -> {\n            hasTexCoords = true\n            hasColor = true\n        }\n        73 -> {\n        }\n        74, 75 -> {\n            hasDoubleTexCoords = true\n        }\n        else -> error(\"Unexpected chunk type ID: ${chunkTypeId}.\")\n    }\n\n    val strips: MutableList<NjTriangleStrip> = mutableListOf()\n\n    repeat(stripCount) {\n        val windingFlagAndIndexCount = cursor.short().toInt()\n        val clockwiseWinding = windingFlagAndIndexCount < 0\n        val indexCount = abs(windingFlagAndIndexCount)\n\n        val vertices: MutableList<NjMeshVertex> = mutableListOf()\n\n        for (j in 0 until indexCount) {\n            val index = cursor.uShort().toInt()\n\n            val texCoords = if (hasTexCoords) {\n                Vec2(cursor.uShort().toFloat() / 255f, cursor.uShort().toFloat() / 255f)\n            } else null\n\n            // Ignore ARGB8888 color.\n            if (hasColor) {\n                cursor.seek(4)\n            }\n\n            val normal = if (hasNormal) {\n                Vec3(\n                    cursor.uShort().toFloat() / 255f,\n                    cursor.uShort().toFloat() / 255f,\n                    cursor.uShort().toFloat() / 255f,\n                )\n            } else null\n\n            // Ignore double texture coordinates (Ua, Vb, Ua, Vb).\n            if (hasDoubleTexCoords) {\n                cursor.seek(8)\n            }\n\n            // User flags start at the third vertex because they are per-triangle.\n            if (j >= 2) {\n                cursor.seek(userFlagsSize)\n            }\n\n            vertices.add(NjMeshVertex(\n                index,\n                normal,\n                texCoords,\n            ))\n        }\n\n        strips.add(NjTriangleStrip(\n            ignoreLight,\n            ignoreSpecular,\n            ignoreAmbient,\n            useAlpha,\n            doubleSide,\n            flatShading,\n            environmentMapping,\n            clockwiseWinding,\n            hasTexCoords,\n            hasNormal,\n            textureId = null,\n            srcAlpha = null,\n            dstAlpha = null,\n            vertices,\n        ))\n    }\n\n    return strips\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.Failure\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.parseIff\nimport world.phantasmal.lib.fileFormats.parseIffHeaders\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val XVMH = 0x484d5658\nprivate const val XVRT = 0x54525658\n\nclass Xvm(\n    val textures: List<XvrTexture>,\n)\n\nclass XvrTexture(\n    val id: Int,\n    val format: Pair<Int, Int>,\n    val width: Int,\n    val height: Int,\n    val size: Int,\n    val data: Buffer,\n)\n\nfun parseXvr(cursor: Cursor): XvrTexture {\n    val format1 = cursor.int()\n    val format2 = cursor.int()\n    val id = cursor.int()\n    val width = cursor.uShort().toInt()\n    val height = cursor.uShort().toInt()\n    val size = cursor.int()\n    cursor.seek(36)\n    val data = cursor.buffer(size)\n    return XvrTexture(\n        id,\n        format = Pair(format1, format2),\n        width,\n        height,\n        size,\n        data,\n    )\n}\n\nfun isXvm(cursor: Cursor): Boolean {\n    val iffResult = parseIffHeaders(cursor, silent = true)\n    cursor.seekStart(0)\n\n    return iffResult is Success &&\n            iffResult.value.any { chunk -> chunk.type == XVMH || chunk.type == XVRT }\n}\n\nfun parseXvm(cursor: Cursor): PwResult<Xvm> {\n    val iffResult = parseIff(cursor)\n\n    if (iffResult !is Success) {\n        return iffResult as Failure\n    }\n\n    val result = PwResult.build<Xvm>(logger)\n    result.addResult(iffResult)\n    val chunks = iffResult.value\n    val headerChunk = chunks.find { it.type == XVMH }\n    val header = headerChunk?.data?.let(::parseHeader)\n\n    val textures = chunks\n        .filter { it.type == XVRT }\n        .map { parseXvr(it.data) }\n\n    if (header == null && textures.isEmpty()) {\n        result.addProblem(\n            Severity.Error,\n            \"Corrupted XVM file.\",\n            \"No header and no XVRT chunks found.\",\n        )\n\n        return result.failure()\n    }\n\n    if (header != null && header.textureCount != textures.size) {\n        result.addProblem(\n            Severity.Warning,\n            \"Corrupted XVM file.\",\n            \"Found ${textures.size} textures instead of ${header.textureCount} as defined in the header.\",\n        )\n    }\n\n    return result.success(Xvm(textures))\n}\n\nprivate class Header(\n    val textureCount: Int,\n)\n\nprivate fun parseHeader(cursor: Cursor): Header {\n    val textureCount = cursor.uShort().toInt()\n    return Header(textureCount)\n}\n","package world.phantasmal.lib.fileFormats.ninja\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.fileFormats.Vec2\nimport world.phantasmal.lib.fileFormats.Vec3\nimport world.phantasmal.lib.fileFormats.vec2Float\nimport world.phantasmal.lib.fileFormats.vec3Float\n\nprivate val logger = KotlinLogging.logger {}\n\nfun parseXjModel(cursor: Cursor): XjModel {\n    cursor.seek(4) // Flags according to QEdit, seemingly always 0.\n    val vertexInfoTableOffset = cursor.int()\n    val vertexInfoCount = cursor.int()\n    val triangleStripTableOffset = cursor.int()\n    val triangleStripCount = cursor.int()\n    val transparentTriangleStripTableOffset = cursor.int()\n    val transparentTriangleStripCount = cursor.int()\n    val collisionSpherePosition = cursor.vec3Float()\n    val collisionSphereRadius = cursor.float()\n\n    val vertices = mutableListOf<XjVertex>()\n\n    if (vertexInfoCount > 0) {\n        // TODO: parse all vertex info tables.\n        vertices.addAll(parseVertexInfoTable(cursor, vertexInfoTableOffset))\n    }\n\n    val meshes = mutableListOf<XjMesh>()\n\n    meshes.addAll(\n        parseTriangleStripTable(cursor, triangleStripTableOffset, triangleStripCount),\n    )\n\n    meshes.addAll(\n        parseTriangleStripTable(\n            cursor,\n            transparentTriangleStripTableOffset,\n            transparentTriangleStripCount,\n        ),\n    )\n\n    return XjModel(\n        vertices,\n        meshes,\n        collisionSpherePosition,\n        collisionSphereRadius,\n    )\n}\n\nprivate fun parseVertexInfoTable(cursor: Cursor, vertexInfoTableOffset: Int): List<XjVertex> {\n    cursor.seekStart(vertexInfoTableOffset)\n    val vertexType = cursor.short().toInt()\n    cursor.seek(2) // Flags?\n    val vertexTableOffset = cursor.int()\n    val vertexSize = cursor.int()\n    val vertexCount = cursor.int()\n\n    return (0 until vertexCount).map { i ->\n        cursor.seekStart(vertexTableOffset + i * vertexSize)\n\n        val position = cursor.vec3Float()\n        var normal: Vec3? = null\n        var uv: Vec2? = null\n\n        when (vertexType) {\n            2 -> {\n                normal = cursor.vec3Float()\n            }\n            3 -> {\n                normal = cursor.vec3Float()\n                uv = cursor.vec2Float()\n            }\n            4 -> {\n                // Skip 4 bytes.\n            }\n            5 -> {\n                cursor.seek(4)\n                uv = cursor.vec2Float()\n            }\n            6 -> {\n                normal = cursor.vec3Float()\n                // Skip 4 bytes.\n            }\n            7 -> {\n                normal = cursor.vec3Float()\n                uv = cursor.vec2Float()\n            }\n            else -> {\n                logger.warn { \"Unknown vertex type $vertexType with size ${vertexSize}.\" }\n            }\n        }\n\n        XjVertex(\n            position,\n            normal,\n            uv,\n        )\n    }\n}\n\nprivate fun parseTriangleStripTable(\n    cursor: Cursor,\n    triangleStripListOffset: Int,\n    triangleStripCount: Int,\n): List<XjMesh> {\n    return (0 until triangleStripCount).map { i ->\n        cursor.seekStart(triangleStripListOffset + i * 20)\n\n        val materialTableOffset = cursor.int()\n        val materialTableSize = cursor.int()\n        val indexListOffset = cursor.int()\n        val indexCount = cursor.int()\n\n        val material = parseTriangleStripMaterial(\n            cursor,\n            materialTableOffset,\n            materialTableSize,\n        )\n\n        cursor.seekStart(indexListOffset)\n        val indices = cursor.uShortArray(indexCount)\n\n        XjMesh(\n            material,\n            indices = indices.map { it.toInt() },\n        )\n    }\n}\n\nprivate fun parseTriangleStripMaterial(\n    cursor: Cursor,\n    offset: Int,\n    size: Int,\n): XjMaterial {\n    var srcAlpha: Int? = null\n    var dstAlpha: Int? = null\n    var textureId: Int? = null\n    var diffuseR: Int? = null\n    var diffuseG: Int? = null\n    var diffuseB: Int? = null\n    var diffuseA: Int? = null\n\n    for (i in 0 until size) {\n        cursor.seekStart(offset + i * 16)\n\n        when (cursor.int()) {\n            2 -> {\n                srcAlpha = cursor.int()\n                dstAlpha = cursor.int()\n            }\n            3 -> {\n                textureId = cursor.int()\n            }\n            5 -> {\n                diffuseR = cursor.uByte().toInt()\n                diffuseG = cursor.uByte().toInt()\n                diffuseB = cursor.uByte().toInt()\n                diffuseA = cursor.uByte().toInt()\n            }\n        }\n    }\n\n    return XjMaterial(\n        srcAlpha,\n        dstAlpha,\n        textureId,\n        diffuseR,\n        diffuseG,\n        diffuseB,\n        diffuseA,\n    )\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val DC_GC_OBJECT_CODE_OFFSET = 468\nprivate const val PC_OBJECT_CODE_OFFSET = 920\nprivate const val BB_OBJECT_CODE_OFFSET = 4652\n\nclass BinFile(\n    var format: BinFormat,\n    var questId: Int,\n    var language: Int,\n    var questName: String,\n    var shortDescription: String,\n    var longDescription: String,\n    val bytecode: Buffer,\n    val labelOffsets: IntArray,\n    val shopItems: UIntArray,\n)\n\nenum class BinFormat {\n    /**\n     * Dreamcast/GameCube\n     */\n    DC_GC,\n\n    /**\n     * Desktop\n     */\n    PC,\n\n    /**\n     * BlueBurst\n     */\n    BB,\n}\n\nfun parseBin(cursor: Cursor): BinFile {\n    val bytecodeOffset = cursor.int()\n    val labelOffsetTableOffset = cursor.int() // Relative offsets\n    val size = cursor.int()\n    cursor.seek(4) // Always seems to be 0xFFFFFFFF.\n\n    val format = when (bytecodeOffset) {\n        DC_GC_OBJECT_CODE_OFFSET -> BinFormat.DC_GC\n        PC_OBJECT_CODE_OFFSET -> BinFormat.PC\n        BB_OBJECT_CODE_OFFSET -> BinFormat.BB\n        else -> {\n            logger.warn {\n                \"Byte code at unexpected offset $bytecodeOffset, assuming file is a PC file.\"\n            }\n            BinFormat.PC\n        }\n    }\n\n    val questId: Int\n    val language: Int\n    val questName: String\n    val shortDescription: String\n    val longDescription: String\n\n    if (format == BinFormat.DC_GC) {\n        cursor.seek(1)\n        language = cursor.byte().toInt()\n        questId = cursor.short().toInt()\n        questName = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n        shortDescription = cursor.stringAscii(128, nullTerminated = true, dropRemaining = true)\n        longDescription = cursor.stringAscii(288, nullTerminated = true, dropRemaining = true)\n    } else {\n        if (format == BinFormat.PC) {\n            language = cursor.short().toInt()\n            questId = cursor.short().toInt()\n        } else {\n            questId = cursor.int()\n            language = cursor.int()\n        }\n\n        questName = cursor.stringUtf16(64, nullTerminated = true, dropRemaining = true)\n        shortDescription = cursor.stringUtf16(256, nullTerminated = true, dropRemaining = true)\n        longDescription = cursor.stringUtf16(576, nullTerminated = true, dropRemaining = true)\n    }\n\n    if (size != cursor.size) {\n        logger.warn { \"Value $size in bin size field does not match actual size ${cursor.size}.\" }\n    }\n\n    val shopItems = if (format == BinFormat.BB) {\n        cursor.seek(4) // Skip padding.\n        cursor.uIntArray(932)\n    } else {\n        UIntArray(0)\n    }\n\n    val labelOffsetCount = (cursor.size - labelOffsetTableOffset) / 4\n    val labelOffsets = cursor\n        .seekStart(labelOffsetTableOffset)\n        .intArray(labelOffsetCount)\n\n    val bytecode = cursor\n        .seekStart(bytecodeOffset)\n        .buffer(labelOffsetTableOffset - bytecodeOffset)\n\n    return BinFile(\n        format,\n        questId,\n        language,\n        questName,\n        shortDescription,\n        longDescription,\n        bytecode,\n        labelOffsets,\n        shopItems,\n    )\n}\n\nfun writeBin(bin: BinFile): Buffer {\n    require(bin.questName.length <= 32) {\n        \"questName can't be longer than 32 characters, was ${bin.questName.length}\"\n    }\n    require(bin.shortDescription.length <= 127) {\n        \"shortDescription can't be longer than 127 characters, was ${bin.shortDescription.length}\"\n    }\n    require(bin.longDescription.length <= 287) {\n        \"longDescription can't be longer than 287 characters, was ${bin.longDescription.length}\"\n    }\n    require(bin.shopItems.isEmpty() || bin.format == BinFormat.BB) {\n        \"shopItems is only supported in BlueBurst quests.\"\n    }\n    require(bin.shopItems.size <= 932) {\n        \"shopItems can't be larger than 932, was ${bin.shopItems.size}.\"\n    }\n\n    val bytecodeOffset = when (bin.format) {\n        BinFormat.DC_GC -> DC_GC_OBJECT_CODE_OFFSET\n        BinFormat.PC -> PC_OBJECT_CODE_OFFSET\n        BinFormat.BB -> BB_OBJECT_CODE_OFFSET\n    }\n\n    val fileSize = bytecodeOffset + bin.bytecode.size + 4 * bin.labelOffsets.size\n    val buffer = Buffer.withCapacity(fileSize)\n    val cursor = buffer.cursor()\n\n    cursor.writeInt(bytecodeOffset)\n    cursor.writeInt(bytecodeOffset + bin.bytecode.size) // Label table offset.\n    cursor.writeInt(fileSize)\n    cursor.writeInt(-1)\n\n    if (bin.format == BinFormat.DC_GC) {\n        cursor.writeByte(0)\n        cursor.writeByte(bin.language.toByte())\n        cursor.writeShort(bin.questId.toShort())\n        cursor.writeStringAscii(bin.questName, 32)\n        cursor.writeStringAscii(bin.shortDescription, 128)\n        cursor.writeStringAscii(bin.longDescription, 288)\n    } else {\n        if (bin.format == BinFormat.PC) {\n            cursor.writeShort(bin.language.toShort())\n            cursor.writeShort(bin.questId.toShort())\n        } else {\n            cursor.writeInt(bin.questId)\n            cursor.writeInt(bin.language)\n        }\n\n        cursor.writeStringUtf16(bin.questName, 64)\n        cursor.writeStringUtf16(bin.shortDescription, 256)\n        cursor.writeStringUtf16(bin.longDescription, 576)\n    }\n\n    if (bin.format == BinFormat.BB) {\n        cursor.writeInt(0)\n        cursor.writeUIntArray(bin.shopItems)\n\n        repeat(932 - bin.shopItems.size) {\n            cursor.writeUInt(0u)\n        }\n    }\n\n    check(cursor.position == bytecodeOffset) {\n        \"Expected to write $bytecodeOffset bytes before bytecode, but wrote ${cursor.position}.\"\n    }\n\n    cursor.writeCursor(bin.bytecode.cursor())\n\n    cursor.writeIntArray(bin.labelOffsets)\n\n    check(cursor.position == fileSize) {\n        \"Expected to write $fileSize bytes, but wrote ${cursor.position}.\"\n    }\n\n    return buffer\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.asm.*\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getRegisterValue\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getStackValue\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.BufferCursor\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val MAX_TOTAL_NOPS = 20\nprivate const val MAX_SEQUENTIAL_NOPS = 10\nprivate const val MAX_UNKNOWN_OPCODE_RATIO = 0.2\nprivate const val MAX_STACK_POP_WITHOUT_PRECEDING_PUSH_RATIO = 0.2\nprivate const val MAX_UNKNOWN_LABEL_RATIO = 0.2\n\nval SEGMENT_PRIORITY = mapOf(\n    SegmentType.Instructions to 2,\n    SegmentType.String to 1,\n    SegmentType.Data to 0,\n)\n\n/**\n * These functions are built into the client and can optionally be overridden on BB. Other versions\n * require you to always specify them in the script.\n */\nval BUILTIN_FUNCTIONS = setOf(\n    60,\n    70,\n    80,\n    90,\n    100,\n    110,\n    120,\n    130,\n    140,\n    800,\n    810,\n    820,\n    830,\n    840,\n    850,\n    860,\n    900,\n    910,\n    920,\n    930,\n    940,\n    950,\n    960,\n)\n\n/**\n * Parses bytecode into bytecode IR.\n */\nfun parseBytecode(\n    bytecode: Buffer,\n    labelOffsets: IntArray,\n    entryLabels: Set<Int>,\n    dcGcFormat: Boolean,\n    lenient: Boolean,\n): PwResult<BytecodeIr> {\n    val cursor = BufferCursor(bytecode)\n    val labelHolder = LabelHolder(labelOffsets)\n    val result = PwResult.build<BytecodeIr>(logger)\n    val offsetToSegment = mutableMapOf<Int, Segment>()\n\n    findAndParseSegments(\n        cursor,\n        labelHolder,\n        entryLabels.associateWith { SegmentType.Instructions },\n        offsetToSegment,\n        lenient,\n        dcGcFormat,\n    )\n\n    val segments: MutableList<Segment> = mutableListOf()\n\n    // Put segments in an array and try to parse leftover segments as instructions segments. When a\n    // segment can't be parsed as instructions, fall back to parsing it as a data segment.\n    var offset = 0\n\n    while (offset < cursor.size) {\n        var segment: Segment? = offsetToSegment[offset]\n\n        // If we have a segment, add it. Otherwise create a new data segment.\n        if (segment == null) {\n            val labels = labelHolder.getLabels(offset)\n            var endOffset: Int\n\n            if (labels == null) {\n                endOffset = cursor.size\n\n                for (label in labelHolder.labels) {\n                    if (label.offset > offset) {\n                        endOffset = label.offset\n                        break\n                    }\n                }\n            } else {\n                val info = labelHolder.getInfo(labels[0])!!\n                endOffset = info.next?.offset ?: cursor.size\n            }\n\n            cursor.seekStart(offset)\n\n            val isInstructionsSegment = tryParseInstructionsSegment(\n                offsetToSegment,\n                labelHolder,\n                cursor,\n                endOffset,\n                labels?.toMutableList() ?: mutableListOf(),\n                dcGcFormat,\n            )\n\n            if (!isInstructionsSegment) {\n                cursor.seekStart(offset)\n\n                parseDataSegment(\n                    offsetToSegment,\n                    cursor,\n                    endOffset,\n                    labels?.toMutableList() ?: mutableListOf()\n                )\n            }\n\n            segment = offsetToSegment[offset]\n\n            check(endOffset > offset) {\n                \"Next offset $endOffset was smaller than or equal to current offset ${offset}.\"\n            }\n            checkNotNull(segment) { \"Couldn't create segment for offset ${offset}.\" }\n        }\n\n        segments.add(segment)\n\n        offset += segment.size(dcGcFormat)\n    }\n\n    // Add unreferenced labels to their segment.\n    for ((label, labelOffset) in labelHolder.labels) {\n        val segment = offsetToSegment[labelOffset]\n\n        if (segment == null) {\n            result.addProblem(\n                Severity.Warning,\n                \"Label $label doesn't point to anything.\",\n                \"Label $label with offset $labelOffset doesn't point to anything.\",\n            )\n        } else {\n            if (label !in segment.labels) {\n                segment.labels.add(label)\n                segment.labels.sort()\n            }\n        }\n    }\n\n    // Sanity check parsed byte code.\n    if (cursor.size != offset) {\n        result.addProblem(\n            Severity.Error,\n            \"The script code is corrupt.\",\n            \"Expected to parse ${cursor.size} bytes but parsed $offset instead.\",\n        )\n\n        if (!lenient) {\n            return result.failure()\n        }\n    }\n\n    return result.success(BytecodeIr(segments))\n}\n\nprivate fun findAndParseSegments(\n    cursor: Cursor,\n    labelHolder: LabelHolder,\n    labels: Map<Int, SegmentType>,\n    offsetToSegment: MutableMap<Int, Segment>,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    var newLabels = labels\n    var startSegmentCount: Int\n    // Instruction segments which we've been able to fully analyze for label references so far.\n    val analyzedSegments = mutableSetOf<InstructionSegment>()\n\n    // Iteratively parse segments from label references.\n    do {\n        startSegmentCount = offsetToSegment.size\n\n        // Parse segments of which the type is known.\n        for ((label, type) in newLabels) {\n            parseSegment(offsetToSegment, labelHolder, cursor, label, type, lenient, dcGcFormat)\n        }\n\n        // Find label references.\n        val sortedSegments = offsetToSegment.entries\n            .filter { (_, s) -> s is InstructionSegment }\n            .sortedBy { it.key }\n            .map { (_, s) -> s as InstructionSegment }\n\n        val cfg = ControlFlowGraph.create(sortedSegments)\n\n        newLabels = mutableMapOf()\n\n        for (segment in sortedSegments) {\n            if (segment in analyzedSegments) continue\n\n            var foundAllLabels = true\n\n            for (instructionIdx in segment.instructions.indices) {\n                val instruction = segment.instructions[instructionIdx]\n                var i = 0\n\n                while (i < instruction.opcode.params.size) {\n                    val param = instruction.opcode.params[i]\n\n                    when (param.type) {\n                        is ILabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.Instructions,\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is ILabelVarType -> {\n                            // Never on the stack.\n                            // Eat all remaining arguments.\n                            while (i < instruction.args.size) {\n                                newLabels[instruction.args[i].value as Int] =\n                                    SegmentType.Instructions\n                                i++\n                            }\n                        }\n\n                        is DLabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.Data\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is SLabelType -> {\n                            if (!getArgLabelValues(\n                                    cfg,\n                                    newLabels,\n                                    segment,\n                                    instructionIdx,\n                                    i,\n                                    SegmentType.String\n                                )\n                            ) {\n                                foundAllLabels = false\n                            }\n                        }\n\n                        is RegRefType -> if (param.type.registers != null) {\n                            for (j in param.type.registers.indices) {\n                                val registerParam = param.type.registers[j]\n\n                                // Never on the stack.\n                                if (registerParam.type is ILabelType) {\n                                    val firstRegister = instruction.args[0].value as Int\n                                    val labelValues = getRegisterValue(\n                                        cfg,\n                                        instruction,\n                                        firstRegister + j,\n                                    )\n\n                                    if (labelValues.size <= 20) {\n                                        for (label in labelValues) {\n                                            newLabels[label] = SegmentType.Instructions\n                                        }\n                                    } else {\n                                        foundAllLabels = false\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    i++\n                }\n            }\n\n            if (foundAllLabels) {\n                analyzedSegments.add(segment)\n            }\n        }\n    } while (offsetToSegment.size > startSegmentCount)\n}\n\n/**\n * Returns immediate arguments or stack arguments.\n */\nprivate fun getArgLabelValues(\n    cfg: ControlFlowGraph,\n    labels: MutableMap<Int, SegmentType>,\n    instructionSegment: InstructionSegment,\n    instructionIdx: Int,\n    paramIdx: Int,\n    segmentType: SegmentType,\n): Boolean {\n    val instruction = instructionSegment.instructions[instructionIdx]\n\n    if (instruction.opcode.stack === StackInteraction.Pop) {\n        val stackValues = getStackValue(\n            cfg,\n            instruction,\n            instruction.opcode.params.size - paramIdx - 1,\n        )\n\n        if (stackValues.size <= 20) {\n            for (value in stackValues) {\n                val oldType = labels[value]\n\n                if (\n                    oldType == null ||\n                    SEGMENT_PRIORITY.getValue(segmentType) > SEGMENT_PRIORITY.getValue(oldType)\n                ) {\n                    labels[value] = segmentType\n                }\n            }\n\n            return true\n        }\n    } else {\n        val value = instruction.args[paramIdx].value as Int\n        val oldType = labels[value]\n\n        if (\n            oldType == null ||\n            SEGMENT_PRIORITY.getValue(segmentType) > SEGMENT_PRIORITY.getValue(oldType)\n        ) {\n            labels[value] = segmentType\n        }\n\n        return true\n    }\n\n    return false\n}\n\nprivate fun parseSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    label: Int,\n    type: SegmentType,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    try {\n        val info = labelHolder.getInfo(label)\n\n        if (info == null) {\n            if (label !in BUILTIN_FUNCTIONS) {\n                logger.warn { \"Label $label is not registered in the label table.\" }\n            }\n\n            return\n        }\n\n        // Check whether we've already parsed this segment and reparse it if necessary.\n        val segment = offsetToSegment[info.offset]\n\n        val labels: MutableList<Int> =\n            if (segment == null) {\n                mutableListOf(label)\n            } else {\n                if (label !in segment.labels) {\n                    segment.labels.add(label)\n                    segment.labels.sort()\n                }\n\n                if (SEGMENT_PRIORITY.getValue(type) > SEGMENT_PRIORITY.getValue(segment.type)) {\n                    segment.labels\n                } else {\n                    return\n                }\n            }\n\n        val endOffset = info.next?.offset ?: cursor.size\n        cursor.seekStart(info.offset)\n\n        return when (type) {\n            SegmentType.Instructions ->\n                parseInstructionsSegment(\n                    offsetToSegment,\n                    labelHolder,\n                    cursor,\n                    endOffset,\n                    labels,\n                    info.next?.label,\n                    lenient,\n                    dcGcFormat,\n                )\n\n            SegmentType.Data ->\n                parseDataSegment(offsetToSegment, cursor, endOffset, labels)\n\n            SegmentType.String ->\n                parseStringSegment(offsetToSegment, cursor, endOffset, labels, dcGcFormat)\n        }\n    } catch (e: Exception) {\n        if (lenient) {\n            logger.error(e) { \"Couldn't fully parse byte code segment.\" }\n        } else {\n            throw e\n        }\n    }\n}\n\nprivate fun parseInstructionsSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    nextLabel: Int?,\n    lenient: Boolean,\n    dcGcFormat: Boolean,\n) {\n    val instructions = mutableListOf<Instruction>()\n\n    val segment = InstructionSegment(\n        labels,\n        instructions,\n        SegmentSrcLoc()\n    )\n    offsetToSegment[cursor.position] = segment\n\n    while (cursor.position < endOffset) {\n        // Parse the opcode.\n        val mainOpcode = cursor.uByte()\n\n        val fullOpcode = when (mainOpcode.toInt()) {\n            0xF8, 0xF9 -> ((mainOpcode.toInt() shl 8) or cursor.uByte().toInt())\n            else -> mainOpcode.toInt()\n        }\n\n        val opcode = codeToOpcode(fullOpcode)\n\n        // Parse the arguments.\n        try {\n            val args = parseInstructionArguments(cursor, opcode, dcGcFormat)\n            instructions.add(Instruction(opcode, args, srcLoc = null))\n        } catch (e: Exception) {\n            if (lenient) {\n                logger.error(e) {\n                    \"Exception occurred while parsing arguments for instruction ${opcode.mnemonic}.\"\n                }\n                instructions.add(Instruction(opcode, emptyList(), srcLoc = null))\n            } else {\n                throw e\n            }\n        }\n    }\n\n    // Recurse on label drop-through.\n    if (nextLabel != null) {\n        // Find the last ret or jmp.\n        var dropThrough = true\n\n        for (i in instructions.lastIndex downTo 0) {\n            val opcode = instructions[i].opcode.code\n\n            if (opcode == OP_RET.code || opcode == OP_JMP.code) {\n                dropThrough = false\n                break\n            }\n        }\n\n        if (dropThrough) {\n            parseSegment(\n                offsetToSegment,\n                labelHolder,\n                cursor,\n                nextLabel,\n                SegmentType.Instructions,\n                lenient,\n                dcGcFormat,\n            )\n        }\n    }\n}\n\nprivate fun parseDataSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n) {\n    val startOffset = cursor.position\n    val segment = DataSegment(\n        labels,\n        cursor.buffer(endOffset - startOffset),\n        SegmentSrcLoc(),\n    )\n    offsetToSegment[startOffset] = segment\n}\n\nprivate fun parseStringSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    dcGcFormat: Boolean,\n) {\n    val startOffset = cursor.position\n    val byteLength = endOffset - startOffset\n    val segment = StringSegment(\n        labels,\n        if (dcGcFormat) {\n            cursor.stringAscii(\n                byteLength,\n                nullTerminated = true,\n                dropRemaining = true\n            )\n        } else {\n            cursor.stringUtf16(\n                byteLength,\n                nullTerminated = true,\n                dropRemaining = true\n            )\n        },\n        byteLength,\n        SegmentSrcLoc()\n    )\n    offsetToSegment[startOffset] = segment\n}\n\nprivate fun parseInstructionArguments(\n    cursor: Cursor,\n    opcode: Opcode,\n    dcGcFormat: Boolean,\n): List<Arg> {\n    val args = mutableListOf<Arg>()\n\n    if (opcode.stack != StackInteraction.Pop) {\n        var varargCount = 0\n\n        for (param in opcode.params) {\n            when (param.type) {\n                is ByteType ->\n                    args.add(Arg(cursor.uByte().toInt()))\n\n                is ShortType ->\n                    args.add(Arg(cursor.uShort().toInt()))\n\n                is IntType ->\n                    args.add(Arg(cursor.int()))\n\n                is FloatType ->\n                    args.add(Arg(cursor.float()))\n\n                // Ensure this case is before the LabelType case because ILabelVarType extends\n                // LabelType.\n                is ILabelVarType -> {\n                    varargCount++\n                    val argSize = cursor.uByte()\n                    args.addAll(cursor.uShortArray(argSize.toInt()).map { Arg(it.toInt()) })\n                }\n\n                is LabelType -> {\n                    args.add(Arg(cursor.uShort().toInt()))\n                }\n\n                is StringType -> {\n                    val maxBytes = min(4096, cursor.bytesLeft)\n                    args.add(\n                        Arg(\n                            if (dcGcFormat) {\n                                cursor.stringAscii(\n                                    maxBytes,\n                                    nullTerminated = true,\n                                    dropRemaining = false\n                                )\n                            } else {\n                                cursor.stringUtf16(\n                                    maxBytes,\n                                    nullTerminated = true,\n                                    dropRemaining = false\n                                )\n                            },\n                        )\n                    )\n                }\n\n                is RegRefType -> {\n                    args.add(Arg(cursor.uByte().toInt()))\n                }\n\n                is RegRefVarType -> {\n                    varargCount++\n                    val argSize = cursor.uByte()\n                    args.addAll(cursor.uByteArray(argSize.toInt()).map { Arg(it.toInt()) })\n                }\n\n                else -> error(\"Parameter type ${param.type} not implemented.\")\n            }\n        }\n\n        val minExpectedArgs = opcode.params.size - varargCount\n\n        check(args.size >= minExpectedArgs) {\n            \"Expected to parse at least $minExpectedArgs, only parsed ${args.size}.\"\n        }\n    }\n\n    return args\n}\n\nprivate fun tryParseInstructionsSegment(\n    offsetToSegment: MutableMap<Int, Segment>,\n    labelHolder: LabelHolder,\n    cursor: Cursor,\n    endOffset: Int,\n    labels: MutableList<Int>,\n    dcGcFormat: Boolean,\n): Boolean {\n    val offset = cursor.position\n\n    fun logReason(reason: String, t: Throwable? = null) {\n        logger.trace(t) {\n            buildString {\n                append(\"Determined that segment \")\n\n                if (labels.isEmpty()) {\n                    append(\"without label\")\n                } else {\n                    if (labels.size == 1) append(\"with label \")\n                    else append(\"with labels \")\n\n                    labels.joinTo(this)\n                }\n\n                append(\" at offset \")\n                append(offset)\n                append(\" is not an instructions segment because \")\n                append(reason)\n                append(\".\")\n            }\n        }\n    }\n\n    try {\n        parseInstructionsSegment(\n            offsetToSegment,\n            labelHolder,\n            cursor,\n            endOffset,\n            labels,\n            nextLabel = null,\n            lenient = false,\n            dcGcFormat,\n        )\n\n        val segment = offsetToSegment[offset]\n        val instructions = (segment as InstructionSegment).instructions\n\n        // Heuristically try to detect whether the segment is actually a data segment.\n        var prevOpcode: Opcode? = null\n        var totalNopCount = 0\n        var sequentialNopCount = 0\n        var unknownOpcodeCount = 0\n        var stackPopCount = 0\n        var stackPopWithoutPrecedingPushCount = 0\n        var labelCount = 0\n        var unknownLabelCount = 0\n\n        for (inst in instructions) {\n            if (inst.opcode.code == OP_NOP.code) {\n                if (++totalNopCount > MAX_TOTAL_NOPS) {\n                    logReason(\"it has more than $MAX_TOTAL_NOPS nop instructions\")\n                    return false\n                }\n\n                if (++sequentialNopCount > MAX_SEQUENTIAL_NOPS) {\n                    logReason(\"it has more than $MAX_SEQUENTIAL_NOPS sequential nop instructions\")\n                    return false\n                }\n            } else {\n                sequentialNopCount = 0\n            }\n\n            if (!inst.opcode.known) {\n                unknownOpcodeCount++\n            }\n\n            if (inst.opcode.stack == StackInteraction.Pop) {\n                stackPopCount++\n\n                if (prevOpcode?.stack != StackInteraction.Push) {\n                    stackPopWithoutPrecedingPushCount++\n                }\n            }\n\n            for ((index, param) in inst.opcode.params.withIndex()) {\n                if (index >= inst.args.size) break\n\n                if (param.type is LabelType) {\n                    for (arg in inst.getArgs(index)) {\n                        labelCount++\n\n                        if (!labelHolder.hasLabel(arg.value as Int)) {\n                            unknownLabelCount++\n                        }\n                    }\n                }\n            }\n\n            prevOpcode = inst.opcode\n        }\n\n        val unknownLabelRatio = unknownLabelCount.toDouble() / labelCount\n\n        if (unknownLabelRatio > MAX_UNKNOWN_LABEL_RATIO) {\n            logReason(\n                \"${100 * unknownLabelRatio}% of its label references are to nonexistent labels\"\n            )\n            return false\n        }\n\n        val stackPopWithoutPrecedingPushRatio =\n            stackPopWithoutPrecedingPushCount.toDouble() / stackPopCount\n\n        if (stackPopWithoutPrecedingPushRatio > MAX_STACK_POP_WITHOUT_PRECEDING_PUSH_RATIO) {\n            logReason(\n                \"${100 * stackPopWithoutPrecedingPushRatio}% of its stack pop instructions don't have a preceding push instruction\"\n            )\n            return false\n        }\n\n        val unknownOpcodeRatio = unknownOpcodeCount.toDouble() / instructions.size\n\n        if (unknownOpcodeRatio > MAX_UNKNOWN_OPCODE_RATIO) {\n            logReason(\"${100 * unknownOpcodeRatio}% of its opcodes are unknown\")\n            return false\n        }\n\n        return true\n    } catch (e: Exception) {\n        logReason(\"parsing it resulted in an exception\", e)\n        return false\n    }\n}\n\nfun writeBytecode(bytecodeIr: BytecodeIr, dcGcFormat: Boolean): BytecodeAndLabelOffsets {\n    val buffer = Buffer.withCapacity(100 * bytecodeIr.segments.size, Endianness.Little)\n    val cursor = buffer.cursor()\n    // Keep track of label offsets.\n    val largestLabel = bytecodeIr.segments.asSequence().flatMap { it.labels }.maxOrNull() ?: -1\n    val labelOffsets = IntArray(largestLabel + 1) { -1 }\n\n    for (segment in bytecodeIr.segments) {\n        for (label in segment.labels) {\n            labelOffsets[label] = cursor.position\n        }\n\n        when (segment) {\n            is InstructionSegment -> {\n                for (instruction in segment.instructions) {\n                    val opcode = instruction.opcode\n\n                    if (opcode.size == 2) {\n                        cursor.writeByte((opcode.code ushr 8).toByte())\n                    }\n\n                    cursor.writeByte(opcode.code.toByte())\n\n                    if (opcode.stack != StackInteraction.Pop) {\n                        for (i in opcode.params.indices) {\n                            val param = opcode.params[i]\n                            val args = instruction.getArgs(i)\n                            val arg = args.firstOrNull()\n\n                            if (arg == null) {\n                                logger.warn {\n                                    \"No argument passed to ${opcode.mnemonic} for parameter ${i + 1}.\"\n                                }\n                                continue\n                            }\n\n                            when (param.type) {\n                                ByteType -> cursor.writeByte((arg.value as Int).toByte())\n                                ShortType -> cursor.writeShort((arg.value as Int).toShort())\n                                IntType -> cursor.writeInt(arg.value as Int)\n                                FloatType -> cursor.writeFloat(arg.value as Float)\n                                // Ensure this case is before the LabelType case because\n                                // ILabelVarType extends LabelType.\n                                ILabelVarType -> {\n                                    cursor.writeByte(args.size.toByte())\n\n                                    for (a in args) {\n                                        cursor.writeShort((a.value as Int).toShort())\n                                    }\n                                }\n                                is LabelType -> cursor.writeShort((arg.value as Int).toShort())\n                                StringType -> {\n                                    val str = arg.value as String\n\n                                    if (dcGcFormat) cursor.writeStringAscii(str, str.length + 1)\n                                    else cursor.writeStringUtf16(str, 2 * str.length + 2)\n                                }\n                                is RegRefType -> {\n                                    cursor.writeByte((arg.value as Int).toByte())\n                                }\n                                RegRefVarType -> {\n                                    cursor.writeByte(args.size.toByte())\n\n                                    for (a in args) {\n                                        cursor.writeByte((a.value as Int).toByte())\n                                    }\n                                }\n                                else -> error(\n                                    \"Parameter type ${param.type::class.simpleName} not supported.\"\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n\n            is StringSegment -> {\n                // String segments should be multiples of 4 bytes.\n                if (dcGcFormat) {\n                    cursor.writeStringAscii(segment.value, segment.size(dcGcFormat))\n                } else {\n                    cursor.writeStringUtf16(segment.value, segment.size(dcGcFormat))\n                }\n            }\n\n            is DataSegment -> {\n                cursor.writeCursor(segment.data.cursor())\n            }\n        }\n    }\n\n    return BytecodeAndLabelOffsets(buffer, labelOffsets)\n}\n\nclass BytecodeAndLabelOffsets(\n    val bytecode: Buffer,\n    val labelOffsets: IntArray,\n) {\n    operator fun component1(): Buffer = bytecode\n    operator fun component2(): IntArray = labelOffsets\n}\n\nprivate data class LabelAndOffset(val label: Int, val offset: Int)\nprivate data class OffsetAndIndex(val offset: Int, val index: Int)\nprivate class LabelInfo(val offset: Int, val next: LabelAndOffset?)\n\nprivate class LabelHolder(labelOffsets: IntArray) {\n    /**\n     * Mapping of labels to their offset and index into [labels].\n     */\n    private val labelMap: MutableMap<Int, OffsetAndIndex> = mutableMapOf()\n\n    /**\n     * Mapping of offsets to lists of labels.\n     */\n    private val offsetMap: MutableMap<Int, MutableList<Int>> = mutableMapOf()\n\n    /**\n     * Labels and their offset sorted by offset and then label.\n     */\n    val labels: List<LabelAndOffset>\n\n    init {\n        val labels = mutableListOf<LabelAndOffset>()\n\n        // Populate the main label list.\n        for (label in labelOffsets.indices) {\n            val offset = labelOffsets[label]\n\n            if (offset != -1) {\n                labels.add(LabelAndOffset(label, offset))\n            }\n        }\n\n        // Sort by offset, then label.\n        labels.sortWith { a, b ->\n            if (a.offset - b.offset != 0) a.offset - b.offset\n            else a.label - b.label\n        }\n\n        this.labels = labels\n\n        // Populate the label and offset maps.\n        for (index in 0 until labels.size) {\n            val (label, offset) = labels[index]\n\n            labelMap[label] = OffsetAndIndex(offset, index)\n\n            offsetMap.getOrPut(offset) { mutableListOf() }.add(label)\n        }\n    }\n\n    fun hasLabel(label: Int): Boolean = label in labelMap\n\n    fun getLabels(offset: Int): List<Int>? = offsetMap[offset]\n\n    fun getInfo(label: Int): LabelInfo? {\n        val offsetAndIndex = labelMap[label] ?: return null\n\n        // Find the next label with a different offset.\n        var next: LabelAndOffset? = null\n\n        for (i in offsetAndIndex.index + 1 until labels.size) {\n            next = labels[i]\n\n            // Skip the label if it points to the same offset.\n            if (next.offset > offsetAndIndex.offset) {\n                break\n            } else {\n                next = null\n            }\n        }\n\n        return LabelInfo(offsetAndIndex.offset, next)\n    }\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.WritableCursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.max\n\nprivate val logger = KotlinLogging.logger {}\n\nprivate const val EVENT_ACTION_SPAWN_NPCS: Byte = 0x8\nprivate const val EVENT_ACTION_UNLOCK: Byte = 0xA\nprivate const val EVENT_ACTION_LOCK: Byte = 0xB\nprivate const val EVENT_ACTION_TRIGGER_EVENT: Byte = 0xC\n\nconst val OBJECT_BYTE_SIZE = 68\nconst val NPC_BYTE_SIZE = 72\n\nclass DatFile(\n    val objs: MutableList<DatEntity>,\n    val npcs: MutableList<DatEntity>,\n    val events: MutableList<DatEvent>,\n    val unknowns: MutableList<DatUnknown>,\n)\n\nclass DatEntity(\n    var areaId: Int,\n    val data: Buffer,\n)\n\nclass DatEvent(\n    var id: Int,\n    var sectionId: Short,\n    var wave: Short,\n    var delay: Short,\n    val actions: MutableList<DatEventAction>,\n    var areaId: Int,\n    var unknown: Short,\n)\n\nsealed class DatEventAction {\n    class SpawnNpcs(\n        var sectionId: Short,\n        var appearFlag: Short,\n    ) : DatEventAction()\n\n    class Unlock(\n        var doorId: Short,\n    ) : DatEventAction()\n\n    class Lock(\n        var doorId: Short,\n    ) : DatEventAction()\n\n    class TriggerEvent(\n        var eventId: Int,\n    ) : DatEventAction()\n}\n\nclass DatUnknown(\n    var entityType: Int,\n    var totalSize: Int,\n    var areaId: Int,\n    var entitiesSize: Int,\n    val data: ByteArray,\n)\n\nfun parseDat(cursor: Cursor): DatFile {\n    val objs = mutableListOf<DatEntity>()\n    val npcs = mutableListOf<DatEntity>()\n    val events = mutableListOf<DatEvent>()\n    val unknowns = mutableListOf<DatUnknown>()\n\n    while (cursor.hasBytesLeft()) {\n        val entityType = cursor.int()\n        val totalSize = cursor.int()\n        val areaId = cursor.int()\n        val entitiesSize = cursor.int()\n\n        if (entityType == 0) {\n            break\n        } else {\n            require(entitiesSize == totalSize - 16) {\n                \"Malformed DAT file. Expected an entities size of ${totalSize - 16}, got ${entitiesSize}.\"\n            }\n\n            val entitiesCursor = cursor.take(entitiesSize)\n\n            when (entityType) {\n                1 -> parseEntities(entitiesCursor, areaId, objs, OBJECT_BYTE_SIZE)\n                2 -> parseEntities(entitiesCursor, areaId, npcs, NPC_BYTE_SIZE)\n                3 -> parseEvents(entitiesCursor, areaId, events)\n                else -> {\n                    // Unknown entity types 4 and 5 (challenge mode).\n                    unknowns.add(DatUnknown(\n                        entityType,\n                        totalSize,\n                        areaId,\n                        entitiesSize,\n                        data = cursor.byteArray(entitiesSize),\n                    ))\n                }\n            }\n\n            if (entitiesCursor.hasBytesLeft()) {\n                logger.warn {\n                    \"Read ${entitiesCursor.position} bytes instead of expected ${entitiesCursor.size} for entity type ${entityType}.\"\n                }\n            }\n        }\n    }\n\n    return DatFile(\n        objs,\n        npcs,\n        events,\n        unknowns\n    )\n}\n\nprivate fun parseEntities(\n    cursor: Cursor,\n    areaId: Int,\n    entities: MutableList<DatEntity>,\n    entitySize: Int,\n) {\n    val entityCount = cursor.size / entitySize\n\n    repeat(entityCount) {\n        entities.add(DatEntity(\n            areaId,\n            data = cursor.buffer(entitySize),\n        ))\n    }\n}\n\nprivate fun parseEvents(cursor: Cursor, areaId: Int, events: MutableList<DatEvent>) {\n    val actionsOffset = cursor.int()\n    cursor.seek(4) // Always 0x10\n    val eventCount = cursor.int()\n    cursor.seek(3) // Always 0\n    val eventType = cursor.byte()\n\n    require(eventType.toInt() != 0x32) {\n        \"Can't parse challenge mode quests yet.\"\n    }\n\n    cursor.seekStart(actionsOffset)\n    val actionsCursor = cursor.take(cursor.bytesLeft)\n    cursor.seekStart(16)\n\n    repeat(eventCount) {\n        val id = cursor.int()\n        cursor.seek(4) // Always 0x100\n        val sectionId = cursor.short()\n        val wave = cursor.short()\n        val delay = cursor.short()\n        val unknown = cursor.short() // \"wavesetting\"?\n        val eventActionsOffset = cursor.int()\n\n        val actions: MutableList<DatEventAction> =\n            if (eventActionsOffset < actionsCursor.size) {\n                actionsCursor.seekStart(eventActionsOffset)\n                parseEventActions(actionsCursor)\n            } else {\n                logger.warn { \"Invalid event actions offset $eventActionsOffset for event ${id}.\" }\n                mutableListOf()\n            }\n\n        events.add(DatEvent(\n            id,\n            sectionId,\n            wave,\n            delay,\n            actions,\n            areaId,\n            unknown,\n        ))\n    }\n\n    if (cursor.position != actionsOffset) {\n        logger.warn {\n            \"Read ${cursor.position - 16} bytes of event data instead of expected ${actionsOffset - 16}.\"\n        }\n    }\n\n    var lastByte: Byte = -1\n\n    while (actionsCursor.hasBytesLeft()) {\n        lastByte = actionsCursor.byte()\n\n        if (lastByte.toInt() != -1) {\n            break\n        }\n    }\n\n    if (lastByte.toInt() != -1) {\n        actionsCursor.seek(-1)\n    }\n\n    // Make sure the cursor position represents the amount of bytes we've consumed.\n    cursor.seekStart(actionsOffset + actionsCursor.position)\n}\n\nprivate fun parseEventActions(cursor: Cursor): MutableList<DatEventAction> {\n    val actions = mutableListOf<DatEventAction>()\n\n    outer@ while (cursor.hasBytesLeft()) {\n        when (val type = cursor.byte()) {\n            (1).toByte() -> break@outer\n\n            EVENT_ACTION_SPAWN_NPCS ->\n                actions.add(DatEventAction.SpawnNpcs(\n                    sectionId = cursor.short(),\n                    appearFlag = cursor.short(),\n                ))\n\n            EVENT_ACTION_UNLOCK ->\n                actions.add(DatEventAction.Unlock(\n                    doorId = cursor.short(),\n                ))\n\n            EVENT_ACTION_LOCK ->\n                actions.add(DatEventAction.Lock(\n                    doorId = cursor.short(),\n                ))\n\n            EVENT_ACTION_TRIGGER_EVENT ->\n                actions.add(DatEventAction.TriggerEvent(\n                    eventId = cursor.int(),\n                ))\n\n            else -> {\n                logger.warn { \"Unexpected event action type ${type}.\" }\n                break@outer\n            }\n        }\n    }\n\n    return actions\n}\n\nfun writeDat(dat: DatFile): Buffer {\n    val buffer = Buffer.withCapacity(\n        dat.objs.size * (16 + OBJECT_BYTE_SIZE) +\n                dat.npcs.size * (16 + NPC_BYTE_SIZE) +\n                dat.unknowns.sumBy { it.totalSize },\n        endianness = Endianness.Little,\n    )\n    val cursor = buffer.cursor()\n\n    writeEntities(cursor, dat.objs, 1, OBJECT_BYTE_SIZE)\n    writeEntities(cursor, dat.npcs, 2, NPC_BYTE_SIZE)\n    writeEvents(cursor, dat.events)\n\n    for (unknown in dat.unknowns) {\n        cursor.writeInt(unknown.entityType)\n        cursor.writeInt(unknown.totalSize)\n        cursor.writeInt(unknown.areaId)\n        cursor.writeInt(unknown.entitiesSize)\n        cursor.writeByteArray(unknown.data)\n    }\n\n    // Final header.\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n    cursor.writeInt(0)\n\n    return buffer\n}\n\nprivate fun writeEntities(\n    cursor: WritableCursor,\n    entities: List<DatEntity>,\n    entityType: Int,\n    entitySize: Int,\n) {\n    val groupedEntities = entities.groupBy { it.areaId }\n\n    for ((areaId, areaEntities) in groupedEntities.entries) {\n        val entitiesSize = areaEntities.size * entitySize\n        cursor.writeInt(entityType)\n        cursor.writeInt(16 + entitiesSize)\n        cursor.writeInt(areaId)\n        cursor.writeInt(entitiesSize)\n        val startPos = cursor.position\n\n        for (entity in areaEntities) {\n            require(entity.data.size == entitySize) {\n                \"Malformed entity in area $areaId, data buffer was of size ${\n                    entity.data.size\n                } instead of expected $entitySize.\"\n            }\n\n            cursor.writeCursor(entity.data.cursor())\n        }\n\n        check(cursor.position == startPos + entitiesSize) {\n            \"Wrote ${\n                cursor.position - startPos\n            } bytes of entity data instead of expected $entitiesSize bytes for area $areaId.\"\n        }\n    }\n}\n\nprivate fun writeEvents(cursor: WritableCursor, events: List<DatEvent>) {\n    val groupedEvents = events.groupBy { it.areaId }\n\n    for ((areaId, areaEvents) in groupedEvents.entries) {\n        // Standard header.\n        cursor.writeInt(3) // Entity type\n        val totalSizeOffset = cursor.position\n        cursor.writeInt(0) // Placeholder for the total size.\n        cursor.writeInt(areaId)\n        val entitiesSizeOffset = cursor.position\n        cursor.writeInt(0) // Placeholder for the entities size.\n\n        // Event header.\n        val startPos = cursor.position\n        // TODO: actual event size is dependent on the event type (challenge mode).\n        // Absolute offset.\n        val actionsOffset = startPos + 16 + 20 * areaEvents.size\n        cursor.size = max(actionsOffset, cursor.size)\n\n        cursor.writeInt(actionsOffset - startPos)\n        cursor.writeInt(0x10)\n        cursor.writeInt(areaEvents.size)\n        cursor.writeInt(0) // TODO: write event type (challenge mode).\n\n        // Relative offset.\n        var eventActionsOffset = 0\n\n        for (event in areaEvents) {\n            cursor.writeInt(event.id)\n            cursor.writeInt(0x10000)\n            cursor.writeShort(event.sectionId)\n            cursor.writeShort(event.wave)\n            cursor.writeShort(event.delay)\n            cursor.writeShort(event.unknown)\n            cursor.writeInt(eventActionsOffset)\n            val nextEventPos = cursor.position\n\n            cursor.seekStart(actionsOffset + eventActionsOffset)\n\n            for (action in event.actions) {\n                when (action) {\n                    is DatEventAction.SpawnNpcs -> {\n                        cursor.writeByte(EVENT_ACTION_SPAWN_NPCS)\n                        cursor.writeShort(action.sectionId)\n                        cursor.writeShort(action.appearFlag)\n                    }\n                    is DatEventAction.Unlock -> {\n                        cursor.writeByte(EVENT_ACTION_UNLOCK)\n                        cursor.writeShort(action.doorId)\n                    }\n                    is DatEventAction.Lock -> {\n                        cursor.writeByte(EVENT_ACTION_LOCK)\n                        cursor.writeShort(action.doorId)\n                    }\n                    is DatEventAction.TriggerEvent -> {\n                        cursor.writeByte(EVENT_ACTION_TRIGGER_EVENT)\n                        cursor.writeInt(action.eventId)\n                    }\n                }\n            }\n\n            // End of event actions.\n            cursor.writeByte(1)\n\n            eventActionsOffset = cursor.position - actionsOffset\n\n            cursor.seekStart(nextEventPos)\n        }\n\n        cursor.seekStart(actionsOffset + eventActionsOffset)\n\n        while ((cursor.position - actionsOffset) % 4 != 0) {\n            cursor.writeByte(-1)\n        }\n\n        val endPos = cursor.position\n\n        cursor.seekStart(totalSizeOffset)\n        cursor.writeInt(16 + endPos - startPos)\n\n        cursor.seekStart(entitiesSizeOffset)\n        cursor.writeInt(endPos - startPos)\n\n        cursor.seekStart(endPos)\n    }\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport world.phantasmal.lib.Episode\n\nprivate val EP_AND_NAME_TO_NPC_TYPE: Map<Pair<String, Episode>, NpcType> =\n    mutableMapOf<Pair<String, Episode>, NpcType>().also { map ->\n        for (npcType in NpcType.VALUES) {\n            if (npcType.episode != null) {\n                map[Pair(npcType.simpleName, npcType.episode)] = npcType\n                map[Pair(npcType.ultimateName, npcType.episode)] = npcType\n            }\n        }\n    }\n\n/**\n * Uniquely identifies an NPC. Tries to match on [NpcType.simpleName] and [NpcType.ultimateName].\n */\nfun NpcType.Companion.fromNameAndEpisode(name: String, episode: Episode): NpcType? =\n    EP_AND_NAME_TO_NPC_TYPE[Pair(name, episode)]\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.PwResult\nimport world.phantasmal.core.Severity\nimport world.phantasmal.core.Success\nimport world.phantasmal.core.filenameBase\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.WritableCursor\nimport world.phantasmal.lib.cursor.cursor\nimport kotlin.math.ceil\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate val logger = KotlinLogging.logger {}\n\n// .qst format\nprivate const val DC_GC_PC_HEADER_SIZE = 60\nprivate const val BB_HEADER_SIZE = 88\nprivate const val ONLINE_QUEST = 0x44\nprivate const val DOWNLOAD_QUEST = 0xa6\n\n// Chunks\nprivate const val CHUNK_BODY_SIZE = 1024\nprivate const val DC_GC_PC_CHUNK_HEADER_SIZE = 20\nprivate const val DC_GC_PC_CHUNK_TRAILER_SIZE = 4\nprivate const val DC_GC_PC_CHUNK_SIZE =\n    CHUNK_BODY_SIZE + DC_GC_PC_CHUNK_HEADER_SIZE + DC_GC_PC_CHUNK_TRAILER_SIZE\nprivate const val BB_CHUNK_HEADER_SIZE = 24\nprivate const val BB_CHUNK_TRAILER_SIZE = 8\nprivate const val BB_CHUNK_SIZE = CHUNK_BODY_SIZE + BB_CHUNK_HEADER_SIZE + BB_CHUNK_TRAILER_SIZE\n\nclass QstContent(\n    val version: Version,\n    val online: Boolean,\n    val files: List<QstContainedFile>,\n)\n\nclass QstContainedFile(\n    val id: Int?,\n    val filename: String,\n    val questName: String?,\n    val data: Buffer,\n)\n\n/**\n * Low level parsing function for .qst files.\n */\nfun parseQst(cursor: Cursor): PwResult<QstContent> {\n    val result = PwResult.build<QstContent>(logger)\n\n    // A .qst file contains two headers that describe the embedded .dat and .bin files.\n    // Read headers and contained files.\n    val headers = parseHeaders(cursor)\n\n    if (headers.size < 2) {\n        return result\n            .addProblem(\n                Severity.Error,\n                \"This .qst file is corrupt.\",\n                \"Corrupt .qst file, expected at least 2 headers but only found ${headers.size}.\",\n            )\n            .failure()\n    }\n\n    var version: Version? = null\n    var online: Boolean? = null\n\n    for (header in headers) {\n        if (version != null && header.version != version) {\n            return result\n                .addProblem(\n                    Severity.Error,\n                    \"This .qst file is corrupt.\",\n                    \"Corrupt .qst file, header version ${header.version} for file ${\n                        header.filename\n                    } doesn't match the previous header's version ${version}.\",\n                )\n                .failure()\n        }\n\n        if (online != null && header.online != online) {\n            return result\n                .addProblem(\n                    Severity.Error,\n                    \"This .qst file is corrupt.\",\n                    \"Corrupt .qst file, header type ${\n                        if (header.online) \"\\\"online\\\"\" else \"\\\"download\\\"\"\n                    } for file ${header.filename} doesn't match the previous header's type ${\n                        if (online) \"\\\"online\\\"\" else \"\\\"download\\\"\"\n                    }.\",\n                )\n                .failure()\n        }\n\n        version = header.version\n        online = header.online\n    }\n\n    checkNotNull(version)\n    checkNotNull(online)\n\n    val parseFilesResult: PwResult<List<QstContainedFile>> = parseFiles(\n        cursor,\n        version,\n        headers.map { it.filename to it }.toMap()\n    )\n    result.addResult(parseFilesResult)\n\n    if (parseFilesResult !is Success) {\n        return result.failure()\n    }\n\n    return result.success(QstContent(\n        version,\n        online,\n        parseFilesResult.value\n    ))\n}\n\nprivate class QstHeader(\n    val version: Version,\n    val online: Boolean,\n    val questId: Int,\n    val name: String,\n    val filename: String,\n    val size: Int,\n)\n\nprivate fun parseHeaders(cursor: Cursor): List<QstHeader> {\n    val headers = mutableListOf<QstHeader>()\n\n    var prevQuestId: Int? = null\n    var prevFilename: String? = null\n\n    // .qst files should have two headers. Some malformed files have more, so we tried to detect at\n    // most 4 headers.\n    repeat(4) {\n        // Detect version and whether it's an online or download quest.\n        val version: Version\n        val online: Boolean\n\n        val versionA = cursor.uByte().toInt()\n        cursor.seek(1)\n        val versionB = cursor.uByte().toInt()\n        cursor.seek(-3)\n\n        if (versionA == BB_HEADER_SIZE && versionB == ONLINE_QUEST) {\n            version = Version.BB\n            online = true\n        } else if (versionA == DC_GC_PC_HEADER_SIZE && versionB == ONLINE_QUEST) {\n            version = Version.PC\n            online = true\n        } else if (versionB == DC_GC_PC_HEADER_SIZE) {\n            val pos = cursor.position\n            cursor.seek(35)\n\n            version = if (cursor.byte().toInt() == 0) {\n                Version.GC\n            } else {\n                Version.DC\n            }\n\n            cursor.seekStart(pos)\n\n            online = when (versionA) {\n                ONLINE_QUEST -> true\n                DOWNLOAD_QUEST -> false\n                else -> return@repeat\n            }\n        } else {\n            return@repeat\n        }\n\n        // Read header.\n        val headerSize: Int\n        val questId: Int\n        val name: String\n        val filename: String\n        val size: Int\n\n        when (version) {\n            Version.DC -> {\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                headerSize = cursor.uShort().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(3)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                cursor.seek(1)\n                size = cursor.int()\n            }\n\n            Version.GC -> {\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                headerSize = cursor.uShort().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(4)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n            }\n\n            Version.PC -> {\n                headerSize = cursor.uShort().toInt()\n                cursor.seek(1) // Skip online/download.\n                questId = cursor.uByte().toInt()\n                name = cursor.stringAscii(32, nullTerminated = true, dropRemaining = true)\n                cursor.seek(4)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n            }\n\n            Version.BB -> {\n                headerSize = cursor.uShort().toInt()\n                cursor.seek(2) // Skip online/download.\n                questId = cursor.uShort().toInt()\n                cursor.seek(38)\n                filename = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n                size = cursor.int()\n                name = cursor.stringAscii(24, nullTerminated = true, dropRemaining = true)\n            }\n        }\n\n        // Use some simple heuristics to figure out whether the file contains more than two headers.\n        // Some malformed .qst files have extra headers.\n        if (\n            prevQuestId != null &&\n            prevFilename != null &&\n            (questId != prevQuestId || filenameBase(filename) != filenameBase(prevFilename!!))\n        ) {\n            cursor.seek(-headerSize)\n            return@repeat\n        }\n\n        prevQuestId = questId\n        prevFilename = filename\n\n        headers.add(QstHeader(\n            version,\n            online,\n            questId,\n            name,\n            filename,\n            size,\n        ))\n    }\n\n    return headers\n}\n\nprivate class QstFileData(\n    val name: String,\n    val expectedSize: Int?,\n    val cursor: WritableCursor,\n    var chunkNos: MutableSet<Int>,\n)\n\nprivate fun parseFiles(\n    cursor: Cursor,\n    version: Version,\n    headers: Map<String, QstHeader>,\n): PwResult<List<QstContainedFile>> {\n    val result = PwResult.build<List<QstContainedFile>>(logger)\n\n    // Files are interleaved in 1048 or 1056 byte chunks, depending on the version.\n    // Each chunk has a 20 or 24 byte header, 1024 byte data segment and a 4 or 8 byte trailer.\n    val files = mutableMapOf<String, QstFileData>()\n\n    val chunkSize: Int // Size including padding, header and trailer.\n    val trailerSize: Int\n\n    when (version) {\n        Version.DC,\n        Version.GC,\n        Version.PC,\n        -> {\n            chunkSize = DC_GC_PC_CHUNK_SIZE\n            trailerSize = DC_GC_PC_CHUNK_TRAILER_SIZE\n        }\n\n        Version.BB -> {\n            chunkSize = BB_CHUNK_SIZE\n            trailerSize = BB_CHUNK_TRAILER_SIZE\n        }\n    }\n\n    while (cursor.bytesLeft >= chunkSize) {\n        val startPosition = cursor.position\n\n        // Read chunk header.\n        var chunkNo: Int\n\n        when (version) {\n            Version.DC,\n            Version.GC,\n            -> {\n                cursor.seek(1)\n                chunkNo = cursor.uByte().toInt()\n                cursor.seek(2)\n            }\n\n            Version.PC -> {\n                cursor.seek(3)\n                chunkNo = cursor.uByte().toInt()\n            }\n\n            Version.BB -> {\n                cursor.seek(4)\n                chunkNo = cursor.int()\n            }\n        }\n\n        val fileName = cursor.stringAscii(16, nullTerminated = true, dropRemaining = true)\n\n        val file = files.getOrPut(fileName) {\n            val header = headers[fileName]\n            QstFileData(\n                fileName,\n                header?.size,\n                Buffer.withCapacity(\n                    header?.size ?: (10 * CHUNK_BODY_SIZE),\n                    Endianness.Little\n                ).cursor(),\n                mutableSetOf()\n            )\n        }\n\n        if (chunkNo in file.chunkNos) {\n            result.addProblem(\n                Severity.Warning,\n                \"File chunk Int $chunkNo of file $fileName was already encountered, overwriting previous chunk.\",\n            )\n        } else {\n            file.chunkNos.add(chunkNo)\n        }\n\n        // Read file data.\n        var size = cursor.seek(CHUNK_BODY_SIZE).int()\n        cursor.seek(-CHUNK_BODY_SIZE - 4)\n\n        if (size > CHUNK_BODY_SIZE) {\n            result.addProblem(\n                Severity.Warning,\n                \"Data segment size of $size is larger than expected maximum size, reading just $CHUNK_BODY_SIZE bytes.\",\n            )\n            size = CHUNK_BODY_SIZE\n        }\n\n        val data = cursor.take(size)\n        val chunkPosition = chunkNo * CHUNK_BODY_SIZE\n        file.cursor.size = max(chunkPosition + size, file.cursor.size)\n        file.cursor.seekStart(chunkPosition).writeCursor(data)\n\n        // Skip the padding and the trailer.\n        cursor.seek(CHUNK_BODY_SIZE - data.size + trailerSize)\n\n        check(cursor.position == startPosition + chunkSize) {\n            \"Read ${\n                cursor.position - startPosition\n            } file chunk message bytes instead of expected ${chunkSize}.\"\n        }\n    }\n\n    if (cursor.hasBytesLeft()) {\n        result.addProblem(Severity.Warning, \"${cursor.bytesLeft} Bytes left in file.\")\n    }\n\n    for (file in files.values) {\n        // Clean up file properties.\n        file.cursor.seekStart(0)\n        file.chunkNos = file.chunkNos.sorted().toMutableSet()\n\n        // Check whether the expected size was correct.\n        if (file.expectedSize != null && file.cursor.size != file.expectedSize) {\n            result.addProblem(\n                Severity.Warning,\n                \"File ${file.name} has an actual size of ${\n                    file.cursor.size\n                } instead of the expected size ${file.expectedSize}.\",\n            )\n        }\n\n        // Detect missing file chunks.\n        val actualSize = max(file.cursor.size, file.expectedSize ?: 0)\n        val expectedChunkCount = ceil(actualSize.toDouble() / CHUNK_BODY_SIZE).toInt()\n\n        for (chunkNo in 0 until expectedChunkCount) {\n            if (chunkNo !in file.chunkNos) {\n                result.addProblem(\n                    Severity.Warning,\n                    \"File ${file.name} is missing chunk ${chunkNo}.\",\n                )\n            }\n        }\n    }\n\n    return result.success(\n        files.values.map { file ->\n            val header = headers[file.name]\n            QstContainedFile(\n                header?.questId,\n                file.name,\n                header?.name,\n                file.cursor.seekStart(0).buffer(),\n            )\n        }\n    )\n}\n\nfun writeQst(qst: QstContent): Buffer {\n    val fileHeaderSize: Int\n    val chunkSize: Int\n\n    when (qst.version) {\n        Version.DC, Version.GC, Version.PC -> {\n            fileHeaderSize = DC_GC_PC_HEADER_SIZE\n            chunkSize = DC_GC_PC_CHUNK_SIZE\n        }\n        Version.BB -> {\n            fileHeaderSize = BB_HEADER_SIZE\n            chunkSize = BB_CHUNK_SIZE\n        }\n    }\n\n    val totalSize = qst.files.sumOf {\n        fileHeaderSize + ceil(it.data.size.toDouble() / CHUNK_BODY_SIZE).toInt() * chunkSize\n    }\n\n    val buffer = Buffer.withCapacity(totalSize)\n    val cursor = buffer.cursor()\n\n    writeFileHeaders(cursor, qst.files, qst.version, qst.online, fileHeaderSize)\n    writeFileChunks(cursor, qst.files, qst.version)\n\n    check(cursor.position == totalSize) {\n        \"Expected a final file size of $totalSize, but got ${cursor.position}.\"\n    }\n\n    return buffer\n}\n\nprivate fun writeFileHeaders(\n    cursor: WritableCursor,\n    files: List<QstContainedFile>,\n    version: Version,\n    online: Boolean,\n    headerSize: Int,\n) {\n    val maxId: Int\n    val maxQuestNameLength: Int\n\n    if (version == Version.BB) {\n        maxId = 0xffff\n        maxQuestNameLength = 23\n    } else {\n        maxId = 0xff\n        maxQuestNameLength = 31\n    }\n\n    for (file in files) {\n        require(file.id == null || (file.id in 0..maxId)) {\n            \"Quest ID should be between 0 and $maxId, inclusive.\"\n        }\n        require(file.questName == null || file.questName.length <= maxQuestNameLength) {\n            \"File ${file.filename} has a quest name longer than $maxQuestNameLength characters (${file.questName}).\"\n        }\n        require(file.filename.length <= 15) {\n            \"File ${file.filename} has a filename longer than 15 characters.\"\n        }\n\n        when (version) {\n            Version.DC -> {\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeByte(0)\n                cursor.writeByte(0)\n                cursor.writeByte(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeByte(0)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.GC -> {\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeInt(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.PC -> {\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeUByte((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUByte())\n                cursor.writeUByte(file.id?.toUByte() ?: 0u)\n                cursor.writeStringAscii(file.questName ?: file.filename, 32)\n                cursor.writeInt(0)\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n            }\n\n            Version.BB -> {\n                cursor.writeUShort(headerSize.toUShort())\n                cursor.writeUShort((if (online) ONLINE_QUEST else DOWNLOAD_QUEST).toUShort())\n                cursor.writeUShort(file.id?.toUShort() ?: 0u)\n                repeat(38) { cursor.writeByte(0) }\n                cursor.writeStringAscii(file.filename, 16)\n                cursor.writeInt(file.data.size)\n                cursor.writeStringAscii(file.questName ?: file.filename, 24)\n            }\n        }\n    }\n}\n\nprivate class FileToChunk(\n    var no: Int,\n    val data: Cursor,\n    val name: String,\n)\n\nprivate fun writeFileChunks(\n    cursor: WritableCursor,\n    files: List<QstContainedFile>,\n    version: Version,\n) {\n    // Files are interleaved in chunks. Each chunk has a header, fixed-size data segment and a\n    // trailer.\n    val filesToChunk = files.map { file ->\n        FileToChunk(\n            no = 0,\n            data = file.data.cursor(),\n            name = file.filename,\n        )\n    }\n    var done = 0\n\n    while (done < filesToChunk.size) {\n        for (fileToChunk in filesToChunk) {\n            if (fileToChunk.data.hasBytesLeft()) {\n                if (\n                    !writeFileChunk(\n                        cursor,\n                        fileToChunk.data,\n                        fileToChunk.no++,\n                        fileToChunk.name,\n                        version,\n                    )\n                ) {\n                    done++\n                }\n            }\n        }\n    }\n\n    for (fileToChunk in filesToChunk) {\n        val expectedChunks = ceil(fileToChunk.data.size.toDouble() / CHUNK_BODY_SIZE).toInt()\n\n        check(fileToChunk.no == expectedChunks) {\n            \"\"\"Expected to write $expectedChunks chunks for file \"${\n                fileToChunk.name\n            }\" but ${fileToChunk.no} where written.\"\"\"\n        }\n    }\n}\n\n/**\n * Returns true if there are bytes left to write in [data], false otherwise.\n */\nprivate fun writeFileChunk(\n    cursor: WritableCursor,\n    data: Cursor,\n    chunkNo: Int,\n    name: String,\n    version: Version,\n): Boolean {\n    when (version) {\n        Version.DC,\n        Version.GC,\n        -> {\n            cursor.writeByte(0)\n            cursor.writeUByte(chunkNo.toUByte())\n            cursor.writeShort(0)\n        }\n\n        Version.PC -> {\n            cursor.writeByte(0)\n            cursor.writeByte(0)\n            cursor.writeByte(0)\n            cursor.writeUByte(chunkNo.toUByte())\n        }\n\n        Version.BB -> {\n            cursor.writeByte(28)\n            cursor.writeByte(4)\n            cursor.writeByte(19)\n            cursor.writeByte(0)\n            cursor.writeInt(chunkNo)\n        }\n    }\n\n    cursor.writeStringAscii(name, 16)\n\n    val size = min(CHUNK_BODY_SIZE, data.bytesLeft)\n    cursor.writeCursor(data.take(size))\n\n    // Padding.\n    repeat(CHUNK_BODY_SIZE - size) {\n        cursor.writeByte(0)\n    }\n\n    cursor.writeInt(size)\n\n    if (version == Version.BB) {\n        cursor.writeInt(0)\n    }\n\n    return data.hasBytesLeft()\n}\n","package world.phantasmal.lib.fileFormats.quest\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.*\nimport world.phantasmal.lib.Episode\nimport world.phantasmal.lib.asm.BytecodeIr\nimport world.phantasmal.lib.asm.InstructionSegment\nimport world.phantasmal.lib.asm.OP_SET_EPISODE\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getMapDesignations\nimport world.phantasmal.lib.buffer.Buffer\nimport world.phantasmal.lib.compression.prs.prsCompress\nimport world.phantasmal.lib.compression.prs.prsDecompress\nimport world.phantasmal.lib.cursor.Cursor\nimport world.phantasmal.lib.cursor.cursor\n\nprivate val logger = KotlinLogging.logger {}\n\nclass Quest(\n    var id: Int,\n    var language: Int,\n    var name: String,\n    var shortDescription: String,\n    var longDescription: String,\n    var episode: Episode,\n    val objects: MutableList<QuestObject>,\n    val npcs: MutableList<QuestNpc>,\n    val events: MutableList<DatEvent>,\n    /**\n     * (Partial) raw DAT data that can't be parsed yet by Phantasmal.\n     */\n    val datUnknowns: MutableList<DatUnknown>,\n    var bytecodeIr: BytecodeIr,\n    val shopItems: UIntArray,\n    val mapDesignations: MutableMap<Int, Int>,\n)\n\n/**\n * High level quest parsing function that delegates to [parseBin] and [parseDat].\n */\nfun parseBinDatToQuest(\n    binCursor: Cursor,\n    datCursor: Cursor,\n    lenient: Boolean = false,\n): PwResult<Quest> {\n    val result = PwResult.build<Quest>(logger)\n\n    // Decompress and parse files.\n    val binDecompressed = prsDecompress(binCursor)\n    result.addResult(binDecompressed)\n\n    if (binDecompressed !is Success) {\n        return result.failure()\n    }\n\n    val bin = parseBin(binDecompressed.value)\n\n    val datDecompressed = prsDecompress(datCursor)\n    result.addResult(datDecompressed)\n\n    if (datDecompressed !is Success) {\n        return result.failure()\n    }\n\n    val dat = parseDat(datDecompressed.value)\n    val objects = dat.objs.mapTo(mutableListOf()) { QuestObject(it.areaId, it.data) }\n    // Initialize NPCs with random episode and correct it later.\n    val npcs = dat.npcs.mapTo(mutableListOf()) { QuestNpc(Episode.I, it.areaId, it.data) }\n\n    // Extract episode and map designations from byte code.\n    var episode = Episode.I\n    var mapDesignations = mutableMapOf<Int, Int>()\n\n    val parseBytecodeResult = parseBytecode(\n        bin.bytecode,\n        bin.labelOffsets,\n        extractScriptEntryPoints(objects, npcs),\n        bin.format == BinFormat.DC_GC,\n        lenient,\n    )\n\n    result.addResult(parseBytecodeResult)\n\n    if (parseBytecodeResult !is Success) {\n        return result.failure()\n    }\n\n    val bytecodeIr = parseBytecodeResult.value\n\n    if (bytecodeIr.segments.isEmpty()) {\n        result.addProblem(Severity.Warning, \"File contains no instruction labels.\")\n    } else {\n        val instructionSegments = bytecodeIr.instructionSegments()\n\n        var label0Segment: InstructionSegment? = null\n\n        for (segment in instructionSegments) {\n            if (0 in segment.labels) {\n                label0Segment = segment\n                break\n            }\n        }\n\n        if (label0Segment != null) {\n            episode = getEpisode(result, label0Segment)\n\n            for (npc in npcs) {\n                npc.episode = episode\n            }\n\n            mapDesignations =\n                getMapDesignations(label0Segment) { ControlFlowGraph.create(bytecodeIr) }\n        } else {\n            result.addProblem(Severity.Warning, \"No instruction segment for label 0 found.\")\n        }\n    }\n\n    return result.success(Quest(\n        id = bin.questId,\n        language = bin.language,\n        name = bin.questName,\n        shortDescription = bin.shortDescription,\n        longDescription = bin.longDescription,\n        episode,\n        objects,\n        npcs,\n        events = dat.events,\n        datUnknowns = dat.unknowns,\n        bytecodeIr,\n        shopItems = bin.shopItems,\n        mapDesignations,\n    ))\n}\n\nclass QuestData(\n    val quest: Quest,\n    val version: Version,\n    val online: Boolean,\n)\n\n/**\n * High level .qst parsing function that delegates to [parseQst], [parseBin] and [parseDat].\n */\nfun parseQstToQuest(cursor: Cursor, lenient: Boolean = false): PwResult<QuestData> {\n    val result = PwResult.build<QuestData>(logger)\n\n    // Extract contained .dat and .bin files.\n    val qstResult = parseQst(cursor)\n    result.addResult(qstResult)\n\n    if (qstResult !is Success) {\n        return result.failure()\n    }\n\n    val version = qstResult.value.version\n    val online = qstResult.value.online\n    val files = qstResult.value.files\n    var datFile: QstContainedFile? = null\n    var binFile: QstContainedFile? = null\n\n    for (file in files) {\n        val fileName = file.filename.trim().toLowerCase()\n\n        if (fileName.endsWith(\".dat\")) {\n            datFile = file\n        } else if (fileName.endsWith(\".bin\")) {\n            binFile = file\n        }\n    }\n\n    if (datFile == null) {\n        return result.addProblem(Severity.Error, \"File contains no DAT file.\").failure()\n    }\n\n    if (binFile == null) {\n        return result.addProblem(Severity.Error, \"File contains no BIN file.\").failure()\n    }\n\n    val questResult = parseBinDatToQuest(\n        binFile.data.cursor(),\n        datFile.data.cursor(),\n        lenient,\n    )\n    result.addResult(questResult)\n\n    if (questResult !is Success) {\n        return result.failure()\n    }\n\n    return result.success(QuestData(\n        questResult.value,\n        version,\n        online,\n    ))\n}\n\n/**\n * Defaults to episode I.\n */\nprivate fun getEpisode(rb: PwResultBuilder<*>, func0Segment: InstructionSegment): Episode {\n    val setEpisode = func0Segment.instructions.find {\n        it.opcode == OP_SET_EPISODE\n    }\n\n    if (setEpisode == null) {\n        logger.debug { \"Function 0 has no set_episode instruction.\" }\n        return Episode.I\n    }\n\n    return when (val episode = setEpisode.args[0].value) {\n        0 -> Episode.I\n        1 -> Episode.II\n        2 -> Episode.IV\n        else -> {\n            rb.addProblem(\n                Severity.Warning,\n                \"Unknown episode $episode in function 0 set_episode instruction.\"\n            )\n            Episode.I\n        }\n    }\n}\n\nprivate fun extractScriptEntryPoints(\n    objects: List<QuestObject>,\n    npcs: List<QuestNpc>,\n): Set<Int> {\n    val entryPoints = mutableSetOf(0)\n\n    objects.forEach { obj ->\n        obj.scriptLabel?.let(entryPoints::add)\n        obj.scriptLabel2?.let(entryPoints::add)\n    }\n\n    npcs.forEach { npc ->\n        entryPoints.add(npc.scriptLabel)\n    }\n\n    return entryPoints\n}\n\n/**\n * Returns a .bin and .dat file in that order.\n */\nfun writeQuestToBinDat(quest: Quest, version: Version): Pair<Buffer, Buffer> {\n    val dat = writeDat(DatFile(\n        objs = quest.objects.mapTo(mutableListOf()) { DatEntity(it.areaId, it.data) },\n        npcs = quest.npcs.mapTo(mutableListOf()) { DatEntity(it.areaId, it.data) },\n        events = quest.events,\n        unknowns = quest.datUnknowns,\n    ))\n\n    val binFormat = when (version) {\n        Version.DC, Version.GC -> BinFormat.DC_GC\n        Version.PC -> BinFormat.PC\n        Version.BB -> BinFormat.BB\n    }\n\n    val (bytecode, labelOffsets) = writeBytecode(quest.bytecodeIr, binFormat == BinFormat.DC_GC)\n\n    val bin = writeBin(BinFile(\n        binFormat,\n        quest.id,\n        quest.language,\n        quest.name,\n        quest.shortDescription,\n        quest.longDescription,\n        bytecode,\n        labelOffsets,\n        quest.shopItems,\n    ))\n\n    return Pair(bin, dat)\n}\n\n/**\n * Creates a .qst file from [quest].\n */\nfun writeQuestToQst(quest: Quest, filename: String, version: Version, online: Boolean): Buffer {\n    val (bin, dat) = writeQuestToBinDat(quest, version)\n\n    val baseFilename = (filenameBase(filename) ?: filename).take(11)\n    val questName = quest.name.take(if (version == Version.BB) 23 else 31)\n\n    return writeQst(QstContent(\n        version,\n        online,\n        files = listOf(\n            QstContainedFile(\n                id = quest.id,\n                filename = \"$baseFilename.dat\",\n                questName = questName,\n                data = prsCompress(dat.cursor()).buffer(),\n            ),\n            QstContainedFile(\n                id = quest.id,\n                filename = \"$baseFilename.bin\",\n                questName = questName,\n                data = prsCompress(bin.cursor()).buffer(),\n            ),\n        ),\n    ))\n}\n","package world.phantasmal.lib.vm\n\nimport mu.KotlinLogging\nimport world.phantasmal.lib.Endianness\nimport world.phantasmal.lib.Episode\nimport world.phantasmal.lib.asm.*\nimport world.phantasmal.lib.buffer.Buffer\n\nprivate val logger = KotlinLogging.logger {}\n\nenum class ExecutionResult {\n    /**\n     * There are no live threads, nothing to do.\n     */\n    Suspended,\n\n    /**\n     * Execution is paused because of the [ExecutionInterceptor].\n     */\n    Paused,\n\n    /**\n     * All threads have yielded.\n     */\n    WaitingVsync,\n\n    /**\n     * Execution has halted because the VM encountered an `exit` instruction, a fatal error was\n     * raised or the VM was halted from outside.\n     */\n    Halted,\n}\n\ninterface ExecutionInterceptor {\n    /**\n     * Called before the VM executes an instruction. If false is returned, the VM won't execute the\n     * instruction and pause.\n     */\n    fun intercept(instruction: InstructionReference): Boolean\n}\n\n/**\n * This class emulates the PSO script engine. It's in charge of memory, threading and executing\n * instructions.\n */\nclass VirtualMachine {\n    // Quest Details\n\n    private var episode: Episode = Episode.I\n\n    var bytecode: BytecodeIr = BytecodeIr(emptyList())\n        private set\n\n    private val labelToSegIdx: MutableMap<Int, Int> = mutableMapOf()\n\n    // VM State\n\n    private val registers = Buffer.withSize(REGISTER_COUNT * REGISTER_SIZE, Endianness.Little)\n    private var stringArgStore = \"\"\n\n    /**\n     * All live threads.\n     */\n    private val threads: MutableList<Thread> = mutableListOf()\n\n    /**\n     * Current thread index into [threads].\n     */\n    private var threadIdx = 0\n\n    var halted = true\n        private set\n\n    var executionInterceptor: ExecutionInterceptor? = null\n\n    /**\n     * Halts and resets the VM, then loads new bytecode.\n     */\n    fun loadBytecode(bytecode: BytecodeIr, episode: Episode) {\n        halt()\n\n        logger.debug { \"Starting.\" }\n\n        this.bytecode = bytecode\n        this.episode = episode\n\n        labelToSegIdx.clear()\n\n        for ((segIdx, segment) in bytecode.segments.withIndex()) {\n            for (label in segment.labels) {\n                labelToSegIdx[label] = segIdx\n            }\n        }\n\n        halted = false\n    }\n\n    /**\n     * Executes instructions while possible.\n     */\n    fun execute(): ExecutionResult {\n        require(!halted) { \"Halted.\" }\n        require(threads.isNotEmpty()) { \"Suspended.\" }\n        require(threadIdx < threads.size) { \"Awaiting vsync.\" }\n\n        try {\n            // Limit amount of instructions executed to prevent infinite loops.\n            var executionCounter = 0\n\n            while (executionCounter++ < 10_000) {\n                // Execute the instruction pointed to by the current thread.\n                val thread = currentThread()!!\n                val instRef = thread.instructionPointer!!\n\n                if (executionInterceptor?.intercept(instRef) == false) {\n                    return ExecutionResult.Paused\n                } else {\n                    val result = executeInstruction()\n\n                    if (result != null && result != ExecutionResult.WaitingVsync) {\n                        return result\n                    }\n                }\n\n                if (threads.isEmpty()) {\n                    return ExecutionResult.Suspended\n                }\n\n                if (threadIdx > threads.lastIndex) {\n                    return ExecutionResult.WaitingVsync\n                }\n            }\n\n            // TODO: Output error \"Maximum execution count reached. The code probably contains an infinite loop.\".\n            halt()\n            return ExecutionResult.Halted\n        } catch (e: Throwable) {\n            // TODO: Output error.\n            halt()\n            return ExecutionResult.Halted\n        }\n    }\n\n    /**\n     * Signal to the VM that a vsync has happened.\n     */\n    fun vsync() {\n        if (threadIdx > threads.lastIndex) {\n            threadIdx = 0\n        }\n    }\n\n    /**\n     * Halts execution of all threads.\n     */\n    fun halt() {\n        if (!halted) {\n            logger.debug { \"Halting.\" }\n\n            registers.zero()\n            stringArgStore = \"\"\n            threads.clear()\n            threadIdx = 0\n            // TODO:\n//            window_msg_open = false\n//            set_episode_called = false\n//            list_open = false\n//            selection_reg = 0\n            halted = true\n//            paused = false\n//            breakpoints.splice(0, Infinity)\n//            unsupported_opcodes_logged.clear()\n            Thread.resetIdCounter()\n        }\n    }\n\n    private fun executeInstruction(): ExecutionResult? {\n        val thread = threads[threadIdx]\n        val inst = thread.instructionPointer!!.instruction\n        val args = inst.args.map { it.value }\n\n        var advance = true\n        var result: ExecutionResult? = null\n\n        when (inst.opcode.code) {\n            OP_NOP.code -> {\n            }\n            OP_RET.code -> {\n                popFrame(threadIdx)\n            }\n            OP_SYNC.code -> {\n                advanceInstructionPointer(threadIdx)\n                threadIdx++\n                advance = false\n                result = ExecutionResult.WaitingVsync\n            }\n            OP_EXIT.code -> {\n                halt()\n            }\n            OP_THREAD.code -> {\n                TODO()\n            }\n            OP_CALL.code -> {\n                pushFrame(thread, args[0] as Int)\n                advance = false\n            }\n            OP_JMP.code -> {\n                jumpToLabel(thread, args[0] as Int)\n                advance = false\n            }\n        }\n\n        if (advance) {\n            advanceInstructionPointer(threadIdx)\n        }\n\n        return result\n    }\n\n    /**\n     * Simply advance to the next instruction no matter what the current instruction is. I.e. this\n     * method simply advances past jumps and calls.\n     */\n    private fun advanceInstructionPointer(threadIdx: Int) {\n        val thread = threads[threadIdx]\n        require(thread.live) { \"Trying to advance the instruction pointer within a dead thread.\" }\n\n        val frame = thread.currentStackFrame()!!\n        val next = frame.instructionPointer.next()\n\n        if (next == null) {\n            // Reached EOF.\n            // Game will crash if call stack is not empty.\n            require(thread.callStack.isEmpty()) {\n                \"Reached EOF but call stack was not empty\"\n            }\n\n            thread.popFrame()\n            terminateThread(threadIdx)\n        } else {\n            frame.instructionPointer = next\n        }\n    }\n\n    private fun currentThread(): Thread? = threads.getOrNull(threadIdx)\n\n    private fun terminateThread(idx: Int) {\n        val thread = threads.removeAt(idx)\n\n        if (threadIdx >= idx && threadIdx > 0) {\n            threadIdx--\n        }\n\n        logger.debug { \"Thread #${thread.id} terminated.\" }\n    }\n\n    private fun pushFrame(thread: Thread, label: Int) {\n        val segIdx = getSegmentIndexByLabel(label)\n        val segment = bytecode.segments[segIdx]\n\n        require(segment.type == SegmentType.Instructions) {\n            \"Label $label points to a ${segment.type} segment, expecting ${\n                SegmentType.Instructions\n            }.\"\n        }\n\n        thread.pushFrame(InstructionReference(segIdx, 0, bytecode))\n    }\n\n    private fun popFrame(threadIdx: Int) {\n        val thread = threads[threadIdx]\n        thread.popFrame()\n\n        if (!thread.live) {\n            terminateThread(threadIdx)\n        }\n    }\n\n    private fun jumpToLabel(thread: Thread, label: Int) {\n        thread.currentStackFrame()!!.instructionPointer =\n            InstructionReference(getSegmentIndexByLabel(label), 0, bytecode)\n    }\n\n    private fun getSegmentIndexByLabel(label: Int): Int =\n        labelToSegIdx[label] ?: error(\"Invalid argument: No such label $label.\")\n\n    companion object {\n        private const val REGISTER_SIZE = 4\n\n        const val REGISTER_COUNT = 256\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return TimeSource.Monotonic.measureTime(block)\n}\n\n\n/**\n * Executes the given function [block] and returns the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun TimeSource.measureTime(block: () -> Unit): Duration {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    block()\n    return mark.elapsedNow()\n}\n\n\n/**\n * Data class representing a result of executing an action, along with the duration of elapsed time interval.\n *\n * @property value the result of the action.\n * @property duration the time elapsed to execute the action.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic data class TimedValue<T>(val value: T, val duration: Duration)\n\n/**\n * Executes the given function [block] and returns an instance of [TimedValue] class, containing both\n * the result of the function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with [TimeSource.Monotonic].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return TimeSource.Monotonic.measureTimedValue(block)\n}\n\n/**\n * Executes the given [block] and returns an instance of [TimedValue] class, containing both\n * the result of function execution and the duration of elapsed time interval.\n *\n * The elapsed time is measured with the specified `this` [TimeSource] instance.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic inline fun <T> TimeSource.measureTimedValue(block: () -> T): TimedValue<T> {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val mark = markNow()\n    val result = block()\n    return TimedValue(result, mark.elapsedNow())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n@Deprecated(\"Use runningReduce instead.\", ReplaceWith(\"runningReduce(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return runningReduce(operation)\n}\n\n@Deprecated(\"Use runningReduceIndexed instead.\", ReplaceWith(\"runningReduceIndexed(operation)\"), level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <S, T : S> Sequence<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return runningReduceIndexed(operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","package world.phantasmal.web.assemblyWorker\n\nimport mu.KotlinLogging\nimport world.phantasmal.core.*\nimport world.phantasmal.lib.asm.*\nimport world.phantasmal.lib.asm.dataFlowAnalysis.ControlFlowGraph\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getMapDesignations\nimport world.phantasmal.lib.asm.dataFlowAnalysis.getStackValue\nimport world.phantasmal.web.shared.Throttle\nimport world.phantasmal.web.shared.messages.*\nimport kotlin.math.min\nimport kotlin.time.measureTime\nimport world.phantasmal.lib.asm.AssemblyProblem as AssemblerAssemblyProblem\n\nprivate val logger = KotlinLogging.logger {}\n\nclass AssemblyWorker(private val sendMessage: (ServerMessage) -> Unit) {\n    private val messageQueue: MutableList<ClientMessage> = mutableListOf()\n    private val messageProcessingThrottle = Throttle(wait = 100)\n    private val tokenizer = LineTokenizer()\n\n    // User input.\n    private var inlineStackArgs: Boolean = true\n    private val asm: JsArray<String> = jsArrayOf()\n\n    // Output.\n    private var bytecodeIr = BytecodeIr(emptyList())\n    private var problems: List<AssemblyProblem>? = null\n\n    // Derived data.\n    private var _cfg: ControlFlowGraph? = null\n    private val cfg: ControlFlowGraph\n        get() {\n            if (_cfg == null) _cfg = ControlFlowGraph.create(bytecodeIr)\n            return _cfg!!\n        }\n\n    private var mapDesignations: Map<Int, Int>? = null\n\n    fun receiveMessage(message: ClientMessage) {\n        messageQueue.add(message)\n        messageProcessingThrottle(::processMessages)\n    }\n\n    private fun processMessages() {\n        // Split messages into ASM changes and other messages. Remove useless/duplicate\n        // notifications.\n        val asmChanges = mutableListOf<ClientNotification>()\n        val otherMessages = mutableListOf<ClientMessage>()\n\n        for (message in messageQueue) {\n            when (message) {\n                is ClientNotification.SetAsm -> {\n                    // All previous ASM change messages can be discarded when the entire ASM has\n                    // changed.\n                    asmChanges.clear()\n                    asmChanges.add(message)\n                }\n\n                is ClientNotification.UpdateAsm ->\n                    asmChanges.add(message)\n\n                else ->\n                    otherMessages.add(message)\n            }\n        }\n\n        messageQueue.clear()\n\n        // Process ASM changes first.\n        processAsmChanges(asmChanges)\n        otherMessages.forEach(::processMessage)\n    }\n\n    private fun processAsmChanges(messages: List<ClientNotification>) {\n        if (messages.isNotEmpty()) {\n            val time = measureTime {\n                for (message in messages) {\n                    when (message) {\n                        is ClientNotification.SetAsm ->\n                            setAsm(message.asm, message.inlineStackArgs)\n\n                        is ClientNotification.UpdateAsm ->\n                            updateAsm(message.changes)\n                    }\n                }\n\n                processAsm()\n            }\n\n            logger.trace {\n                \"Processed ${messages.size} assembly changes in ${time.inMilliseconds}ms.\"\n            }\n        }\n    }\n\n    private fun processMessage(message: ClientMessage) {\n        val time = measureTime {\n            when (message) {\n                is ClientNotification.SetAsm,\n                is ClientNotification.UpdateAsm ->\n                    logger.error { \"Unexpected ${message::class.simpleName}.\" }\n\n                is Request.GetCompletions ->\n                    getCompletions(message.id, message.lineNo, message.col)\n\n                is Request.GetSignatureHelp ->\n                    getSignatureHelp(message.id, message.lineNo, message.col)\n\n                is Request.GetHover ->\n                    getHover(message.id, message.lineNo, message.col)\n\n                is Request.GetDefinition ->\n                    getDefinition(message.id, message.lineNo, message.col)\n            }\n        }\n\n        logger.trace { \"Processed ${message::class.simpleName} in ${time.inMilliseconds}ms.\" }\n    }\n\n    private fun setAsm(asm: List<String>, inlineStackArgs: Boolean) {\n        this.inlineStackArgs = inlineStackArgs\n        this.asm.splice(0, this.asm.length, *asm.toTypedArray())\n        mapDesignations = null\n    }\n\n    private fun updateAsm(changes: List<AsmChange>) {\n        for (change in changes) {\n            val (startLineNo, startCol, endLineNo, endCol) = change.range\n            val linesChanged = endLineNo - startLineNo + 1\n            val newLines = change.newAsm.split(\"\\n\").toJsArray()\n\n            when {\n                linesChanged == 1 -> {\n                    replaceLinePart(startLineNo, startCol, endCol, newLines)\n                }\n\n                newLines.length == 1 -> {\n                    replaceLinesAndMergeLineParts(\n                        startLineNo,\n                        endLineNo,\n                        startCol,\n                        endCol,\n                        newLines[0],\n                    )\n                }\n\n                else -> {\n                    // Keep the left part of the first changed line.\n                    replaceLinePartRight(startLineNo, startCol, newLines[0])\n\n                    // Keep the right part of the last changed line.\n                    replaceLinePartLeft(endLineNo, endCol, newLines[newLines.length - 1])\n\n                    // Replace all the lines in between.\n                    // It's important that we do this last.\n                    replaceLines(\n                        startLineNo + 1,\n                        endLineNo - 1,\n                        newLines.slice(1, newLines.length - 1),\n                    )\n                }\n            }\n        }\n    }\n\n    private fun replaceLinePart(\n        lineNo: Int,\n        startCol: Int,\n        endCol: Int,\n        newLineParts: JsArray<String>,\n    ) {\n        val line = asm[lineNo - 1]\n        // We keep the parts of the line that weren't affected by the edit.\n        val lineStart = line.substring(0, startCol - 1)\n        val lineEnd = line.substring(endCol - 1)\n\n        if (newLineParts.length == 1) {\n            asm[lineNo - 1] = lineStart + newLineParts[0] + lineEnd\n        } else {\n            asm.splice(\n                lineNo - 1,\n                1,\n                lineStart + newLineParts[0],\n                *newLineParts.slice(1, newLineParts.length - 1).asArray(),\n                newLineParts[newLineParts.length - 1] + lineEnd,\n            )\n        }\n    }\n\n    private fun replaceLinePartLeft(lineNo: Int, endCol: Int, newLinePart: String) {\n        asm[lineNo - 1] = newLinePart + asm[lineNo - 1].substring(endCol - 1)\n    }\n\n    private fun replaceLinePartRight(lineNo: Int, startCol: Int, newLinePart: String) {\n        asm[lineNo - 1] = asm[lineNo - 1].substring(0, startCol - 1) + newLinePart\n    }\n\n    private fun replaceLines(startLineNo: Int, endLineNo: Int, newLines: JsArray<String>) {\n        asm.splice(startLineNo - 1, endLineNo - startLineNo + 1, *newLines.asArray())\n    }\n\n    private fun replaceLinesAndMergeLineParts(\n        startLineNo: Int,\n        endLineNo: Int,\n        startCol: Int,\n        endCol: Int,\n        newLinePart: String,\n    ) {\n        val startLine = asm[startLineNo - 1]\n        val endLine = asm[endLineNo - 1]\n        // We keep the parts of the lines that weren't affected by the edit.\n        val startLineStart = startLine.substring(0, startCol - 1)\n        val endLineEnd = endLine.substring(endCol - 1)\n\n        asm.splice(\n            startLineNo - 1,\n            endLineNo - startLineNo + 1,\n            startLineStart + newLinePart + endLineEnd,\n        )\n    }\n\n    private fun processAsm() {\n        _cfg = null\n\n        val assemblyResult = assemble(asm.asArray().toList(), inlineStackArgs)\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val problems = (assemblyResult.problems as List<AssemblerAssemblyProblem>).map {\n            AssemblyProblem(it.severity, it.uiMessage, it.lineNo, it.col, it.len)\n        }\n\n        if (problems != this.problems) {\n            this.problems = problems\n            sendMessage(ServerNotification.Problems(problems))\n        }\n\n        if (assemblyResult is Success) {\n            bytecodeIr = assemblyResult.value\n\n            val instructionSegments = bytecodeIr.instructionSegments()\n\n            instructionSegments.find { 0 in it.labels }?.let { label0Segment ->\n                val designations = getMapDesignations(label0Segment) { cfg }\n\n                if (designations != mapDesignations) {\n                    mapDesignations = designations\n                    sendMessage(\n                        ServerNotification.MapDesignations(\n                            designations\n                        )\n                    )\n                }\n            }\n        }\n    }\n\n    private fun getCompletions(requestId: Int, lineNo: Int, col: Int) {\n        val text = getLine(lineNo)?.take(col)?.trim()?.toLowerCase() ?: \"\"\n\n        val completions: List<CompletionItem> = when {\n            KEYWORD_REGEX.matches(text) -> KEYWORD_SUGGESTIONS\n\n            INSTRUCTION_REGEX.matches(text) -> {\n                val suggestions = INSTRUCTION_SUGGESTIONS.asSequence()\n                val startingWith = suggestions.filter { it.label.startsWith(text) }\n                val containing = suggestions.filter { it.label.contains(text) }\n\n                (startingWith + containing)\n                    .take(20)\n                    .toList()\n            }\n\n            else -> emptyList()\n        }\n\n        sendMessage(Response.GetCompletions(requestId, completions))\n    }\n\n    private fun getSignatureHelp(requestId: Int, lineNo: Int, col: Int) {\n        sendMessage(Response.GetSignatureHelp(requestId, signatureHelp(lineNo, col)))\n    }\n\n    private fun signatureHelp(lineNo: Int, col: Int): SignatureHelp? {\n        // Hacky way of providing parameter hints.\n        // We just tokenize the current line and look for the first identifier and check whether\n        // it's a valid opcode.\n        var signature: Signature? = null\n        var activeParam = -1\n\n        getLine(lineNo)?.let { text ->\n            tokenizer.tokenize(text)\n\n            while (tokenizer.nextToken()) {\n                if (tokenizer.type === Token.Ident) {\n                    mnemonicToOpcode(tokenizer.strValue)?.let { opcode ->\n                        signature = getSignature(opcode)\n                    }\n                }\n\n                if (tokenizer.col + tokenizer.len > col) {\n                    break\n                } else if (tokenizer.type === Token.Ident && activeParam == -1) {\n                    activeParam = 0\n                } else if (tokenizer.type === Token.ArgSeparator) {\n                    activeParam++\n                }\n            }\n        }\n\n        return signature?.let { sig ->\n            SignatureHelp(\n                signature = sig,\n                activeParameter = activeParam,\n            )\n        }\n    }\n\n    private fun getSignature(opcode: Opcode): Signature {\n        var signature = opcode.mnemonic + \" \"\n        val params = mutableListOf<Parameter>()\n        var first = true\n\n        for (param in opcode.params) {\n            if (first) {\n                first = false\n            } else {\n                signature += \", \"\n            }\n\n            params.add(\n                Parameter(\n                    labelStart = signature.length,\n                    labelEnd = signature.length + param.type.uiName.length,\n                    documentation = param.doc,\n                )\n            )\n\n            signature += param.type.uiName\n        }\n\n        return Signature(\n            label = signature,\n            documentation = opcode.doc,\n            parameters = params,\n        )\n    }\n\n    private fun getHover(requestId: Int, lineNo: Int, col: Int) {\n        val hover = signatureHelp(lineNo, col)?.let { help ->\n            val sig = help.signature\n            val param = sig.parameters.getOrNull(help.activeParameter)\n\n            val contents = mutableListOf<String>()\n\n            // Instruction signature. Parameter highlighted if possible.\n            contents.add(\n                if (param == null) {\n                    sig.label\n                } else {\n                    // TODO: Figure out how to underline the active parameter in addition to\n                    //  bolding it to make it match the look of the signature help.\n                    sig.label.substring(0, param.labelStart) +\n                            \"__\" +\n                            sig.label.substring(param.labelStart, param.labelEnd) +\n                            \"__\" +\n                            sig.label.substring(param.labelEnd)\n                }\n            )\n\n            // Put the parameter doc and the instruction doc in the same string to match the look of the\n            // signature help.\n            var doc = \"\"\n\n            // Parameter doc.\n            if (param?.documentation != null) {\n                doc += param.documentation\n\n                // TODO: Figure out how add an empty line here to make it match the look of the\n                //  signature help.\n                doc += \"\\n\\n\"\n            }\n\n            // Instruction doc.\n            sig.documentation?.let { doc += it }\n\n            if (doc.isNotEmpty()) {\n                contents.add(doc)\n            }\n\n            Hover(contents)\n        }\n\n        sendMessage(Response.GetHover(requestId, hover))\n    }\n\n    private fun getDefinition(requestId: Int, lineNo: Int, col: Int) {\n        var result = emptyList<AsmRange>()\n\n        getInstruction(lineNo, col)?.let { inst ->\n            loop@\n            for ((paramIdx, param) in inst.opcode.params.withIndex()) {\n                if (param.type is LabelType) {\n                    if (inst.opcode.stack != StackInteraction.Pop) {\n                        // Immediate arguments.\n                        val args = inst.getArgs(paramIdx)\n                        val argSrcLocs = inst.getArgSrcLocs(paramIdx)\n\n                        for (i in 0 until min(args.size, argSrcLocs.size)) {\n                            val arg = args[i]\n                            val srcLoc = argSrcLocs[i]\n\n                            if (positionInside(lineNo, col, srcLoc)) {\n                                val label = arg.value as Int\n                                result = getLabelDefinitions(label)\n                                break@loop\n                            }\n                        }\n                    } else {\n                        // Stack arguments.\n                        val argSrcLocs = inst.getStackArgSrcLocs(paramIdx)\n\n                        for ((i, argSrcLoc) in argSrcLocs.withIndex()) {\n                            if (positionInside(lineNo, col, argSrcLoc)) {\n                                val labelValues = getStackValue(cfg, inst, argSrcLocs.lastIndex - i)\n\n                                if (labelValues.size <= 5) {\n                                    result = labelValues.flatMap(::getLabelDefinitions)\n                                }\n\n                                break@loop\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        sendMessage(Response.GetDefinition(requestId, result))\n    }\n\n    private fun getInstruction(lineNo: Int, col: Int): Instruction? {\n        for (segment in bytecodeIr.segments) {\n            if (segment is InstructionSegment) {\n                // Loop over instructions in reverse order so stack popping instructions will be\n                // handled before the related stack pushing instructions when inlineStackArgs is on.\n                for (i in segment.instructions.lastIndex downTo 0) {\n                    val inst = segment.instructions[i]\n\n                    inst.srcLoc?.let { srcLoc ->\n                        if (positionInside(lineNo, col, srcLoc.mnemonic)) {\n                            return inst\n                        }\n\n                        for (argSrcLoc in srcLoc.args) {\n                            if (positionInside(lineNo, col, argSrcLoc)) {\n                                return inst\n                            }\n                        }\n\n                        if (inlineStackArgs) {\n                            for (argSrcLoc in srcLoc.stackArgs) {\n                                if (positionInside(lineNo, col, argSrcLoc)) {\n                                    return inst\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return null\n    }\n\n    private fun getLabelDefinitions(label: Int): List<AsmRange> =\n        bytecodeIr.segments.asSequence()\n            .filter { label in it.labels }\n            .mapNotNull { segment ->\n                val labelIdx = segment.labels.indexOf(label)\n\n                segment.srcLoc.labels.getOrNull(labelIdx)?.let { labelSrcLoc ->\n                    AsmRange(\n                        startLineNo = labelSrcLoc.lineNo,\n                        startCol = labelSrcLoc.col,\n                        endLineNo = labelSrcLoc.lineNo,\n                        endCol = labelSrcLoc.col + labelSrcLoc.len,\n                    )\n                }\n            }\n            .toList()\n\n    private fun positionInside(lineNo: Int, col: Int, srcLoc: SrcLoc?): Boolean =\n        if (srcLoc == null) {\n            false\n        } else {\n            lineNo == srcLoc.lineNo && col >= srcLoc.col && col <= srcLoc.col + srcLoc.len\n        }\n\n    @Suppress(\"RedundantNullableReturnType\") // Can return undefined.\n    private fun getLine(lineNo: Int): String? = asm[lineNo - 1]\n\n    companion object {\n        private val KEYWORD_REGEX = Regex(\"\"\"^\\s*\\.[a-z]+${'$'}\"\"\")\n        private val KEYWORD_SUGGESTIONS: List<CompletionItem> =\n            listOf(\n                CompletionItem(\n                    label = \".code\",\n                    type = CompletionItemType.Keyword,\n                    insertText = \"code\",\n                ),\n                CompletionItem(\n                    label = \".data\",\n                    type = CompletionItemType.Keyword,\n                    insertText = \"data\",\n                ),\n                CompletionItem(\n                    label = \".string\",\n                    type = CompletionItemType.Keyword,\n                    insertText = \"string\",\n                ),\n            )\n\n        private val INSTRUCTION_REGEX = Regex(\"\"\"^\\s*([a-z][a-z0-9_=<>!]*)?${'$'}\"\"\")\n        private val INSTRUCTION_SUGGESTIONS: List<CompletionItem> =\n            (OPCODES.asSequence() + OPCODES_F8.asSequence() + OPCODES_F9.asSequence())\n                .filterNotNull()\n                .map { opcode ->\n                    CompletionItem(\n                        label = opcode.mnemonic,\n                        // TODO: Add signature?\n                        type = CompletionItemType.Opcode,\n                        insertText = opcode.mnemonic,\n                    )\n                }\n                .sortedBy { it.label }\n                .toList()\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage world.phantasmal.core\n\nexternal interface JsArray<T> {\n    val length: Int\n\n    fun push(vararg elements: T): Int\n\n    fun slice(start: Int = definedExternally): JsArray<T>\n    fun slice(start: Int, end: Int = definedExternally): JsArray<T>\n\n    fun some(callback: (element: T, index: Int) -> Boolean): Boolean\n\n    fun splice(start: Int, deleteCount: Int = definedExternally): JsArray<T>\n    fun splice(start: Int, deleteCount: Int, vararg items: T): JsArray<T>\n}\n\ninline operator fun <T> JsArray<T>.get(index: Int): T = asDynamic()[index].unsafeCast<T>()\n\ninline operator fun <T> JsArray<T>.set(index: Int, value: T) {\n    asDynamic()[index] = value\n}\n\ninline fun <T> jsArrayOf(vararg elements: T): JsArray<T> =\n    elements.unsafeCast<JsArray<T>>()\n\ninline fun <T> JsArray<T>.asArray(): Array<T> =\n    unsafeCast<Array<T>>()\n\ninline fun <T> Array<T>.asJsArray(): JsArray<T> =\n    unsafeCast<JsArray<T>>()\n\ninline fun <T> List<T>.toJsArray(): JsArray<T> =\n    toTypedArray().asJsArray()\n\n@Suppress(\"unused\")\nexternal interface JsPair<out A, out B>\n\ninline val <T> JsPair<T, *>.first: T get() = asDynamic()[0].unsafeCast<T>()\ninline val <T> JsPair<*, T>.second: T get() = asDynamic()[1].unsafeCast<T>()\n\ninline operator fun <T> JsPair<T, *>.component1(): T = first\ninline operator fun <T> JsPair<*, T>.component2(): T = second\n\n@Suppress(\"UNUSED_PARAMETER\")\ninline fun objectEntries(jsObject: dynamic): Array<JsPair<String, dynamic>> =\n    js(\"Object.entries(jsObject)\").unsafeCast<Array<JsPair<String, dynamic>>>()\n\nexternal interface JsSet<T> {\n    val size: Int\n\n    fun add(value: T): JsSet<T>\n    fun clear()\n    fun delete(value: T): Boolean\n    fun has(value: T): Boolean\n    fun forEach(callback: (value: T) -> Unit)\n}\n\ninline fun <T> emptyJsSet(): JsSet<T> =\n    js(\"new Set()\").unsafeCast<JsSet<T>>()\n\n@Suppress(\"UNUSED_PARAMETER\")\ninline fun <T> jsSetOf(vararg values: T): JsSet<T> =\n    js(\"new Set(values)\").unsafeCast<JsSet<T>>()\n","package world.phantasmal.web.assemblyWorker\n\nimport kotlinx.serialization.decodeFromString\nimport kotlinx.serialization.encodeToString\nimport mu.KotlinLoggingConfiguration\nimport mu.KotlinLoggingLevel\nimport world.phantasmal.web.shared.JSON_FORMAT\nimport world.phantasmal.web.shared.externals.self\nimport world.phantasmal.web.shared.logging.LogAppender\nimport world.phantasmal.web.shared.logging.LogFormatter\n\nfun main() {\n    KotlinLoggingConfiguration.FORMATTER = LogFormatter()\n    KotlinLoggingConfiguration.APPENDER = LogAppender()\n\n    if (self.location.hostname == \"localhost\") {\n        KotlinLoggingConfiguration.LOG_LEVEL = KotlinLoggingLevel.TRACE\n    }\n\n    val asmWorker = AssemblyWorker(\n        sendMessage = { message ->\n            self.postMessage(JSON_FORMAT.encodeToString(message))\n        }\n    )\n\n    self.onmessage = { e ->\n        val json = e.data as String\n        asmWorker.receiveMessage(JSON_FORMAT.decodeFromString(json))\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n",null,null,null,null,null,null,null,null,null,null,"package world.phantasmal.web.shared\n\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonBuilder\n\nval JSON_FORMAT = Json {\n    defaultConfig()\n}\n\nval JSON_FORMAT_PRETTY = Json {\n    defaultConfig()\n    prettyPrint = true\n}\n\nprivate fun JsonBuilder.defaultConfig() {\n    ignoreUnknownKeys = true\n    classDiscriminator = \"#type\"\n}\n","package world.phantasmal.web.shared.messages\n\nimport kotlinx.serialization.Serializable\nimport world.phantasmal.core.Severity\n\n/*\n * The protocol between the AsmAnalyser and the assembly web worker is loosely based on the language\n * server protocol. With the idea that at some point we might implement a full LSP server.\n *\n * There are 3 kinds of messages:\n * - Request: sent by the client expecting a response.\n * - Response: sent by server in response to a request.\n * - Notifications: sent by either the client or server. No response is required.\n */\n\n@Serializable\nsealed class ClientMessage\n\n@Serializable\nsealed class ClientNotification : ClientMessage() {\n    @Serializable\n    class SetAsm(\n        val asm: List<String>,\n        val inlineStackArgs: Boolean,\n    ) : ClientNotification()\n\n    @Serializable\n    class UpdateAsm(\n        val changes: List<AsmChange>,\n    ) : ClientNotification()\n}\n\n@Serializable\nsealed class Request : ClientMessage() {\n    /**\n     * Will be echoed in the response so the client can match responses to requests.\n     */\n    abstract val id: Int\n\n    @Serializable\n    class GetCompletions(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetSignatureHelp(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetHover(override val id: Int, val lineNo: Int, val col: Int) : Request()\n\n    @Serializable\n    class GetDefinition(override val id: Int, val lineNo: Int, val col: Int) : Request()\n}\n\n@Serializable\nsealed class ServerMessage\n\n@Serializable\nsealed class ServerNotification : ServerMessage() {\n    @Serializable\n    class MapDesignations(\n        val mapDesignations: Map<Int, Int>,\n    ) : ServerNotification()\n\n    @Serializable\n    class Problems(\n        val problems: List<AssemblyProblem>,\n    ) : ServerNotification()\n}\n\n@Serializable\nsealed class Response<T> : ServerMessage() {\n    /**\n     * ID of the related request.\n     */\n    abstract val id: Int\n\n    abstract val result: T\n\n    @Serializable\n    class GetCompletions(\n        override val id: Int,\n        override val result: List<CompletionItem>,\n    ) : Response<List<CompletionItem>>()\n\n    @Serializable\n    class GetSignatureHelp(\n        override val id: Int,\n        override val result: SignatureHelp?,\n    ) : Response<SignatureHelp?>()\n\n    @Serializable\n    class GetHover(\n        override val id: Int,\n        override val result: Hover?,\n    ) : Response<Hover?>()\n\n    @Serializable\n    class GetDefinition(\n        override val id: Int,\n        override val result: List<AsmRange>,\n    ) : Response<List<AsmRange>>()\n}\n\n@Serializable\ndata class AsmRange(\n    val startLineNo: Int,\n    val startCol: Int,\n    val endLineNo: Int,\n    val endCol: Int,\n)\n\nenum class CompletionItemType {\n    Keyword, Opcode\n}\n\n@Serializable\nclass CompletionItem(val label: String, val type: CompletionItemType, val insertText: String)\n\n@Serializable\nclass SignatureHelp(val signature: Signature, val activeParameter: Int)\n\n@Serializable\nclass Signature(val label: String, val documentation: String?, val parameters: List<Parameter>)\n\n@Serializable\nclass Parameter(\n    /**\n     * Start column of the parameter label within [Signature.label].\n     */\n    val labelStart: Int,\n    /**\n     * End column (exclusive) of the parameter label within [Signature.label].\n     */\n    val labelEnd: Int,\n    val documentation: String?,\n)\n\n@Serializable\nclass Hover(\n    /**\n     * List of markdown strings.\n     */\n    val contents: List<String>,\n)\n\n@Serializable\nclass AsmChange(\n    val range: AsmRange,\n    val newAsm: String,\n)\n\n@Serializable\nclass AssemblyProblem(\n    val severity: Severity,\n    val message: String,\n    val lineNo: Int,\n    val col: Int,\n    val len: Int,\n)\n","package world.phantasmal.web.shared\n\nimport world.phantasmal.web.shared.externals.self\n\n/**\n * Helper for limiting the amount of times a function is called within a given window.\n *\n * @param wait The number of milliseconds to throttle invocations to.\n * @param leading Invoke on the leading edge of the timeout window.\n * @param trailing Invoke on the trailing edge of the timeout window.\n */\nclass Throttle(\n    private val wait: Int,\n    private val leading: Boolean = true,\n    private val trailing: Boolean = true,\n) {\n    private var timeout: Int? = null\n    private var invokeOnTimeout = false\n\n    operator fun invoke(f: () -> Unit) {\n        if (timeout == null) {\n            if (leading) {\n                f()\n            }\n\n            timeout = self.setTimeout({\n                if (invokeOnTimeout) {\n                    f()\n                }\n\n                timeout = null\n                invokeOnTimeout = false\n            }, wait)\n        } else {\n            invokeOnTimeout = trailing\n        }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nimport mu.Appender\n\nclass LogAppender : Appender {\n    override fun trace(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.log(message.message, message.throwable)\n        } else {\n            console.log(message)\n        }\n    }\n\n    override fun debug(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.log(message.message, message.throwable)\n        } else {\n            console.log(message)\n        }\n    }\n\n    override fun info(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.info(message.message, message.throwable)\n        } else {\n            console.info(message)\n        }\n    }\n\n    override fun warn(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.warn(message.message, message.throwable)\n        } else {\n            console.warn(message)\n        }\n    }\n\n    override fun error(message: Any?) {\n        if (message is MessageWithThrowable) {\n            console.error(message.message, message.throwable)\n        } else {\n            console.error(message)\n        }\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nimport mu.Formatter\nimport mu.KotlinLoggingLevel\nimport mu.Marker\nimport kotlin.js.Date\n\nclass LogFormatter : Formatter {\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        msg: () -> Any?,\n    ): String =\n        \"${time()} ${level.str()} $loggerName - ${msg.toStringSafe()}\"\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        t: Throwable?,\n        msg: () -> Any?,\n    ): MessageWithThrowable =\n        MessageWithThrowable(formatMessage(level, loggerName, msg), t)\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        marker: Marker?,\n        msg: () -> Any?,\n    ): String =\n        \"${time()} ${level.str()} $loggerName [${marker?.getName()}] - ${msg.toStringSafe()}\"\n\n    override fun formatMessage(\n        level: KotlinLoggingLevel,\n        loggerName: String,\n        marker: Marker?,\n        t: Throwable?,\n        msg: () -> Any?,\n    ): MessageWithThrowable =\n        MessageWithThrowable(formatMessage(level, loggerName, marker, msg), t)\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun (() -> Any?).toStringSafe(): String {\n        return try {\n            invoke().toString()\n        } catch (e: Exception) {\n            \"Log message invocation failed: $e\"\n        }\n    }\n\n    private fun KotlinLoggingLevel.str(): String =\n        name.padEnd(MIN_LEVEL_LEN)\n\n    private fun time(): String {\n        val date = Date()\n        val h = date.getHours().toString().padStart(2, '0')\n        val m = date.getMinutes().toString().padStart(2, '0')\n        val s = date.getSeconds().toString().padStart(2, '0')\n        val ms = date.getMilliseconds().toString().padStart(3, '0')\n        return \"$h:$m:$s.$ms\"\n    }\n\n    companion object {\n        private val MIN_LEVEL_LEN: Int =\n            KotlinLoggingLevel.values().map { it.name.length }.maxOrNull()!!\n    }\n}\n","package world.phantasmal.web.shared.logging\n\nclass MessageWithThrowable(\n    val message: Any?,\n    val throwable: Throwable?,\n)\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sourceRoot":""}